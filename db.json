{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"source/images/promise/promises.png","path":"images/promise/promises.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible03.png","path":"images/flexible/flexible03.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible06.png","path":"images/flexible/flexible06.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible08.png","path":"images/flexible/flexible08.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible04.png","path":"images/flexible/flexible04.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible07.png","path":"images/flexible/flexible07.png","modified":0,"renderable":0},{"_id":"source/images/serviceWorker/sw-lifecycle.png","path":"images/serviceWorker/sw-lifecycle.png","modified":0,"renderable":0},{"_id":"source/images/react/1-4zODv5vgvKsi6Ts7TihsoA.png","path":"images/react/1-4zODv5vgvKsi6Ts7TihsoA.png","modified":0,"renderable":0},{"_id":"source/images/react/1-5JaZSc3Jsn9PJY7daEDVDA.png","path":"images/react/1-5JaZSc3Jsn9PJY7daEDVDA.png","modified":0,"renderable":0},{"_id":"source/images/serviceWorker/sw-events.png","path":"images/serviceWorker/sw-events.png","modified":0,"renderable":0},{"_id":"source/images/react/1-D1RcVrMV2rp6AH9hk5xZ8g.png","path":"images/react/1-D1RcVrMV2rp6AH9hk5xZ8g.png","modified":0,"renderable":0},{"_id":"source/images/react/1-Gztc7THzxzOgJmGvJ95IQA.png","path":"images/react/1-Gztc7THzxzOgJmGvJ95IQA.png","modified":0,"renderable":0},{"_id":"source/images/react/1--S_dYe6BoQBgwSRpF7Hriw.png","path":"images/react/1--S_dYe6BoQBgwSRpF7Hriw.png","modified":0,"renderable":0},{"_id":"source/images/react/1-8_fU31-jNQnQ0dp-wplm5w.png","path":"images/react/1-8_fU31-jNQnQ0dp-wplm5w.png","modified":0,"renderable":0},{"_id":"source/images/react/1-GNDs7SY53lEhp7mX8V25lw.png","path":"images/react/1-GNDs7SY53lEhp7mX8V25lw.png","modified":0,"renderable":0},{"_id":"source/images/react/1-MG736zGtLMBbSkhwu4D3cA.png","path":"images/react/1-MG736zGtLMBbSkhwu4D3cA.png","modified":0,"renderable":0},{"_id":"source/images/react/1-L66K9uCQjjHmpAwT-a9C5Q.png","path":"images/react/1-L66K9uCQjjHmpAwT-a9C5Q.png","modified":0,"renderable":0},{"_id":"source/images/react/1-TgCkFcjlD9SxSrMvVX3DrA.png","path":"images/react/1-TgCkFcjlD9SxSrMvVX3DrA.png","modified":0,"renderable":0},{"_id":"source/images/react/1-Uljrrh4Z7UiUwk8AjUO9PA.png","path":"images/react/1-Uljrrh4Z7UiUwk8AjUO9PA.png","modified":0,"renderable":0},{"_id":"source/images/react/1-JXPeiNP-it60-QYKb-p2eQ.png","path":"images/react/1-JXPeiNP-it60-QYKb-p2eQ.png","modified":0,"renderable":0},{"_id":"source/images/react/1-Vocy_6Gl9PbFlCIJsE9r3A.png","path":"images/react/1-Vocy_6Gl9PbFlCIJsE9r3A.png","modified":0,"renderable":0},{"_id":"source/images/react/1-bUMekI8QlEfFxSBCuVuIkw.png","path":"images/react/1-bUMekI8QlEfFxSBCuVuIkw.png","modified":0,"renderable":0},{"_id":"source/images/react/1-aVoD3gGddKUy3VCxwylthQ.png","path":"images/react/1-aVoD3gGddKUy3VCxwylthQ.png","modified":0,"renderable":0},{"_id":"source/images/react/1-NYMutQLW8TcEgbO8VNeqHA.png","path":"images/react/1-NYMutQLW8TcEgbO8VNeqHA.png","modified":0,"renderable":0},{"_id":"source/images/react/1-wLRhZ0wtI0duLsigdxL1CA.png","path":"images/react/1-wLRhZ0wtI0duLsigdxL1CA.png","modified":0,"renderable":0},{"_id":"source/images/react/1-p4EkWE_8upZ97Z0IapKDcQ.png","path":"images/react/1-p4EkWE_8upZ97Z0IapKDcQ.png","modified":0,"renderable":0},{"_id":"source/images/react/1-zrsSoAAyf4pqTMHiA6P8Ww.png","path":"images/react/1-zrsSoAAyf4pqTMHiA6P8Ww.png","modified":0,"renderable":0},{"_id":"source/images/react/flux.jpg","path":"images/react/flux.jpg","modified":0,"renderable":0},{"_id":"source/images/react/redux.jpg","path":"images/react/redux.jpg","modified":0,"renderable":0},{"_id":"source/images/范畴论/1.png","path":"images/范畴论/1.png","modified":0,"renderable":0},{"_id":"source/images/范畴论/3.png","path":"images/范畴论/3.png","modified":0,"renderable":0},{"_id":"source/images/范畴论/2.png","path":"images/范畴论/2.png","modified":0,"renderable":0},{"_id":"source/images/react/1-zmFp3bmDq7b6Bvlo8Ineag.png","path":"images/react/1-zmFp3bmDq7b6Bvlo8Ineag.png","modified":0,"renderable":0},{"_id":"source/images/react/1-nBsGCWmJTR-Zj7aXeIE8yg.png","path":"images/react/1-nBsGCWmJTR-Zj7aXeIE8yg.png","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"source/images/flexible/flexible02.png","path":"images/flexible/flexible02.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible05.png","path":"images/flexible/flexible05.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible01.png","path":"images/flexible/flexible01.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible10.png","path":"images/flexible/flexible10.png","modified":0,"renderable":0},{"_id":"source/images/flexible/flexible09.png","path":"images/flexible/flexible09.png","modified":0,"renderable":0},{"_id":"source/images/react/1-_R-rGNfKr2Xu2FlXNZNPJg.png","path":"images/react/1-_R-rGNfKr2Xu2FlXNZNPJg.png","modified":0,"renderable":0},{"_id":"source/images/react/1-Je2mow8mjYLngXreGGlIEg.png","path":"images/react/1-Je2mow8mjYLngXreGGlIEg.png","modified":0,"renderable":0},{"_id":"source/images/react/1-qGatznV4QujuxGe49YfX5A.png","path":"images/react/1-qGatznV4QujuxGe49YfX5A.png","modified":0,"renderable":0},{"_id":"source/images/react/1-x6vBvUlFJktJqty56jr0QQ.png","path":"images/react/1-x6vBvUlFJktJqty56jr0QQ.png","modified":0,"renderable":0},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/bower.json","path":"vendors/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","path":"vendors/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/bower.json","path":"vendors/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/README.md","path":"vendors/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","path":"vendors/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","path":"vendors/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/LICENSE","path":"vendors/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","path":"vendors/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/bower.json","path":"vendors/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","path":"vendors/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","path":"vendors/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"source/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png","path":"images/react/1-dODKUGyGkF8qeGLrXKWkiA.png","modified":0,"renderable":0},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","path":"vendors/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery/index.js","path":"vendors/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","path":"vendors/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","path":"vendors/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","path":"vendors/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","path":"vendors/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","path":"vendors/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","path":"vendors/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","path":"vendors/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","path":"vendors/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","path":"vendors/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","path":"vendors/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","path":"vendors/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","path":"vendors/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","path":"vendors/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","path":"vendors/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","path":"vendors/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","path":"vendors/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","path":"vendors/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","path":"vendors/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","path":"vendors/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","path":"vendors/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","path":"vendors/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","path":"vendors/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","path":"vendors/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/velocity/velocity.js","path":"vendors/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","path":"vendors/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"2fee1653bd2540632d79b43158dc970577d7fdda","modified":1463364692474},{"_id":"source/favicon.ico","hash":"421c09dd34bd64ec866f4d34b808c887b23b1afe","modified":1463364692480},{"_id":"themes/next/.bowerrc","hash":"20038353db532b4c40625419d396da7359f89cbe","modified":1463364692491},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1463364692492},{"_id":"themes/next/.gitignore","hash":"63d003fa46cf9665b4dab1786f9dc694812a5a79","modified":1463364692493},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1463364692493},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1463364692494},{"_id":"themes/next/.javascript_ignore","hash":"beb0b95736650284ceb712a162cc033847a83cd3","modified":1463364692493},{"_id":"themes/next/_config.yml","hash":"eb890e709a4fe2112207d60c64d3c04083996717","modified":1463364692495},{"_id":"themes/next/gulpfile.coffee","hash":"0494704f9e1ac8f63b9bd2791c443ffbf6091df3","modified":1463364692495},{"_id":"themes/next/README.md","hash":"06aaf1241e9e1619956c86d8b1397a643840a9d1","modified":1463364692494},{"_id":"themes/next/bower.json","hash":"93adc30dab22314f3757c3b6d3c13771de994b08","modified":1463364692495},{"_id":"themes/next/package.json","hash":"afc2cbda2fe4643808c151135d5528267ee634c4","modified":1463364692510},{"_id":"themes/next/README.en.md","hash":"fa31bbc6dd8778b8dee469740c92b3b5b59702af","modified":1463364692494},{"_id":"source/_posts/JavaScript秘密花园.md","hash":"c29e0deeaecbc11f70ed3709ba65a72d3cc2be85","modified":1470638164316},{"_id":"source/_posts/Javascript的函数式库.md","hash":"4504a1682117e1026f2ce7ad8a7e2ec679045054","modified":1463641715739},{"_id":"source/_posts/JSON-stringify-JSON-parse.md","hash":"3e46b46a8c54c1d0a075d72035bc7dd46a58d4b9","modified":1466672539693},{"_id":"source/_posts/JS函数式编程的力量-转.md","hash":"8cfd9fefef336340869b6530af083196159b8f56","modified":1463540861672},{"_id":"source/_posts/animation-详解.md","hash":"47e9bf3c94c17e23554b62779214f78f0d8023e7","modified":1463364692475},{"_id":"source/_posts/es6函数式编程.md","hash":"04d365a914bb5d247e1ab384c96e55fe24f91d5d","modified":1463534852761},{"_id":"source/_posts/es6系列教程一.md","hash":"d9d7e9e63eb55e39b0009d49542795084b46b1d6","modified":1464835910139},{"_id":"source/_posts/React-Redux文档.md","hash":"9163e0be00ea3c7851321fd5e71a02563865dd9b","modified":1464767163420},{"_id":"source/_posts/es6系列教程三.md","hash":"6d39037cc318976bacfc8fd8c0193a5bdeda422d","modified":1465186363682},{"_id":"source/_posts/es6系列教程二.md","hash":"701806d960b50ff8d9a035afb5ff9d77c4fde22e","modified":1464860524090},{"_id":"source/_posts/reduce的用法.md","hash":"46ef993fb3a6f55bcbc91155d1046bb3be17cf64","modified":1463364692475},{"_id":"source/_posts/webapck配置指导.md","hash":"791374a4f327b4e6357d4b4212e8fe1946131b95","modified":1463364692476},{"_id":"source/_posts/zepto学习笔记.md","hash":"5736a703ed0069c189cd984838294886f328a997","modified":1463364692476},{"_id":"source/_posts/使用Flexible实现H5页面终端适配.md","hash":"c417be85a0481b1ebc39d06ca3df29e95e4a63a3","modified":1463364692477},{"_id":"source/_posts/es6系列教程四.md","hash":"853fc887067de32720c5c0da6a26cb27170a3b03","modified":1466393840968},{"_id":"source/_posts/Immutable详解及React中实践.md","hash":"d41fa060f070f03fe95234c6561ce89d2808c081","modified":1470366835264},{"_id":"source/_posts/使用ServiceWorkers.md","hash":"f9e64ef157a192ded2a6a193ff08555e07f04902","modified":1469685207602},{"_id":"source/_posts/函数式编程基础-转.md","hash":"641c7de72cd4543c155234ae585da9b9f1fec6b7","modified":1463624238120},{"_id":"source/_posts/Redux快速上手.md","hash":"fe8b8ac57ed63014d45aa2dbaaf61780499d69fb","modified":1464312496267},{"_id":"source/_posts/初识ServiceWorker.md","hash":"1e777a2e4ac28c742a79f75a56e1c1913289d998","modified":1469583670376},{"_id":"source/_posts/初始Promise.md","hash":"e8471d0c8fcdbe0f2001b2a6f2a8d5db1750b72d","modified":1470017498967},{"_id":"source/_posts/基本函数式的编程.md","hash":"71bfd5e5c51ad2801a2aba55964eaf0e4ea09610","modified":1463966811351},{"_id":"source/_posts/函数组合-JS函数式编程.md","hash":"9f6df7be866ec00f20a499ea6a1bd2af05573770","modified":1463966811349},{"_id":"source/_posts/模块系统.md","hash":"d6f08161af9f976759bdfac7fb448608a270ad9f","modified":1463364692479},{"_id":"source/_posts/流程控制与错误处理.md","hash":"a4ba61b13e3ccfb7c3925146bdd648c811a0ee4e","modified":1463533820731},{"_id":"source/_posts/数组中插入元素.md","hash":"e070ab34206402e98186b450da8a0db295079338","modified":1466410248966},{"_id":"source/_posts/用卡通图介绍Redux.md","hash":"b01a2a9959d37744ab09cbf5bf788989b394329b","modified":1464597390020},{"_id":"source/_posts/深入理解Redux的Middleware.md","hash":"1a6ec6298eebb85ca2f6418d2422a31e45162d3d","modified":1464321733507},{"_id":"source/_posts/语法和数据类型.md","hash":"ec86f1ba6e098e37f5a39236ffd6484e933d8604","modified":1463479487584},{"_id":"source/_posts/范畴论-JS函数式编程.md","hash":"588cf5824516b4be9cc97b71c51a5b3ea0218c8c","modified":1464081837936},{"_id":"source/_posts/函数式编程-月影.md","hash":"7143734ccaf3a37dcc33c511e8dd4aaef1a66969","modified":1463629434126},{"_id":"source/about/index.md","hash":"b52b14fb83bc7f5e080f0ab61b0e28e39df937b6","modified":1463364692479},{"_id":"source/images/avatar.jpg","hash":"cec12ec035c5a08107cf379ea621d240b71377a0","modified":1463364692480},{"_id":"source/_posts/迭代协议.md","hash":"ef5430c6d407274f27c0576ec2d582e64ad2ee67","modified":1467947842891},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"4312fb37fa2b8663006be3c4fe01125ec01171c1","modified":1463364692492},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a09da7ff6504131e928b9c99dcec98a411331812","modified":1463364692492},{"_id":"themes/next/languages/de.yml","hash":"4c3ffeb0d214c807a226dd98214958cb5483df1c","modified":1463364692496},{"_id":"themes/next/languages/default.yml","hash":"d2f6784b9c6567b64e58736e36025dbf96d863d4","modified":1463364692496},{"_id":"source/_posts/在Javascript中实现函数式编程的技术0.md","hash":"4cc9356278c01631cc6ece66572bbdbca2e31755","modified":1468202785293},{"_id":"themes/next/languages/en.yml","hash":"df81ab6b1cf3c88ed053d3766381cd12eb659fe3","modified":1463364692496},{"_id":"themes/next/languages/fr-FR.yml","hash":"d8a40fe025fad6f42df0cf16d4be2d513769b062","modified":1463364692496},{"_id":"themes/next/languages/ja.yml","hash":"e594aa42a33c489e4a65065659a01bb76c3c0cb5","modified":1463364692497},{"_id":"themes/next/languages/pt.yml","hash":"4c64594f477905d5d2d9ca2422f03175b7b0c617","modified":1463364692497},{"_id":"themes/next/languages/ru.yml","hash":"c3aedb94decf05a301662afc3398ab563dd9995a","modified":1463364692497},{"_id":"themes/next/languages/zh-Hans.yml","hash":"1693a2027de3736a8e4b08109e664d64771410c3","modified":1463364692497},{"_id":"themes/next/languages/zh-hk.yml","hash":"88e603eb0f3fd25c35bb37bd30372fd77bba7c46","modified":1463364692498},{"_id":"themes/next/languages/zh-tw.yml","hash":"04479b419c72b71fd34046f3fc33ebda4fe8de84","modified":1463364692498},{"_id":"themes/next/layout/_layout.swig","hash":"bd7d977379b8efc5873f637f1c4d53879626f4d6","modified":1463364692498},{"_id":"themes/next/layout/about.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1463364692508},{"_id":"themes/next/layout/index.swig","hash":"da76d90fbda3597623ea6d01d5e758b8bd6f180f","modified":1463364692509},{"_id":"source/_posts/这个API很迷人.md","hash":"4acee40ed80c617d825792863bbe633644b0a313","modified":1469516704931},{"_id":"themes/next/layout/tag.swig","hash":"6f764ea3ab11eeb7c530df45528d449b14f5dc62","modified":1463364692509},{"_id":"themes/next/scripts/merge-configs.js","hash":"f8cde6953939802f92da5b7a2458c6c539e9be69","modified":1463364692510},{"_id":"themes/next/test/.jshintrc","hash":"1dae9d1cf7df1ae6d5c5efd6cffb949e9b8dcebb","modified":1463364692563},{"_id":"themes/next/layout/archive.swig","hash":"b867a08f6b43de8b5d700c84b943df55917407ae","modified":1463364692508},{"_id":"themes/next/layout/category.swig","hash":"58cf08388901f7549b1fca95548b2c79173aa840","modified":1463364692509},{"_id":"themes/next/layout/page.swig","hash":"a91e3fd7aef26e8a02e339e3372801c517f400cf","modified":1463364692509},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1463364692563},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1463364692563},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692531},{"_id":"source/images/promise/promises.png","hash":"6ee3f072dbb90940644c141bc1bb8a604b449ae1","modified":1469684192068},{"_id":"source/images/flexible/flexible03.png","hash":"f3c194f0ea9047ba2b12f777d2f66c19813cb55e","modified":1463364692484},{"_id":"source/images/flexible/flexible06.png","hash":"5d054f69961f17a7b971998d7579c7b196bf042c","modified":1463364692487},{"_id":"source/images/flexible/flexible08.png","hash":"4c841e678059a3eaac0b8c4ac4d70cce106e95c3","modified":1463364692488},{"_id":"source/images/flexible/flexible04.png","hash":"dbd8d6ab64540975fc2dce44368a5986d787e6b9","modified":1463364692485},{"_id":"source/images/flexible/flexible07.png","hash":"c8f5535f6c970f2951cff1339920991153aeaed2","modified":1463364692488},{"_id":"source/images/serviceWorker/sw-lifecycle.png","hash":"dcaf6ee3efa6becb3588e944354c73fe77632a0b","modified":1469674914088},{"_id":"source/images/react/1-4zODv5vgvKsi6Ts7TihsoA.png","hash":"c0d74e0233df0341147d641813cb2058422d6827","modified":1464596997999},{"_id":"source/images/react/1-5JaZSc3Jsn9PJY7daEDVDA.png","hash":"5d3efa895e30500fc8661c3ce57873508c8bdcb0","modified":1464597010102},{"_id":"source/images/serviceWorker/sw-events.png","hash":"50126437d4e20df5a44f913c44c93e0e1fceecc8","modified":1469674914087},{"_id":"source/images/react/1-D1RcVrMV2rp6AH9hk5xZ8g.png","hash":"2a7ade4c9c17954d10db094b138caf2d5aff087f","modified":1464597029697},{"_id":"source/images/react/1-Gztc7THzxzOgJmGvJ95IQA.png","hash":"6559629c36d2aa8ea2e234fe14b766aa0469d4c7","modified":1464597017751},{"_id":"source/images/react/1--S_dYe6BoQBgwSRpF7Hriw.png","hash":"b0639562e2ecfe74a6802990b403996da4d8723c","modified":1464597067504},{"_id":"source/images/react/1-8_fU31-jNQnQ0dp-wplm5w.png","hash":"9795a04c4817cb716581a41d8125d3462721c503","modified":1464597037681},{"_id":"source/images/react/1-GNDs7SY53lEhp7mX8V25lw.png","hash":"b466301399e5fe9aa2769da066d94df9a92fcd77","modified":1464597048295},{"_id":"source/images/react/1-MG736zGtLMBbSkhwu4D3cA.png","hash":"b7734507e434cfde8879ef60c5f2fe94a3872c18","modified":1464597006458},{"_id":"source/images/react/1-L66K9uCQjjHmpAwT-a9C5Q.png","hash":"0e02a0ca0aa650609e61f772466f4b7b86b63068","modified":1464596989588},{"_id":"source/images/react/1-TgCkFcjlD9SxSrMvVX3DrA.png","hash":"20e4ea236faea61934af0b91550ca2becf3cc242","modified":1464597025787},{"_id":"source/images/react/1-Uljrrh4Z7UiUwk8AjUO9PA.png","hash":"5d338c472035f19f44f6b072ff1e2fa45afd13a1","modified":1464597014276},{"_id":"source/images/react/1-JXPeiNP-it60-QYKb-p2eQ.png","hash":"d2d6bef781841017619f123307da45ef44d70868","modified":1464597034022},{"_id":"source/images/react/1-Vocy_6Gl9PbFlCIJsE9r3A.png","hash":"dbe612ae15b6595db75aec1fc4947c58ee9a744d","modified":1464597021353},{"_id":"source/images/react/1-bUMekI8QlEfFxSBCuVuIkw.png","hash":"8314a77614428110601d643d5d362731e82cee36","modified":1464597075002},{"_id":"source/images/react/1-aVoD3gGddKUy3VCxwylthQ.png","hash":"42a8b98d8fafb24119fdeeea0ce522b5f342fd42","modified":1464597045155},{"_id":"source/images/react/1-NYMutQLW8TcEgbO8VNeqHA.png","hash":"840e59a71ade03013b5ee756d54181794f3075b7","modified":1464597041250},{"_id":"source/images/react/1-wLRhZ0wtI0duLsigdxL1CA.png","hash":"6837565e8c7c53b604a55577892ac866e593d8cb","modified":1464597001566},{"_id":"source/images/react/1-p4EkWE_8upZ97Z0IapKDcQ.png","hash":"778f29b3160c2013bc2ff781d430d75096a2996b","modified":1464597051498},{"_id":"source/images/react/1-zrsSoAAyf4pqTMHiA6P8Ww.png","hash":"016b1c15d2d1ba396637d5242b2bd13adce7f5ef","modified":1464597058784},{"_id":"source/images/react/flux.jpg","hash":"e98cca3e6d29e1f6aacd7f86e242ba684d56858f","modified":1463990624600},{"_id":"source/images/react/redux.jpg","hash":"3db24afe31e7218b4ac6cc74497204250b2f5f3a","modified":1463990630018},{"_id":"source/images/范畴论/1.png","hash":"6204a06b24080c3995b1caec5c67e2465dc972fc","modified":1463968782288},{"_id":"source/images/范畴论/3.png","hash":"5b7eb63e53fec4910d3e51c07a0d38f3d0872930","modified":1463968800823},{"_id":"source/images/范畴论/2.png","hash":"874f391403fabb07b9ca73213e702764c884bd2a","modified":1463968795369},{"_id":"themes/next/layout/_macro/post.swig","hash":"a61cf39c2d79f790fbb4a8e07ac2bbb06b95390d","modified":1463364692499},{"_id":"source/images/react/1-zmFp3bmDq7b6Bvlo8Ineag.png","hash":"470c69de4a6ebe714b6b3d6d0ffcb8e56e1745e3","modified":1464597055306},{"_id":"source/images/react/1-nBsGCWmJTR-Zj7aXeIE8yg.png","hash":"e93dbeee0b3c295fad94eeb949158bb7aed4c2d5","modified":1464596993801},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1463364692503},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1463364692504},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6de4ea6db39fe8e04b058bcefc5b23f954726e77","modified":1463364692499},{"_id":"themes/next/layout/_partials/comments.swig","hash":"325dd5923d845a539fc0524ca72ce40edd1e516a","modified":1463364692500},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1463364692500},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"1a51b8caa5130ff55948ae59dddb87ee0550c1e9","modified":1463364692508},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"b87a5122dbff1d5fccf8f3d09d1640bd4b01c4a0","modified":1463364692499},{"_id":"themes/next/layout/_partials/footer.swig","hash":"cba20577cea89196d714ddfe6b3ea00f7c906ba7","modified":1463364692500},{"_id":"themes/next/layout/_macro/reward.swig","hash":"89f3d2e978d4062b470e774eda21c2ed3a086ab9","modified":1463364692499},{"_id":"themes/next/layout/_partials/head.swig","hash":"9d6501b54b959d28a6e0b5fde87d25fc38b97660","modified":1463364692500},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1463364692501},{"_id":"themes/next/layout/_partials/search.swig","hash":"95b55fe35f2d2c22f2cc055d4379b5435314c7ec","modified":1463364692501},{"_id":"themes/next/layout/_partials/header.swig","hash":"b3f4f07f03bedd615039934b44d552b91e2a4a1d","modified":1463364692501},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1463364692531},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1463364692532},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1463364692532},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1463364692532},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1463364692532},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1463364692534},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1463364692534},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1463364692534},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1463364692534},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1463364692534},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1463364692510},{"_id":"themes/next/scripts/tags/full-image.js","hash":"86194a05a8c6499de0b2aaa525d6de135778c0ae","modified":1463364692510},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1463364692511},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1463364692533},{"_id":"source/images/flexible/flexible02.png","hash":"858c0905d08a2454cc3fdbc32726d3c856717fab","modified":1463364692483},{"_id":"source/images/flexible/flexible05.png","hash":"9a9389cbb474f1216a6c2c80d4e9cd131d148598","modified":1463364692486},{"_id":"source/images/flexible/flexible01.png","hash":"dc9be1fd1a3eb85adc0cdb803ae4d51e00ca2180","modified":1463364692482},{"_id":"source/images/flexible/flexible10.png","hash":"a943ddd6f14e34e3267f2f15f8027fcc4a3f78c8","modified":1463364692491},{"_id":"source/images/flexible/flexible09.png","hash":"689c9ef22b7ba120aabe2b40b38a586ac700e158","modified":1463364692489},{"_id":"source/images/react/1-_R-rGNfKr2Xu2FlXNZNPJg.png","hash":"72aed04ac02b45246a053a982f3e26e04d9cb74e","modified":1464597070846},{"_id":"source/images/react/1-Je2mow8mjYLngXreGGlIEg.png","hash":"288cc20960a034474b34470f18c4afb05f7c94e3","modified":1464597084572},{"_id":"source/images/react/1-qGatznV4QujuxGe49YfX5A.png","hash":"13fd9e9a77ee9ad75e740152873215c6816e919f","modified":1464597081691},{"_id":"source/images/react/1-x6vBvUlFJktJqty56jr0QQ.png","hash":"827e121a7ae678b9a10eb0bd78a12bbfba1a01cc","modified":1464597078804},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692504},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692504},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1463364692535},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692524},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692524},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692524},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692530},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1463364692531},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1463364692533},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"6fa4daa91adee5800cbb0954e571b75e9796f99b","modified":1463364692504},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1463364692505},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"91c5353fcb94cc3b3f265b06ad2341734bc4c826","modified":1463364692505},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"8ba01f1ac07fbca62a4b00f5a0a3a506122c1530","modified":1463364692506},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1463364692508},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"aebc73513c9cbbbbda2935e2eb18e09bb1c24bf8","modified":1463364692507},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"5bd98c26cc188a2a30504d1330a0eaae34034db0","modified":1463364692507},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"efa7efcbb575381b508f9aa0e0c53140eef72a7b","modified":1463364692502},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1463364692502},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"8eecd19c756df615afb3f5ec6a527cd7bd06d20c","modified":1463364692508},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1463364692502},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"bf8e9223a40748b2e3ef77d753a8e1dbbce8095e","modified":1463364692502},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"3fdde03f45a80f7a85097a40b40358adde618fc7","modified":1463364692503},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1463364692523},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"e55265c8a8a6ae0c3c08e3509de92ee62c3cb5f6","modified":1463364692530},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1463364692503},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1463364692524},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"9f87ded9cde425048e8ae063cbb481e78a0e469c","modified":1463364692530},{"_id":"themes/next/source/css/_variables/default.styl","hash":"17779fa6fa3c9e1262ba100a86a8dec730c2f312","modified":1463364692531},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"12684840de632eb16e53ffa863166306a756fd4f","modified":1463364692503},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1463364692535},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"4a0da1bed19e65bd7db42421b447061bc1618710","modified":1463364692535},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1463364692536},{"_id":"themes/next/source/js/src/motion.js","hash":"ff9ea37d05c269e3a140c4ab448af03efc4bcc76","modified":1463364692536},{"_id":"themes/next/source/css/_variables/base.styl","hash":"f171c71d42f8798608235206dd41b37193faed88","modified":1463364692531},{"_id":"themes/next/source/vendors/font-awesome/.bower.json","hash":"bb093f2ac1f1305069d873a7941324c8e0de3135","modified":1463364692544},{"_id":"themes/next/source/vendors/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1463364692544},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1463364692536},{"_id":"themes/next/source/vendors/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1463364692545},{"_id":"themes/next/source/vendors/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1463364692545},{"_id":"themes/next/source/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1463364692545},{"_id":"themes/next/source/vendors/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1463364692543},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"10ca6744a8594c1a085b50120f4ed0a1ef433f40","modified":1463364692524},{"_id":"themes/next/source/js/src/utils.js","hash":"efcb2a7de9dc371d03a8598da2d71e2c53132d4c","modified":1463364692537},{"_id":"themes/next/source/vendors/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1463364692543},{"_id":"themes/next/source/vendors/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1463364692555},{"_id":"themes/next/source/vendors/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1463364692543},{"_id":"themes/next/source/vendors/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1463364692556},{"_id":"themes/next/source/vendors/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1463364692556},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1463364692557},{"_id":"themes/next/source/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1463364692543},{"_id":"themes/next/source/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1463364692557},{"_id":"themes/next/source/vendors/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1463364692559},{"_id":"themes/next/source/vendors/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1463364692559},{"_id":"themes/next/source/vendors/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1463364692562},{"_id":"themes/next/source/vendors/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1463364692561},{"_id":"source/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png","hash":"6087bb43308243aa4a0bdc06f8c431449f8b48ef","modified":1464596576775},{"_id":"themes/next/source/vendors/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1463364692562},{"_id":"themes/next/source/vendors/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1463364692555},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"ae5b8597603d4e42ee66ed121544e7b1c644767e","modified":1463364692505},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"096e7a6958b3bcacaa94361266832871ccb989c0","modified":1463364692505},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"61347b9cf5c42a02f28cda4b6d920d6d17099d44","modified":1463364692505},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"1b6af02fd0ba3f729675cd95429a0cea4aebf358","modified":1463364692506},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1463364692506},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"c1186e609d4810ebfb3e675e9045b023a557d1db","modified":1463364692506},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"da8aa3beab56d8c306dd97cf41127a3859e2d00c","modified":1463364692507},{"_id":"themes/next/source/vendors/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1463364692556},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5a35aa0381b0e1d465b952a997194441020446ea","modified":1463364692522},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"05be2af57229c5125297c945d2e60ca97070bae1","modified":1463364692522},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"c9218b48c56e52c06af9ce3cc8fbdae737cf16fe","modified":1463364692523},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1463364692523},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ad69cbf94eedacc27e756cdb9c7073416db697d0","modified":1463364692511},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"22828f5141c0cecb9ef25a110e194cdfa3a36423","modified":1463364692511},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1463364692512},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"b7d5cc29586ac796a50d90974ad99d24a5982137","modified":1463364692512},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1463364692520},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"d110befc142dbb881c4fdcb94df65ed2f603f1c1","modified":1463364692523},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1463364692525},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1463364692525},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1463364692525},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1463364692525},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"88559b13ce94311405b170a0506ded91273beceb","modified":1463364692515},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1463364692526},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"55b44e03054cd20ed8129bf986b15fba5fd85aad","modified":1463364692526},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"124b540f059fd1ed13514362007cfc70355278c6","modified":1463364692527},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"5187512cc4b2ce095230928c7046e0b26c3897bd","modified":1463364692526},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1463364692527},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"13af2fb21fabfc4df4b577ce5363e13d03daff71","modified":1463364692527},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1463364692527},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"f70fa81275eb4e0ea5e5a740b7a35539c6ffa9ba","modified":1463364692527},{"_id":"themes/next/source/css/_schemes/Pisces/_full-image.styl","hash":"de31e923bf5102498f06b1ae6bdf2ea22409f3e0","modified":1463364692528},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"59c0f66602ebc1c05c16f117bc8710d9f3744538","modified":1463364692528},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"9887bd3894db5394c1e64e800afaae55f47e8dd0","modified":1463364692528},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1463364692528},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"96f95471da25d0e80c6b82f1e834b03c9aba58a9","modified":1463364692528},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"88a5e0e95f93e4adb196bff1aac17d6cfb03768a","modified":1463364692530},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8b37699252a24741716b40fb70972a77453cbfe1","modified":1463364692536},{"_id":"themes/next/source/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1463364692537},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"802e599b1ac749eac162dae396f66b0acaa5edcc","modified":1463364692529},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1463364692522},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1463364692538},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1463364692538},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1463364692538},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1463364692538},{"_id":"themes/next/source/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1463364692539},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1463364692542},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1463364692541},{"_id":"themes/next/source/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1463364692542},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css","hash":"811432ad1e2d6c1f6da9a63fd919bf2a02b71dd9","modified":1463364692546},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.min.css","hash":"4c2c5f5f6cc86d775a44b944661e038b7be98149","modified":1463364692546},{"_id":"themes/next/source/vendors/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1463364692556},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1463364692544},{"_id":"themes/next/source/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1463364692544},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1463364692558},{"_id":"themes/next/source/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1463364692546},{"_id":"themes/next/source/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1463364692558},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1463364692554},{"_id":"themes/next/source/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1463364692548},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1463364692549},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1463364692553},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1463364692512},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1463364692513},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"852fd77500bda2c1a6651a14aa48d7d6222adc9d","modified":1463364692513},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4c4ef6e997d0c6e21de39c2daa0c768e12c8c6fa","modified":1463364692512},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1463364692513},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"f168f79ba8cc80c775907da4cc00d01771ac1e1e","modified":1463364692513},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"6c34f2cf9ad9b9b787007cfca522deeb6b1ae3b7","modified":1463364692515},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"b8f9c95702e87fd0b170ab586c82c9718a245f8a","modified":1463364692515},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1463364692515},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"12724e07713c9e8d577d921c131f04de7a5e65b1","modified":1463364692514},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1463364692516},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"9f0606d4d94ffa6bd77f91628507bba19133cf36","modified":1463364692514},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1463364692516},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"5dba4ca272d7c767b57233cd99fba95dbf82153f","modified":1463364692516},{"_id":"themes/next/source/css/_common/components/post/post-more-link.styl","hash":"c9e3c5aca361ed9bbfa41a9755f3c516025da67e","modified":1463364692517},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"929fac3a505bacbce6ba63009fd15851e2a8669d","modified":1463364692517},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1463364692517},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"758d64ad65f718537ab5bfe5592a626abc40987e","modified":1463364692517},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1463364692517},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"8539c1122966a6aea64267d48af05603caa5fa29","modified":1463364692514},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"7f2bdd6109614d35408ee5ac3335aad4464c69c7","modified":1463364692518},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"70407054dbb5180c69e50ea2655d32835494394e","modified":1463364692518},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"821991c0890966a512b43e8b1cf9537e738a09a0","modified":1463364692518},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1463364692518},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1463364692518},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"68ed6b0ad40745cb07ecd38f13960bb217aef848","modified":1463364692515},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"06b9a99d63b4d57fdbf70b88ab7036fbc47e3f52","modified":1463364692519},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"4866fb9453d7d4c83a1c4e55d74e4afed336eb8b","modified":1463364692516},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"99c4b7d1459569cda394c733845d368008a180bf","modified":1463364692520},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"0e91a5a80fb62ed38c97cb649b166f945c6ce5f1","modified":1463364692517},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1463364692520},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"dd941824210733588841897457e0cc9697ca5608","modified":1463364692520},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1463364692520},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"a83f493e494f5c73fab8f6f5b686ef1670490095","modified":1463364692521},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1463364692521},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"97832be1f30b631dbc2202524918b6eb55e74c4b","modified":1463364692519},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1463364692521},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1463364692521},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"0f368e6e95c0ba46580b491819e46ae31910c94b","modified":1463364692522},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"546ad04994f74643334fd36cdb548c17f71b11be","modified":1463364692519},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1463364692526},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1463364692539},{"_id":"themes/next/source/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1463364692539},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"dcb4548d07cbb38b645b1753cf3ee7157e16921a","modified":1463364692521},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1463364692540},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1463364692540},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1463364692540},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1463364692553},{"_id":"themes/next/source/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1463364692541},{"_id":"themes/next/source/vendors/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1463364692561},{"_id":"themes/next/source/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1463364692551},{"_id":"public/sitemap.xml","hash":"a8ae7836afbdac540e48171a2aca59dbf97dfd61","modified":1470638197852},{"_id":"public/atom.xml","hash":"284d6d3d789e84bc8b1d0dcf2bf8c45756d8daaa","modified":1470638197857},{"_id":"public/about/index.html","hash":"f67a93cabb61ced6db34db4e700761e41a7c532f","modified":1470638200134},{"_id":"public/2016/06/27/迭代协议/index.html","hash":"da8f6bc8b73da204613dab3c0cf24a19503c5b06","modified":1470638200158},{"_id":"public/2016/07/27/使用ServiceWorkers/index.html","hash":"2476e2e61b6fd692c7d60c1f4e7bd90145c61fbe","modified":1470638200158},{"_id":"public/2016/07/26/初识ServiceWorker/index.html","hash":"9734c0703ec36a73014f51910fb7080057555c73","modified":1470638200158},{"_id":"public/2016/08/05/JavaScript秘密花园/index.html","hash":"23d0deea3d80e25ba7acc2eecb7a3a79ee0c1ee0","modified":1470638200158},{"_id":"public/2016/07/28/初始Promise/index.html","hash":"4a41af3f1689ce627217b26418e1c192804ec076","modified":1470638200158},{"_id":"public/2016/07/25/这个API很迷人/index.html","hash":"bd3d224bc450e96cb96ad14fe4e1c32433399dc0","modified":1470638200158},{"_id":"public/2016/06/20/数组中插入元素/index.html","hash":"6370c5110fff2055d6acfd1ec62d1827ad628005","modified":1470638200158},{"_id":"public/2016/06/02/es6系列教程三/index.html","hash":"2d897d7453df9917901d809bc8aae1600b9d4348","modified":1470638200158},{"_id":"public/2016/06/02/es6系列教程二/index.html","hash":"f49d144618718d4b8208f9354d1562213f167302","modified":1470638200158},{"_id":"public/2016/06/06/es6系列教程四/index.html","hash":"ca4f8cf4da92ea7bb3dee7f19002000106e66d2e","modified":1470638200158},{"_id":"public/2016/06/01/es6系列教程一/index.html","hash":"37e00f57cb9f1dce8e58e6805492003ada8c6b94","modified":1470638200158},{"_id":"public/2016/06/23/JSON-stringify-JSON-parse/index.html","hash":"95df6c897b9c2e5e659dee95d2e765a49cab7632","modified":1470638200158},{"_id":"public/2016/05/30/用卡通图介绍Redux/index.html","hash":"063653d1d72d65b9dbc4dec5f79f0a70219ed4bb","modified":1470638200213},{"_id":"public/2016/04/04/animation-详解/index.html","hash":"187a83dd3b556b84c05b17852ebe772908df144c","modified":1470638200214},{"_id":"public/2015/10/27/zepto学习笔记/index.html","hash":"81c804c764d098cb79b267d6b155502f77c09ab0","modified":1470638200214},{"_id":"public/categories/转载笔记/page/2/index.html","hash":"9ceeda7789a2e7da0e7f0495edcb643050843dbb","modified":1470638200214},{"_id":"public/categories/转载笔记/index.html","hash":"762724c61a7cfdd130cda0332b0bb7b1316956e6","modified":1470638200214},{"_id":"public/categories/转载笔记/page/3/index.html","hash":"627d0ae6464c742aef72fa60cf834e89282da051","modified":1470638200214},{"_id":"public/categories/笔记/index.html","hash":"dbe66d0b454d857d3fa8f039d31fe3f3d4abc732","modified":1470638200214},{"_id":"public/categories/教程/index.html","hash":"b57b2d2200d4fe58ee422b137043ffad5b0719bc","modified":1470638200214},{"_id":"public/categories/教程/page/2/index.html","hash":"b96cb1a0cf8c9993a3ca15df715a05f23acaa355","modified":1470638200214},{"_id":"public/categories/原创/index.html","hash":"29720800b983e167e2752cde9c47cb260f1122e5","modified":1470638200214},{"_id":"public/categories/翻译/index.html","hash":"60a421a8847b9ddb8363be50366bcc67cd23bebe","modified":1470638200214},{"_id":"public/archives/index.html","hash":"395bb42a76b2f7a92032599d673e0f8236d01fd8","modified":1470638200214},{"_id":"public/categories/笔记/page/2/index.html","hash":"711256afee0b0217b25421eb5660806c8558c043","modified":1470638200214},{"_id":"public/archives/page/3/index.html","hash":"2716da50f8806492e6302724fc5b005fa96df34c","modified":1470638200214},{"_id":"public/archives/page/5/index.html","hash":"98a89402f54654cd20ae0a7bb95ec2fbee1831ad","modified":1470638200214},{"_id":"public/archives/page/2/index.html","hash":"45ec0877fde0b2e4b2229fa157ddfa237b999bd2","modified":1470638200214},{"_id":"public/archives/2015/index.html","hash":"1c33c8d20fb8036910861a22b4a736d6df5df2d2","modified":1470638200214},{"_id":"public/archives/2015/10/index.html","hash":"e52f15037852672e209f8e65f3b68d4591de9e70","modified":1470638200214},{"_id":"public/archives/page/4/index.html","hash":"754d05a6a8eeb66225571291939a884896ced6e6","modified":1470638200214},{"_id":"public/archives/page/6/index.html","hash":"226883fff202c028c17c9e83319ddc35e9e6f77f","modified":1470638200214},{"_id":"public/archives/page/7/index.html","hash":"2313dc5c19a66592a38122e15d01cef1410199f6","modified":1470638200214},{"_id":"public/archives/2016/index.html","hash":"679b351c843d1bab4c2aa853038743249cf5b3cd","modified":1470638200214},{"_id":"public/archives/2016/page/3/index.html","hash":"3f26afa0ef531134d9154b0fa9cab4c895eb1200","modified":1470638200214},{"_id":"public/archives/2016/page/4/index.html","hash":"53f7a65a3323e932562e9f589c4046ff37235c1e","modified":1470638200214},{"_id":"public/archives/2016/page/5/index.html","hash":"819ede91af44ae19fd824b97e021bd1e39fc9d52","modified":1470638200214},{"_id":"public/archives/2016/page/2/index.html","hash":"02c12a467ed8ee4c7d70abf03b281fabe46f0cf4","modified":1470638200214},{"_id":"public/archives/2016/page/6/index.html","hash":"ea26142542061e798a42533c1a938f3325767709","modified":1470638200214},{"_id":"public/archives/2016/page/7/index.html","hash":"7712578f0c5cbc7ef1fc0029b678d878aeb0560c","modified":1470638200215},{"_id":"public/archives/2016/03/index.html","hash":"d532b0b9e925fabb96fb7e70bdc06697c3dfdaf4","modified":1470638200215},{"_id":"public/archives/2016/04/index.html","hash":"0ee9ddb100ab8f3a01996a6973daf5b1822014dd","modified":1470638200215},{"_id":"public/archives/2016/05/index.html","hash":"eb9210b161ad172545d35a6f1759c3f5d457fe92","modified":1470638200215},{"_id":"public/archives/2016/05/page/4/index.html","hash":"7a1646b9cd1c7793dcefe52447d7fba77df49316","modified":1470638200215},{"_id":"public/archives/2016/05/page/2/index.html","hash":"5a6a1c255373e1b05cd6dc282fe0ed9a1d9fd55d","modified":1470638200215},{"_id":"public/archives/2016/05/page/3/index.html","hash":"b4ef7f69bb4716d4c0ab3fc98c98e6317b34ce6f","modified":1470638200215},{"_id":"public/archives/2016/06/index.html","hash":"6bddc111873f0eb4b7108b28d3794f96ac6ff21f","modified":1470638200215},{"_id":"public/archives/2016/06/page/2/index.html","hash":"1ca38011f1d8c9abf6e8df7b9e1205f2c0f4d9f6","modified":1470638200215},{"_id":"public/archives/2016/07/index.html","hash":"3b1e8e856c35f4793eca4d53b9055c180ce18c0e","modified":1470638200215},{"_id":"public/archives/2016/08/index.html","hash":"0fecb153cac60c8b92fc918421fb441ed4e5cf42","modified":1470638200215},{"_id":"public/tags/javascript/index.html","hash":"7a43fd6372331d1911f08554b20a4acbfea7b366","modified":1470638200216},{"_id":"public/tags/javascript/page/4/index.html","hash":"f62ffb14266ede02cce4dc4d89bb943aaa5d6485","modified":1470638200216},{"_id":"public/tags/javascript/page/3/index.html","hash":"fd15f7a55fcf6245c6f0e05e9c64276bcfe4242b","modified":1470638200216},{"_id":"public/tags/javascript/page/2/index.html","hash":"832d4942a0e97130e7b4a064703da5f11b99b3f2","modified":1470638200216},{"_id":"public/tags/函数式编程/index.html","hash":"66514f64fa11cce1d95009e97386808f6370a995","modified":1470638200216},{"_id":"public/tags/javascript/page/5/index.html","hash":"b04af899c0a6c8519d2246b5e85ae2f52728579d","modified":1470638200216},{"_id":"public/tags/函数式编程/page/2/index.html","hash":"c5fd16b1fba0955d7d3628ec4354691336fcc6a7","modified":1470638200216},{"_id":"public/tags/css3/index.html","hash":"df570890b5d53819f3ffb72c2b4908b3d3fdf1de","modified":1470638200216},{"_id":"public/tags/animation/index.html","hash":"f8d83416e5f23e13d2cc9508369f47da3b0400e8","modified":1470638200216},{"_id":"public/tags/es6/index.html","hash":"d867a99357a9c88eca43beab15670fe34274e1c0","modified":1470638200216},{"_id":"public/tags/JSON/index.html","hash":"d99f13cff1326206c0a141f2e55f0efdf49f4650","modified":1470638200216},{"_id":"public/tags/Redux/index.html","hash":"9b8eed85e3567f7efab9aec74151d7b3ea8bc210","modified":1470638200216},{"_id":"public/tags/react/index.html","hash":"b76d4d0537fb03706c9628eacec1530f5d70e9b8","modified":1470638200216},{"_id":"public/tags/reduce/index.html","hash":"f7e3cce81c86cf7f4cc58d4cef1ac5055fed5ea8","modified":1470638200216},{"_id":"public/tags/zepto/index.html","hash":"b433751f87c5b7fb11bcc4db1b06fdf1b150892e","modified":1470638200216},{"_id":"public/tags/学习笔记/index.html","hash":"113af848711955545e8a94c5fc48a03dc2a30ab9","modified":1470638200216},{"_id":"public/tags/webpack/index.html","hash":"d5961a37fdb8eb2eb8ae41518c56d312d981e3e1","modified":1470638200216},{"_id":"public/tags/快速上手/index.html","hash":"3f835de85f4017fb02e94f96af6be4f854cba4d9","modified":1470638200216},{"_id":"public/tags/flexible/index.html","hash":"6542f8cfe120a837172532350f5d8aea698875e9","modified":1470638200216},{"_id":"public/tags/终端适配/index.html","hash":"6370edf10c19a42613698e16ad7bb7905218337e","modified":1470638200216},{"_id":"public/tags/immutable/index.html","hash":"850fa99dfecd6dfa261276b50797827d7faa2b58","modified":1470638200216},{"_id":"public/tags/service-worker/index.html","hash":"e84e975a1f54b73ee4443dd2f1d33f5b70ee8b25","modified":1470638200216},{"_id":"public/tags/模块系统/index.html","hash":"c26eff2796cb51de3302de48f82616307a6400ee","modified":1470638200216},{"_id":"public/tags/流程控制和错误处理/index.html","hash":"694a55de2a62b7e6fee236cfd752bed7a56d192c","modified":1470638200216},{"_id":"public/tags/promise/index.html","hash":"26d82d0af8aed1be2fa39e8c3207ca53617cdace","modified":1470638200216},{"_id":"public/tags/tips/index.html","hash":"66ec7fd3fb5230c33f950dac928ac31d879e8137","modified":1470638200216},{"_id":"public/tags/语法和数据类型/index.html","hash":"16344946a7f378572eae243e0c8aa05ee6f33bcd","modified":1470638200217},{"_id":"public/tags/protocol/index.html","hash":"6807dd0198f0b1f0609878c41a8f47d0eb13b72a","modified":1470638200217},{"_id":"public/2016/05/31/React-Redux文档/index.html","hash":"27ea8922ded15214f36c353fe49f9ec91480785b","modified":1470638200217},{"_id":"public/2016/05/26/深入理解Redux的Middleware/index.html","hash":"9bdf9510dde6162eea0969f2e349fc28f3f5f627","modified":1470638200217},{"_id":"public/2016/05/23/Redux快速上手/index.html","hash":"67c175a95cbe830fb13ef06e715bdbaf3ab53bc8","modified":1470638200217},{"_id":"public/2016/05/22/函数组合-JS函数式编程/index.html","hash":"1576513b2a8ff5b0877dd9a105c5df38df6d9a6c","modified":1470638200217},{"_id":"public/2016/05/22/基本函数式的编程/index.html","hash":"e168254e1a34c7e2d8d64e4478ea05417d11e1ed","modified":1470638200217},{"_id":"public/2016/05/19/在Javascript中实现函数式编程的技术0/index.html","hash":"12c92b2b5179bc3b621f1d6271d316dde63f4d08","modified":1470638200217},{"_id":"public/2016/05/19/Javascript的函数式库/index.html","hash":"bc79f07cdf48b3ccd13fcae3c716eee6ae254a84","modified":1470638200217},{"_id":"public/2016/05/18/函数式编程-月影/index.html","hash":"ab70e7d85355d7a8bc81d5aa8e3672e9059fea41","modified":1470638200217},{"_id":"public/2016/05/18/JS函数式编程的力量-转/index.html","hash":"62afc6f3d66fa52657886b5cc667a80a9cc40a54","modified":1470638200217},{"_id":"public/2016/05/17/流程控制与错误处理/index.html","hash":"556727b787140f10083264bdd2d41647653c425f","modified":1470638200217},{"_id":"public/2016/05/18/函数式编程基础-转/index.html","hash":"08e6e19071bc037c6ac50220787a79a596de5427","modified":1470638200217},{"_id":"public/2016/05/16/语法和数据类型/index.html","hash":"53e0272deffde4345905dcd26563f9aabf888c1b","modified":1470638200217},{"_id":"public/2016/05/23/范畴论-JS函数式编程/index.html","hash":"e5e05762b684a80681d358bf44ca117d636c8b22","modified":1470638200217},{"_id":"public/2016/05/09/Immutable详解及React中实践/index.html","hash":"1215f98ce45ef51df1aa4837d65ac40554a37d34","modified":1470638200217},{"_id":"public/2016/05/09/reduce的用法/index.html","hash":"ec4f6a647423366d31f0d85d0025353965eca4b2","modified":1470638200217},{"_id":"public/2016/05/08/es6函数式编程/index.html","hash":"f5d68d268a48719d3dace4021ab4828ab45b7db0","modified":1470638200217},{"_id":"public/2016/03/22/webapck配置指导/index.html","hash":"9d0252ab3adb6b61b36a96c315ed9a8abf7eaa1f","modified":1470638200217},{"_id":"public/2016/03/18/模块系统/index.html","hash":"bbb1bbfd1d57b661fa975c502d1c4278567e6a08","modified":1470638200217},{"_id":"public/2016/03/24/使用Flexible实现H5页面终端适配/index.html","hash":"52424e5a3571e1d779700588929c3ce1bdd7b79b","modified":1470638200217},{"_id":"public/index.html","hash":"4972ce56f79916e8a15bae4a977ae3b6b45f7fc9","modified":1470638200218},{"_id":"public/page/2/index.html","hash":"a24a0bd7904c0088ebd01eb571c29d8e3d38535b","modified":1470638200218},{"_id":"public/page/3/index.html","hash":"6358edeaff5f97937780b40bc779969faa21e9be","modified":1470638200218},{"_id":"public/page/4/index.html","hash":"c2a72ae67bb984c0e0e6731fc0c4f8aab6c986e6","modified":1470638200218},{"_id":"public/page/7/index.html","hash":"ef3db88b9563034ce443f8b827156fd73fbe7f7a","modified":1470638200218},{"_id":"public/page/5/index.html","hash":"2c805daa03b8c3c92d049a498c9c8e9ed88033bb","modified":1470638200218},{"_id":"public/page/6/index.html","hash":"494ade743cb6e921da523cc98524729abd0563db","modified":1470638200218},{"_id":"public/favicon.ico","hash":"421c09dd34bd64ec866f4d34b808c887b23b1afe","modified":1470638200237},{"_id":"public/images/avatar.jpg","hash":"cec12ec035c5a08107cf379ea621d240b71377a0","modified":1470638200237},{"_id":"public/images/promise/promises.png","hash":"6ee3f072dbb90940644c141bc1bb8a604b449ae1","modified":1470638200237},{"_id":"public/images/flexible/flexible03.png","hash":"f3c194f0ea9047ba2b12f777d2f66c19813cb55e","modified":1470638200237},{"_id":"public/images/flexible/flexible04.png","hash":"dbd8d6ab64540975fc2dce44368a5986d787e6b9","modified":1470638200237},{"_id":"public/images/flexible/flexible06.png","hash":"5d054f69961f17a7b971998d7579c7b196bf042c","modified":1470638200237},{"_id":"public/images/flexible/flexible07.png","hash":"c8f5535f6c970f2951cff1339920991153aeaed2","modified":1470638200237},{"_id":"public/images/serviceWorker/sw-events.png","hash":"50126437d4e20df5a44f913c44c93e0e1fceecc8","modified":1470638200237},{"_id":"public/images/serviceWorker/sw-lifecycle.png","hash":"dcaf6ee3efa6becb3588e944354c73fe77632a0b","modified":1470638200237},{"_id":"public/images/flexible/flexible08.png","hash":"4c841e678059a3eaac0b8c4ac4d70cce106e95c3","modified":1470638200237},{"_id":"public/images/react/1-4zODv5vgvKsi6Ts7TihsoA.png","hash":"c0d74e0233df0341147d641813cb2058422d6827","modified":1470638200237},{"_id":"public/images/react/1-Gztc7THzxzOgJmGvJ95IQA.png","hash":"6559629c36d2aa8ea2e234fe14b766aa0469d4c7","modified":1470638200237},{"_id":"public/images/react/1-5JaZSc3Jsn9PJY7daEDVDA.png","hash":"5d3efa895e30500fc8661c3ce57873508c8bdcb0","modified":1470638200237},{"_id":"public/images/react/1-D1RcVrMV2rp6AH9hk5xZ8g.png","hash":"2a7ade4c9c17954d10db094b138caf2d5aff087f","modified":1470638200237},{"_id":"public/images/react/1--S_dYe6BoQBgwSRpF7Hriw.png","hash":"b0639562e2ecfe74a6802990b403996da4d8723c","modified":1470638200237},{"_id":"public/images/react/1-GNDs7SY53lEhp7mX8V25lw.png","hash":"b466301399e5fe9aa2769da066d94df9a92fcd77","modified":1470638200237},{"_id":"public/images/react/1-8_fU31-jNQnQ0dp-wplm5w.png","hash":"9795a04c4817cb716581a41d8125d3462721c503","modified":1470638200237},{"_id":"public/images/react/1-L66K9uCQjjHmpAwT-a9C5Q.png","hash":"0e02a0ca0aa650609e61f772466f4b7b86b63068","modified":1470638200237},{"_id":"public/images/react/1-MG736zGtLMBbSkhwu4D3cA.png","hash":"b7734507e434cfde8879ef60c5f2fe94a3872c18","modified":1470638200237},{"_id":"public/images/react/1-Uljrrh4Z7UiUwk8AjUO9PA.png","hash":"5d338c472035f19f44f6b072ff1e2fa45afd13a1","modified":1470638200237},{"_id":"public/images/react/1-TgCkFcjlD9SxSrMvVX3DrA.png","hash":"20e4ea236faea61934af0b91550ca2becf3cc242","modified":1470638200237},{"_id":"public/images/react/1-JXPeiNP-it60-QYKb-p2eQ.png","hash":"d2d6bef781841017619f123307da45ef44d70868","modified":1470638200237},{"_id":"public/images/react/1-Vocy_6Gl9PbFlCIJsE9r3A.png","hash":"dbe612ae15b6595db75aec1fc4947c58ee9a744d","modified":1470638200238},{"_id":"public/images/react/1-NYMutQLW8TcEgbO8VNeqHA.png","hash":"840e59a71ade03013b5ee756d54181794f3075b7","modified":1470638200238},{"_id":"public/images/react/1-wLRhZ0wtI0duLsigdxL1CA.png","hash":"6837565e8c7c53b604a55577892ac866e593d8cb","modified":1470638200238},{"_id":"public/images/react/1-aVoD3gGddKUy3VCxwylthQ.png","hash":"42a8b98d8fafb24119fdeeea0ce522b5f342fd42","modified":1470638200238},{"_id":"public/images/react/1-p4EkWE_8upZ97Z0IapKDcQ.png","hash":"778f29b3160c2013bc2ff781d430d75096a2996b","modified":1470638200238},{"_id":"public/images/react/1-bUMekI8QlEfFxSBCuVuIkw.png","hash":"8314a77614428110601d643d5d362731e82cee36","modified":1470638200238},{"_id":"public/images/react/1-zrsSoAAyf4pqTMHiA6P8Ww.png","hash":"016b1c15d2d1ba396637d5242b2bd13adce7f5ef","modified":1470638200238},{"_id":"public/images/react/flux.jpg","hash":"e98cca3e6d29e1f6aacd7f86e242ba684d56858f","modified":1470638200239},{"_id":"public/images/范畴论/1.png","hash":"6204a06b24080c3995b1caec5c67e2465dc972fc","modified":1470638200239},{"_id":"public/images/范畴论/3.png","hash":"5b7eb63e53fec4910d3e51c07a0d38f3d0872930","modified":1470638200239},{"_id":"public/images/范畴论/2.png","hash":"874f391403fabb07b9ca73213e702764c884bd2a","modified":1470638200239},{"_id":"public/images/react/1-nBsGCWmJTR-Zj7aXeIE8yg.png","hash":"e93dbeee0b3c295fad94eeb949158bb7aed4c2d5","modified":1470638200239},{"_id":"public/images/react/1-zmFp3bmDq7b6Bvlo8Ineag.png","hash":"470c69de4a6ebe714b6b3d6d0ffcb8e56e1745e3","modified":1470638200239},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1470638200239},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1470638200239},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1470638200239},{"_id":"public/CNAME","hash":"2fee1653bd2540632d79b43158dc970577d7fdda","modified":1470638200239},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1470638200239},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1470638200239},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1470638200239},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1470638200239},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1470638200239},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1470638200239},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1470638200239},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1470638200239},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1470638200239},{"_id":"public/images/react/redux.jpg","hash":"3db24afe31e7218b4ac6cc74497204250b2f5f3a","modified":1470638200239},{"_id":"public/vendors/font-awesome/HELP-US-OUT.txt","hash":"ed80b43dbc7e3009b2f436741b9796df8eb3be02","modified":1470638200239},{"_id":"public/vendors/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1470638200239},{"_id":"public/vendors/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1470638200239},{"_id":"public/vendors/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1470638200240},{"_id":"public/vendors/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1470638200240},{"_id":"public/vendors/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1470638200240},{"_id":"public/vendors/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1470638200240},{"_id":"public/vendors/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1470638200240},{"_id":"public/vendors/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1470638200240},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff2","hash":"574ea2698c03ae9477db2ea3baf460ee32f1a7ea","modified":1470638200240},{"_id":"public/vendors/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1470638200240},{"_id":"public/images/flexible/flexible02.png","hash":"858c0905d08a2454cc3fdbc32726d3c856717fab","modified":1470638201183},{"_id":"public/images/flexible/flexible01.png","hash":"dc9be1fd1a3eb85adc0cdb803ae4d51e00ca2180","modified":1470638201185},{"_id":"public/images/flexible/flexible05.png","hash":"9a9389cbb474f1216a6c2c80d4e9cd131d148598","modified":1470638201190},{"_id":"public/images/flexible/flexible10.png","hash":"a943ddd6f14e34e3267f2f15f8027fcc4a3f78c8","modified":1470638201190},{"_id":"public/images/flexible/flexible09.png","hash":"689c9ef22b7ba120aabe2b40b38a586ac700e158","modified":1470638201190},{"_id":"public/images/react/1-_R-rGNfKr2Xu2FlXNZNPJg.png","hash":"72aed04ac02b45246a053a982f3e26e04d9cb74e","modified":1470638201190},{"_id":"public/images/react/1-Je2mow8mjYLngXreGGlIEg.png","hash":"288cc20960a034474b34470f18c4afb05f7c94e3","modified":1470638201190},{"_id":"public/images/react/1-x6vBvUlFJktJqty56jr0QQ.png","hash":"827e121a7ae678b9a10eb0bd78a12bbfba1a01cc","modified":1470638201190},{"_id":"public/images/react/1-qGatznV4QujuxGe49YfX5A.png","hash":"13fd9e9a77ee9ad75e740152873215c6816e919f","modified":1470638201190},{"_id":"public/vendors/font-awesome/fonts/FontAwesome.otf","hash":"0112e96f327d413938d37c1693806f468ffdbace","modified":1470638201190},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.eot","hash":"b3c2f08e73320135b69c23a3908b87a12053a2f6","modified":1470638201190},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.woff","hash":"507970402e328b2baeb05bde73bf9ded4e2c3a2d","modified":1470638201190},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1470638201198},{"_id":"public/js/src/utils.js","hash":"cf24307d8aeb18e9bad093647c7fb50dc3d9fbe8","modified":1470638201198},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1470638201198},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1470638201198},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1470638201198},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1470638201198},{"_id":"public/vendors/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1470638201198},{"_id":"public/vendors/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1470638201198},{"_id":"public/vendors/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1470638201198},{"_id":"public/vendors/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1470638201198},{"_id":"public/vendors/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1470638201198},{"_id":"public/vendors/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1470638201198},{"_id":"public/vendors/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1470638201198},{"_id":"public/vendors/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1470638201198},{"_id":"public/js/src/schemes/pisces.js","hash":"94f935331995bfeadf1084fb8f0665ab39fd1c8d","modified":1470638201198},{"_id":"public/vendors/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1470638201198},{"_id":"public/vendors/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1470638201198},{"_id":"public/vendors/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1470638201198},{"_id":"public/vendors/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1470638201198},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1470638201198},{"_id":"public/vendors/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1470638201198},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1470638201198},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1470638201198},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1470638201198},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1470638201198},{"_id":"public/vendors/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1470638201198},{"_id":"public/css/main.css","hash":"427bbaf63a8c775c7a5b5e2cfb4b726eaa30ba2e","modified":1470638201198},{"_id":"public/vendors/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1470638201198},{"_id":"public/vendors/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1470638201198},{"_id":"public/vendors/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1470638201198},{"_id":"public/vendors/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1470638201198},{"_id":"public/vendors/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1470638201198},{"_id":"public/vendors/font-awesome/css/font-awesome.css","hash":"3b87c2560832748cd06f9bfd2fd6ea8edbdae8c7","modified":1470638201199},{"_id":"public/vendors/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1470638201199},{"_id":"public/vendors/font-awesome/css/font-awesome.min.css","hash":"05ea25bc9b3ac48993e1fee322d3bc94b49a6e22","modified":1470638201199},{"_id":"public/vendors/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1470638201199},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.ttf","hash":"27cf1f2ec59aece6938c7bb2feb0e287ea778ff9","modified":1470638201199},{"_id":"public/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png","hash":"6087bb43308243aa4a0bdc06f8c431449f8b48ef","modified":1470638201492},{"_id":"public/vendors/font-awesome/fonts/fontawesome-webfont.svg","hash":"f346b8b3df147e4059e1a7d66c52c9a6e1cec3e8","modified":1470638201669}],"Category":[{"name":"笔记","_id":"cirlo0elr0004b0dltsse9log"},{"name":"转载笔记","_id":"cirlo0em10009b0dlfjjcnjon"},{"name":"教程","_id":"cirlo0emo000kb0dldl5b4905"},{"name":"原创","_id":"cirlo0emv000yb0dlmhfm7xa5"},{"name":"翻译","_id":"cirlo0ens002bb0dlhgd76615"}],"Data":[],"Page":[{"title":"about","date":"2016-03-22T08:02:16.000Z","_content":"## 我很帅，页面加载不出来了。。。","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-03-22 16:02:16\n---\n## 我很帅，页面加载不出来了。。。","updated":"2016-05-16T02:11:32.479Z","path":"about/index.html","comments":1,"layout":"page","_id":"cirlo0elm0001b0dlzkvr9274","content":"<h2 id=\"我很帅，页面加载不出来了。。。\"><a href=\"#我很帅，页面加载不出来了。。。\" class=\"headerlink\" title=\"我很帅，页面加载不出来了。。。\"></a>我很帅，页面加载不出来了。。。</h2>","excerpt":"","more":"<h2 id=\"我很帅，页面加载不出来了。。。\"><a href=\"#我很帅，页面加载不出来了。。。\" class=\"headerlink\" title=\"我很帅，页面加载不出来了。。。\"></a>我很帅，页面加载不出来了。。。</h2>"}],"Post":[{"title":"JavaScript秘密花园","date":"2016-08-05T08:22:23.000Z","_content":"> Laughing is the most touching mask.\n\n## 对象\n\n### 对象使用和属性\nJavaScript中所有变量都可以当作对象使用，除了两个例外`null`和`undefined`。\n```javascript\n  false.toString(); //'false'\n  [1,2,3].toString(); //'1,2,3'\n\n  function Foo(){}\n  Foo.bar = 1;\n  Foo.bar; //1\n```\n一个常见的误解是数字的字面值(literal)不能当作对象使用。这是因为JavaScript解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。\n```javascript\n  2.toString(); //SyntaxError\n```\n有很多变通方法可以让数字的字面值看起来像对象。\n```javascript\n  2..toString(); //第二个点号可以正常解析\n  2 .toString(); //注意点号前面的空格\n  (2).toString(); //2先被计算\n```\n\n### 对象作为数据类型\nJavaScript的对象可以作为哈希值使用，主要用来保存命名的键与值的对应关系。\n使用对象的字面语法- {} -可以创建一个简单对象。这个新创建的对象从`Object.prototye`继承下来，没有任何自定义属性。\n```javascript\n  var foo = {}; //一个空对象\n  //一个新对象，拥有一个值为12的自定义属性'test'\n  var bar = {test: 12};\n```\n\n### 访问属性\n有两种方式来访问对象的属性，点操作符或者中括号操作符。\n```javascript\n  var foo = {name: 'kitten'};\n  foo.name; // kitten\n  foo['name']; // kitten\n\n  var get = 'name';\n  foo[get]; // kitten\n\n  foo.1234; // SyntaxError\n  foo['1234']; // works\n```\n两种语法是等价的，但是中括号操作符在下面两种情况下依然有效\n - 动态设置属性\n - 属性名不是一个有效的变量名(比如属性名中包含空格，或者属性名是JS的关键词)\n\n### 删除属性\n删除属性的唯一方法是使用`delete`操作符;设置属性为`undefined`或者`null`并不能真正的删除属性，而仅仅是移除了属性和值的关联。\n```javascript\n  var obj = {bar: 1, foo:2, baz:3};\n  obj.bar = undefined;\n  obj.foo = null;\n  delete obj.baz;\n\n  for(var i in obj){\n    if(obj.hasOwnProperty(i)){\n      console.log(i, ''+obj[i]);\n    }\n  }\n```\n上面的输出的结果有`bar undefined`和`foo null`只有`baz`被真正的删除了，所以从输出结果中消失。\n\n### 属性名的语法\n```javascript\n  var test = {\n    'case': 'I am a keyword so I must be notated as a string',\n    delete: 'I am a keyword too so me' // 出错：SyntaxError\n  }\n```\n对象的属性名可以使用字符串或者普通字符声明。但是由于javascript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript5之前会抛出`SyntaxError`的错误。\n这个错误的原因 是delete是javascript语言的一个关键词；因此为了在更低版本的javascript引擎下也能运行，必须使用字符串字面值声明方式。\n\n### 原型\nJavaScript不包含传统的类继承模型，而是使用prototype原型模型。\n虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。\n由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。\n\n第一个不同之处在于JavaScript使用原型链的继承方式。\n```javascript\n  function Foo(){\n    this.value = 42;\n  }\n  Foo.prototype = {\n    method: function(){}\n  };\n\n  function Bar(){}\n\n  //设置Bar的prototype属性为Foo的实例对象\n  Bar.prototype = new Foo();\n  Bar.prototype.foo = 'Hello World';\n\n  //修正Bar.prototype.constructor为Bar本身\n  Bar.prototype.constructor = Bar;\n\n  var test = new Bar() // 创建Bar的一个新实例\n\n  //原型链\n  test [Bar的实例]\n    Bar.prototype [Foo的实例]\n      {foo: 'Hello World'}\n      Foo.prototype\n        {method: ...};\n        Object.prototype\n          {toString: ...}\n```\n**注意：** 简单的使用`Bar.prototype = Foo.prototype`将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。不要使用`Bar.prototype = Foo`，因为这不会执行`Foo`的原型，而是指向函数`Foo`。因此原型链将会回溯到`Function.prototype`而不是`Foo.prototype`，因此`method`将不会在`Bar`的原型链上。\n\n上面的例子中，`test`对象从`Bar.prototype`和`Foo.prototype`继承下来;因此，它能访问`Foo`的原型方法`method`。同时，它也能够访问那个定义在原型上的`Foo`实例属性`value`。需要注意的是`new Bar()`不会创造出一个新的`Foo`实例，而是重复使用它原型上的那个实例；因此，所有的`Bar`实例都会共享相同的`value`属性。\n\n### 属性查找\n当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。\n到查找到达原型链的顶部-也就是`Object.prototype`-但是仍然没有找到指定的属性，就会返回`undefined`。\n\n### 原型属性\n当原型属性用来创建原型链时，可以把任何类型的值赋给它(prototype)。然而将原子类型赋给prototype的操作将会被忽略。\n```javascript\n  function Foo(){}\n  Foo.prototype = 1; //无效\n```\n而将对象赋值给prototype,正如上面的例子所示，将会动态的创建原型链。\n\n### 性能\n如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。\n并且，当使用`for in`循环遍历对象属性时，原型链上的所有的属性都将被访问。\n\n### 扩展内置类型的原型\n一个错误特性被经常使用，那就是拓展`Object.prototype`或者其他内置类型的原型对象。\n这种技术被称之为`mobkey patching`并且会破坏封装。虽然它被广泛的应用到一些JavaScript类库中，比如`Prototype`，但是为内置类型添加一些非标准的函数仍然不是一个好主意。\n扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如`Array.forEach`.\n\n### 总结\n在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。\n\n### hasOwnProperty函数\n为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自`Object.prototype`的`hasOwnProperty`方法。\n`hasOwnProperty`是JavaScript中唯一一个处理属性但是不查找原型链的函数。\n**注意：** 通过判断一个属性是否undefined是不够的。因为一个属性可能确实存在，只不过它的值被设置为undefined。\n```javascript\n  //修改Object.prototype\n  Object.prototype.bar = 1;\n  var foo = {goo: undefined};\n\n  foo.bar; //1\n  'bar' in foo; //true\n\n  foo.hasOwnProperty('bar'); //false\n  foo.hasOwnProperty('goo'); //true\n```\n只有`hasOwnProperty`可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其他方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。\n\n**hasOwnProperty** 作为属性\n`Javascript`不会保护`hasOwnProperty`被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的`hasOwnProperty`函数来获取正确的结果。\n```javascript\n  var foo = {\n    hasOwnProperty: function(){\n      return false;\n    },\n    bar: 'Here be dragons'\n  };\n\n  foo.hasOwnProperty('bar') // 总是返回false\n\n  //使用其他对象的hasOwnProperty，并将其上下文设置为foo\n  ({}).hasOwnProperty.call(foo,'bar'); //true\n```\n\n当检查对象上某个属性是否存在时，`hasOwnProperty`是唯一可用的方法。同时在使用`for in`loop遍历对象时，推荐总是使用`hasOwnProperty`方法，这将会避免原型对象扩展带来的干扰。\n\n### for in循环\n和`in`操作符一样，`for in`循环同样在查找对象属性时遍历原型链上的所有的属性。\n**注意：** `for in`循环不会遍历那些`enumerable`设置为`false`的属性；比如数组的`length`属性。\n```javascript\n  //修改Object.prototype\n  Obkect.prototype.bar = 1;\n\n  var foo = {moo: 2};\n  for(var i in foo){\n    console.log(i); //输出两个属性： bar和moo\n  }\n```\n由于不可能改变`for in`自身的行为，因此有必要过滤那些不希望出现在循环体中的属性，这可以通过`Object.prototype`原型上的额`hasOwnProperty`函数来完成。\n\n### 使用hasOwnProperty过滤\n**注意：** 由于`for in`总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。\n```javascript\n  //foo 变量是上例中的\n  for(var i in foo){\n    if(foo.hasOwnProperty(i)){\n      console.log(i);\n    }\n  }\n```\n这个版本的代码是唯一正确的写法。由于我们使用`hasOwnProperty`，所以这次只输出`moo`。如果不使用`hasOwnProperty`，则这段代码在原生对象原型(比如`Object.prototype`)被扩展时可能会出错。\n推荐总是使用`hasOwnProperty`。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。\n\n## 函数\n### 函数声明与表达式\n函数是javascript中的一等对象，这意味着可以把函数像其他值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。\n\n函数声明\n```javascript\n  function foo(){}\n```\n上面的方法会被在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。\n```javascript\n  foo(); //正常运行，因为foo在代码前已经被创建\n  function foo(){}\n```\n\n函数赋值表达式\n```javascript\n  var foo = function(){}\n```\n这个例子把一个匿名函数赋值给变量`foo`。\n```javascript\n  foo; //'undefined'\n  foo(); //Error: TypeError\n  var foo = function(){}\n```\n由于`var`定义了一个声明语句，对变量`foo`的解析是在代码运行之前，因此`foo`变量在代码运行时已经被定义过了。\n但是由于赋值语句只在运行时执行，因此在相应代码执行之前，`foo`的值缺省为`undefined`。\n\n命名函数的赋值表达式\n另一个特殊的情况是将命名函数赋值给一个变量\n```javascript\n  var foo = function bar(){\n    bar(); //正常运行\n  }\n  bar(); //Error: ReferenceError\n```\nbar函数声明外是不可见的，这是因为我们已经把函数值赋值给了foo；然而在bar内部依然可见。这是由于JavaScript的命名处理所致，函数名在函数内总是可见的。\n**注意：** 在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，解析成两个函数`foo`和`bar`\n\n### this的工作原理\nJavaScript有一套完全不同于其他语言的对`this`的处理机制。在五种不同的情况下，this指向的各不相同。\n\n**全局范围内**\n> this  \n\n当在全局范围内使用this，它将会指向全局对象。\n\n**函数调用**\n> foo();\n\n这里的this也会指向全局对象。\n\n**方法调用**\n> test.foo();\n\n这个例子中，this指向test对象。*ES5注意：* 在严格模式下，不存在全局变量，这种情况下this将会是undefined。\n\n**调用构造函数**\n> new foo();\n\n如果函数倾向于和`new`关键词一块使用，则我们称这个函数是 *构造函数* 。在函数内部，`this`指向新创建的对象。\n\n**显示的设置this**\n> function foo(a,b,c){}\n  var bar = {};\n  foo.apply(bar,[1,2,3]); //数组将会被扩展，如下所示\n  foo.call(bar,1,2,3); //传递到foo的参数是：a = 1,b = 2,c = 3\n\n当使用`Function.prototype`上的call或者apply方法时，函数内的this将会被显示设置为函数调用的第一个参数。\n因此函数调用的规则在上例中已经不使用了，在foo函数内this被设置成了bar。\n\n**常见误解**\n尽管大部分的情况都说的过去，不过第二个规则被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。\n```javaScript\n  Foo.method = function(){\n    function test(){\n      // this将会被设置为全局对象(浏览器环境中也就是window对象)\n    }\n    test();\n  }\n```\n**注意：** 在对象的字面声明语法中，this不能用来指向对象本身。因此`var obj = {me: this}`中的me不会指向obj，因为this只可能出现在上述的五种情况中。在这个例子中，如果是浏览器中运行，obj.me等于window对象。\n\n一个常见的误解是`test`中的`this`将会指向`Foo`对象，实际上不是这样子的。\n为了在`test`中获取对`Foo`对象的引用，我们需要在`method`函数内部创建一个局部变量指向`Foo`对象。\n```javaScript\n  Foo.method = function(){\n    var that = this;\n    function test(){\n      //使用that来指向Foo对象\n    }\n    test();\n  }\n```\nthat只是我们随意起的名字，不过这个名字被广泛的用来指向外部的this对象。在闭包一节，我们可以看到that可以作为参数传递。\n\n### 方法的赋值表达式\n另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。\n```javaScript\n  var test = someObject.methodTest;\n  test();\n```\n上例中，test就像一个普通的函数被调用；因此，函数内的this将不再被指向到`someObject`对象。\n虽然this的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。\n```javaScript\n  function Foo(){}\n  Foo.prototype.method = function(){}\n\n  function Bar(){}\n  Bar.prototype = Foo.prototype;\n\n  new Bar().method();\n```\n让method被调用时，this将会指向Bar的实例对象。\n\n### 闭包和引用\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---------------------\n","source":"_posts/JavaScript秘密花园.md","raw":"---\ntitle: JavaScript秘密花园\ndate: 2016-08-05 16:22:23\ntags:\n- javascript\ncategories: 笔记\n---\n> Laughing is the most touching mask.\n\n## 对象\n\n### 对象使用和属性\nJavaScript中所有变量都可以当作对象使用，除了两个例外`null`和`undefined`。\n```javascript\n  false.toString(); //'false'\n  [1,2,3].toString(); //'1,2,3'\n\n  function Foo(){}\n  Foo.bar = 1;\n  Foo.bar; //1\n```\n一个常见的误解是数字的字面值(literal)不能当作对象使用。这是因为JavaScript解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。\n```javascript\n  2.toString(); //SyntaxError\n```\n有很多变通方法可以让数字的字面值看起来像对象。\n```javascript\n  2..toString(); //第二个点号可以正常解析\n  2 .toString(); //注意点号前面的空格\n  (2).toString(); //2先被计算\n```\n\n### 对象作为数据类型\nJavaScript的对象可以作为哈希值使用，主要用来保存命名的键与值的对应关系。\n使用对象的字面语法- {} -可以创建一个简单对象。这个新创建的对象从`Object.prototye`继承下来，没有任何自定义属性。\n```javascript\n  var foo = {}; //一个空对象\n  //一个新对象，拥有一个值为12的自定义属性'test'\n  var bar = {test: 12};\n```\n\n### 访问属性\n有两种方式来访问对象的属性，点操作符或者中括号操作符。\n```javascript\n  var foo = {name: 'kitten'};\n  foo.name; // kitten\n  foo['name']; // kitten\n\n  var get = 'name';\n  foo[get]; // kitten\n\n  foo.1234; // SyntaxError\n  foo['1234']; // works\n```\n两种语法是等价的，但是中括号操作符在下面两种情况下依然有效\n - 动态设置属性\n - 属性名不是一个有效的变量名(比如属性名中包含空格，或者属性名是JS的关键词)\n\n### 删除属性\n删除属性的唯一方法是使用`delete`操作符;设置属性为`undefined`或者`null`并不能真正的删除属性，而仅仅是移除了属性和值的关联。\n```javascript\n  var obj = {bar: 1, foo:2, baz:3};\n  obj.bar = undefined;\n  obj.foo = null;\n  delete obj.baz;\n\n  for(var i in obj){\n    if(obj.hasOwnProperty(i)){\n      console.log(i, ''+obj[i]);\n    }\n  }\n```\n上面的输出的结果有`bar undefined`和`foo null`只有`baz`被真正的删除了，所以从输出结果中消失。\n\n### 属性名的语法\n```javascript\n  var test = {\n    'case': 'I am a keyword so I must be notated as a string',\n    delete: 'I am a keyword too so me' // 出错：SyntaxError\n  }\n```\n对象的属性名可以使用字符串或者普通字符声明。但是由于javascript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript5之前会抛出`SyntaxError`的错误。\n这个错误的原因 是delete是javascript语言的一个关键词；因此为了在更低版本的javascript引擎下也能运行，必须使用字符串字面值声明方式。\n\n### 原型\nJavaScript不包含传统的类继承模型，而是使用prototype原型模型。\n虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。\n由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。\n\n第一个不同之处在于JavaScript使用原型链的继承方式。\n```javascript\n  function Foo(){\n    this.value = 42;\n  }\n  Foo.prototype = {\n    method: function(){}\n  };\n\n  function Bar(){}\n\n  //设置Bar的prototype属性为Foo的实例对象\n  Bar.prototype = new Foo();\n  Bar.prototype.foo = 'Hello World';\n\n  //修正Bar.prototype.constructor为Bar本身\n  Bar.prototype.constructor = Bar;\n\n  var test = new Bar() // 创建Bar的一个新实例\n\n  //原型链\n  test [Bar的实例]\n    Bar.prototype [Foo的实例]\n      {foo: 'Hello World'}\n      Foo.prototype\n        {method: ...};\n        Object.prototype\n          {toString: ...}\n```\n**注意：** 简单的使用`Bar.prototype = Foo.prototype`将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。不要使用`Bar.prototype = Foo`，因为这不会执行`Foo`的原型，而是指向函数`Foo`。因此原型链将会回溯到`Function.prototype`而不是`Foo.prototype`，因此`method`将不会在`Bar`的原型链上。\n\n上面的例子中，`test`对象从`Bar.prototype`和`Foo.prototype`继承下来;因此，它能访问`Foo`的原型方法`method`。同时，它也能够访问那个定义在原型上的`Foo`实例属性`value`。需要注意的是`new Bar()`不会创造出一个新的`Foo`实例，而是重复使用它原型上的那个实例；因此，所有的`Bar`实例都会共享相同的`value`属性。\n\n### 属性查找\n当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。\n到查找到达原型链的顶部-也就是`Object.prototype`-但是仍然没有找到指定的属性，就会返回`undefined`。\n\n### 原型属性\n当原型属性用来创建原型链时，可以把任何类型的值赋给它(prototype)。然而将原子类型赋给prototype的操作将会被忽略。\n```javascript\n  function Foo(){}\n  Foo.prototype = 1; //无效\n```\n而将对象赋值给prototype,正如上面的例子所示，将会动态的创建原型链。\n\n### 性能\n如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。\n并且，当使用`for in`循环遍历对象属性时，原型链上的所有的属性都将被访问。\n\n### 扩展内置类型的原型\n一个错误特性被经常使用，那就是拓展`Object.prototype`或者其他内置类型的原型对象。\n这种技术被称之为`mobkey patching`并且会破坏封装。虽然它被广泛的应用到一些JavaScript类库中，比如`Prototype`，但是为内置类型添加一些非标准的函数仍然不是一个好主意。\n扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如`Array.forEach`.\n\n### 总结\n在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。\n\n### hasOwnProperty函数\n为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自`Object.prototype`的`hasOwnProperty`方法。\n`hasOwnProperty`是JavaScript中唯一一个处理属性但是不查找原型链的函数。\n**注意：** 通过判断一个属性是否undefined是不够的。因为一个属性可能确实存在，只不过它的值被设置为undefined。\n```javascript\n  //修改Object.prototype\n  Object.prototype.bar = 1;\n  var foo = {goo: undefined};\n\n  foo.bar; //1\n  'bar' in foo; //true\n\n  foo.hasOwnProperty('bar'); //false\n  foo.hasOwnProperty('goo'); //true\n```\n只有`hasOwnProperty`可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其他方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。\n\n**hasOwnProperty** 作为属性\n`Javascript`不会保护`hasOwnProperty`被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的`hasOwnProperty`函数来获取正确的结果。\n```javascript\n  var foo = {\n    hasOwnProperty: function(){\n      return false;\n    },\n    bar: 'Here be dragons'\n  };\n\n  foo.hasOwnProperty('bar') // 总是返回false\n\n  //使用其他对象的hasOwnProperty，并将其上下文设置为foo\n  ({}).hasOwnProperty.call(foo,'bar'); //true\n```\n\n当检查对象上某个属性是否存在时，`hasOwnProperty`是唯一可用的方法。同时在使用`for in`loop遍历对象时，推荐总是使用`hasOwnProperty`方法，这将会避免原型对象扩展带来的干扰。\n\n### for in循环\n和`in`操作符一样，`for in`循环同样在查找对象属性时遍历原型链上的所有的属性。\n**注意：** `for in`循环不会遍历那些`enumerable`设置为`false`的属性；比如数组的`length`属性。\n```javascript\n  //修改Object.prototype\n  Obkect.prototype.bar = 1;\n\n  var foo = {moo: 2};\n  for(var i in foo){\n    console.log(i); //输出两个属性： bar和moo\n  }\n```\n由于不可能改变`for in`自身的行为，因此有必要过滤那些不希望出现在循环体中的属性，这可以通过`Object.prototype`原型上的额`hasOwnProperty`函数来完成。\n\n### 使用hasOwnProperty过滤\n**注意：** 由于`for in`总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。\n```javascript\n  //foo 变量是上例中的\n  for(var i in foo){\n    if(foo.hasOwnProperty(i)){\n      console.log(i);\n    }\n  }\n```\n这个版本的代码是唯一正确的写法。由于我们使用`hasOwnProperty`，所以这次只输出`moo`。如果不使用`hasOwnProperty`，则这段代码在原生对象原型(比如`Object.prototype`)被扩展时可能会出错。\n推荐总是使用`hasOwnProperty`。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。\n\n## 函数\n### 函数声明与表达式\n函数是javascript中的一等对象，这意味着可以把函数像其他值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。\n\n函数声明\n```javascript\n  function foo(){}\n```\n上面的方法会被在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。\n```javascript\n  foo(); //正常运行，因为foo在代码前已经被创建\n  function foo(){}\n```\n\n函数赋值表达式\n```javascript\n  var foo = function(){}\n```\n这个例子把一个匿名函数赋值给变量`foo`。\n```javascript\n  foo; //'undefined'\n  foo(); //Error: TypeError\n  var foo = function(){}\n```\n由于`var`定义了一个声明语句，对变量`foo`的解析是在代码运行之前，因此`foo`变量在代码运行时已经被定义过了。\n但是由于赋值语句只在运行时执行，因此在相应代码执行之前，`foo`的值缺省为`undefined`。\n\n命名函数的赋值表达式\n另一个特殊的情况是将命名函数赋值给一个变量\n```javascript\n  var foo = function bar(){\n    bar(); //正常运行\n  }\n  bar(); //Error: ReferenceError\n```\nbar函数声明外是不可见的，这是因为我们已经把函数值赋值给了foo；然而在bar内部依然可见。这是由于JavaScript的命名处理所致，函数名在函数内总是可见的。\n**注意：** 在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，解析成两个函数`foo`和`bar`\n\n### this的工作原理\nJavaScript有一套完全不同于其他语言的对`this`的处理机制。在五种不同的情况下，this指向的各不相同。\n\n**全局范围内**\n> this  \n\n当在全局范围内使用this，它将会指向全局对象。\n\n**函数调用**\n> foo();\n\n这里的this也会指向全局对象。\n\n**方法调用**\n> test.foo();\n\n这个例子中，this指向test对象。*ES5注意：* 在严格模式下，不存在全局变量，这种情况下this将会是undefined。\n\n**调用构造函数**\n> new foo();\n\n如果函数倾向于和`new`关键词一块使用，则我们称这个函数是 *构造函数* 。在函数内部，`this`指向新创建的对象。\n\n**显示的设置this**\n> function foo(a,b,c){}\n  var bar = {};\n  foo.apply(bar,[1,2,3]); //数组将会被扩展，如下所示\n  foo.call(bar,1,2,3); //传递到foo的参数是：a = 1,b = 2,c = 3\n\n当使用`Function.prototype`上的call或者apply方法时，函数内的this将会被显示设置为函数调用的第一个参数。\n因此函数调用的规则在上例中已经不使用了，在foo函数内this被设置成了bar。\n\n**常见误解**\n尽管大部分的情况都说的过去，不过第二个规则被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。\n```javaScript\n  Foo.method = function(){\n    function test(){\n      // this将会被设置为全局对象(浏览器环境中也就是window对象)\n    }\n    test();\n  }\n```\n**注意：** 在对象的字面声明语法中，this不能用来指向对象本身。因此`var obj = {me: this}`中的me不会指向obj，因为this只可能出现在上述的五种情况中。在这个例子中，如果是浏览器中运行，obj.me等于window对象。\n\n一个常见的误解是`test`中的`this`将会指向`Foo`对象，实际上不是这样子的。\n为了在`test`中获取对`Foo`对象的引用，我们需要在`method`函数内部创建一个局部变量指向`Foo`对象。\n```javaScript\n  Foo.method = function(){\n    var that = this;\n    function test(){\n      //使用that来指向Foo对象\n    }\n    test();\n  }\n```\nthat只是我们随意起的名字，不过这个名字被广泛的用来指向外部的this对象。在闭包一节，我们可以看到that可以作为参数传递。\n\n### 方法的赋值表达式\n另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。\n```javaScript\n  var test = someObject.methodTest;\n  test();\n```\n上例中，test就像一个普通的函数被调用；因此，函数内的this将不再被指向到`someObject`对象。\n虽然this的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。\n```javaScript\n  function Foo(){}\n  Foo.prototype.method = function(){}\n\n  function Bar(){}\n  Bar.prototype = Foo.prototype;\n\n  new Bar().method();\n```\n让method被调用时，this将会指向Bar的实例对象。\n\n### 闭包和引用\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n---------------------\n","slug":"JavaScript秘密花园","published":1,"updated":"2016-08-08T06:36:04.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0elf0000b0dlk2s310sx","content":"<blockquote>\n<p>Laughing is the most touching mask.</p>\n</blockquote>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"对象使用和属性\"><a href=\"#对象使用和属性\" class=\"headerlink\" title=\"对象使用和属性\"></a>对象使用和属性</h3><p>JavaScript中所有变量都可以当作对象使用，除了两个例外<code>null</code>和<code>undefined</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span>.toString(); <span class=\"comment\">//'false'</span></span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].toString(); <span class=\"comment\">//'1,2,3'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Foo.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">Foo.bar; <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure></p>\n<p>一个常见的误解是数字的字面值(literal)不能当作对象使用。这是因为JavaScript解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span>toString(); <span class=\"comment\">//SyntaxError</span></span><br></pre></td></tr></table></figure></p>\n<p>有很多变通方法可以让数字的字面值看起来像对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span>.toString(); <span class=\"comment\">//第二个点号可以正常解析</span></span><br><span class=\"line\"><span class=\"number\">2</span> .toString(); <span class=\"comment\">//注意点号前面的空格</span></span><br><span class=\"line\">(<span class=\"number\">2</span>).toString(); <span class=\"comment\">//2先被计算</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象作为数据类型\"><a href=\"#对象作为数据类型\" class=\"headerlink\" title=\"对象作为数据类型\"></a>对象作为数据类型</h3><p>JavaScript的对象可以作为哈希值使用，主要用来保存命名的键与值的对应关系。<br>使用对象的字面语法- {} -可以创建一个简单对象。这个新创建的对象从<code>Object.prototye</code>继承下来，没有任何自定义属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;; <span class=\"comment\">//一个空对象</span></span><br><span class=\"line\"><span class=\"comment\">//一个新对象，拥有一个值为12的自定义属性'test'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = &#123;test: <span class=\"number\">12</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问属性\"><a href=\"#访问属性\" class=\"headerlink\" title=\"访问属性\"></a>访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;name: <span class=\"string\">'kitten'</span>&#125;;</span><br><span class=\"line\">foo.name; <span class=\"comment\">// kitten</span></span><br><span class=\"line\">foo[<span class=\"string\">'name'</span>]; <span class=\"comment\">// kitten</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> get = <span class=\"string\">'name'</span>;</span><br><span class=\"line\">foo[get]; <span class=\"comment\">// kitten</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo<span class=\"number\">.1234</span>; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">foo[<span class=\"string\">'1234'</span>]; <span class=\"comment\">// works</span></span><br></pre></td></tr></table></figure></p>\n<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>\n<ul>\n<li>动态设置属性</li>\n<li>属性名不是一个有效的变量名(比如属性名中包含空格，或者属性名是JS的关键词)</li>\n</ul>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h3><p>删除属性的唯一方法是使用<code>delete</code>操作符;设置属性为<code>undefined</code>或者<code>null</code>并不能真正的删除属性，而仅仅是移除了属性和值的关联。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;bar: <span class=\"number\">1</span>, foo:<span class=\"number\">2</span>, baz:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">obj.bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">obj.foo = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.baz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(obj.hasOwnProperty(i))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i, <span class=\"string\">''</span>+obj[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的输出的结果有<code>bar undefined</code>和<code>foo null</code>只有<code>baz</code>被真正的删除了，所以从输出结果中消失。</p>\n<h3 id=\"属性名的语法\"><a href=\"#属性名的语法\" class=\"headerlink\" title=\"属性名的语法\"></a>属性名的语法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\">  <span class=\"string\">'case'</span>: <span class=\"string\">'I am a keyword so I must be notated as a string'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>: <span class=\"string\">'I am a keyword too so me'</span> <span class=\"comment\">// 出错：SyntaxError</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对象的属性名可以使用字符串或者普通字符声明。但是由于javascript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript5之前会抛出<code>SyntaxError</code>的错误。<br>这个错误的原因 是delete是javascript语言的一个关键词；因此为了在更低版本的javascript引擎下也能运行，必须使用字符串字面值声明方式。</p>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>JavaScript不包含传统的类继承模型，而是使用prototype原型模型。<br>虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。<br>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>\n<p>第一个不同之处在于JavaScript使用原型链的继承方式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置Bar的prototype属性为Foo的实例对象</span></span><br><span class=\"line\">Bar.prototype = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">Bar.prototype.foo = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修正Bar.prototype.constructor为Bar本身</span></span><br><span class=\"line\">Bar.prototype.constructor = Bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"keyword\">new</span> Bar() <span class=\"comment\">// 创建Bar的一个新实例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//原型链</span></span><br><span class=\"line\">test [Bar的实例]</span><br><span class=\"line\">  Bar.prototype [Foo的实例]</span><br><span class=\"line\">    &#123;foo: <span class=\"string\">'Hello World'</span>&#125;</span><br><span class=\"line\">    Foo.prototype</span><br><span class=\"line\">      &#123;method: ...&#125;;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\">        &#123;toString: ...&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 简单的使用<code>Bar.prototype = Foo.prototype</code>将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。不要使用<code>Bar.prototype = Foo</code>，因为这不会执行<code>Foo</code>的原型，而是指向函数<code>Foo</code>。因此原型链将会回溯到<code>Function.prototype</code>而不是<code>Foo.prototype</code>，因此<code>method</code>将不会在<code>Bar</code>的原型链上。</p>\n<p>上面的例子中，<code>test</code>对象从<code>Bar.prototype</code>和<code>Foo.prototype</code>继承下来;因此，它能访问<code>Foo</code>的原型方法<code>method</code>。同时，它也能够访问那个定义在原型上的<code>Foo</code>实例属性<code>value</code>。需要注意的是<code>new Bar()</code>不会创造出一个新的<code>Foo</code>实例，而是重复使用它原型上的那个实例；因此，所有的<code>Bar</code>实例都会共享相同的<code>value</code>属性。</p>\n<h3 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。<br>到查找到达原型链的顶部-也就是<code>Object.prototype</code>-但是仍然没有找到指定的属性，就会返回<code>undefined</code>。</p>\n<h3 id=\"原型属性\"><a href=\"#原型属性\" class=\"headerlink\" title=\"原型属性\"></a>原型属性</h3><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它(prototype)。然而将原子类型赋给prototype的操作将会被忽略。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Foo.prototype = <span class=\"number\">1</span>; <span class=\"comment\">//无效</span></span><br></pre></td></tr></table></figure></p>\n<p>而将对象赋值给prototype,正如上面的例子所示，将会动态的创建原型链。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。<br>并且，当使用<code>for in</code>循环遍历对象属性时，原型链上的所有的属性都将被访问。</p>\n<h3 id=\"扩展内置类型的原型\"><a href=\"#扩展内置类型的原型\" class=\"headerlink\" title=\"扩展内置类型的原型\"></a>扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是拓展<code>Object.prototype</code>或者其他内置类型的原型对象。<br>这种技术被称之为<code>mobkey patching</code>并且会破坏封装。虽然它被广泛的应用到一些JavaScript类库中，比如<code>Prototype</code>，但是为内置类型添加一些非标准的函数仍然不是一个好主意。<br>扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如<code>Array.forEach</code>.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。</p>\n<h3 id=\"hasOwnProperty函数\"><a href=\"#hasOwnProperty函数\" class=\"headerlink\" title=\"hasOwnProperty函数\"></a>hasOwnProperty函数</h3><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自<code>Object.prototype</code>的<code>hasOwnProperty</code>方法。<br><code>hasOwnProperty</code>是JavaScript中唯一一个处理属性但是不查找原型链的函数。<br><strong>注意：</strong> 通过判断一个属性是否undefined是不够的。因为一个属性可能确实存在，只不过它的值被设置为undefined。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;goo: <span class=\"literal\">undefined</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar; <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"string\">'bar'</span> <span class=\"keyword\">in</span> foo; <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'bar'</span>); <span class=\"comment\">//false</span></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'goo'</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>只有<code>hasOwnProperty</code>可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其他方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>\n<p><strong>hasOwnProperty</strong> 作为属性<br><code>Javascript</code>不会保护<code>hasOwnProperty</code>被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的<code>hasOwnProperty</code>函数来获取正确的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  hasOwnProperty: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bar: <span class=\"string\">'Here be dragons'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'bar'</span>) <span class=\"comment\">// 总是返回false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用其他对象的hasOwnProperty，并将其上下文设置为foo</span></span><br><span class=\"line\">(&#123;&#125;).hasOwnProperty.call(foo,<span class=\"string\">'bar'</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code>是唯一可用的方法。同时在使用<code>for in</code>loop遍历对象时，推荐总是使用<code>hasOwnProperty</code>方法，这将会避免原型对象扩展带来的干扰。</p>\n<h3 id=\"for-in循环\"><a href=\"#for-in循环\" class=\"headerlink\" title=\"for in循环\"></a>for in循环</h3><p>和<code>in</code>操作符一样，<code>for in</code>循环同样在查找对象属性时遍历原型链上的所有的属性。<br><strong>注意：</strong> <code>for in</code>循环不会遍历那些<code>enumerable</code>设置为<code>false</code>的属性；比如数组的<code>length</code>属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改Object.prototype</span></span><br><span class=\"line\">Obkect.prototype.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;moo: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> foo)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">//输出两个属性： bar和moo</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于不可能改变<code>for in</code>自身的行为，因此有必要过滤那些不希望出现在循环体中的属性，这可以通过<code>Object.prototype</code>原型上的额<code>hasOwnProperty</code>函数来完成。</p>\n<h3 id=\"使用hasOwnProperty过滤\"><a href=\"#使用hasOwnProperty过滤\" class=\"headerlink\" title=\"使用hasOwnProperty过滤\"></a>使用hasOwnProperty过滤</h3><p><strong>注意：</strong> 由于<code>for in</code>总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//foo 变量是上例中的</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> foo)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(foo.hasOwnProperty(i))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个版本的代码是唯一正确的写法。由于我们使用<code>hasOwnProperty</code>，所以这次只输出<code>moo</code>。如果不使用<code>hasOwnProperty</code>，则这段代码在原生对象原型(比如<code>Object.prototype</code>)被扩展时可能会出错。<br>推荐总是使用<code>hasOwnProperty</code>。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数声明与表达式\"><a href=\"#函数声明与表达式\" class=\"headerlink\" title=\"函数声明与表达式\"></a>函数声明与表达式</h3><p>函数是javascript中的一等对象，这意味着可以把函数像其他值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。</p>\n<p>函数声明<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法会被在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">//正常运行，因为foo在代码前已经被创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数赋值表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个例子把一个匿名函数赋值给变量<code>foo</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo; <span class=\"comment\">//'undefined'</span></span><br><span class=\"line\">foo(); <span class=\"comment\">//Error: TypeError</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>var</code>定义了一个声明语句，对变量<code>foo</code>的解析是在代码运行之前，因此<code>foo</code>变量在代码运行时已经被定义过了。<br>但是由于赋值语句只在运行时执行，因此在相应代码执行之前，<code>foo</code>的值缺省为<code>undefined</code>。</p>\n<p>命名函数的赋值表达式<br>另一个特殊的情况是将命名函数赋值给一个变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  bar(); <span class=\"comment\">//正常运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\">//Error: ReferenceError</span></span><br></pre></td></tr></table></figure></p>\n<p>bar函数声明外是不可见的，这是因为我们已经把函数值赋值给了foo；然而在bar内部依然可见。这是由于JavaScript的命名处理所致，函数名在函数内总是可见的。<br><strong>注意：</strong> 在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，解析成两个函数<code>foo</code>和<code>bar</code></p>\n<h3 id=\"this的工作原理\"><a href=\"#this的工作原理\" class=\"headerlink\" title=\"this的工作原理\"></a>this的工作原理</h3><p>JavaScript有一套完全不同于其他语言的对<code>this</code>的处理机制。在五种不同的情况下，this指向的各不相同。</p>\n<p><strong>全局范围内</strong></p>\n<blockquote>\n<p>this  </p>\n</blockquote>\n<p>当在全局范围内使用this，它将会指向全局对象。</p>\n<p><strong>函数调用</strong></p>\n<blockquote>\n<p>foo();</p>\n</blockquote>\n<p>这里的this也会指向全局对象。</p>\n<p><strong>方法调用</strong></p>\n<blockquote>\n<p>test.foo();</p>\n</blockquote>\n<p>这个例子中，this指向test对象。<em>ES5注意：</em> 在严格模式下，不存在全局变量，这种情况下this将会是undefined。</p>\n<p><strong>调用构造函数</strong></p>\n<blockquote>\n<p>new foo();</p>\n</blockquote>\n<p>如果函数倾向于和<code>new</code>关键词一块使用，则我们称这个函数是 <em>构造函数</em> 。在函数内部，<code>this</code>指向新创建的对象。</p>\n<p><strong>显示的设置this</strong></p>\n<blockquote>\n<p>function foo(a,b,c){}<br>  var bar = {};<br>  foo.apply(bar,[1,2,3]); //数组将会被扩展，如下所示<br>  foo.call(bar,1,2,3); //传递到foo的参数是：a = 1,b = 2,c = 3</p>\n</blockquote>\n<p>当使用<code>Function.prototype</code>上的call或者apply方法时，函数内的this将会被显示设置为函数调用的第一个参数。<br>因此函数调用的规则在上例中已经不使用了，在foo函数内this被设置成了bar。</p>\n<p><strong>常见误解</strong><br>尽管大部分的情况都说的过去，不过第二个规则被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.method = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this将会被设置为全局对象(浏览器环境中也就是window对象)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 在对象的字面声明语法中，this不能用来指向对象本身。因此<code>var obj = {me: this}</code>中的me不会指向obj，因为this只可能出现在上述的五种情况中。在这个例子中，如果是浏览器中运行，obj.me等于window对象。</p>\n<p>一个常见的误解是<code>test</code>中的<code>this</code>将会指向<code>Foo</code>对象，实际上不是这样子的。<br>为了在<code>test</code>中获取对<code>Foo</code>对象的引用，我们需要在<code>method</code>函数内部创建一个局部变量指向<code>Foo</code>对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.method = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用that来指向Foo对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>that只是我们随意起的名字，不过这个名字被广泛的用来指向外部的this对象。在闭包一节，我们可以看到that可以作为参数传递。</p>\n<h3 id=\"方法的赋值表达式\"><a href=\"#方法的赋值表达式\" class=\"headerlink\" title=\"方法的赋值表达式\"></a>方法的赋值表达式</h3><p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = someObject.methodTest;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure></p>\n<p>上例中，test就像一个普通的函数被调用；因此，函数内的this将不再被指向到<code>someObject</code>对象。<br>虽然this的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Foo.prototype.method = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Bar.prototype = Foo.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bar().method();</span><br></pre></td></tr></table></figure></p>\n<p>让method被调用时，this将会指向Bar的实例对象。</p>\n<h3 id=\"闭包和引用\"><a href=\"#闭包和引用\" class=\"headerlink\" title=\"闭包和引用\"></a>闭包和引用</h3><hr>\n","excerpt":"","more":"<blockquote>\n<p>Laughing is the most touching mask.</p>\n</blockquote>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><h3 id=\"对象使用和属性\"><a href=\"#对象使用和属性\" class=\"headerlink\" title=\"对象使用和属性\"></a>对象使用和属性</h3><p>JavaScript中所有变量都可以当作对象使用，除了两个例外<code>null</code>和<code>undefined</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span>.toString(); <span class=\"comment\">//'false'</span></span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].toString(); <span class=\"comment\">//'1,2,3'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Foo.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\">Foo.bar; <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure></p>\n<p>一个常见的误解是数字的字面值(literal)不能当作对象使用。这是因为JavaScript解析器的一个错误，它试图将点操作符解析为浮点数字面值的一部分。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span>toString(); <span class=\"comment\">//SyntaxError</span></span><br></pre></td></tr></table></figure></p>\n<p>有很多变通方法可以让数字的字面值看起来像对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span>.toString(); <span class=\"comment\">//第二个点号可以正常解析</span></span><br><span class=\"line\"><span class=\"number\">2</span> .toString(); <span class=\"comment\">//注意点号前面的空格</span></span><br><span class=\"line\">(<span class=\"number\">2</span>).toString(); <span class=\"comment\">//2先被计算</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象作为数据类型\"><a href=\"#对象作为数据类型\" class=\"headerlink\" title=\"对象作为数据类型\"></a>对象作为数据类型</h3><p>JavaScript的对象可以作为哈希值使用，主要用来保存命名的键与值的对应关系。<br>使用对象的字面语法- {} -可以创建一个简单对象。这个新创建的对象从<code>Object.prototye</code>继承下来，没有任何自定义属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;; <span class=\"comment\">//一个空对象</span></span><br><span class=\"line\"><span class=\"comment\">//一个新对象，拥有一个值为12的自定义属性'test'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = &#123;test: <span class=\"number\">12</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"访问属性\"><a href=\"#访问属性\" class=\"headerlink\" title=\"访问属性\"></a>访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;name: <span class=\"string\">'kitten'</span>&#125;;</span><br><span class=\"line\">foo.name; <span class=\"comment\">// kitten</span></span><br><span class=\"line\">foo[<span class=\"string\">'name'</span>]; <span class=\"comment\">// kitten</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> get = <span class=\"string\">'name'</span>;</span><br><span class=\"line\">foo[get]; <span class=\"comment\">// kitten</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo<span class=\"number\">.1234</span>; <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">foo[<span class=\"string\">'1234'</span>]; <span class=\"comment\">// works</span></span><br></pre></td></tr></table></figure></p>\n<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效</p>\n<ul>\n<li>动态设置属性</li>\n<li>属性名不是一个有效的变量名(比如属性名中包含空格，或者属性名是JS的关键词)</li>\n</ul>\n<h3 id=\"删除属性\"><a href=\"#删除属性\" class=\"headerlink\" title=\"删除属性\"></a>删除属性</h3><p>删除属性的唯一方法是使用<code>delete</code>操作符;设置属性为<code>undefined</code>或者<code>null</code>并不能真正的删除属性，而仅仅是移除了属性和值的关联。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;bar: <span class=\"number\">1</span>, foo:<span class=\"number\">2</span>, baz:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">obj.bar = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">obj.foo = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">delete</span> obj.baz;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(obj.hasOwnProperty(i))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i, <span class=\"string\">''</span>+obj[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的输出的结果有<code>bar undefined</code>和<code>foo null</code>只有<code>baz</code>被真正的删除了，所以从输出结果中消失。</p>\n<h3 id=\"属性名的语法\"><a href=\"#属性名的语法\" class=\"headerlink\" title=\"属性名的语法\"></a>属性名的语法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = &#123;</span><br><span class=\"line\">  <span class=\"string\">'case'</span>: <span class=\"string\">'I am a keyword so I must be notated as a string'</span>,</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>: <span class=\"string\">'I am a keyword too so me'</span> <span class=\"comment\">// 出错：SyntaxError</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对象的属性名可以使用字符串或者普通字符声明。但是由于javascript解析器的另一个错误设计，上面的第二种声明方式在ECMAScript5之前会抛出<code>SyntaxError</code>的错误。<br>这个错误的原因 是delete是javascript语言的一个关键词；因此为了在更低版本的javascript引擎下也能运行，必须使用字符串字面值声明方式。</p>\n<h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><p>JavaScript不包含传统的类继承模型，而是使用prototype原型模型。<br>虽然这经常被当作是JavaScript的缺点被提及，其实基于原型的继承模型比传统类继承还要强大。实现传统的类继承模型是很简单，但是实现JavaScript中的原型继承则要困难的多。<br>由于JavaScript是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>\n<p>第一个不同之处在于JavaScript使用原型链的继承方式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.value = <span class=\"number\">42</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prototype = &#123;</span><br><span class=\"line\">  method: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//设置Bar的prototype属性为Foo的实例对象</span></span><br><span class=\"line\">Bar.prototype = <span class=\"keyword\">new</span> Foo();</span><br><span class=\"line\">Bar.prototype.foo = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//修正Bar.prototype.constructor为Bar本身</span></span><br><span class=\"line\">Bar.prototype.constructor = Bar;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"keyword\">new</span> Bar() <span class=\"comment\">// 创建Bar的一个新实例</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//原型链</span></span><br><span class=\"line\">test [Bar的实例]</span><br><span class=\"line\">  Bar.prototype [Foo的实例]</span><br><span class=\"line\">    &#123;foo: <span class=\"string\">'Hello World'</span>&#125;</span><br><span class=\"line\">    Foo.prototype</span><br><span class=\"line\">      &#123;method: ...&#125;;</span><br><span class=\"line\">      <span class=\"built_in\">Object</span>.prototype</span><br><span class=\"line\">        &#123;toString: ...&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 简单的使用<code>Bar.prototype = Foo.prototype</code>将会导致两个对象共享相同的原型。因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。不要使用<code>Bar.prototype = Foo</code>，因为这不会执行<code>Foo</code>的原型，而是指向函数<code>Foo</code>。因此原型链将会回溯到<code>Function.prototype</code>而不是<code>Foo.prototype</code>，因此<code>method</code>将不会在<code>Bar</code>的原型链上。</p>\n<p>上面的例子中，<code>test</code>对象从<code>Bar.prototype</code>和<code>Foo.prototype</code>继承下来;因此，它能访问<code>Foo</code>的原型方法<code>method</code>。同时，它也能够访问那个定义在原型上的<code>Foo</code>实例属性<code>value</code>。需要注意的是<code>new Bar()</code>不会创造出一个新的<code>Foo</code>实例，而是重复使用它原型上的那个实例；因此，所有的<code>Bar</code>实例都会共享相同的<code>value</code>属性。</p>\n<h3 id=\"属性查找\"><a href=\"#属性查找\" class=\"headerlink\" title=\"属性查找\"></a>属性查找</h3><p>当查找一个对象的属性时，JavaScript会向上遍历原型链，直到找到给定名称的属性为止。<br>到查找到达原型链的顶部-也就是<code>Object.prototype</code>-但是仍然没有找到指定的属性，就会返回<code>undefined</code>。</p>\n<h3 id=\"原型属性\"><a href=\"#原型属性\" class=\"headerlink\" title=\"原型属性\"></a>原型属性</h3><p>当原型属性用来创建原型链时，可以把任何类型的值赋给它(prototype)。然而将原子类型赋给prototype的操作将会被忽略。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Foo.prototype = <span class=\"number\">1</span>; <span class=\"comment\">//无效</span></span><br></pre></td></tr></table></figure></p>\n<p>而将对象赋值给prototype,正如上面的例子所示，将会动态的创建原型链。</p>\n<h3 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h3><p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。<br>并且，当使用<code>for in</code>循环遍历对象属性时，原型链上的所有的属性都将被访问。</p>\n<h3 id=\"扩展内置类型的原型\"><a href=\"#扩展内置类型的原型\" class=\"headerlink\" title=\"扩展内置类型的原型\"></a>扩展内置类型的原型</h3><p>一个错误特性被经常使用，那就是拓展<code>Object.prototype</code>或者其他内置类型的原型对象。<br>这种技术被称之为<code>mobkey patching</code>并且会破坏封装。虽然它被广泛的应用到一些JavaScript类库中，比如<code>Prototype</code>，但是为内置类型添加一些非标准的函数仍然不是一个好主意。<br>扩展内置类型的唯一理由是为了和新的JavaScript保持一致，比如<code>Array.forEach</code>.</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>在写复杂的JavaScript应用之前，充分理解原型链继承的工作方式是每个JavaScript程序员必修的功课。要提防原型链过长带来的性能问题，并指导如何通过缩短原型链来提高性能。更进一步，绝对不要扩展内置类型的原型，除非是为了和新的JavaScript引擎兼容。</p>\n<h3 id=\"hasOwnProperty函数\"><a href=\"#hasOwnProperty函数\" class=\"headerlink\" title=\"hasOwnProperty函数\"></a>hasOwnProperty函数</h3><p>为了判断一个对象是否包含自定义属性而不是原型链上的属性，我们需要使用继承自<code>Object.prototype</code>的<code>hasOwnProperty</code>方法。<br><code>hasOwnProperty</code>是JavaScript中唯一一个处理属性但是不查找原型链的函数。<br><strong>注意：</strong> 通过判断一个属性是否undefined是不够的。因为一个属性可能确实存在，只不过它的值被设置为undefined。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;goo: <span class=\"literal\">undefined</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.bar; <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"string\">'bar'</span> <span class=\"keyword\">in</span> foo; <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'bar'</span>); <span class=\"comment\">//false</span></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'goo'</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>只有<code>hasOwnProperty</code>可以给出正确和期望的结果，这在遍历对象的属性时会很有用。没有其他方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>\n<p><strong>hasOwnProperty</strong> 作为属性<br><code>Javascript</code>不会保护<code>hasOwnProperty</code>被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的<code>hasOwnProperty</code>函数来获取正确的结果。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  hasOwnProperty: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bar: <span class=\"string\">'Here be dragons'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">foo.hasOwnProperty(<span class=\"string\">'bar'</span>) <span class=\"comment\">// 总是返回false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用其他对象的hasOwnProperty，并将其上下文设置为foo</span></span><br><span class=\"line\">(&#123;&#125;).hasOwnProperty.call(foo,<span class=\"string\">'bar'</span>); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code>是唯一可用的方法。同时在使用<code>for in</code>loop遍历对象时，推荐总是使用<code>hasOwnProperty</code>方法，这将会避免原型对象扩展带来的干扰。</p>\n<h3 id=\"for-in循环\"><a href=\"#for-in循环\" class=\"headerlink\" title=\"for in循环\"></a>for in循环</h3><p>和<code>in</code>操作符一样，<code>for in</code>循环同样在查找对象属性时遍历原型链上的所有的属性。<br><strong>注意：</strong> <code>for in</code>循环不会遍历那些<code>enumerable</code>设置为<code>false</code>的属性；比如数组的<code>length</code>属性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//修改Object.prototype</span></span><br><span class=\"line\">Obkect.prototype.bar = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;moo: <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> foo)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">//输出两个属性： bar和moo</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于不可能改变<code>for in</code>自身的行为，因此有必要过滤那些不希望出现在循环体中的属性，这可以通过<code>Object.prototype</code>原型上的额<code>hasOwnProperty</code>函数来完成。</p>\n<h3 id=\"使用hasOwnProperty过滤\"><a href=\"#使用hasOwnProperty过滤\" class=\"headerlink\" title=\"使用hasOwnProperty过滤\"></a>使用hasOwnProperty过滤</h3><p><strong>注意：</strong> 由于<code>for in</code>总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//foo 变量是上例中的</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i <span class=\"keyword\">in</span> foo)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(foo.hasOwnProperty(i))&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个版本的代码是唯一正确的写法。由于我们使用<code>hasOwnProperty</code>，所以这次只输出<code>moo</code>。如果不使用<code>hasOwnProperty</code>，则这段代码在原生对象原型(比如<code>Object.prototype</code>)被扩展时可能会出错。<br>推荐总是使用<code>hasOwnProperty</code>。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><h3 id=\"函数声明与表达式\"><a href=\"#函数声明与表达式\" class=\"headerlink\" title=\"函数声明与表达式\"></a>函数声明与表达式</h3><p>函数是javascript中的一等对象，这意味着可以把函数像其他值一样传递。一个常见的用法是把匿名函数作为回调函数传递到异步函数中。</p>\n<p>函数声明<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法会被在执行前被解析(hoisted)，因此它存在于当前上下文的任意一个地方，即使在函数定义体的上面被调用也是对的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo(); <span class=\"comment\">//正常运行，因为foo在代码前已经被创建</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数赋值表达式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个例子把一个匿名函数赋值给变量<code>foo</code>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo; <span class=\"comment\">//'undefined'</span></span><br><span class=\"line\">foo(); <span class=\"comment\">//Error: TypeError</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于<code>var</code>定义了一个声明语句，对变量<code>foo</code>的解析是在代码运行之前，因此<code>foo</code>变量在代码运行时已经被定义过了。<br>但是由于赋值语句只在运行时执行，因此在相应代码执行之前，<code>foo</code>的值缺省为<code>undefined</code>。</p>\n<p>命名函数的赋值表达式<br>另一个特殊的情况是将命名函数赋值给一个变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  bar(); <span class=\"comment\">//正常运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar(); <span class=\"comment\">//Error: ReferenceError</span></span><br></pre></td></tr></table></figure></p>\n<p>bar函数声明外是不可见的，这是因为我们已经把函数值赋值给了foo；然而在bar内部依然可见。这是由于JavaScript的命名处理所致，函数名在函数内总是可见的。<br><strong>注意：</strong> 在IE8及IE8以下版本浏览器bar在外部也是可见的，是因为浏览器对命名函数赋值表达式进行了错误的解析，解析成两个函数<code>foo</code>和<code>bar</code></p>\n<h3 id=\"this的工作原理\"><a href=\"#this的工作原理\" class=\"headerlink\" title=\"this的工作原理\"></a>this的工作原理</h3><p>JavaScript有一套完全不同于其他语言的对<code>this</code>的处理机制。在五种不同的情况下，this指向的各不相同。</p>\n<p><strong>全局范围内</strong></p>\n<blockquote>\n<p>this  </p>\n</blockquote>\n<p>当在全局范围内使用this，它将会指向全局对象。</p>\n<p><strong>函数调用</strong></p>\n<blockquote>\n<p>foo();</p>\n</blockquote>\n<p>这里的this也会指向全局对象。</p>\n<p><strong>方法调用</strong></p>\n<blockquote>\n<p>test.foo();</p>\n</blockquote>\n<p>这个例子中，this指向test对象。<em>ES5注意：</em> 在严格模式下，不存在全局变量，这种情况下this将会是undefined。</p>\n<p><strong>调用构造函数</strong></p>\n<blockquote>\n<p>new foo();</p>\n</blockquote>\n<p>如果函数倾向于和<code>new</code>关键词一块使用，则我们称这个函数是 <em>构造函数</em> 。在函数内部，<code>this</code>指向新创建的对象。</p>\n<p><strong>显示的设置this</strong></p>\n<blockquote>\n<p>function foo(a,b,c){}<br>  var bar = {};<br>  foo.apply(bar,[1,2,3]); //数组将会被扩展，如下所示<br>  foo.call(bar,1,2,3); //传递到foo的参数是：a = 1,b = 2,c = 3</p>\n</blockquote>\n<p>当使用<code>Function.prototype</code>上的call或者apply方法时，函数内的this将会被显示设置为函数调用的第一个参数。<br>因此函数调用的规则在上例中已经不使用了，在foo函数内this被设置成了bar。</p>\n<p><strong>常见误解</strong><br>尽管大部分的情况都说的过去，不过第二个规则被认为是JavaScript语言另一个错误设计的地方，因为它从来就没有实际的用途。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.method = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// this将会被设置为全局对象(浏览器环境中也就是window对象)</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：</strong> 在对象的字面声明语法中，this不能用来指向对象本身。因此<code>var obj = {me: this}</code>中的me不会指向obj，因为this只可能出现在上述的五种情况中。在这个例子中，如果是浏览器中运行，obj.me等于window对象。</p>\n<p>一个常见的误解是<code>test</code>中的<code>this</code>将会指向<code>Foo</code>对象，实际上不是这样子的。<br>为了在<code>test</code>中获取对<code>Foo</code>对象的引用，我们需要在<code>method</code>函数内部创建一个局部变量指向<code>Foo</code>对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Foo.method = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//使用that来指向Foo对象</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  test();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>that只是我们随意起的名字，不过这个名字被广泛的用来指向外部的this对象。在闭包一节，我们可以看到that可以作为参数传递。</p>\n<h3 id=\"方法的赋值表达式\"><a href=\"#方法的赋值表达式\" class=\"headerlink\" title=\"方法的赋值表达式\"></a>方法的赋值表达式</h3><p>另一个看起来奇怪的地方是函数别名，也就是将一个方法赋值给一个变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> test = someObject.methodTest;</span><br><span class=\"line\">test();</span><br></pre></td></tr></table></figure></p>\n<p>上例中，test就像一个普通的函数被调用；因此，函数内的this将不再被指向到<code>someObject</code>对象。<br>虽然this的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Foo</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Foo.prototype.method = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Bar</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\">Bar.prototype = Foo.prototype;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> Bar().method();</span><br></pre></td></tr></table></figure></p>\n<p>让method被调用时，this将会指向Bar的实例对象。</p>\n<h3 id=\"闭包和引用\"><a href=\"#闭包和引用\" class=\"headerlink\" title=\"闭包和引用\"></a>闭包和引用</h3><hr>\n"},{"title":"Javascript的函数式库","date":"2016-05-19T03:44:41.000Z","_content":"> A book that remains shut is but a block.\n\n## Javascript的函数式库\n据说所有的函数是程序员都会写自己的函数库，函数式Javascript程序员也不例外。随着如今开源代码分享平台如GitHab、Bower和NPM的涌现，对这些函数库进行分享、变得及补充变得越来越容易。 现在已经有很多Javascript的函数式变成库，从小巧的工具集到庞大的模块库都有。\n\n每一个库都宣扬着自己的函数式编程风格。从一本正经的数学风格到灵活松散的非正式风格，每一个库都不尽相同， 然而他们他们有一个共同的特点：都是通过抽象的Javascript函数式能力来增进代码的重用行、可读性和健壮性。\n\n### Underscore.js\nUnderscore在很多人眼里已经成为函数式Javascript库的标准。它成熟稳定， 其创建者Jeremy Ashkenas也是Backbone.js和Coffeescript的创建者。 Underscore实际上是对Ruby的Enumerable模块的重新实现， 这也解释了为什么Coffeescript也是受Ruby影响。\n\n与jQuery相似，Underscore并不改变Javascript原生对象，而是用一个符号来定义自己的对象， 就是下划线（underscore）字符“_”。所以使用Underscore会是这个样子：\n```javascript\n   var x = _.map([1,2,3], Math.sqrt); // Underscore的map函数\n   console.log(x.toString()); \n```\n\n我们已经见过Javascript数组原生的map()方法，它是这样用的：\n```javascript\n   var x = [1,2,3].map(Math.sqrt); \n```\n\n不同的是，用underscore时，数组对象和回调函数都是作为参数传入给underscore的map()方法（_.map）的， 而不是像数组原生的map()方法（Array.prototype.map）那样只需传递回调。\n\n不过underscore除了map()还有很多内建函数，他们都是非常好用的函数， 比如find()、invoke()、pluck()、sortBy()、groupBy()等等。\n```javascript\n    var greetings = [{\n      origin: 'spanish',\n      value: 'hola'\n    }, {\n      origin: 'english',\n      value: 'hello'\n    }];\n    console.log(_.pluck(greetings, 'value'));\n    // 获取一个对象的属性.\n    // 返回: ['hola', 'hello']\n    console.log(_.find(greetings, function(s) {\n      return s.origin ==\n        'spanish';\n    }));\n    // 查找第一个回调函数返回真的元素\n    // 返回: {origin: 'spanish', value: 'hola'}\n    greetings = greetings.concat(_.object(['origin', 'value'], ['french', 'bonjour']));\n    console.log(greetings);\n    // _.object通过合并两个数组来建立一个对象\n    // 返回: [{origin: 'spanish', value: 'hola'},\n    //{origin: 'english', value: 'hello'},\n    //{origin: 'french', value: 'bonjour'}]  \n```\n\n并且它还提供了链式调用方法\n```javascript\n    var g = _.chain(greetings)\n      .sortBy(function(x) {\n        return x.value.length\n      })\n      .pluck('origin')\n      .map(function(x) {\n        return x.charAt(0).toUpperCase() + x.slice(1)\n      })\n      .reduce(function(x, y) {\n        return x + ' ' + y\n      }, '')\n      .value(); // 应用这些函数\n    // 返回: 'Spanish English French'\n    console.log(g);\n```\n\n> _.chain()方法的返回值被包在了一个拥有Underscore全部函数的对象里。_.value方法用于把被包裹的对象提取出来。 包裹的对象对于把Underscore混合到面向对象编程中非常有用。\n\nUnderscore也许并没有要追求函数式编程数学上的正确性，不过它也从来没有想要把Javascript扩展或者转变为一个纯函数语言。 它把自己定义为一个提供一大堆有用的函数式编程辅助函数的Javascript库。 也许它比那些伪造得看起来像函数式辅助函数的玩意儿要好些，不过它也不是一个严肃的函数式库。\n\n那么有没有更好的库呢？一个建立在数学之上的库？\n\n### Lazy.js\nLazy是一个实用的库，他更大程度上是沿着Underscore的路线，不过它有惰性求值策略。正因为如此，Lazy让即可解释的语言本不可能完成的函数式计算变成了可能。他还会显著提升性能。\n\nLazy的主意是，我们能够迭代的所有东西都是一个序列。由于这个库用方法执行的先后来控制顺序，很多很酷的事情就可以实现了：异步循环（并行编程）、无限序列、函数式响应式编程等等。\n\n下面的例子展示了以下各种情形的代码：\n```javascript\n    //获得一首歌歌词的前三行\n    var lyrics = \"我徘徊在海之滨山之巅\\n越此城镇越彼乡园\\n ...\"\n    //如果没有惰性，整个歌词会先根据换行来分隔\n    console.log(lyrics.split('\\n').slice(0,3));\n    //有了惰性，可以只文本分割出来前三行\n    //歌词甚至可以无限长\n    console.log(Lazy(lyrics).split('\\n').take(3));\n```\n\n```javascript\n   //前十个能被3整除的平方数\n    var oneTo1000 = Lazy.range(1,1000).toArray();\n    var sequence = Lazy(oneTo1000)\n        .map(function(x){return x*x})\n        .filter(function(x){return x % 3 === 0})\n        .take(10)\n        .each(function(x){console.log(x)});\n```\n\n```javascript\n    //对无限序列的异步循环\n    var asyncSequence = Lazy.generate(function(x){\n        return x++\n    }).async(100) //每两个元素间隔0.1秒\n    .take(20) //只计算前20项\n    .each(function(e){\n        console.log(new Date().getMilliseconds() + \": \" + e);\n    });\n```\n\n不过Lazy库的这个主意并不能保证它完全的正确性。它还有一个前辈，Bacon.js，他们的工作方式差不多。\n\n### 其他的一些库\nJavascript函数式编程的库实在太多了，无法在本书中一一展示。我们再来简单看几个吧。\n\n - Functional\n    - 这也许是Javascript的第一个函数式编程库，它包括了全面的高阶函数支持和string lambdas。\n - wu.js\n    - 因其curryable()函数而饱受赞誉的wu.js库是一个很优秀的函数式编程库。它是第一个（据我所知） 实现了惰性求值的库，这影响了Bacon.js、Lazy.js等库。\n    - 是的，它的名字来源于臭名昭著的摇滚组合“Wu-Tang Clan”\n - sloth.js\n    - 和Lazy.js很像，但是更小\n - stream.js\n    - 支持无限流，其它没什么\n    - 特别小\n - Lo-Dash.js\n    - 就像名字所暗示的那样，它是受underscore.js的启发\n    - 高度优化\n - Sugar\n    - Sugar是Javascript函数式编程技术的支持库，和Underscore相像，但是在实现上有一些关键的不同。\n    - underscore中的 _.pluck(myObjs, 'value')在Suger中仅仅是myObjs.map('value')。 意思是他修改了Javascript原生的对象，所以它在跟其它库混用的时候会有些风险，比如Prototype。\n - from.js\n    - 一个新的函数式库，Javascript的LINQ（语言集成查询）引擎，支持.net所提供的大多数LINQ函数。\n    - 100%惰性求值，并支持lambda表达式\n    - 很年轻，但是文档很出色\n - JSLINQ\n    - 另一个Javascript的LINQ引擎\n    - 比from.js更老也更成熟\n - Boiler.js\n    - 另一个让Javascript扩展的函数式方法更加原生的工具库，包括：字符串、数字、对象、集合和数组\n - Folktale\n    - 像Bilby.js那样，Folktable是一个对Fantasy Land实现的新库。并且像他的祖先那样， Folktable也是一个Javascript函数式编程库的集合。它还很年轻，但有光明的前景。\n - jQuery\n    - 在这里看到jQuery很吃惊吗？尽管jQuery不是一个用于函数式编程的工具，但它自己是函数式的。 jQuery应该是根植于函数式编程的使用最广泛的库。\n    - jQuery对象实际是一个monad。jQuery使用了monad的规则来实现方法链式调用： ```$('#mydiv').fadeIn().css('left': 50).alert('hi!');``` \n    - 它的一些函数是高阶的 ```$('li').css('left': function(index){return index*50});``` \n    - jQuery1.8以上的deferred.then实现了函数式概念Promise\n    - jQuery是一个抽象层，主要是面向DOM。它不是一个框架或工具集， 只是一个使用抽象来提高代码复用和减少丑陋代码的方式。而函数式编程不全都是关于这些的吗？\n\n## 开发和生产环境\n### 环境\n编程风格与应用所部属或者将要部署的环境没啥关系。但是库就有关系了。\n\n### 浏览器\n主要的Javascript应用还是跑在客户端的，也就是浏览器。基于浏览器的环境对于开发来说非常好， 因为浏览器无处不在，你可以在本地机器上写代码，解释器是浏览器的Javascript引擎， 所有的浏览器都有开发者终端。火狐的FireBug提供了非常有用的错误信息，并支持断点等等， 不过同样的代码运行在Chrome和Safari上的交叉引用的错误输出会很有用。甚至连IE都包含开发者工具。\n\n浏览器的问题是他们对Javascript的解析不尽相同！尽管不是普遍现象，但是可能有些代码在不同的浏览器上会得到非常不同的结果。 不过主要的差别在于它们如何处理DOM，而不是在原型和函数如何工作上。举个明显的例子，Math.sqrt(4) 在任何浏览器和shell上都会返回2。但是scrollLeft方法依赖于浏览器的布局策略。\n\n编写针对浏览器的特定代码是在浪费时间，这也是为何要使用库的另外一个原因。\n\n### 服务器端Javascript\nNode.js已经成为创建服务器端和基于网络应用的标准平台。函数式编程可以用于服务器端应用的编程吗？ 可以！OK，不过现在的这些函数式库是为这种注重性能的环境设计的吗？答案仍然是肯定的。\n\n这章提到的所有的函数式库都可以工作在Node.js上，有些需要依赖browserify.js模块来处理浏览器元素。\n\n### 服务器端环境的一个函数式用例\n在我们的网络系统这个无畏的新世界里，服务器端应用开发人员总在担心并发问题，这是应该的。 经典的例子就是一个应用允许多个用户修改同一个文件，如果他们打算同时修改这个文件，你将会陷入令人作呕的混乱。 这就是困扰了程序员几十年的状态维持问题。\n\n假设下面这个情景：\n 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。\n 2.比利打开了同一份报告，添加了内容，并且保存了报告。\n 3.亚当吃完午饭回来，又往这份报告里添加了内容，并且保存，不知情地覆盖了比利的内容。\n 4.第二天，比利发现他的内容消失了。他的老板冲他咆哮，所有的人都一起冲着开发人员发飙，结果开发人员丢了工作。\n \n长期以来，解决这个问题的办法就是给文件建立状态。当有人编辑这个文件的时候就把状态切换为加锁， 这就防止其他人编辑这个文件，并在保存这个文件后把状态切换为解锁。在我们的情景里，比利应该无法修改报告， 直到亚当吃完饭回来。并且只要文件没被保存就没有其他人可以编辑它。\n\n这正是函数式编程关于不可变数据和状态的思想具有实际意义之处。函数式的实现并不是直接修改文件， 而是修改文件的一个拷贝，也就是一个新的版本。如果要保存这个版本而此时一个新的版本已经存在， 我们就知道已经有别人修改了原来的文件。危险规避了。\n\n现在这个场景可以这样展开了：\n 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。\n 2.比利打开了同一份报告，添加了内容，保存为了一个新的版本。\n 3.亚当吃完饭回来继续添加内容，当他要保存时，系统告诉他现在已经存在一个新版本了。\n 4.亚当打开了这个新版本，添加了自己的内容，并保存为另一个新版本。\n 5.通过查看版本历史，老板看到了一切在平稳运行。所有人都很开心，应用的开发人员也得到了晋升和奖赏。\n \n这个叫做事件源。不需要维护明确的状态，只需要事件。这个过程非常清晰，整个事件的历史都可以回顾。\n\n这个思想以及其它一些优势是函数式编程在服务器端日益增长的原因。\n\n## 第三章总结\n你选择使用哪个数据库取决于你的需要是什么。需要函数响应式编程来处理事件和动态值？使用bacon.js。 需要无限流而不需要别的？用stream.js。想要一个函数式助手来补充jQuery？试试underscore.js。 需要严格特定多态的结构化环境？看看bilby.js。需要面面俱到的函数式编程工具？使用Lazy.js。 用这些都不爽？你自己写一个。\n\n任何库都只擅长于它所使用的方式。尽管这章提到的库里面有几个缺点很少，大多数错误都会在不经意间就出现。 这取决于你选择的库是否正确，是否符合你的需求。","source":"_posts/Javascript的函数式库.md","raw":"---\ntitle: Javascript的函数式库\ndate: 2016-05-19 11:44:41\ntags:\n- javascript\n- 函数式编程\ncategories: 转载笔记\n---\n> A book that remains shut is but a block.\n\n## Javascript的函数式库\n据说所有的函数是程序员都会写自己的函数库，函数式Javascript程序员也不例外。随着如今开源代码分享平台如GitHab、Bower和NPM的涌现，对这些函数库进行分享、变得及补充变得越来越容易。 现在已经有很多Javascript的函数式变成库，从小巧的工具集到庞大的模块库都有。\n\n每一个库都宣扬着自己的函数式编程风格。从一本正经的数学风格到灵活松散的非正式风格，每一个库都不尽相同， 然而他们他们有一个共同的特点：都是通过抽象的Javascript函数式能力来增进代码的重用行、可读性和健壮性。\n\n### Underscore.js\nUnderscore在很多人眼里已经成为函数式Javascript库的标准。它成熟稳定， 其创建者Jeremy Ashkenas也是Backbone.js和Coffeescript的创建者。 Underscore实际上是对Ruby的Enumerable模块的重新实现， 这也解释了为什么Coffeescript也是受Ruby影响。\n\n与jQuery相似，Underscore并不改变Javascript原生对象，而是用一个符号来定义自己的对象， 就是下划线（underscore）字符“_”。所以使用Underscore会是这个样子：\n```javascript\n   var x = _.map([1,2,3], Math.sqrt); // Underscore的map函数\n   console.log(x.toString()); \n```\n\n我们已经见过Javascript数组原生的map()方法，它是这样用的：\n```javascript\n   var x = [1,2,3].map(Math.sqrt); \n```\n\n不同的是，用underscore时，数组对象和回调函数都是作为参数传入给underscore的map()方法（_.map）的， 而不是像数组原生的map()方法（Array.prototype.map）那样只需传递回调。\n\n不过underscore除了map()还有很多内建函数，他们都是非常好用的函数， 比如find()、invoke()、pluck()、sortBy()、groupBy()等等。\n```javascript\n    var greetings = [{\n      origin: 'spanish',\n      value: 'hola'\n    }, {\n      origin: 'english',\n      value: 'hello'\n    }];\n    console.log(_.pluck(greetings, 'value'));\n    // 获取一个对象的属性.\n    // 返回: ['hola', 'hello']\n    console.log(_.find(greetings, function(s) {\n      return s.origin ==\n        'spanish';\n    }));\n    // 查找第一个回调函数返回真的元素\n    // 返回: {origin: 'spanish', value: 'hola'}\n    greetings = greetings.concat(_.object(['origin', 'value'], ['french', 'bonjour']));\n    console.log(greetings);\n    // _.object通过合并两个数组来建立一个对象\n    // 返回: [{origin: 'spanish', value: 'hola'},\n    //{origin: 'english', value: 'hello'},\n    //{origin: 'french', value: 'bonjour'}]  \n```\n\n并且它还提供了链式调用方法\n```javascript\n    var g = _.chain(greetings)\n      .sortBy(function(x) {\n        return x.value.length\n      })\n      .pluck('origin')\n      .map(function(x) {\n        return x.charAt(0).toUpperCase() + x.slice(1)\n      })\n      .reduce(function(x, y) {\n        return x + ' ' + y\n      }, '')\n      .value(); // 应用这些函数\n    // 返回: 'Spanish English French'\n    console.log(g);\n```\n\n> _.chain()方法的返回值被包在了一个拥有Underscore全部函数的对象里。_.value方法用于把被包裹的对象提取出来。 包裹的对象对于把Underscore混合到面向对象编程中非常有用。\n\nUnderscore也许并没有要追求函数式编程数学上的正确性，不过它也从来没有想要把Javascript扩展或者转变为一个纯函数语言。 它把自己定义为一个提供一大堆有用的函数式编程辅助函数的Javascript库。 也许它比那些伪造得看起来像函数式辅助函数的玩意儿要好些，不过它也不是一个严肃的函数式库。\n\n那么有没有更好的库呢？一个建立在数学之上的库？\n\n### Lazy.js\nLazy是一个实用的库，他更大程度上是沿着Underscore的路线，不过它有惰性求值策略。正因为如此，Lazy让即可解释的语言本不可能完成的函数式计算变成了可能。他还会显著提升性能。\n\nLazy的主意是，我们能够迭代的所有东西都是一个序列。由于这个库用方法执行的先后来控制顺序，很多很酷的事情就可以实现了：异步循环（并行编程）、无限序列、函数式响应式编程等等。\n\n下面的例子展示了以下各种情形的代码：\n```javascript\n    //获得一首歌歌词的前三行\n    var lyrics = \"我徘徊在海之滨山之巅\\n越此城镇越彼乡园\\n ...\"\n    //如果没有惰性，整个歌词会先根据换行来分隔\n    console.log(lyrics.split('\\n').slice(0,3));\n    //有了惰性，可以只文本分割出来前三行\n    //歌词甚至可以无限长\n    console.log(Lazy(lyrics).split('\\n').take(3));\n```\n\n```javascript\n   //前十个能被3整除的平方数\n    var oneTo1000 = Lazy.range(1,1000).toArray();\n    var sequence = Lazy(oneTo1000)\n        .map(function(x){return x*x})\n        .filter(function(x){return x % 3 === 0})\n        .take(10)\n        .each(function(x){console.log(x)});\n```\n\n```javascript\n    //对无限序列的异步循环\n    var asyncSequence = Lazy.generate(function(x){\n        return x++\n    }).async(100) //每两个元素间隔0.1秒\n    .take(20) //只计算前20项\n    .each(function(e){\n        console.log(new Date().getMilliseconds() + \": \" + e);\n    });\n```\n\n不过Lazy库的这个主意并不能保证它完全的正确性。它还有一个前辈，Bacon.js，他们的工作方式差不多。\n\n### 其他的一些库\nJavascript函数式编程的库实在太多了，无法在本书中一一展示。我们再来简单看几个吧。\n\n - Functional\n    - 这也许是Javascript的第一个函数式编程库，它包括了全面的高阶函数支持和string lambdas。\n - wu.js\n    - 因其curryable()函数而饱受赞誉的wu.js库是一个很优秀的函数式编程库。它是第一个（据我所知） 实现了惰性求值的库，这影响了Bacon.js、Lazy.js等库。\n    - 是的，它的名字来源于臭名昭著的摇滚组合“Wu-Tang Clan”\n - sloth.js\n    - 和Lazy.js很像，但是更小\n - stream.js\n    - 支持无限流，其它没什么\n    - 特别小\n - Lo-Dash.js\n    - 就像名字所暗示的那样，它是受underscore.js的启发\n    - 高度优化\n - Sugar\n    - Sugar是Javascript函数式编程技术的支持库，和Underscore相像，但是在实现上有一些关键的不同。\n    - underscore中的 _.pluck(myObjs, 'value')在Suger中仅仅是myObjs.map('value')。 意思是他修改了Javascript原生的对象，所以它在跟其它库混用的时候会有些风险，比如Prototype。\n - from.js\n    - 一个新的函数式库，Javascript的LINQ（语言集成查询）引擎，支持.net所提供的大多数LINQ函数。\n    - 100%惰性求值，并支持lambda表达式\n    - 很年轻，但是文档很出色\n - JSLINQ\n    - 另一个Javascript的LINQ引擎\n    - 比from.js更老也更成熟\n - Boiler.js\n    - 另一个让Javascript扩展的函数式方法更加原生的工具库，包括：字符串、数字、对象、集合和数组\n - Folktale\n    - 像Bilby.js那样，Folktable是一个对Fantasy Land实现的新库。并且像他的祖先那样， Folktable也是一个Javascript函数式编程库的集合。它还很年轻，但有光明的前景。\n - jQuery\n    - 在这里看到jQuery很吃惊吗？尽管jQuery不是一个用于函数式编程的工具，但它自己是函数式的。 jQuery应该是根植于函数式编程的使用最广泛的库。\n    - jQuery对象实际是一个monad。jQuery使用了monad的规则来实现方法链式调用： ```$('#mydiv').fadeIn().css('left': 50).alert('hi!');``` \n    - 它的一些函数是高阶的 ```$('li').css('left': function(index){return index*50});``` \n    - jQuery1.8以上的deferred.then实现了函数式概念Promise\n    - jQuery是一个抽象层，主要是面向DOM。它不是一个框架或工具集， 只是一个使用抽象来提高代码复用和减少丑陋代码的方式。而函数式编程不全都是关于这些的吗？\n\n## 开发和生产环境\n### 环境\n编程风格与应用所部属或者将要部署的环境没啥关系。但是库就有关系了。\n\n### 浏览器\n主要的Javascript应用还是跑在客户端的，也就是浏览器。基于浏览器的环境对于开发来说非常好， 因为浏览器无处不在，你可以在本地机器上写代码，解释器是浏览器的Javascript引擎， 所有的浏览器都有开发者终端。火狐的FireBug提供了非常有用的错误信息，并支持断点等等， 不过同样的代码运行在Chrome和Safari上的交叉引用的错误输出会很有用。甚至连IE都包含开发者工具。\n\n浏览器的问题是他们对Javascript的解析不尽相同！尽管不是普遍现象，但是可能有些代码在不同的浏览器上会得到非常不同的结果。 不过主要的差别在于它们如何处理DOM，而不是在原型和函数如何工作上。举个明显的例子，Math.sqrt(4) 在任何浏览器和shell上都会返回2。但是scrollLeft方法依赖于浏览器的布局策略。\n\n编写针对浏览器的特定代码是在浪费时间，这也是为何要使用库的另外一个原因。\n\n### 服务器端Javascript\nNode.js已经成为创建服务器端和基于网络应用的标准平台。函数式编程可以用于服务器端应用的编程吗？ 可以！OK，不过现在的这些函数式库是为这种注重性能的环境设计的吗？答案仍然是肯定的。\n\n这章提到的所有的函数式库都可以工作在Node.js上，有些需要依赖browserify.js模块来处理浏览器元素。\n\n### 服务器端环境的一个函数式用例\n在我们的网络系统这个无畏的新世界里，服务器端应用开发人员总在担心并发问题，这是应该的。 经典的例子就是一个应用允许多个用户修改同一个文件，如果他们打算同时修改这个文件，你将会陷入令人作呕的混乱。 这就是困扰了程序员几十年的状态维持问题。\n\n假设下面这个情景：\n 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。\n 2.比利打开了同一份报告，添加了内容，并且保存了报告。\n 3.亚当吃完午饭回来，又往这份报告里添加了内容，并且保存，不知情地覆盖了比利的内容。\n 4.第二天，比利发现他的内容消失了。他的老板冲他咆哮，所有的人都一起冲着开发人员发飙，结果开发人员丢了工作。\n \n长期以来，解决这个问题的办法就是给文件建立状态。当有人编辑这个文件的时候就把状态切换为加锁， 这就防止其他人编辑这个文件，并在保存这个文件后把状态切换为解锁。在我们的情景里，比利应该无法修改报告， 直到亚当吃完饭回来。并且只要文件没被保存就没有其他人可以编辑它。\n\n这正是函数式编程关于不可变数据和状态的思想具有实际意义之处。函数式的实现并不是直接修改文件， 而是修改文件的一个拷贝，也就是一个新的版本。如果要保存这个版本而此时一个新的版本已经存在， 我们就知道已经有别人修改了原来的文件。危险规避了。\n\n现在这个场景可以这样展开了：\n 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。\n 2.比利打开了同一份报告，添加了内容，保存为了一个新的版本。\n 3.亚当吃完饭回来继续添加内容，当他要保存时，系统告诉他现在已经存在一个新版本了。\n 4.亚当打开了这个新版本，添加了自己的内容，并保存为另一个新版本。\n 5.通过查看版本历史，老板看到了一切在平稳运行。所有人都很开心，应用的开发人员也得到了晋升和奖赏。\n \n这个叫做事件源。不需要维护明确的状态，只需要事件。这个过程非常清晰，整个事件的历史都可以回顾。\n\n这个思想以及其它一些优势是函数式编程在服务器端日益增长的原因。\n\n## 第三章总结\n你选择使用哪个数据库取决于你的需要是什么。需要函数响应式编程来处理事件和动态值？使用bacon.js。 需要无限流而不需要别的？用stream.js。想要一个函数式助手来补充jQuery？试试underscore.js。 需要严格特定多态的结构化环境？看看bilby.js。需要面面俱到的函数式编程工具？使用Lazy.js。 用这些都不爽？你自己写一个。\n\n任何库都只擅长于它所使用的方式。尽管这章提到的库里面有几个缺点很少，大多数错误都会在不经意间就出现。 这取决于你选择的库是否正确，是否符合你的需求。","slug":"Javascript的函数式库","published":1,"updated":"2016-05-19T07:08:35.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0eln0002b0dl58xj7aqe","content":"<blockquote>\n<p>A book that remains shut is but a block.</p>\n</blockquote>\n<h2 id=\"Javascript的函数式库\"><a href=\"#Javascript的函数式库\" class=\"headerlink\" title=\"Javascript的函数式库\"></a>Javascript的函数式库</h2><p>据说所有的函数是程序员都会写自己的函数库，函数式Javascript程序员也不例外。随着如今开源代码分享平台如GitHab、Bower和NPM的涌现，对这些函数库进行分享、变得及补充变得越来越容易。 现在已经有很多Javascript的函数式变成库，从小巧的工具集到庞大的模块库都有。</p>\n<p>每一个库都宣扬着自己的函数式编程风格。从一本正经的数学风格到灵活松散的非正式风格，每一个库都不尽相同， 然而他们他们有一个共同的特点：都是通过抽象的Javascript函数式能力来增进代码的重用行、可读性和健壮性。</p>\n<h3 id=\"Underscore-js\"><a href=\"#Underscore-js\" class=\"headerlink\" title=\"Underscore.js\"></a>Underscore.js</h3><p>Underscore在很多人眼里已经成为函数式Javascript库的标准。它成熟稳定， 其创建者Jeremy Ashkenas也是Backbone.js和Coffeescript的创建者。 Underscore实际上是对Ruby的Enumerable模块的重新实现， 这也解释了为什么Coffeescript也是受Ruby影响。</p>\n<p>与jQuery相似，Underscore并不改变Javascript原生对象，而是用一个符号来定义自己的对象， 就是下划线（underscore）字符“_”。所以使用Underscore会是这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = _.map([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], <span class=\"built_in\">Math</span>.sqrt); <span class=\"comment\">// Underscore的map函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x.toString());</span><br></pre></td></tr></table></figure></p>\n<p>我们已经见过Javascript数组原生的map()方法，它是这样用的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"built_in\">Math</span>.sqrt);</span><br></pre></td></tr></table></figure></p>\n<p>不同的是，用underscore时，数组对象和回调函数都是作为参数传入给underscore的map()方法（_.map）的， 而不是像数组原生的map()方法（Array.prototype.map）那样只需传递回调。</p>\n<p>不过underscore除了map()还有很多内建函数，他们都是非常好用的函数， 比如find()、invoke()、pluck()、sortBy()、groupBy()等等。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greetings = [&#123;</span><br><span class=\"line\">  origin: <span class=\"string\">'spanish'</span>,</span><br><span class=\"line\">  value: <span class=\"string\">'hola'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  origin: <span class=\"string\">'english'</span>,</span><br><span class=\"line\">  value: <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_.pluck(greetings, <span class=\"string\">'value'</span>));</span><br><span class=\"line\"><span class=\"comment\">// 获取一个对象的属性.</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: ['hola', 'hello']</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_.find(greetings, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.origin ==</span><br><span class=\"line\">    <span class=\"string\">'spanish'</span>;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"><span class=\"comment\">// 查找第一个回调函数返回真的元素</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: &#123;origin: 'spanish', value: 'hola'&#125;</span></span><br><span class=\"line\">greetings = greetings.concat(_.object([<span class=\"string\">'origin'</span>, <span class=\"string\">'value'</span>], [<span class=\"string\">'french'</span>, <span class=\"string\">'bonjour'</span>]));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greetings);</span><br><span class=\"line\"><span class=\"comment\">// _.object通过合并两个数组来建立一个对象</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: [&#123;origin: 'spanish', value: 'hola'&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;origin: 'english', value: 'hello'&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;origin: 'french', value: 'bonjour'&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<p>并且它还提供了链式调用方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = _.chain(greetings)</span><br><span class=\"line\">  .sortBy(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.value.length</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .pluck(<span class=\"string\">'origin'</span>)</span><br><span class=\"line\">  .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.charAt(<span class=\"number\">0</span>).toUpperCase() + x.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"string\">' '</span> + y</span><br><span class=\"line\">  &#125;, <span class=\"string\">''</span>)</span><br><span class=\"line\">  .value(); <span class=\"comment\">// 应用这些函数</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: 'Spanish English French'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><em>.chain()方法的返回值被包在了一个拥有Underscore全部函数的对象里。</em>.value方法用于把被包裹的对象提取出来。 包裹的对象对于把Underscore混合到面向对象编程中非常有用。</p>\n</blockquote>\n<p>Underscore也许并没有要追求函数式编程数学上的正确性，不过它也从来没有想要把Javascript扩展或者转变为一个纯函数语言。 它把自己定义为一个提供一大堆有用的函数式编程辅助函数的Javascript库。 也许它比那些伪造得看起来像函数式辅助函数的玩意儿要好些，不过它也不是一个严肃的函数式库。</p>\n<p>那么有没有更好的库呢？一个建立在数学之上的库？</p>\n<h3 id=\"Lazy-js\"><a href=\"#Lazy-js\" class=\"headerlink\" title=\"Lazy.js\"></a>Lazy.js</h3><p>Lazy是一个实用的库，他更大程度上是沿着Underscore的路线，不过它有惰性求值策略。正因为如此，Lazy让即可解释的语言本不可能完成的函数式计算变成了可能。他还会显著提升性能。</p>\n<p>Lazy的主意是，我们能够迭代的所有东西都是一个序列。由于这个库用方法执行的先后来控制顺序，很多很酷的事情就可以实现了：异步循环（并行编程）、无限序列、函数式响应式编程等等。</p>\n<p>下面的例子展示了以下各种情形的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得一首歌歌词的前三行</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lyrics = <span class=\"string\">\"我徘徊在海之滨山之巅\\n越此城镇越彼乡园\\n ...\"</span></span><br><span class=\"line\"><span class=\"comment\">//如果没有惰性，整个歌词会先根据换行来分隔</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lyrics.split(<span class=\"string\">'\\n'</span>).slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">//有了惰性，可以只文本分割出来前三行</span></span><br><span class=\"line\"><span class=\"comment\">//歌词甚至可以无限长</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Lazy(lyrics).split(<span class=\"string\">'\\n'</span>).take(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前十个能被3整除的平方数</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> oneTo1000 = Lazy.range(<span class=\"number\">1</span>,<span class=\"number\">1000</span>).toArray();</span><br><span class=\"line\"> <span class=\"keyword\">var</span> sequence = Lazy(oneTo1000)</span><br><span class=\"line\">     .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x*x&#125;)</span><br><span class=\"line\">     .filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x % <span class=\"number\">3</span> === <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">     .take(<span class=\"number\">10</span>)</span><br><span class=\"line\">     .each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"built_in\">console</span>.log(x)&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对无限序列的异步循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> asyncSequence = Lazy.generate(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x++</span><br><span class=\"line\">&#125;).async(<span class=\"number\">100</span>) <span class=\"comment\">//每两个元素间隔0.1秒</span></span><br><span class=\"line\">.take(<span class=\"number\">20</span>) <span class=\"comment\">//只计算前20项</span></span><br><span class=\"line\">.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getMilliseconds() + <span class=\"string\">\": \"</span> + e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>不过Lazy库的这个主意并不能保证它完全的正确性。它还有一个前辈，Bacon.js，他们的工作方式差不多。</p>\n<h3 id=\"其他的一些库\"><a href=\"#其他的一些库\" class=\"headerlink\" title=\"其他的一些库\"></a>其他的一些库</h3><p>Javascript函数式编程的库实在太多了，无法在本书中一一展示。我们再来简单看几个吧。</p>\n<ul>\n<li>Functional<ul>\n<li>这也许是Javascript的第一个函数式编程库，它包括了全面的高阶函数支持和string lambdas。</li>\n</ul>\n</li>\n<li>wu.js<ul>\n<li>因其curryable()函数而饱受赞誉的wu.js库是一个很优秀的函数式编程库。它是第一个（据我所知） 实现了惰性求值的库，这影响了Bacon.js、Lazy.js等库。</li>\n<li>是的，它的名字来源于臭名昭著的摇滚组合“Wu-Tang Clan”</li>\n</ul>\n</li>\n<li>sloth.js<ul>\n<li>和Lazy.js很像，但是更小</li>\n</ul>\n</li>\n<li>stream.js<ul>\n<li>支持无限流，其它没什么</li>\n<li>特别小</li>\n</ul>\n</li>\n<li>Lo-Dash.js<ul>\n<li>就像名字所暗示的那样，它是受underscore.js的启发</li>\n<li>高度优化</li>\n</ul>\n</li>\n<li>Sugar<ul>\n<li>Sugar是Javascript函数式编程技术的支持库，和Underscore相像，但是在实现上有一些关键的不同。</li>\n<li>underscore中的 _.pluck(myObjs, ‘value’)在Suger中仅仅是myObjs.map(‘value’)。 意思是他修改了Javascript原生的对象，所以它在跟其它库混用的时候会有些风险，比如Prototype。</li>\n</ul>\n</li>\n<li>from.js<ul>\n<li>一个新的函数式库，Javascript的LINQ（语言集成查询）引擎，支持.net所提供的大多数LINQ函数。</li>\n<li>100%惰性求值，并支持lambda表达式</li>\n<li>很年轻，但是文档很出色</li>\n</ul>\n</li>\n<li>JSLINQ<ul>\n<li>另一个Javascript的LINQ引擎</li>\n<li>比from.js更老也更成熟</li>\n</ul>\n</li>\n<li>Boiler.js<ul>\n<li>另一个让Javascript扩展的函数式方法更加原生的工具库，包括：字符串、数字、对象、集合和数组</li>\n</ul>\n</li>\n<li>Folktale<ul>\n<li>像Bilby.js那样，Folktable是一个对Fantasy Land实现的新库。并且像他的祖先那样， Folktable也是一个Javascript函数式编程库的集合。它还很年轻，但有光明的前景。</li>\n</ul>\n</li>\n<li>jQuery<ul>\n<li>在这里看到jQuery很吃惊吗？尽管jQuery不是一个用于函数式编程的工具，但它自己是函数式的。 jQuery应该是根植于函数式编程的使用最广泛的库。</li>\n<li>jQuery对象实际是一个monad。jQuery使用了monad的规则来实现方法链式调用： <code>$(&#39;#mydiv&#39;).fadeIn().css(&#39;left&#39;: 50).alert(&#39;hi!&#39;);</code> </li>\n<li>它的一些函数是高阶的 <code>$(&#39;li&#39;).css(&#39;left&#39;: function(index){return index*50});</code> </li>\n<li>jQuery1.8以上的deferred.then实现了函数式概念Promise</li>\n<li>jQuery是一个抽象层，主要是面向DOM。它不是一个框架或工具集， 只是一个使用抽象来提高代码复用和减少丑陋代码的方式。而函数式编程不全都是关于这些的吗？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发和生产环境\"><a href=\"#开发和生产环境\" class=\"headerlink\" title=\"开发和生产环境\"></a>开发和生产环境</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>编程风格与应用所部属或者将要部署的环境没啥关系。但是库就有关系了。</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><p>主要的Javascript应用还是跑在客户端的，也就是浏览器。基于浏览器的环境对于开发来说非常好， 因为浏览器无处不在，你可以在本地机器上写代码，解释器是浏览器的Javascript引擎， 所有的浏览器都有开发者终端。火狐的FireBug提供了非常有用的错误信息，并支持断点等等， 不过同样的代码运行在Chrome和Safari上的交叉引用的错误输出会很有用。甚至连IE都包含开发者工具。</p>\n<p>浏览器的问题是他们对Javascript的解析不尽相同！尽管不是普遍现象，但是可能有些代码在不同的浏览器上会得到非常不同的结果。 不过主要的差别在于它们如何处理DOM，而不是在原型和函数如何工作上。举个明显的例子，Math.sqrt(4) 在任何浏览器和shell上都会返回2。但是scrollLeft方法依赖于浏览器的布局策略。</p>\n<p>编写针对浏览器的特定代码是在浪费时间，这也是为何要使用库的另外一个原因。</p>\n<h3 id=\"服务器端Javascript\"><a href=\"#服务器端Javascript\" class=\"headerlink\" title=\"服务器端Javascript\"></a>服务器端Javascript</h3><p>Node.js已经成为创建服务器端和基于网络应用的标准平台。函数式编程可以用于服务器端应用的编程吗？ 可以！OK，不过现在的这些函数式库是为这种注重性能的环境设计的吗？答案仍然是肯定的。</p>\n<p>这章提到的所有的函数式库都可以工作在Node.js上，有些需要依赖browserify.js模块来处理浏览器元素。</p>\n<h3 id=\"服务器端环境的一个函数式用例\"><a href=\"#服务器端环境的一个函数式用例\" class=\"headerlink\" title=\"服务器端环境的一个函数式用例\"></a>服务器端环境的一个函数式用例</h3><p>在我们的网络系统这个无畏的新世界里，服务器端应用开发人员总在担心并发问题，这是应该的。 经典的例子就是一个应用允许多个用户修改同一个文件，如果他们打算同时修改这个文件，你将会陷入令人作呕的混乱。 这就是困扰了程序员几十年的状态维持问题。</p>\n<p>假设下面这个情景：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，并且保存了报告。<br> 3.亚当吃完午饭回来，又往这份报告里添加了内容，并且保存，不知情地覆盖了比利的内容。<br> 4.第二天，比利发现他的内容消失了。他的老板冲他咆哮，所有的人都一起冲着开发人员发飙，结果开发人员丢了工作。</p>\n<p>长期以来，解决这个问题的办法就是给文件建立状态。当有人编辑这个文件的时候就把状态切换为加锁， 这就防止其他人编辑这个文件，并在保存这个文件后把状态切换为解锁。在我们的情景里，比利应该无法修改报告， 直到亚当吃完饭回来。并且只要文件没被保存就没有其他人可以编辑它。</p>\n<p>这正是函数式编程关于不可变数据和状态的思想具有实际意义之处。函数式的实现并不是直接修改文件， 而是修改文件的一个拷贝，也就是一个新的版本。如果要保存这个版本而此时一个新的版本已经存在， 我们就知道已经有别人修改了原来的文件。危险规避了。</p>\n<p>现在这个场景可以这样展开了：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，保存为了一个新的版本。<br> 3.亚当吃完饭回来继续添加内容，当他要保存时，系统告诉他现在已经存在一个新版本了。<br> 4.亚当打开了这个新版本，添加了自己的内容，并保存为另一个新版本。<br> 5.通过查看版本历史，老板看到了一切在平稳运行。所有人都很开心，应用的开发人员也得到了晋升和奖赏。</p>\n<p>这个叫做事件源。不需要维护明确的状态，只需要事件。这个过程非常清晰，整个事件的历史都可以回顾。</p>\n<p>这个思想以及其它一些优势是函数式编程在服务器端日益增长的原因。</p>\n<h2 id=\"第三章总结\"><a href=\"#第三章总结\" class=\"headerlink\" title=\"第三章总结\"></a>第三章总结</h2><p>你选择使用哪个数据库取决于你的需要是什么。需要函数响应式编程来处理事件和动态值？使用bacon.js。 需要无限流而不需要别的？用stream.js。想要一个函数式助手来补充jQuery？试试underscore.js。 需要严格特定多态的结构化环境？看看bilby.js。需要面面俱到的函数式编程工具？使用Lazy.js。 用这些都不爽？你自己写一个。</p>\n<p>任何库都只擅长于它所使用的方式。尽管这章提到的库里面有几个缺点很少，大多数错误都会在不经意间就出现。 这取决于你选择的库是否正确，是否符合你的需求。</p>\n","excerpt":"","more":"<blockquote>\n<p>A book that remains shut is but a block.</p>\n</blockquote>\n<h2 id=\"Javascript的函数式库\"><a href=\"#Javascript的函数式库\" class=\"headerlink\" title=\"Javascript的函数式库\"></a>Javascript的函数式库</h2><p>据说所有的函数是程序员都会写自己的函数库，函数式Javascript程序员也不例外。随着如今开源代码分享平台如GitHab、Bower和NPM的涌现，对这些函数库进行分享、变得及补充变得越来越容易。 现在已经有很多Javascript的函数式变成库，从小巧的工具集到庞大的模块库都有。</p>\n<p>每一个库都宣扬着自己的函数式编程风格。从一本正经的数学风格到灵活松散的非正式风格，每一个库都不尽相同， 然而他们他们有一个共同的特点：都是通过抽象的Javascript函数式能力来增进代码的重用行、可读性和健壮性。</p>\n<h3 id=\"Underscore-js\"><a href=\"#Underscore-js\" class=\"headerlink\" title=\"Underscore.js\"></a>Underscore.js</h3><p>Underscore在很多人眼里已经成为函数式Javascript库的标准。它成熟稳定， 其创建者Jeremy Ashkenas也是Backbone.js和Coffeescript的创建者。 Underscore实际上是对Ruby的Enumerable模块的重新实现， 这也解释了为什么Coffeescript也是受Ruby影响。</p>\n<p>与jQuery相似，Underscore并不改变Javascript原生对象，而是用一个符号来定义自己的对象， 就是下划线（underscore）字符“_”。所以使用Underscore会是这个样子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = _.map([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>], <span class=\"built_in\">Math</span>.sqrt); <span class=\"comment\">// Underscore的map函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x.toString());</span><br></pre></td></tr></table></figure></p>\n<p>我们已经见过Javascript数组原生的map()方法，它是这样用的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].map(<span class=\"built_in\">Math</span>.sqrt);</span><br></pre></td></tr></table></figure></p>\n<p>不同的是，用underscore时，数组对象和回调函数都是作为参数传入给underscore的map()方法（_.map）的， 而不是像数组原生的map()方法（Array.prototype.map）那样只需传递回调。</p>\n<p>不过underscore除了map()还有很多内建函数，他们都是非常好用的函数， 比如find()、invoke()、pluck()、sortBy()、groupBy()等等。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greetings = [&#123;</span><br><span class=\"line\">  origin: <span class=\"string\">'spanish'</span>,</span><br><span class=\"line\">  value: <span class=\"string\">'hola'</span></span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  origin: <span class=\"string\">'english'</span>,</span><br><span class=\"line\">  value: <span class=\"string\">'hello'</span></span><br><span class=\"line\">&#125;];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_.pluck(greetings, <span class=\"string\">'value'</span>));</span><br><span class=\"line\"><span class=\"comment\">// 获取一个对象的属性.</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: ['hola', 'hello']</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(_.find(greetings, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.origin ==</span><br><span class=\"line\">    <span class=\"string\">'spanish'</span>;</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"><span class=\"comment\">// 查找第一个回调函数返回真的元素</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: &#123;origin: 'spanish', value: 'hola'&#125;</span></span><br><span class=\"line\">greetings = greetings.concat(_.object([<span class=\"string\">'origin'</span>, <span class=\"string\">'value'</span>], [<span class=\"string\">'french'</span>, <span class=\"string\">'bonjour'</span>]));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(greetings);</span><br><span class=\"line\"><span class=\"comment\">// _.object通过合并两个数组来建立一个对象</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: [&#123;origin: 'spanish', value: 'hola'&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;origin: 'english', value: 'hello'&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//&#123;origin: 'french', value: 'bonjour'&#125;]</span></span><br></pre></td></tr></table></figure></p>\n<p>并且它还提供了链式调用方法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> g = _.chain(greetings)</span><br><span class=\"line\">  .sortBy(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.value.length</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .pluck(<span class=\"string\">'origin'</span>)</span><br><span class=\"line\">  .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.charAt(<span class=\"number\">0</span>).toUpperCase() + x.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"string\">' '</span> + y</span><br><span class=\"line\">  &#125;, <span class=\"string\">''</span>)</span><br><span class=\"line\">  .value(); <span class=\"comment\">// 应用这些函数</span></span><br><span class=\"line\"><span class=\"comment\">// 返回: 'Spanish English French'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(g);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><em>.chain()方法的返回值被包在了一个拥有Underscore全部函数的对象里。</em>.value方法用于把被包裹的对象提取出来。 包裹的对象对于把Underscore混合到面向对象编程中非常有用。</p>\n</blockquote>\n<p>Underscore也许并没有要追求函数式编程数学上的正确性，不过它也从来没有想要把Javascript扩展或者转变为一个纯函数语言。 它把自己定义为一个提供一大堆有用的函数式编程辅助函数的Javascript库。 也许它比那些伪造得看起来像函数式辅助函数的玩意儿要好些，不过它也不是一个严肃的函数式库。</p>\n<p>那么有没有更好的库呢？一个建立在数学之上的库？</p>\n<h3 id=\"Lazy-js\"><a href=\"#Lazy-js\" class=\"headerlink\" title=\"Lazy.js\"></a>Lazy.js</h3><p>Lazy是一个实用的库，他更大程度上是沿着Underscore的路线，不过它有惰性求值策略。正因为如此，Lazy让即可解释的语言本不可能完成的函数式计算变成了可能。他还会显著提升性能。</p>\n<p>Lazy的主意是，我们能够迭代的所有东西都是一个序列。由于这个库用方法执行的先后来控制顺序，很多很酷的事情就可以实现了：异步循环（并行编程）、无限序列、函数式响应式编程等等。</p>\n<p>下面的例子展示了以下各种情形的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获得一首歌歌词的前三行</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lyrics = <span class=\"string\">\"我徘徊在海之滨山之巅\\n越此城镇越彼乡园\\n ...\"</span></span><br><span class=\"line\"><span class=\"comment\">//如果没有惰性，整个歌词会先根据换行来分隔</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lyrics.split(<span class=\"string\">'\\n'</span>).slice(<span class=\"number\">0</span>,<span class=\"number\">3</span>));</span><br><span class=\"line\"><span class=\"comment\">//有了惰性，可以只文本分割出来前三行</span></span><br><span class=\"line\"><span class=\"comment\">//歌词甚至可以无限长</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Lazy(lyrics).split(<span class=\"string\">'\\n'</span>).take(<span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//前十个能被3整除的平方数</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> oneTo1000 = Lazy.range(<span class=\"number\">1</span>,<span class=\"number\">1000</span>).toArray();</span><br><span class=\"line\"> <span class=\"keyword\">var</span> sequence = Lazy(oneTo1000)</span><br><span class=\"line\">     .map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x*x&#125;)</span><br><span class=\"line\">     .filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x % <span class=\"number\">3</span> === <span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">     .take(<span class=\"number\">10</span>)</span><br><span class=\"line\">     .each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"built_in\">console</span>.log(x)&#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//对无限序列的异步循环</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> asyncSequence = Lazy.generate(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x++</span><br><span class=\"line\">&#125;).async(<span class=\"number\">100</span>) <span class=\"comment\">//每两个元素间隔0.1秒</span></span><br><span class=\"line\">.take(<span class=\"number\">20</span>) <span class=\"comment\">//只计算前20项</span></span><br><span class=\"line\">.each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getMilliseconds() + <span class=\"string\">\": \"</span> + e);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>不过Lazy库的这个主意并不能保证它完全的正确性。它还有一个前辈，Bacon.js，他们的工作方式差不多。</p>\n<h3 id=\"其他的一些库\"><a href=\"#其他的一些库\" class=\"headerlink\" title=\"其他的一些库\"></a>其他的一些库</h3><p>Javascript函数式编程的库实在太多了，无法在本书中一一展示。我们再来简单看几个吧。</p>\n<ul>\n<li>Functional<ul>\n<li>这也许是Javascript的第一个函数式编程库，它包括了全面的高阶函数支持和string lambdas。</li>\n</ul>\n</li>\n<li>wu.js<ul>\n<li>因其curryable()函数而饱受赞誉的wu.js库是一个很优秀的函数式编程库。它是第一个（据我所知） 实现了惰性求值的库，这影响了Bacon.js、Lazy.js等库。</li>\n<li>是的，它的名字来源于臭名昭著的摇滚组合“Wu-Tang Clan”</li>\n</ul>\n</li>\n<li>sloth.js<ul>\n<li>和Lazy.js很像，但是更小</li>\n</ul>\n</li>\n<li>stream.js<ul>\n<li>支持无限流，其它没什么</li>\n<li>特别小</li>\n</ul>\n</li>\n<li>Lo-Dash.js<ul>\n<li>就像名字所暗示的那样，它是受underscore.js的启发</li>\n<li>高度优化</li>\n</ul>\n</li>\n<li>Sugar<ul>\n<li>Sugar是Javascript函数式编程技术的支持库，和Underscore相像，但是在实现上有一些关键的不同。</li>\n<li>underscore中的 _.pluck(myObjs, ‘value’)在Suger中仅仅是myObjs.map(‘value’)。 意思是他修改了Javascript原生的对象，所以它在跟其它库混用的时候会有些风险，比如Prototype。</li>\n</ul>\n</li>\n<li>from.js<ul>\n<li>一个新的函数式库，Javascript的LINQ（语言集成查询）引擎，支持.net所提供的大多数LINQ函数。</li>\n<li>100%惰性求值，并支持lambda表达式</li>\n<li>很年轻，但是文档很出色</li>\n</ul>\n</li>\n<li>JSLINQ<ul>\n<li>另一个Javascript的LINQ引擎</li>\n<li>比from.js更老也更成熟</li>\n</ul>\n</li>\n<li>Boiler.js<ul>\n<li>另一个让Javascript扩展的函数式方法更加原生的工具库，包括：字符串、数字、对象、集合和数组</li>\n</ul>\n</li>\n<li>Folktale<ul>\n<li>像Bilby.js那样，Folktable是一个对Fantasy Land实现的新库。并且像他的祖先那样， Folktable也是一个Javascript函数式编程库的集合。它还很年轻，但有光明的前景。</li>\n</ul>\n</li>\n<li>jQuery<ul>\n<li>在这里看到jQuery很吃惊吗？尽管jQuery不是一个用于函数式编程的工具，但它自己是函数式的。 jQuery应该是根植于函数式编程的使用最广泛的库。</li>\n<li>jQuery对象实际是一个monad。jQuery使用了monad的规则来实现方法链式调用： <code>$(&#39;#mydiv&#39;).fadeIn().css(&#39;left&#39;: 50).alert(&#39;hi!&#39;);</code> </li>\n<li>它的一些函数是高阶的 <code>$(&#39;li&#39;).css(&#39;left&#39;: function(index){return index*50});</code> </li>\n<li>jQuery1.8以上的deferred.then实现了函数式概念Promise</li>\n<li>jQuery是一个抽象层，主要是面向DOM。它不是一个框架或工具集， 只是一个使用抽象来提高代码复用和减少丑陋代码的方式。而函数式编程不全都是关于这些的吗？</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"开发和生产环境\"><a href=\"#开发和生产环境\" class=\"headerlink\" title=\"开发和生产环境\"></a>开发和生产环境</h2><h3 id=\"环境\"><a href=\"#环境\" class=\"headerlink\" title=\"环境\"></a>环境</h3><p>编程风格与应用所部属或者将要部署的环境没啥关系。但是库就有关系了。</p>\n<h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><p>主要的Javascript应用还是跑在客户端的，也就是浏览器。基于浏览器的环境对于开发来说非常好， 因为浏览器无处不在，你可以在本地机器上写代码，解释器是浏览器的Javascript引擎， 所有的浏览器都有开发者终端。火狐的FireBug提供了非常有用的错误信息，并支持断点等等， 不过同样的代码运行在Chrome和Safari上的交叉引用的错误输出会很有用。甚至连IE都包含开发者工具。</p>\n<p>浏览器的问题是他们对Javascript的解析不尽相同！尽管不是普遍现象，但是可能有些代码在不同的浏览器上会得到非常不同的结果。 不过主要的差别在于它们如何处理DOM，而不是在原型和函数如何工作上。举个明显的例子，Math.sqrt(4) 在任何浏览器和shell上都会返回2。但是scrollLeft方法依赖于浏览器的布局策略。</p>\n<p>编写针对浏览器的特定代码是在浪费时间，这也是为何要使用库的另外一个原因。</p>\n<h3 id=\"服务器端Javascript\"><a href=\"#服务器端Javascript\" class=\"headerlink\" title=\"服务器端Javascript\"></a>服务器端Javascript</h3><p>Node.js已经成为创建服务器端和基于网络应用的标准平台。函数式编程可以用于服务器端应用的编程吗？ 可以！OK，不过现在的这些函数式库是为这种注重性能的环境设计的吗？答案仍然是肯定的。</p>\n<p>这章提到的所有的函数式库都可以工作在Node.js上，有些需要依赖browserify.js模块来处理浏览器元素。</p>\n<h3 id=\"服务器端环境的一个函数式用例\"><a href=\"#服务器端环境的一个函数式用例\" class=\"headerlink\" title=\"服务器端环境的一个函数式用例\"></a>服务器端环境的一个函数式用例</h3><p>在我们的网络系统这个无畏的新世界里，服务器端应用开发人员总在担心并发问题，这是应该的。 经典的例子就是一个应用允许多个用户修改同一个文件，如果他们打算同时修改这个文件，你将会陷入令人作呕的混乱。 这就是困扰了程序员几十年的状态维持问题。</p>\n<p>假设下面这个情景：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，并且保存了报告。<br> 3.亚当吃完午饭回来，又往这份报告里添加了内容，并且保存，不知情地覆盖了比利的内容。<br> 4.第二天，比利发现他的内容消失了。他的老板冲他咆哮，所有的人都一起冲着开发人员发飙，结果开发人员丢了工作。</p>\n<p>长期以来，解决这个问题的办法就是给文件建立状态。当有人编辑这个文件的时候就把状态切换为加锁， 这就防止其他人编辑这个文件，并在保存这个文件后把状态切换为解锁。在我们的情景里，比利应该无法修改报告， 直到亚当吃完饭回来。并且只要文件没被保存就没有其他人可以编辑它。</p>\n<p>这正是函数式编程关于不可变数据和状态的思想具有实际意义之处。函数式的实现并不是直接修改文件， 而是修改文件的一个拷贝，也就是一个新的版本。如果要保存这个版本而此时一个新的版本已经存在， 我们就知道已经有别人修改了原来的文件。危险规避了。</p>\n<p>现在这个场景可以这样展开了：<br> 1.一天早晨，亚当打开了一份报告开始编辑，但是出去吃午饭的时候没有保存。<br> 2.比利打开了同一份报告，添加了内容，保存为了一个新的版本。<br> 3.亚当吃完饭回来继续添加内容，当他要保存时，系统告诉他现在已经存在一个新版本了。<br> 4.亚当打开了这个新版本，添加了自己的内容，并保存为另一个新版本。<br> 5.通过查看版本历史，老板看到了一切在平稳运行。所有人都很开心，应用的开发人员也得到了晋升和奖赏。</p>\n<p>这个叫做事件源。不需要维护明确的状态，只需要事件。这个过程非常清晰，整个事件的历史都可以回顾。</p>\n<p>这个思想以及其它一些优势是函数式编程在服务器端日益增长的原因。</p>\n<h2 id=\"第三章总结\"><a href=\"#第三章总结\" class=\"headerlink\" title=\"第三章总结\"></a>第三章总结</h2><p>你选择使用哪个数据库取决于你的需要是什么。需要函数响应式编程来处理事件和动态值？使用bacon.js。 需要无限流而不需要别的？用stream.js。想要一个函数式助手来补充jQuery？试试underscore.js。 需要严格特定多态的结构化环境？看看bilby.js。需要面面俱到的函数式编程工具？使用Lazy.js。 用这些都不爽？你自己写一个。</p>\n<p>任何库都只擅长于它所使用的方式。尽管这章提到的库里面有几个缺点很少，大多数错误都会在不经意间就出现。 这取决于你选择的库是否正确，是否符合你的需求。</p>\n"},{"title":"JS函数式编程的力量(转)","date":"2016-05-18T01:29:02.000Z","_content":"> 关于javascript函数式编程这一部分皆为转载外加自己的一些理解和实践。\n\n## Javascript函数式编程的力量\n几十年来，函数式编程一直是计算机科学狂热者的至爱，由于数学的纯洁性和谜一般的本质， 它被埋藏在计算机实验室，只有数据学家和有希望获得博士学位的人士使用。但是现在，它正经历一场复兴， 这要感谢一些现代语言比如Python，Julia，Ruby，Clojure以及——但不是最后一个——Javascript。\n\n你是说Javascript？这个WEB脚本语言？没错！\n\nJavascript已经被证明是一项长期以来都没有消失的重要的技术。这主要是由于它扩展的一些框架和库而使其具有重生的能力， 比如backbone.js，jQuery，Dojo，underscore.js等等。这与Javascript函数式编程语言的真实身份直接相关。 对Javascript函数式编程的理解很重要，并且在相当长的一段时间会对各种水平的程序员很有用。\n\n为什么呢？函数式编程非常强大、健壮并且优雅。它对于大型数据结构非常有用并且高效。 Javascript作为一个客户端脚本语言，在应对日益复杂的网站时，函数式地操作DOM、 组织API响应以及完成一些其它任务会非常有好处。\n\n在这本书里，你将会学习用Javascript进行函数式编程所需要知道的一切：如何用函数式编程构建你的Javascript web应用， 如何解锁Javascript隐藏的力量，如何编写更强大的代码，并且由于程序更小，使得代码更容易维护，能够更快被下载， 并且花费更少的开支。你还会学到函数式编程的核心概念，以及如何将它们应用到Javascript， 还有将Javascript作为函数式语言时如何回避一些问题，如何在Javascript中混合使用函数式编程和面向对象编程。\n\n不过在我们开始前，先来做个实验。\n    \n### 例子\n也许快速举个例子是介绍Javascript函数式编程最好的方式。我们将用Javascript完成一些任务—— 一个使用传统、原生的方法，另一个使用函数式编程。然后我们将会比较这两种方法。\n\n### 应用--一个电子商务网站\n为了追求真实感，我们来做一个电子商务网站，一个邮购咖啡豆的公司。这个网站会销售好几种类型的咖啡，有不同的品质，当然也有不同的价格。\n    \n### 命令式方法\n首先，我们开始写程序。为了让这个例子更接地气，我们需要创建一些对象来保存数据。如果需要的话我们可以从数据库里取值。但是现在我们假设他们是静态定义的。\n```javascript\n    //create some objects to store the data\n    var columbian = {\n        name: 'columbian',\n        basePrice: 5\n    };\n    var frenchRoast = {\n        name: 'french Roast',\n        basePrice: 8\n    };\n    var decaf = {\n        name: 'decaf',\n        basePrice: 6\n    };\n    //我们将使用辅助函数计算价格\n    //根据size打印到一个HTML的列表中\n    function printPrice(coffee,size){\n        if(size == 'small'){\n            var price = coffee.basePrice + 2;\n        }else if(size == 'medium'){\n            var price = coffee.basePrice + 4;\n        }else{\n            var price = coffee.basePrice + 6;\n        }\n        //create the new html list item\n        var node = document.createElement(\"li\");\n        var label = coffee.name + ' ' + size;\n        var textnode = document.createTextNode(label+ 'price: $'+ price);\n        node.appendChild(textnode);\n        document.getElementById('products').appendChild(node);\n    }\n    //现在我们只需要根据咖啡的各种价格和size的组合调用printPrice函数\n    printPrice(columbian, 'small');\n    printPrice(columbian, 'medium');\n    printPrice(columbian, 'large');\n    printPrice(frenchRoast, 'small');\n    printPrice(frenchRoast, 'medium');\n    printPrice(frenchRoast, 'large');\n    printPrice(decaf, 'small');\n    printPrice(decaf, 'medium');\n    printPrice(decaf, 'large');\n```\n如你所见，这个代码非常基础。如果现在有更多的咖啡种类而不只是这三个改怎么办？如果有20个，甚至50个？ 如果有更多的size呢？如果有有机和无机之分呢？这将会很快将代码量变得巨大无比！\n\n采用这种方法，我们让机器去打印每一种咖啡类型和每一个size。这就是采用这种命令式方法的基本问题。\n\n### 函数式编程\n命令式的代码一步一步地告诉电脑需要做什么，相反，函数式编程追求用数学方式来描述问题，其余的交给电脑来做。\n通过更函数式一些的方法，同样的应用可以这样来写：\n```javascript\n    //从接口中分解数据和逻辑\n    var printPrice = function(price,label){\n        var node = document.createElement(\"li\");\n        var textnode = document.createTextNode(label+ ' price: $'+ price);\n        node.appendChild(textnode);\n        document.getElementById('products2').appendChild(node);\n    }\n    //为每种咖啡创建函数对象\n    var columbian = function(){\n        this.name = 'colimbian';\n        this.basePrice = 5;\n    };\n    var frenchRoast = function(){\n     this.name = 'french roast';\n     this.basePrice = 8;\n    };\n    var decaf = function(){\n     this.name = 'decaf';\n     this.basePrice = 6;\n    };\n    //为每种size通过字面量创建对象\n    var small = {\n        getPrice: function(){return this.basePrice + 2},\n        getLabel: function(){return this.name + ' small'}\n    };\n    var medium = {\n      getPrice: function(){return this.basePrice + 4},\n      getLabel: function(){return this.name + ' medium'}\n    };\n    var large = {\n      getPrice: function(){return this.basePrice + 6},\n      getLabel: function(){return this.name + ' large'}\n    };\n    //将所有咖啡的种类和size放到数组里\n    var coffeeTypes = [columbian, frenchRoast, decaf];\n    var coffeeSizes = [small, medium, large];\n    //创建由上面内容组成的新对象，并把它们放到一个新数组里\n    var coffee = coffeeTypes.reduce(function(previous,current){\n        var newCoffee = coffeeSizes.map(function(mixin){\n            //`plusmix`是函数时的mixin\n            var newCoffeeObj = plusMixin(current,mixin);\n            return new newCoffeeObj();\n        });\n        return previous.concat(newCoffee);\n    },[]);\n    //现在我们已经定义了如何获得所有咖啡种类和size组合方式的价格，现在可以直接打印他们了\n    coffee.forEach(function(coffee){\n        printPrice(coffee.getPrice(),coffee.getLabel());\n    })\n```\n\n首先需要明确的是这个代码更加模块化了。现在新增一种size或者新增一个咖啡种类就像下面的代码这样简单：\n```javascript\n    var peruvian = function(){\n        this.name = 'peruvian';\n        this.basePrice = 11;\n    }\n    var extraLarge = {\n        getPrice: function(){return this.basePrice + 10},\n        getLabel: function(){return this.name + ' extra large'}\n    };\n    coffeeTypes.push(peruvian);\n    coffeeSizes.push(extraLarge);\n```\n\n咖啡对象的数组和size对象的数组混合(mix)到了一起，也就是他们的方法和成员变量被组合到了一块--通过一个叫\"plusMixin\"的自定义函数。这些咖啡类型的类包含了成员变量，而这些size对象(small,medium,large)包含了获取名称和计算价格的方法。混合(mixing)这个动作通过一个map操作来起作用，也就是对数组中的每一个成员执行一个纯函数并返回一个新的函数， 然后这些返回的函数被放到了一个reduce函数中被操作，reduce也是一个高阶函数，和map有些像， 只是reduce把数组里的所有元素处理后组合到了一个东西里面。最终，新的数组包含了所有可能的种类和size的组合， 这个数组通过forEach方法遍历，forEach也是一个高阶函数，它会让数组里面每一个对象作为参数执行一遍回调函数。 在这个例子里，这个回调函数是一个匿名函数，它获取这些对象后，以对象的getPrice()和getLabel() 两个方法的返回值作为参数调用printPrice函数。\n\n实际上，我们可以让这个例子更加函数式：去掉coffees变量，并将函数串到一起链式调用，这也是函数式编程的一个小技巧。\n```javascript\n    coffeeTypes.reduce(function(previous,current){\n        var newCoffee = coffeeSizes.map(function(mixin){\n            //`plusMixin`\n            var newCoffeeObj = plusMixin(current,mixin);\n            return new newCoffeeObj();\n        });\n        return previous.concat(newCoffee);\n    }.[]).forEach(function(coffee){\n        printPrice(coffee.getPrice(),coffee.getLabel());\n    });\n```\n    \n这样，控制流没有像命令是代码那样从头到尾的顺序进行。在函数式编程里，map函数和其他高阶函数代替了for和while循环，只有少量关键的代码是在顺序执行。这使得新接触的人在阅读这样范式的代码有些困难，但是一旦你能够欣赏它，你就会发现这根本没啥难的，而且这样写起来更好。\n    \n## 总结\n首先，采用函数式风格的优点已经明确了。 其次，不要害怕函数式编程。的确，它往往被认为是编程语言的纯逻辑形式，但是我们不需要理解lambda演算也能够在日常任务中应用它。 实际上，通过把我们的程序拆分成小的片段，它们变得更容易被理解、维护，也更加可靠。 map和reduce函数是Javascript中不太被知道的内建函数，然而我们将要关注它们。","source":"_posts/JS函数式编程的力量-转.md","raw":"---\ntitle: JS函数式编程的力量(转)\ndate: 2016-05-18 09:29:02\ntags:\n- javascript\n- 函数式编程\ncategories: 转载笔记\n---\n> 关于javascript函数式编程这一部分皆为转载外加自己的一些理解和实践。\n\n## Javascript函数式编程的力量\n几十年来，函数式编程一直是计算机科学狂热者的至爱，由于数学的纯洁性和谜一般的本质， 它被埋藏在计算机实验室，只有数据学家和有希望获得博士学位的人士使用。但是现在，它正经历一场复兴， 这要感谢一些现代语言比如Python，Julia，Ruby，Clojure以及——但不是最后一个——Javascript。\n\n你是说Javascript？这个WEB脚本语言？没错！\n\nJavascript已经被证明是一项长期以来都没有消失的重要的技术。这主要是由于它扩展的一些框架和库而使其具有重生的能力， 比如backbone.js，jQuery，Dojo，underscore.js等等。这与Javascript函数式编程语言的真实身份直接相关。 对Javascript函数式编程的理解很重要，并且在相当长的一段时间会对各种水平的程序员很有用。\n\n为什么呢？函数式编程非常强大、健壮并且优雅。它对于大型数据结构非常有用并且高效。 Javascript作为一个客户端脚本语言，在应对日益复杂的网站时，函数式地操作DOM、 组织API响应以及完成一些其它任务会非常有好处。\n\n在这本书里，你将会学习用Javascript进行函数式编程所需要知道的一切：如何用函数式编程构建你的Javascript web应用， 如何解锁Javascript隐藏的力量，如何编写更强大的代码，并且由于程序更小，使得代码更容易维护，能够更快被下载， 并且花费更少的开支。你还会学到函数式编程的核心概念，以及如何将它们应用到Javascript， 还有将Javascript作为函数式语言时如何回避一些问题，如何在Javascript中混合使用函数式编程和面向对象编程。\n\n不过在我们开始前，先来做个实验。\n    \n### 例子\n也许快速举个例子是介绍Javascript函数式编程最好的方式。我们将用Javascript完成一些任务—— 一个使用传统、原生的方法，另一个使用函数式编程。然后我们将会比较这两种方法。\n\n### 应用--一个电子商务网站\n为了追求真实感，我们来做一个电子商务网站，一个邮购咖啡豆的公司。这个网站会销售好几种类型的咖啡，有不同的品质，当然也有不同的价格。\n    \n### 命令式方法\n首先，我们开始写程序。为了让这个例子更接地气，我们需要创建一些对象来保存数据。如果需要的话我们可以从数据库里取值。但是现在我们假设他们是静态定义的。\n```javascript\n    //create some objects to store the data\n    var columbian = {\n        name: 'columbian',\n        basePrice: 5\n    };\n    var frenchRoast = {\n        name: 'french Roast',\n        basePrice: 8\n    };\n    var decaf = {\n        name: 'decaf',\n        basePrice: 6\n    };\n    //我们将使用辅助函数计算价格\n    //根据size打印到一个HTML的列表中\n    function printPrice(coffee,size){\n        if(size == 'small'){\n            var price = coffee.basePrice + 2;\n        }else if(size == 'medium'){\n            var price = coffee.basePrice + 4;\n        }else{\n            var price = coffee.basePrice + 6;\n        }\n        //create the new html list item\n        var node = document.createElement(\"li\");\n        var label = coffee.name + ' ' + size;\n        var textnode = document.createTextNode(label+ 'price: $'+ price);\n        node.appendChild(textnode);\n        document.getElementById('products').appendChild(node);\n    }\n    //现在我们只需要根据咖啡的各种价格和size的组合调用printPrice函数\n    printPrice(columbian, 'small');\n    printPrice(columbian, 'medium');\n    printPrice(columbian, 'large');\n    printPrice(frenchRoast, 'small');\n    printPrice(frenchRoast, 'medium');\n    printPrice(frenchRoast, 'large');\n    printPrice(decaf, 'small');\n    printPrice(decaf, 'medium');\n    printPrice(decaf, 'large');\n```\n如你所见，这个代码非常基础。如果现在有更多的咖啡种类而不只是这三个改怎么办？如果有20个，甚至50个？ 如果有更多的size呢？如果有有机和无机之分呢？这将会很快将代码量变得巨大无比！\n\n采用这种方法，我们让机器去打印每一种咖啡类型和每一个size。这就是采用这种命令式方法的基本问题。\n\n### 函数式编程\n命令式的代码一步一步地告诉电脑需要做什么，相反，函数式编程追求用数学方式来描述问题，其余的交给电脑来做。\n通过更函数式一些的方法，同样的应用可以这样来写：\n```javascript\n    //从接口中分解数据和逻辑\n    var printPrice = function(price,label){\n        var node = document.createElement(\"li\");\n        var textnode = document.createTextNode(label+ ' price: $'+ price);\n        node.appendChild(textnode);\n        document.getElementById('products2').appendChild(node);\n    }\n    //为每种咖啡创建函数对象\n    var columbian = function(){\n        this.name = 'colimbian';\n        this.basePrice = 5;\n    };\n    var frenchRoast = function(){\n     this.name = 'french roast';\n     this.basePrice = 8;\n    };\n    var decaf = function(){\n     this.name = 'decaf';\n     this.basePrice = 6;\n    };\n    //为每种size通过字面量创建对象\n    var small = {\n        getPrice: function(){return this.basePrice + 2},\n        getLabel: function(){return this.name + ' small'}\n    };\n    var medium = {\n      getPrice: function(){return this.basePrice + 4},\n      getLabel: function(){return this.name + ' medium'}\n    };\n    var large = {\n      getPrice: function(){return this.basePrice + 6},\n      getLabel: function(){return this.name + ' large'}\n    };\n    //将所有咖啡的种类和size放到数组里\n    var coffeeTypes = [columbian, frenchRoast, decaf];\n    var coffeeSizes = [small, medium, large];\n    //创建由上面内容组成的新对象，并把它们放到一个新数组里\n    var coffee = coffeeTypes.reduce(function(previous,current){\n        var newCoffee = coffeeSizes.map(function(mixin){\n            //`plusmix`是函数时的mixin\n            var newCoffeeObj = plusMixin(current,mixin);\n            return new newCoffeeObj();\n        });\n        return previous.concat(newCoffee);\n    },[]);\n    //现在我们已经定义了如何获得所有咖啡种类和size组合方式的价格，现在可以直接打印他们了\n    coffee.forEach(function(coffee){\n        printPrice(coffee.getPrice(),coffee.getLabel());\n    })\n```\n\n首先需要明确的是这个代码更加模块化了。现在新增一种size或者新增一个咖啡种类就像下面的代码这样简单：\n```javascript\n    var peruvian = function(){\n        this.name = 'peruvian';\n        this.basePrice = 11;\n    }\n    var extraLarge = {\n        getPrice: function(){return this.basePrice + 10},\n        getLabel: function(){return this.name + ' extra large'}\n    };\n    coffeeTypes.push(peruvian);\n    coffeeSizes.push(extraLarge);\n```\n\n咖啡对象的数组和size对象的数组混合(mix)到了一起，也就是他们的方法和成员变量被组合到了一块--通过一个叫\"plusMixin\"的自定义函数。这些咖啡类型的类包含了成员变量，而这些size对象(small,medium,large)包含了获取名称和计算价格的方法。混合(mixing)这个动作通过一个map操作来起作用，也就是对数组中的每一个成员执行一个纯函数并返回一个新的函数， 然后这些返回的函数被放到了一个reduce函数中被操作，reduce也是一个高阶函数，和map有些像， 只是reduce把数组里的所有元素处理后组合到了一个东西里面。最终，新的数组包含了所有可能的种类和size的组合， 这个数组通过forEach方法遍历，forEach也是一个高阶函数，它会让数组里面每一个对象作为参数执行一遍回调函数。 在这个例子里，这个回调函数是一个匿名函数，它获取这些对象后，以对象的getPrice()和getLabel() 两个方法的返回值作为参数调用printPrice函数。\n\n实际上，我们可以让这个例子更加函数式：去掉coffees变量，并将函数串到一起链式调用，这也是函数式编程的一个小技巧。\n```javascript\n    coffeeTypes.reduce(function(previous,current){\n        var newCoffee = coffeeSizes.map(function(mixin){\n            //`plusMixin`\n            var newCoffeeObj = plusMixin(current,mixin);\n            return new newCoffeeObj();\n        });\n        return previous.concat(newCoffee);\n    }.[]).forEach(function(coffee){\n        printPrice(coffee.getPrice(),coffee.getLabel());\n    });\n```\n    \n这样，控制流没有像命令是代码那样从头到尾的顺序进行。在函数式编程里，map函数和其他高阶函数代替了for和while循环，只有少量关键的代码是在顺序执行。这使得新接触的人在阅读这样范式的代码有些困难，但是一旦你能够欣赏它，你就会发现这根本没啥难的，而且这样写起来更好。\n    \n## 总结\n首先，采用函数式风格的优点已经明确了。 其次，不要害怕函数式编程。的确，它往往被认为是编程语言的纯逻辑形式，但是我们不需要理解lambda演算也能够在日常任务中应用它。 实际上，通过把我们的程序拆分成小的片段，它们变得更容易被理解、维护，也更加可靠。 map和reduce函数是Javascript中不太被知道的内建函数，然而我们将要关注它们。","slug":"JS函数式编程的力量-转","published":1,"updated":"2016-05-18T03:07:41.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0elu0005b0dl1gvd8sq5","content":"<blockquote>\n<p>关于javascript函数式编程这一部分皆为转载外加自己的一些理解和实践。</p>\n</blockquote>\n<h2 id=\"Javascript函数式编程的力量\"><a href=\"#Javascript函数式编程的力量\" class=\"headerlink\" title=\"Javascript函数式编程的力量\"></a>Javascript函数式编程的力量</h2><p>几十年来，函数式编程一直是计算机科学狂热者的至爱，由于数学的纯洁性和谜一般的本质， 它被埋藏在计算机实验室，只有数据学家和有希望获得博士学位的人士使用。但是现在，它正经历一场复兴， 这要感谢一些现代语言比如Python，Julia，Ruby，Clojure以及——但不是最后一个——Javascript。</p>\n<p>你是说Javascript？这个WEB脚本语言？没错！</p>\n<p>Javascript已经被证明是一项长期以来都没有消失的重要的技术。这主要是由于它扩展的一些框架和库而使其具有重生的能力， 比如backbone.js，jQuery，Dojo，underscore.js等等。这与Javascript函数式编程语言的真实身份直接相关。 对Javascript函数式编程的理解很重要，并且在相当长的一段时间会对各种水平的程序员很有用。</p>\n<p>为什么呢？函数式编程非常强大、健壮并且优雅。它对于大型数据结构非常有用并且高效。 Javascript作为一个客户端脚本语言，在应对日益复杂的网站时，函数式地操作DOM、 组织API响应以及完成一些其它任务会非常有好处。</p>\n<p>在这本书里，你将会学习用Javascript进行函数式编程所需要知道的一切：如何用函数式编程构建你的Javascript web应用， 如何解锁Javascript隐藏的力量，如何编写更强大的代码，并且由于程序更小，使得代码更容易维护，能够更快被下载， 并且花费更少的开支。你还会学到函数式编程的核心概念，以及如何将它们应用到Javascript， 还有将Javascript作为函数式语言时如何回避一些问题，如何在Javascript中混合使用函数式编程和面向对象编程。</p>\n<p>不过在我们开始前，先来做个实验。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>也许快速举个例子是介绍Javascript函数式编程最好的方式。我们将用Javascript完成一些任务—— 一个使用传统、原生的方法，另一个使用函数式编程。然后我们将会比较这两种方法。</p>\n<h3 id=\"应用–一个电子商务网站\"><a href=\"#应用–一个电子商务网站\" class=\"headerlink\" title=\"应用–一个电子商务网站\"></a>应用–一个电子商务网站</h3><p>为了追求真实感，我们来做一个电子商务网站，一个邮购咖啡豆的公司。这个网站会销售好几种类型的咖啡，有不同的品质，当然也有不同的价格。</p>\n<h3 id=\"命令式方法\"><a href=\"#命令式方法\" class=\"headerlink\" title=\"命令式方法\"></a>命令式方法</h3><p>首先，我们开始写程序。为了让这个例子更接地气，我们需要创建一些对象来保存数据。如果需要的话我们可以从数据库里取值。但是现在我们假设他们是静态定义的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//create some objects to store the data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> columbian = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'columbian'</span>,</span><br><span class=\"line\">    basePrice: <span class=\"number\">5</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> frenchRoast = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'french Roast'</span>,</span><br><span class=\"line\">    basePrice: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> decaf = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'decaf'</span>,</span><br><span class=\"line\">    basePrice: <span class=\"number\">6</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//我们将使用辅助函数计算价格</span></span><br><span class=\"line\"><span class=\"comment\">//根据size打印到一个HTML的列表中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printPrice</span>(<span class=\"params\">coffee,size</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size == <span class=\"string\">'small'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> price = coffee.basePrice + <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(size == <span class=\"string\">'medium'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> price = coffee.basePrice + <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> price = coffee.basePrice + <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//create the new html list item</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> label = coffee.name + <span class=\"string\">' '</span> + size;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> textnode = <span class=\"built_in\">document</span>.createTextNode(label+ <span class=\"string\">'price: $'</span>+ price);</span><br><span class=\"line\">    node.appendChild(textnode);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'products'</span>).appendChild(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//现在我们只需要根据咖啡的各种价格和size的组合调用printPrice函数</span></span><br><span class=\"line\">printPrice(columbian, <span class=\"string\">'small'</span>);</span><br><span class=\"line\">printPrice(columbian, <span class=\"string\">'medium'</span>);</span><br><span class=\"line\">printPrice(columbian, <span class=\"string\">'large'</span>);</span><br><span class=\"line\">printPrice(frenchRoast, <span class=\"string\">'small'</span>);</span><br><span class=\"line\">printPrice(frenchRoast, <span class=\"string\">'medium'</span>);</span><br><span class=\"line\">printPrice(frenchRoast, <span class=\"string\">'large'</span>);</span><br><span class=\"line\">printPrice(decaf, <span class=\"string\">'small'</span>);</span><br><span class=\"line\">printPrice(decaf, <span class=\"string\">'medium'</span>);</span><br><span class=\"line\">printPrice(decaf, <span class=\"string\">'large'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，这个代码非常基础。如果现在有更多的咖啡种类而不只是这三个改怎么办？如果有20个，甚至50个？ 如果有更多的size呢？如果有有机和无机之分呢？这将会很快将代码量变得巨大无比！</p>\n<p>采用这种方法，我们让机器去打印每一种咖啡类型和每一个size。这就是采用这种命令式方法的基本问题。</p>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><p>命令式的代码一步一步地告诉电脑需要做什么，相反，函数式编程追求用数学方式来描述问题，其余的交给电脑来做。<br>通过更函数式一些的方法，同样的应用可以这样来写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从接口中分解数据和逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> printPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">price,label</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> textnode = <span class=\"built_in\">document</span>.createTextNode(label+ <span class=\"string\">' price: $'</span>+ price);</span><br><span class=\"line\">    node.appendChild(textnode);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'products2'</span>).appendChild(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//为每种咖啡创建函数对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> columbian = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'colimbian'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> frenchRoast = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = <span class=\"string\">'french roast'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">8</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> decaf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = <span class=\"string\">'decaf'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//为每种size通过字面量创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> small = &#123;</span><br><span class=\"line\">    getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' small'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> medium = &#123;</span><br><span class=\"line\">  getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">4</span>&#125;,</span><br><span class=\"line\">  getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' medium'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> large = &#123;</span><br><span class=\"line\">  getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">  getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' large'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//将所有咖啡的种类和size放到数组里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeTypes = [columbian, frenchRoast, decaf];</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeSizes = [small, medium, large];</span><br><span class=\"line\"><span class=\"comment\">//创建由上面内容组成的新对象，并把它们放到一个新数组里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> coffee = coffeeTypes.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previous,current</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newCoffee = coffeeSizes.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mixin</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//`plusmix`是函数时的mixin</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> newCoffeeObj = plusMixin(current,mixin);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> newCoffeeObj();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous.concat(newCoffee);</span><br><span class=\"line\">&#125;,[]);</span><br><span class=\"line\"><span class=\"comment\">//现在我们已经定义了如何获得所有咖啡种类和size组合方式的价格，现在可以直接打印他们了</span></span><br><span class=\"line\">coffee.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coffee</span>)</span>&#123;</span><br><span class=\"line\">    printPrice(coffee.getPrice(),coffee.getLabel());</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>首先需要明确的是这个代码更加模块化了。现在新增一种size或者新增一个咖啡种类就像下面的代码这样简单：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> peruvian = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'peruvian'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">11</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> extraLarge = &#123;</span><br><span class=\"line\">    getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">    getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' extra large'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">coffeeTypes.push(peruvian);</span><br><span class=\"line\">coffeeSizes.push(extraLarge);</span><br></pre></td></tr></table></figure></p>\n<p>咖啡对象的数组和size对象的数组混合(mix)到了一起，也就是他们的方法和成员变量被组合到了一块–通过一个叫”plusMixin”的自定义函数。这些咖啡类型的类包含了成员变量，而这些size对象(small,medium,large)包含了获取名称和计算价格的方法。混合(mixing)这个动作通过一个map操作来起作用，也就是对数组中的每一个成员执行一个纯函数并返回一个新的函数， 然后这些返回的函数被放到了一个reduce函数中被操作，reduce也是一个高阶函数，和map有些像， 只是reduce把数组里的所有元素处理后组合到了一个东西里面。最终，新的数组包含了所有可能的种类和size的组合， 这个数组通过forEach方法遍历，forEach也是一个高阶函数，它会让数组里面每一个对象作为参数执行一遍回调函数。 在这个例子里，这个回调函数是一个匿名函数，它获取这些对象后，以对象的getPrice()和getLabel() 两个方法的返回值作为参数调用printPrice函数。</p>\n<p>实际上，我们可以让这个例子更加函数式：去掉coffees变量，并将函数串到一起链式调用，这也是函数式编程的一个小技巧。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coffeeTypes.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previous,current</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newCoffee = coffeeSizes.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mixin</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//`plusMixin`</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> newCoffeeObj = plusMixin(current,mixin);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> newCoffeeObj();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous.concat(newCoffee);</span><br><span class=\"line\">&#125;.[]).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coffee</span>)</span>&#123;</span><br><span class=\"line\">    printPrice(coffee.getPrice(),coffee.getLabel());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，控制流没有像命令是代码那样从头到尾的顺序进行。在函数式编程里，map函数和其他高阶函数代替了for和while循环，只有少量关键的代码是在顺序执行。这使得新接触的人在阅读这样范式的代码有些困难，但是一旦你能够欣赏它，你就会发现这根本没啥难的，而且这样写起来更好。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>首先，采用函数式风格的优点已经明确了。 其次，不要害怕函数式编程。的确，它往往被认为是编程语言的纯逻辑形式，但是我们不需要理解lambda演算也能够在日常任务中应用它。 实际上，通过把我们的程序拆分成小的片段，它们变得更容易被理解、维护，也更加可靠。 map和reduce函数是Javascript中不太被知道的内建函数，然而我们将要关注它们。</p>\n","excerpt":"","more":"<blockquote>\n<p>关于javascript函数式编程这一部分皆为转载外加自己的一些理解和实践。</p>\n</blockquote>\n<h2 id=\"Javascript函数式编程的力量\"><a href=\"#Javascript函数式编程的力量\" class=\"headerlink\" title=\"Javascript函数式编程的力量\"></a>Javascript函数式编程的力量</h2><p>几十年来，函数式编程一直是计算机科学狂热者的至爱，由于数学的纯洁性和谜一般的本质， 它被埋藏在计算机实验室，只有数据学家和有希望获得博士学位的人士使用。但是现在，它正经历一场复兴， 这要感谢一些现代语言比如Python，Julia，Ruby，Clojure以及——但不是最后一个——Javascript。</p>\n<p>你是说Javascript？这个WEB脚本语言？没错！</p>\n<p>Javascript已经被证明是一项长期以来都没有消失的重要的技术。这主要是由于它扩展的一些框架和库而使其具有重生的能力， 比如backbone.js，jQuery，Dojo，underscore.js等等。这与Javascript函数式编程语言的真实身份直接相关。 对Javascript函数式编程的理解很重要，并且在相当长的一段时间会对各种水平的程序员很有用。</p>\n<p>为什么呢？函数式编程非常强大、健壮并且优雅。它对于大型数据结构非常有用并且高效。 Javascript作为一个客户端脚本语言，在应对日益复杂的网站时，函数式地操作DOM、 组织API响应以及完成一些其它任务会非常有好处。</p>\n<p>在这本书里，你将会学习用Javascript进行函数式编程所需要知道的一切：如何用函数式编程构建你的Javascript web应用， 如何解锁Javascript隐藏的力量，如何编写更强大的代码，并且由于程序更小，使得代码更容易维护，能够更快被下载， 并且花费更少的开支。你还会学到函数式编程的核心概念，以及如何将它们应用到Javascript， 还有将Javascript作为函数式语言时如何回避一些问题，如何在Javascript中混合使用函数式编程和面向对象编程。</p>\n<p>不过在我们开始前，先来做个实验。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>也许快速举个例子是介绍Javascript函数式编程最好的方式。我们将用Javascript完成一些任务—— 一个使用传统、原生的方法，另一个使用函数式编程。然后我们将会比较这两种方法。</p>\n<h3 id=\"应用–一个电子商务网站\"><a href=\"#应用–一个电子商务网站\" class=\"headerlink\" title=\"应用–一个电子商务网站\"></a>应用–一个电子商务网站</h3><p>为了追求真实感，我们来做一个电子商务网站，一个邮购咖啡豆的公司。这个网站会销售好几种类型的咖啡，有不同的品质，当然也有不同的价格。</p>\n<h3 id=\"命令式方法\"><a href=\"#命令式方法\" class=\"headerlink\" title=\"命令式方法\"></a>命令式方法</h3><p>首先，我们开始写程序。为了让这个例子更接地气，我们需要创建一些对象来保存数据。如果需要的话我们可以从数据库里取值。但是现在我们假设他们是静态定义的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//create some objects to store the data</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> columbian = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'columbian'</span>,</span><br><span class=\"line\">    basePrice: <span class=\"number\">5</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> frenchRoast = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'french Roast'</span>,</span><br><span class=\"line\">    basePrice: <span class=\"number\">8</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> decaf = &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'decaf'</span>,</span><br><span class=\"line\">    basePrice: <span class=\"number\">6</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//我们将使用辅助函数计算价格</span></span><br><span class=\"line\"><span class=\"comment\">//根据size打印到一个HTML的列表中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printPrice</span>(<span class=\"params\">coffee,size</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(size == <span class=\"string\">'small'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> price = coffee.basePrice + <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(size == <span class=\"string\">'medium'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> price = coffee.basePrice + <span class=\"number\">4</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> price = coffee.basePrice + <span class=\"number\">6</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//create the new html list item</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> label = coffee.name + <span class=\"string\">' '</span> + size;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> textnode = <span class=\"built_in\">document</span>.createTextNode(label+ <span class=\"string\">'price: $'</span>+ price);</span><br><span class=\"line\">    node.appendChild(textnode);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'products'</span>).appendChild(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//现在我们只需要根据咖啡的各种价格和size的组合调用printPrice函数</span></span><br><span class=\"line\">printPrice(columbian, <span class=\"string\">'small'</span>);</span><br><span class=\"line\">printPrice(columbian, <span class=\"string\">'medium'</span>);</span><br><span class=\"line\">printPrice(columbian, <span class=\"string\">'large'</span>);</span><br><span class=\"line\">printPrice(frenchRoast, <span class=\"string\">'small'</span>);</span><br><span class=\"line\">printPrice(frenchRoast, <span class=\"string\">'medium'</span>);</span><br><span class=\"line\">printPrice(frenchRoast, <span class=\"string\">'large'</span>);</span><br><span class=\"line\">printPrice(decaf, <span class=\"string\">'small'</span>);</span><br><span class=\"line\">printPrice(decaf, <span class=\"string\">'medium'</span>);</span><br><span class=\"line\">printPrice(decaf, <span class=\"string\">'large'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，这个代码非常基础。如果现在有更多的咖啡种类而不只是这三个改怎么办？如果有20个，甚至50个？ 如果有更多的size呢？如果有有机和无机之分呢？这将会很快将代码量变得巨大无比！</p>\n<p>采用这种方法，我们让机器去打印每一种咖啡类型和每一个size。这就是采用这种命令式方法的基本问题。</p>\n<h3 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h3><p>命令式的代码一步一步地告诉电脑需要做什么，相反，函数式编程追求用数学方式来描述问题，其余的交给电脑来做。<br>通过更函数式一些的方法，同样的应用可以这样来写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从接口中分解数据和逻辑</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> printPrice = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">price,label</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> node = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> textnode = <span class=\"built_in\">document</span>.createTextNode(label+ <span class=\"string\">' price: $'</span>+ price);</span><br><span class=\"line\">    node.appendChild(textnode);</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'products2'</span>).appendChild(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//为每种咖啡创建函数对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> columbian = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'colimbian'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> frenchRoast = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = <span class=\"string\">'french roast'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">8</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> decaf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.name = <span class=\"string\">'decaf'</span>;</span><br><span class=\"line\"> <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//为每种size通过字面量创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> small = &#123;</span><br><span class=\"line\">    getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' small'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> medium = &#123;</span><br><span class=\"line\">  getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">4</span>&#125;,</span><br><span class=\"line\">  getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' medium'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> large = &#123;</span><br><span class=\"line\">  getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">  getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' large'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//将所有咖啡的种类和size放到数组里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeTypes = [columbian, frenchRoast, decaf];</span><br><span class=\"line\"><span class=\"keyword\">var</span> coffeeSizes = [small, medium, large];</span><br><span class=\"line\"><span class=\"comment\">//创建由上面内容组成的新对象，并把它们放到一个新数组里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> coffee = coffeeTypes.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previous,current</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newCoffee = coffeeSizes.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mixin</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//`plusmix`是函数时的mixin</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> newCoffeeObj = plusMixin(current,mixin);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> newCoffeeObj();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous.concat(newCoffee);</span><br><span class=\"line\">&#125;,[]);</span><br><span class=\"line\"><span class=\"comment\">//现在我们已经定义了如何获得所有咖啡种类和size组合方式的价格，现在可以直接打印他们了</span></span><br><span class=\"line\">coffee.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coffee</span>)</span>&#123;</span><br><span class=\"line\">    printPrice(coffee.getPrice(),coffee.getLabel());</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>首先需要明确的是这个代码更加模块化了。现在新增一种size或者新增一个咖啡种类就像下面的代码这样简单：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> peruvian = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'peruvian'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.basePrice = <span class=\"number\">11</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> extraLarge = &#123;</span><br><span class=\"line\">    getPrice: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.basePrice + <span class=\"number\">10</span>&#125;,</span><br><span class=\"line\">    getLabel: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">' extra large'</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">coffeeTypes.push(peruvian);</span><br><span class=\"line\">coffeeSizes.push(extraLarge);</span><br></pre></td></tr></table></figure></p>\n<p>咖啡对象的数组和size对象的数组混合(mix)到了一起，也就是他们的方法和成员变量被组合到了一块–通过一个叫”plusMixin”的自定义函数。这些咖啡类型的类包含了成员变量，而这些size对象(small,medium,large)包含了获取名称和计算价格的方法。混合(mixing)这个动作通过一个map操作来起作用，也就是对数组中的每一个成员执行一个纯函数并返回一个新的函数， 然后这些返回的函数被放到了一个reduce函数中被操作，reduce也是一个高阶函数，和map有些像， 只是reduce把数组里的所有元素处理后组合到了一个东西里面。最终，新的数组包含了所有可能的种类和size的组合， 这个数组通过forEach方法遍历，forEach也是一个高阶函数，它会让数组里面每一个对象作为参数执行一遍回调函数。 在这个例子里，这个回调函数是一个匿名函数，它获取这些对象后，以对象的getPrice()和getLabel() 两个方法的返回值作为参数调用printPrice函数。</p>\n<p>实际上，我们可以让这个例子更加函数式：去掉coffees变量，并将函数串到一起链式调用，这也是函数式编程的一个小技巧。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">coffeeTypes.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previous,current</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> newCoffee = coffeeSizes.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">mixin</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//`plusMixin`</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> newCoffeeObj = plusMixin(current,mixin);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> newCoffeeObj();</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previous.concat(newCoffee);</span><br><span class=\"line\">&#125;.[]).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">coffee</span>)</span>&#123;</span><br><span class=\"line\">    printPrice(coffee.getPrice(),coffee.getLabel());</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，控制流没有像命令是代码那样从头到尾的顺序进行。在函数式编程里，map函数和其他高阶函数代替了for和while循环，只有少量关键的代码是在顺序执行。这使得新接触的人在阅读这样范式的代码有些困难，但是一旦你能够欣赏它，你就会发现这根本没啥难的，而且这样写起来更好。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>首先，采用函数式风格的优点已经明确了。 其次，不要害怕函数式编程。的确，它往往被认为是编程语言的纯逻辑形式，但是我们不需要理解lambda演算也能够在日常任务中应用它。 实际上，通过把我们的程序拆分成小的片段，它们变得更容易被理解、维护，也更加可靠。 map和reduce函数是Javascript中不太被知道的内建函数，然而我们将要关注它们。</p>\n"},{"title":"animation-详解","date":"2016-04-04T08:22:51.000Z","_content":">A glamorous life is quite different to a life of luxury.\n\n## 简介 \nanimation属性是动画属性的简写，其中包括：\n- animation-name\n- animation-duration\n- animation-timing-function\n- animation-delay\n- animation-iteration-count\n- animation-direction\n- animation-fill-mode\n\n## 用法\nanimation可以定义多个动画属性，需要用逗号分隔。比如： \n```javascript\n/*一个animation定义的时候*/\nanimation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];\n/*多个animation定义的时候*/\nanimation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode],\n[animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];\n```\n其中简写的animation属性用空格分隔，而且他们之间的排序没什么影响，除了animation-duration和animation-delay，他们需要顺序。也就是说当你使用两个time参数的时候，第一个时间指的是animation-duration第二个时间指的是animation-delay。\n\n```javascript\nanimation: bounce 0.3s ease-in-out 1s infinite;\n/*equivalent to*/\nanimation-name: bounce;\nanimation-duration: 0.3s;\nanimation-timing-function: ease-in-out;\nanimation-delay: 1s;\nanimation-iteration-count: infinite;\n```\n\n## animation-play-state\nanimation-play-state属性决定CSS animation是运行还是暂停。\n```javascript\nanimation-play-state: running | paused\n```","source":"_posts/animation-详解.md","raw":"---\ntitle: animation-详解\ndate: 2016-04-04 16:22:51\ntags:\n- animation\n- css3\ncategories: 教程\n---\n>A glamorous life is quite different to a life of luxury.\n\n## 简介 \nanimation属性是动画属性的简写，其中包括：\n- animation-name\n- animation-duration\n- animation-timing-function\n- animation-delay\n- animation-iteration-count\n- animation-direction\n- animation-fill-mode\n\n## 用法\nanimation可以定义多个动画属性，需要用逗号分隔。比如： \n```javascript\n/*一个animation定义的时候*/\nanimation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];\n/*多个animation定义的时候*/\nanimation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode],\n[animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];\n```\n其中简写的animation属性用空格分隔，而且他们之间的排序没什么影响，除了animation-duration和animation-delay，他们需要顺序。也就是说当你使用两个time参数的时候，第一个时间指的是animation-duration第二个时间指的是animation-delay。\n\n```javascript\nanimation: bounce 0.3s ease-in-out 1s infinite;\n/*equivalent to*/\nanimation-name: bounce;\nanimation-duration: 0.3s;\nanimation-timing-function: ease-in-out;\nanimation-delay: 1s;\nanimation-iteration-count: infinite;\n```\n\n## animation-play-state\nanimation-play-state属性决定CSS animation是运行还是暂停。\n```javascript\nanimation-play-state: running | paused\n```","slug":"animation-详解","published":1,"updated":"2016-05-16T02:11:32.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0elw0006b0dl54fm7ryc","content":"<blockquote>\n<p>A glamorous life is quite different to a life of luxury.</p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>animation属性是动画属性的简写，其中包括：</p>\n<ul>\n<li>animation-name</li>\n<li>animation-duration</li>\n<li>animation-timing-function</li>\n<li>animation-delay</li>\n<li>animation-iteration-count</li>\n<li>animation-direction</li>\n<li>animation-fill-mode</li>\n</ul>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>animation可以定义多个动画属性，需要用逗号分隔。比如：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*一个animation定义的时候*/</span><br><span class=\"line\">animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];</span><br><span class=\"line\">/*多个animation定义的时候*/</span><br><span class=\"line\">animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode],</span><br><span class=\"line\">[animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];</span><br></pre></td></tr></table></figure></p>\n<p>其中简写的animation属性用空格分隔，而且他们之间的排序没什么影响，除了animation-duration和animation-delay，他们需要顺序。也就是说当你使用两个time参数的时候，第一个时间指的是animation-duration第二个时间指的是animation-delay。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation: bounce <span class=\"number\">0.3</span>s ease-<span class=\"keyword\">in</span>-out <span class=\"number\">1</span>s infinite;</span><br><span class=\"line\"><span class=\"comment\">/*equivalent to*/</span></span><br><span class=\"line\">animation-name: bounce;</span><br><span class=\"line\">animation-duration: <span class=\"number\">0.3</span>s;</span><br><span class=\"line\">animation-timing-<span class=\"function\"><span class=\"keyword\">function</span>: <span class=\"title\">ease</span>-<span class=\"title\">in</span>-<span class=\"title\">out</span>;</span><br><span class=\"line\"><span class=\"title\">animation</span>-<span class=\"title\">delay</span>: 1<span class=\"title\">s</span>;</span><br><span class=\"line\"><span class=\"title\">animation</span>-<span class=\"title\">iteration</span>-<span class=\"title\">count</span>: <span class=\"title\">infinite</span>;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"animation-play-state\"><a href=\"#animation-play-state\" class=\"headerlink\" title=\"animation-play-state\"></a>animation-play-state</h2><p>animation-play-state属性决定CSS animation是运行还是暂停。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation-play-state: running | paused</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>A glamorous life is quite different to a life of luxury.</p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>animation属性是动画属性的简写，其中包括：</p>\n<ul>\n<li>animation-name</li>\n<li>animation-duration</li>\n<li>animation-timing-function</li>\n<li>animation-delay</li>\n<li>animation-iteration-count</li>\n<li>animation-direction</li>\n<li>animation-fill-mode</li>\n</ul>\n<h2 id=\"用法\"><a href=\"#用法\" class=\"headerlink\" title=\"用法\"></a>用法</h2><p>animation可以定义多个动画属性，需要用逗号分隔。比如：<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*一个animation定义的时候*/</span><br><span class=\"line\">animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];</span><br><span class=\"line\">/*多个animation定义的时候*/</span><br><span class=\"line\">animation: [animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode],</span><br><span class=\"line\">[animation-name] [animation-duration] [animation-timing-function] [animation-delay] [animation-iteration-count] [animation-fill-mode];</span><br></pre></td></tr></table></figure></p>\n<p>其中简写的animation属性用空格分隔，而且他们之间的排序没什么影响，除了animation-duration和animation-delay，他们需要顺序。也就是说当你使用两个time参数的时候，第一个时间指的是animation-duration第二个时间指的是animation-delay。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation: bounce <span class=\"number\">0.3</span>s ease-<span class=\"keyword\">in</span>-out <span class=\"number\">1</span>s infinite;</span><br><span class=\"line\"><span class=\"comment\">/*equivalent to*/</span></span><br><span class=\"line\">animation-name: bounce;</span><br><span class=\"line\">animation-duration: <span class=\"number\">0.3</span>s;</span><br><span class=\"line\">animation-timing-<span class=\"function\"><span class=\"keyword\">function</span>: <span class=\"title\">ease</span>-<span class=\"title\">in</span>-<span class=\"title\">out</span>;</span><br><span class=\"line\"><span class=\"title\">animation</span>-<span class=\"title\">delay</span>: 1<span class=\"title\">s</span>;</span><br><span class=\"line\"><span class=\"title\">animation</span>-<span class=\"title\">iteration</span>-<span class=\"title\">count</span>: <span class=\"title\">infinite</span>;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"animation-play-state\"><a href=\"#animation-play-state\" class=\"headerlink\" title=\"animation-play-state\"></a>animation-play-state</h2><p>animation-play-state属性决定CSS animation是运行还是暂停。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation-play-state: running | paused</span><br></pre></td></tr></table></figure></p>\n"},{"title":"es6函数式编程","date":"2016-05-08T13:46:52.000Z","_content":">Intelligence without ambition is a bird without wings.\n\n## 什么是函数式编程\n函数式编程是一种编程范式，我们常见的编程范式有命令式编程，函数式编程和逻辑式编程，常见的面向对象编程也是一种命令式编程。函数式编程世界里，函数是一等公民。\n\n## 函数式编程给我带来的好处\n由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处是不可变性带来的。没有可变的状态，函数就是引用透明的和没有副作用。\n\n好处：函数既不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。\n\n1. 纯函数式\n\n> 什么是纯函数：相同的参数返回的结果相同，它的执行不依赖于系统的状态\n函数式编程的核心就是借助形式化数学来描述逻辑：lambda运算。数学家们喜欢将程序描述为数据的变换，这也引入了第一个概念：纯函数。纯函数无副作用，仅仅依赖于函数的输入，并且当输入相同时输出保持一致。  \n\n1) 非纯净的\n```javascript\n    let number = 1;\n    const increment = () => number + 1;\n    increment();\n```\n2) 纯净的\n```javascript\n    const increment = n => n+1;\n    increment(1);\n```\n\n2. 高阶函数\n函数把其他函数当做参数传递使用或者返回一个函数\n\n1) 加法\n```javascript\n    const sum = (x,y) => x+y;\n    const calculate = (fn,x,y) => fn(x,y);\n    calculate(sum,1,2);\n```\n\n2) filter\n```javascript\n    let students = [\n        {name: 'Tom', grade: 6},\n        {name: 'Tim', grade: 7},\n        {name: 'Bom', grade: 8}\n    ];\n    const isApproved = student => student.grade >=7;\n    students.filter(isApproved);\n```\n\n3) Map\n```javascript\n    const byName = obj => obj.name;\n    students.map(byName);\n```\n\n4) 链式\n```javascript\n    let students = [\n        {name: 'Tom', grade: 6},\n        {name: 'Tim', grade: 7},\n        {name: 'Bom', grade: 8}\n    ];\n    const isApproved = student => student.grade >= 6;\n    \n    const byName = obj => obj.name;\n    \n    students.filter(isApproved).map(byName);\n```\n\n5) Reduce\n```javascript\n    const totalGrades = students.reduce((sum,student) => sum + student.grade, 0);\n    totalGrades\n```\n\n3. 递归\n当一个函数调用它自己的时候就创造了一个循环\n\n1) 递减\n```javascript\n    const countdown = num => {\n        if(num > 0){\n            console.log(num);\n            countdown(num -1);\n        }\n    }\n    countdown(5);\n```\n\n2) 阶乘\n```javascript\n    const factorial = num => {\n        if(num <= 0){\n            return 1;\n        }else{\n            return (num * factorial(num - 1));\n        }\n    }\n    factorial(5);\n```\n\n4. Functor\n有map方法的对象。functor的map方法通过map回调函数调用自己的内容，然后返回一个新的functor.\n\n1) 给数组所有的元素添加一个值\n```javascript\n    const plus1 = num => num + 1;\n    let numbers = [1,2,3];\n    numbers.map(plus1);\n```\n\n5. 组合\n通过组合两个或更多的函数生成一个新的函数\n\n1) 组合两个函数生成一个新的函数\n```javascript\n    const compose = (f,g) => x => f(g(x));\n    const toUpperCase = x => x.toUpperCase();\n    const exclaim = x => `${x}!`;\n    \n    const angry = compose(exclaim,toUpperCase);\n    \n    angry(\"stop this\");\n```\n\n2) 组合三个函数生成一个新的\n```javascript\n    const compose = (f,g) => x => f(g(x));\n    \n    const toUpperCase = x => x.toUpperCase();\n    const exclaim = x => `${x}!`;\n    const moreExclaim = x => `${x}!!!!!`;\n    \n    const reallyAngry = compose(exclaim, compose(toUpperCase,moreExclaim));\n    \n    reallyAngry(\"stop this\");\n```\n\n6. 解构\n从数组中提取数据或对象使用一种语法混合数组和对象文本的建设。或“模式匹配”。\n1) Select from pattern\n\n```javascript\n    const foo = () => [1,2,3];\n    const [a,b] = foo();\n    console.log(a,b);\n```\n\n2) 接收rest值\n```javascript\n    const [a,...b] = [1,2,3];\n    console.log(a,b)\n```\n\n3) 可选参数\n```javascript\n    const ajax = ({ url = \"localhost\", port: p=80}, ...data) => console.log(\"Url:\", url, \"Port:\", p, \"Rest:\", data);\n    \n    ajax({ url: \"someHost\" }, \"additional\", \"data\", \"hello\");\n    // Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]\n    \n    ajax({ }, \"additional\", \"data\", \"hello\");\n    // Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]\n```\n\n7. 柯里化\n一个函数有多个参数，把每个参数通过链式的形式返回下一个函数，知道最后一个返回结果。\n\n1) 对象柯里化\n```javascript\n    const student = name => grade => `Name: ${name} | Grade: ${grade}`;\n    student(\"Matt\")(8);\n    // Name: Matt | Grade: 8\n```\n\n2) 加法函数柯里化\n```javascript\n    const add = x => y => x+y;\n    \n    const increment = add(1);\n    const addFive = add(5);\n    \n    increment(3);\n    //4\n    \n    addFive(10);\n    //15\n```\n\n\n\n\n\n\n","source":"_posts/es6函数式编程.md","raw":"---\ntitle: es6函数式编程\ndate: 2016-05-08 21:46:52\ntags:\n- javascript\n- es6\n- 函数式编程\ncategories: 教程\n---\n>Intelligence without ambition is a bird without wings.\n\n## 什么是函数式编程\n函数式编程是一种编程范式，我们常见的编程范式有命令式编程，函数式编程和逻辑式编程，常见的面向对象编程也是一种命令式编程。函数式编程世界里，函数是一等公民。\n\n## 函数式编程给我带来的好处\n由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处是不可变性带来的。没有可变的状态，函数就是引用透明的和没有副作用。\n\n好处：函数既不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。\n\n1. 纯函数式\n\n> 什么是纯函数：相同的参数返回的结果相同，它的执行不依赖于系统的状态\n函数式编程的核心就是借助形式化数学来描述逻辑：lambda运算。数学家们喜欢将程序描述为数据的变换，这也引入了第一个概念：纯函数。纯函数无副作用，仅仅依赖于函数的输入，并且当输入相同时输出保持一致。  \n\n1) 非纯净的\n```javascript\n    let number = 1;\n    const increment = () => number + 1;\n    increment();\n```\n2) 纯净的\n```javascript\n    const increment = n => n+1;\n    increment(1);\n```\n\n2. 高阶函数\n函数把其他函数当做参数传递使用或者返回一个函数\n\n1) 加法\n```javascript\n    const sum = (x,y) => x+y;\n    const calculate = (fn,x,y) => fn(x,y);\n    calculate(sum,1,2);\n```\n\n2) filter\n```javascript\n    let students = [\n        {name: 'Tom', grade: 6},\n        {name: 'Tim', grade: 7},\n        {name: 'Bom', grade: 8}\n    ];\n    const isApproved = student => student.grade >=7;\n    students.filter(isApproved);\n```\n\n3) Map\n```javascript\n    const byName = obj => obj.name;\n    students.map(byName);\n```\n\n4) 链式\n```javascript\n    let students = [\n        {name: 'Tom', grade: 6},\n        {name: 'Tim', grade: 7},\n        {name: 'Bom', grade: 8}\n    ];\n    const isApproved = student => student.grade >= 6;\n    \n    const byName = obj => obj.name;\n    \n    students.filter(isApproved).map(byName);\n```\n\n5) Reduce\n```javascript\n    const totalGrades = students.reduce((sum,student) => sum + student.grade, 0);\n    totalGrades\n```\n\n3. 递归\n当一个函数调用它自己的时候就创造了一个循环\n\n1) 递减\n```javascript\n    const countdown = num => {\n        if(num > 0){\n            console.log(num);\n            countdown(num -1);\n        }\n    }\n    countdown(5);\n```\n\n2) 阶乘\n```javascript\n    const factorial = num => {\n        if(num <= 0){\n            return 1;\n        }else{\n            return (num * factorial(num - 1));\n        }\n    }\n    factorial(5);\n```\n\n4. Functor\n有map方法的对象。functor的map方法通过map回调函数调用自己的内容，然后返回一个新的functor.\n\n1) 给数组所有的元素添加一个值\n```javascript\n    const plus1 = num => num + 1;\n    let numbers = [1,2,3];\n    numbers.map(plus1);\n```\n\n5. 组合\n通过组合两个或更多的函数生成一个新的函数\n\n1) 组合两个函数生成一个新的函数\n```javascript\n    const compose = (f,g) => x => f(g(x));\n    const toUpperCase = x => x.toUpperCase();\n    const exclaim = x => `${x}!`;\n    \n    const angry = compose(exclaim,toUpperCase);\n    \n    angry(\"stop this\");\n```\n\n2) 组合三个函数生成一个新的\n```javascript\n    const compose = (f,g) => x => f(g(x));\n    \n    const toUpperCase = x => x.toUpperCase();\n    const exclaim = x => `${x}!`;\n    const moreExclaim = x => `${x}!!!!!`;\n    \n    const reallyAngry = compose(exclaim, compose(toUpperCase,moreExclaim));\n    \n    reallyAngry(\"stop this\");\n```\n\n6. 解构\n从数组中提取数据或对象使用一种语法混合数组和对象文本的建设。或“模式匹配”。\n1) Select from pattern\n\n```javascript\n    const foo = () => [1,2,3];\n    const [a,b] = foo();\n    console.log(a,b);\n```\n\n2) 接收rest值\n```javascript\n    const [a,...b] = [1,2,3];\n    console.log(a,b)\n```\n\n3) 可选参数\n```javascript\n    const ajax = ({ url = \"localhost\", port: p=80}, ...data) => console.log(\"Url:\", url, \"Port:\", p, \"Rest:\", data);\n    \n    ajax({ url: \"someHost\" }, \"additional\", \"data\", \"hello\");\n    // Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]\n    \n    ajax({ }, \"additional\", \"data\", \"hello\");\n    // Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]\n```\n\n7. 柯里化\n一个函数有多个参数，把每个参数通过链式的形式返回下一个函数，知道最后一个返回结果。\n\n1) 对象柯里化\n```javascript\n    const student = name => grade => `Name: ${name} | Grade: ${grade}`;\n    student(\"Matt\")(8);\n    // Name: Matt | Grade: 8\n```\n\n2) 加法函数柯里化\n```javascript\n    const add = x => y => x+y;\n    \n    const increment = add(1);\n    const addFive = add(5);\n    \n    increment(3);\n    //4\n    \n    addFive(10);\n    //15\n```\n\n\n\n\n\n\n","slug":"es6函数式编程","published":1,"updated":"2016-05-18T01:27:32.761Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0em00008b0dl1216gtgb","content":"<blockquote>\n<p>Intelligence without ambition is a bird without wings.</p>\n</blockquote>\n<h2 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h2><p>函数式编程是一种编程范式，我们常见的编程范式有命令式编程，函数式编程和逻辑式编程，常见的面向对象编程也是一种命令式编程。函数式编程世界里，函数是一等公民。</p>\n<h2 id=\"函数式编程给我带来的好处\"><a href=\"#函数式编程给我带来的好处\" class=\"headerlink\" title=\"函数式编程给我带来的好处\"></a>函数式编程给我带来的好处</h2><p>由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处是不可变性带来的。没有可变的状态，函数就是引用透明的和没有副作用。</p>\n<p>好处：函数既不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p>\n<ol>\n<li>纯函数式</li>\n</ol>\n<blockquote>\n<p>什么是纯函数：相同的参数返回的结果相同，它的执行不依赖于系统的状态<br>函数式编程的核心就是借助形式化数学来描述逻辑：lambda运算。数学家们喜欢将程序描述为数据的变换，这也引入了第一个概念：纯函数。纯函数无副作用，仅仅依赖于函数的输入，并且当输入相同时输出保持一致。  </p>\n</blockquote>\n<p>1) 非纯净的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> increment = () =&gt; number + <span class=\"number\">1</span>;</span><br><span class=\"line\">increment();</span><br></pre></td></tr></table></figure></p>\n<p>2) 纯净的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> increment = n =&gt; n+<span class=\"number\">1</span>;</span><br><span class=\"line\">increment(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>高阶函数<br>函数把其他函数当做参数传递使用或者返回一个函数</li>\n</ol>\n<p>1) 加法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sum = (x,y) =&gt; x+y;</span><br><span class=\"line\"><span class=\"keyword\">const</span> calculate = (fn,x,y) =&gt; fn(x,y);</span><br><span class=\"line\">calculate(sum,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2) filter<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> students = [</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tom'</span>, grade: <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tim'</span>, grade: <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Bom'</span>, grade: <span class=\"number\">8</span>&#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> isApproved = student =&gt; student.grade &gt;=<span class=\"number\">7</span>;</span><br><span class=\"line\">students.filter(isApproved);</span><br></pre></td></tr></table></figure></p>\n<p>3) Map<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> byName = obj =&gt; obj.name;</span><br><span class=\"line\">students.map(byName);</span><br></pre></td></tr></table></figure></p>\n<p>4) 链式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> students = [</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tom'</span>, grade: <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tim'</span>, grade: <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Bom'</span>, grade: <span class=\"number\">8</span>&#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> isApproved = student =&gt; student.grade &gt;= <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> byName = obj =&gt; obj.name;</span><br><span class=\"line\"></span><br><span class=\"line\">students.filter(isApproved).map(byName);</span><br></pre></td></tr></table></figure></p>\n<p>5) Reduce<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> totalGrades = students.reduce((sum,student) =&gt; sum + student.grade, <span class=\"number\">0</span>);</span><br><span class=\"line\">totalGrades</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>递归<br>当一个函数调用它自己的时候就创造了一个循环</li>\n</ol>\n<p>1) 递减<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> countdown = num =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">        countdown(num <span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">countdown(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2) 阶乘<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> factorial = num =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (num * factorial(num - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Functor<br>有map方法的对象。functor的map方法通过map回调函数调用自己的内容，然后返回一个新的functor.</li>\n</ol>\n<p>1) 给数组所有的元素添加一个值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus1 = num =&gt; num + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">numbers.map(plus1);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>组合<br>通过组合两个或更多的函数生成一个新的函数</li>\n</ol>\n<p>1) 组合两个函数生成一个新的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (f,g) =&gt; x =&gt; f(g(x));</span><br><span class=\"line\"><span class=\"keyword\">const</span> toUpperCase = x =&gt; x.toUpperCase();</span><br><span class=\"line\"><span class=\"keyword\">const</span> exclaim = x =&gt; <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>!`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> angry = compose(exclaim,toUpperCase);</span><br><span class=\"line\"></span><br><span class=\"line\">angry(<span class=\"string\">\"stop this\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2) 组合三个函数生成一个新的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (f,g) =&gt; x =&gt; f(g(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> toUpperCase = x =&gt; x.toUpperCase();</span><br><span class=\"line\"><span class=\"keyword\">const</span> exclaim = x =&gt; <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>!`</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> moreExclaim = x =&gt; <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>!!!!!`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reallyAngry = compose(exclaim, compose(toUpperCase,moreExclaim));</span><br><span class=\"line\"></span><br><span class=\"line\">reallyAngry(<span class=\"string\">\"stop this\"</span>);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>解构<br>从数组中提取数据或对象使用一种语法混合数组和对象文本的建设。或“模式匹配”。<br>1) Select from pattern</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = () =&gt; [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> [a,b] = foo();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b);</span><br></pre></td></tr></table></figure>\n<p>2) 接收rest值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a,...b] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b)</span><br></pre></td></tr></table></figure></p>\n<p>3) 可选参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax = (&#123; url = <span class=\"string\">\"localhost\"</span>, port: p=<span class=\"number\">80</span>&#125;, ...data) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Url:\"</span>, url, <span class=\"string\">\"Port:\"</span>, p, <span class=\"string\">\"Rest:\"</span>, data);</span><br><span class=\"line\"></span><br><span class=\"line\">ajax(&#123; url: <span class=\"string\">\"someHost\"</span> &#125;, <span class=\"string\">\"additional\"</span>, <span class=\"string\">\"data\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">ajax(&#123; &#125;, <span class=\"string\">\"additional\"</span>, <span class=\"string\">\"data\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>柯里化<br>一个函数有多个参数，把每个参数通过链式的形式返回下一个函数，知道最后一个返回结果。</li>\n</ol>\n<p>1) 对象柯里化<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = name =&gt; grade =&gt; <span class=\"string\">`Name: <span class=\"subst\">$&#123;name&#125;</span> | Grade: <span class=\"subst\">$&#123;grade&#125;</span>`</span>;</span><br><span class=\"line\">student(<span class=\"string\">\"Matt\"</span>)(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// Name: Matt | Grade: 8</span></span><br></pre></td></tr></table></figure></p>\n<p>2) 加法函数柯里化<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = x =&gt; y =&gt; x+y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> increment = add(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> addFive = add(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\">addFive(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">//15</span></span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>Intelligence without ambition is a bird without wings.</p>\n</blockquote>\n<h2 id=\"什么是函数式编程\"><a href=\"#什么是函数式编程\" class=\"headerlink\" title=\"什么是函数式编程\"></a>什么是函数式编程</h2><p>函数式编程是一种编程范式，我们常见的编程范式有命令式编程，函数式编程和逻辑式编程，常见的面向对象编程也是一种命令式编程。函数式编程世界里，函数是一等公民。</p>\n<h2 id=\"函数式编程给我带来的好处\"><a href=\"#函数式编程给我带来的好处\" class=\"headerlink\" title=\"函数式编程给我带来的好处\"></a>函数式编程给我带来的好处</h2><p>由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处是不可变性带来的。没有可变的状态，函数就是引用透明的和没有副作用。</p>\n<p>好处：函数既不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。</p>\n<ol>\n<li>纯函数式</li>\n</ol>\n<blockquote>\n<p>什么是纯函数：相同的参数返回的结果相同，它的执行不依赖于系统的状态<br>函数式编程的核心就是借助形式化数学来描述逻辑：lambda运算。数学家们喜欢将程序描述为数据的变换，这也引入了第一个概念：纯函数。纯函数无副作用，仅仅依赖于函数的输入，并且当输入相同时输出保持一致。  </p>\n</blockquote>\n<p>1) 非纯净的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> number = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> increment = () =&gt; number + <span class=\"number\">1</span>;</span><br><span class=\"line\">increment();</span><br></pre></td></tr></table></figure></p>\n<p>2) 纯净的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> increment = n =&gt; n+<span class=\"number\">1</span>;</span><br><span class=\"line\">increment(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>高阶函数<br>函数把其他函数当做参数传递使用或者返回一个函数</li>\n</ol>\n<p>1) 加法<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sum = (x,y) =&gt; x+y;</span><br><span class=\"line\"><span class=\"keyword\">const</span> calculate = (fn,x,y) =&gt; fn(x,y);</span><br><span class=\"line\">calculate(sum,<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2) filter<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> students = [</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tom'</span>, grade: <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tim'</span>, grade: <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Bom'</span>, grade: <span class=\"number\">8</span>&#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> isApproved = student =&gt; student.grade &gt;=<span class=\"number\">7</span>;</span><br><span class=\"line\">students.filter(isApproved);</span><br></pre></td></tr></table></figure></p>\n<p>3) Map<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> byName = obj =&gt; obj.name;</span><br><span class=\"line\">students.map(byName);</span><br></pre></td></tr></table></figure></p>\n<p>4) 链式<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> students = [</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tom'</span>, grade: <span class=\"number\">6</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Tim'</span>, grade: <span class=\"number\">7</span>&#125;,</span><br><span class=\"line\">    &#123;name: <span class=\"string\">'Bom'</span>, grade: <span class=\"number\">8</span>&#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">const</span> isApproved = student =&gt; student.grade &gt;= <span class=\"number\">6</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> byName = obj =&gt; obj.name;</span><br><span class=\"line\"></span><br><span class=\"line\">students.filter(isApproved).map(byName);</span><br></pre></td></tr></table></figure></p>\n<p>5) Reduce<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> totalGrades = students.reduce((sum,student) =&gt; sum + student.grade, <span class=\"number\">0</span>);</span><br><span class=\"line\">totalGrades</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>递归<br>当一个函数调用它自己的时候就创造了一个循环</li>\n</ol>\n<p>1) 递减<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> countdown = num =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(num);</span><br><span class=\"line\">        countdown(num <span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">countdown(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2) 阶乘<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> factorial = num =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(num &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (num * factorial(num - <span class=\"number\">1</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">factorial(<span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>Functor<br>有map方法的对象。functor的map方法通过map回调函数调用自己的内容，然后返回一个新的functor.</li>\n</ol>\n<p>1) 给数组所有的元素添加一个值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus1 = num =&gt; num + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> numbers = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">numbers.map(plus1);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>组合<br>通过组合两个或更多的函数生成一个新的函数</li>\n</ol>\n<p>1) 组合两个函数生成一个新的函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (f,g) =&gt; x =&gt; f(g(x));</span><br><span class=\"line\"><span class=\"keyword\">const</span> toUpperCase = x =&gt; x.toUpperCase();</span><br><span class=\"line\"><span class=\"keyword\">const</span> exclaim = x =&gt; <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>!`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> angry = compose(exclaim,toUpperCase);</span><br><span class=\"line\"></span><br><span class=\"line\">angry(<span class=\"string\">\"stop this\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>2) 组合三个函数生成一个新的<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = (f,g) =&gt; x =&gt; f(g(x));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> toUpperCase = x =&gt; x.toUpperCase();</span><br><span class=\"line\"><span class=\"keyword\">const</span> exclaim = x =&gt; <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>!`</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> moreExclaim = x =&gt; <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>!!!!!`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reallyAngry = compose(exclaim, compose(toUpperCase,moreExclaim));</span><br><span class=\"line\"></span><br><span class=\"line\">reallyAngry(<span class=\"string\">\"stop this\"</span>);</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>解构<br>从数组中提取数据或对象使用一种语法混合数组和对象文本的建设。或“模式匹配”。<br>1) Select from pattern</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = () =&gt; [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> [a,b] = foo();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b);</span><br></pre></td></tr></table></figure>\n<p>2) 接收rest值<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a,...b] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b)</span><br></pre></td></tr></table></figure></p>\n<p>3) 可选参数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax = (&#123; url = <span class=\"string\">\"localhost\"</span>, port: p=<span class=\"number\">80</span>&#125;, ...data) =&gt; <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Url:\"</span>, url, <span class=\"string\">\"Port:\"</span>, p, <span class=\"string\">\"Rest:\"</span>, data);</span><br><span class=\"line\"></span><br><span class=\"line\">ajax(&#123; url: <span class=\"string\">\"someHost\"</span> &#125;, <span class=\"string\">\"additional\"</span>, <span class=\"string\">\"data\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Url: someHost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\">ajax(&#123; &#125;, <span class=\"string\">\"additional\"</span>, <span class=\"string\">\"data\"</span>, <span class=\"string\">\"hello\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// Url: localhost Port: 80 Rest: [ 'additional', 'data', 'hello' ]</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>柯里化<br>一个函数有多个参数，把每个参数通过链式的形式返回下一个函数，知道最后一个返回结果。</li>\n</ol>\n<p>1) 对象柯里化<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> student = name =&gt; grade =&gt; <span class=\"string\">`Name: <span class=\"subst\">$&#123;name&#125;</span> | Grade: <span class=\"subst\">$&#123;grade&#125;</span>`</span>;</span><br><span class=\"line\">student(<span class=\"string\">\"Matt\"</span>)(<span class=\"number\">8</span>);</span><br><span class=\"line\"><span class=\"comment\">// Name: Matt | Grade: 8</span></span><br></pre></td></tr></table></figure></p>\n<p>2) 加法函数柯里化<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = x =&gt; y =&gt; x+y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> increment = add(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> addFive = add(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">increment(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">//4</span></span><br><span class=\"line\"></span><br><span class=\"line\">addFive(<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"comment\">//15</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"JSON.stringify--JSON.parse","date":"2016-06-23T07:54:07.000Z","_content":"> When things go wrong, don't go with them.\n\n## JSON.stringify()概述\nJSON.stringify()方法可以将任意的javascript值序列化成JSON字符串。\n`JSON.stringify(value[, replacer [, space]])`\n\n### 参数\nvalue -- 将要序列化成JSON字符串的值。\nreplacer -- (可选)如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中。\nspace -- (可选)指定缩进用的空白字符，用于美化输出(pretty-print)。\n\n### 描述\n关于序列化，有下面五点注意事项：\n - 非数组对象的属性不能保证以特定的顺序出现序列化后的字符串中。\n - 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。\n - undefined、任意的函数以及symbol值，在序列化过程中会被忽略(出现在非数组对象的属性值中时)或者被转换成null(出现在数组中时)。\n - 所有以symbol为属性键的属性都会被完全忽略掉，即便replacer参数中强制指定包含了它们。\n - 不可枚举的属性会被忽略。\n\n```javascript\n  JSON.stringify({});   //'{}'\n  JSON.stringify(true);   //'true'\n  JSON.stringify(\"foo\");   //'\"foo\"'\n  JSON.stringify([1, \"false\", false]);   //'[1, \"false\", false]'\n  JSON.stringify({x:5});    //'{\"x\":5}'\n\n  JSON.stringify({x: 5, y: 6});              \n  // '{\"x\":5,\"y\":6}' 或者 '{\"y\":6,\"x\":5}' 都可能\n  JSON.stringify([new Number(1), new String(\"false\"), new Boolean(false)]);\n  // '[1,\"false\",false]'\n  JSON.stringify({x: undefined, y: Object, z: Symbol(\"\")});\n  // '{}'\n  JSON.stringify([undefined, Object, Symbol(\"\")]);          \n  // '[null,null,null]'\n  JSON.stringify({[Symbol(\"foo\")]: \"foo\"});                 \n  // '{}'\n  JSON.stringify({[Symbol.for(\"foo\")]: \"foo\"}, [Symbol.for(\"foo\")]);\n  // '{}'\n  JSON.stringify({[Symbol.for(\"foo\")]: \"foo\"}, function (k, v) {\n    if (typeof k === \"symbol\"){\n      return \"a symbol\";\n    }\n  });\n\n  // '{}'  \n\n  // 不可枚举的属性默认会被忽略：\n  JSON.stringify( Object.create(null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true } }) );\n  // '{\"y\":\"y\"}'\n```\n\n### space参数\nspace参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格(最多10个空格);如果是一个字符串，则每一级别会比上一级别多缩进用该字符串(或该字符串的前十个字符)。\n```javascript\n  JSON.stringify({a: 2}, null, ' ');    //'{\\n\"a\": 2\\n}'\n```\n\n使用制表符(\\t)来缩进\n```javascript\n  JSON.stringify({uno: 1, doc: 2}, null, '\\t');\n  // '{            \\\n  //     \"uno\": 1, \\\n  //     \"dos\": 2  \\\n  // }'\n```\n\n### toJSON方法\n如果一个被序列化的对象拥有toJSON方法，那么该toJSON方法就会覆盖该对象默认的序列化行为：不是按个对象被序列化，而是调用toJSON方法后的返回值会被序列化，例如：\n```javascript\n  var obj = {\n    foo: 'foo',\n    toJSON: function(){\n      return 'bar';\n    }\n  };\n\n  JSON.stringify(obj);  //'\"bar\"'\n  JSON.stringify({x: obj});  //'{\"x\": \"bar\"}'\n```\n\n### 使用JSON.stringify结合localStorage的例子\n一些时候，你想存储用户创建的一个对象，并且即使在浏览器被关闭后仍能恢复该对象。下面的例子是JSON.stringify适用于这种情形的一个样板：\n```javascript\n  //创建一个示例数据\n  var session = {\n    'screens': [],\n    'state': true\n  };\n  session.screens.push({\"name\":\"screenA\", \"width\":450, \"height\":250});\n  session.screens.push({\"name\":\"screenB\", \"width\":650, \"height\":350});\n  session.screens.push({\"name\":\"screenC\", \"width\":750, \"height\":120});\n  session.screens.push({\"name\":\"screenD\", \"width\":250, \"height\":60});\n  session.screens.push({\"name\":\"screenE\", \"width\":390, \"height\":120});\n  session.screens.push({\"name\":\"screenF\", \"width\":1240, \"height\":650});\n\n  //使用JSON.stringify转换为JSON字符串\n  //然后使用localStorage保存在session名称里\n  localStorage.setItem('session', JSON.stringify(session));\n\n  //然后是如何转换通过JSON.stringify生成的字符串，该字符串以JSON格式保存在localStorage里\n  var restoreSession = JSON.parse(localStorage.getItem('session'));\n\n  //现在restoreSession 包含了保存在localStorage里的对象\n  console.log(restoreSession);\n```\n\n## JSON.parse()概述\nJSON.parse()方法可以将一个JSON字符串解析成为一个javascript值。在解析过程中，还可以选择性的修改某些属性的原始解析值。\n`JSON.parse(text[, reviver])`\n\n### 参数\ntext -- 要解析的JSON字符串\nreviver -- 一个函数，用来转换解析出的属性值\n\n### 返回值\n从text字符串解析出的一个Object\n\n### 异常\n如果解析的JSON字符串包含语法错误，则会抛出SyntaxError异常。\n\n## 示例\n### 使用JSON.parse()\n```javascript\n  JSON.parse('{}');              // {}\n  JSON.parse('true');            // true\n  JSON.parse('\"foo\"');           // \"foo\"\n  JSON.parse('[1, 5, \"false\"]'); // [1, 5, \"false\"]\n  JSON.parse('null');            // null\n```\n\n### 使用reviver函数\n如果指定了reviver函数，则解析出的javascript值(解析值)会经过一次转换后才将被最终返回(返回值)。更具体点就是：解析值本身以及它所包含的所有属性，会按照一定的顺序(从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身)分别的去调用reviver函数，在调用过程中，当前属性所属的对象回作为this值，当前属性名和属性值会分别作为第一个和第二个参数传入reviver中。如果reviver返回undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。\n\n当遍历到最顶层的值(解析值)时，传入reviver函数的参数会是空字符串\"\"(因为此时已经没有真正的属性)和当前的解析值(有可能已经被修改过)，当前的this值会是{\"\":修改过得解析值}，在编写reviver函数时，要注意到这个特例。\n\n```javascript\n  JSON.parse('{\"p\":5}', function(k,v){\n    if(k === '') return v;  // 如果到了最顶层，则直接返回属性值，\n    return v*2;             // 否则将属性值变为原来的 2 倍。\n  })                        // { p: 10 }\n\n  JSON.parse('{\"1\": 1, \"2\": 2,\"3\": {\"4\": 4, \"5\": {\"6\": 6}}}', function (k, v) {\n    console.log(k); // 输出当前的属性名，从而得知遍历顺序是从内向外的，\n                    // 最后一个属性名会是个空字符串。\n    return v;       // 返回原始属性值，相当于没有传递 reviver 参数。\n  });\n\n  // 1\n  // 2\n  // 4\n  // 6\n  // 5\n  // 3\n  // \"\"\n```\n\n### JSON.parse()不允许用逗号作为结尾\n```javascript\n  //both will throw a SyntaxError\n  JSON.parse(\"[1,2,3,4, ]\");\n  JSON.parse('{\"foo\":1, }');\n```\n","source":"_posts/JSON-stringify-JSON-parse.md","raw":"---\ntitle: JSON.stringify--JSON.parse\ndate: 2016-06-23 15:54:07\ntags:\n- javascript\n- JSON\ncategories: 笔记\n---\n> When things go wrong, don't go with them.\n\n## JSON.stringify()概述\nJSON.stringify()方法可以将任意的javascript值序列化成JSON字符串。\n`JSON.stringify(value[, replacer [, space]])`\n\n### 参数\nvalue -- 将要序列化成JSON字符串的值。\nreplacer -- (可选)如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中。\nspace -- (可选)指定缩进用的空白字符，用于美化输出(pretty-print)。\n\n### 描述\n关于序列化，有下面五点注意事项：\n - 非数组对象的属性不能保证以特定的顺序出现序列化后的字符串中。\n - 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。\n - undefined、任意的函数以及symbol值，在序列化过程中会被忽略(出现在非数组对象的属性值中时)或者被转换成null(出现在数组中时)。\n - 所有以symbol为属性键的属性都会被完全忽略掉，即便replacer参数中强制指定包含了它们。\n - 不可枚举的属性会被忽略。\n\n```javascript\n  JSON.stringify({});   //'{}'\n  JSON.stringify(true);   //'true'\n  JSON.stringify(\"foo\");   //'\"foo\"'\n  JSON.stringify([1, \"false\", false]);   //'[1, \"false\", false]'\n  JSON.stringify({x:5});    //'{\"x\":5}'\n\n  JSON.stringify({x: 5, y: 6});              \n  // '{\"x\":5,\"y\":6}' 或者 '{\"y\":6,\"x\":5}' 都可能\n  JSON.stringify([new Number(1), new String(\"false\"), new Boolean(false)]);\n  // '[1,\"false\",false]'\n  JSON.stringify({x: undefined, y: Object, z: Symbol(\"\")});\n  // '{}'\n  JSON.stringify([undefined, Object, Symbol(\"\")]);          \n  // '[null,null,null]'\n  JSON.stringify({[Symbol(\"foo\")]: \"foo\"});                 \n  // '{}'\n  JSON.stringify({[Symbol.for(\"foo\")]: \"foo\"}, [Symbol.for(\"foo\")]);\n  // '{}'\n  JSON.stringify({[Symbol.for(\"foo\")]: \"foo\"}, function (k, v) {\n    if (typeof k === \"symbol\"){\n      return \"a symbol\";\n    }\n  });\n\n  // '{}'  \n\n  // 不可枚举的属性默认会被忽略：\n  JSON.stringify( Object.create(null, { x: { value: 'x', enumerable: false }, y: { value: 'y', enumerable: true } }) );\n  // '{\"y\":\"y\"}'\n```\n\n### space参数\nspace参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格(最多10个空格);如果是一个字符串，则每一级别会比上一级别多缩进用该字符串(或该字符串的前十个字符)。\n```javascript\n  JSON.stringify({a: 2}, null, ' ');    //'{\\n\"a\": 2\\n}'\n```\n\n使用制表符(\\t)来缩进\n```javascript\n  JSON.stringify({uno: 1, doc: 2}, null, '\\t');\n  // '{            \\\n  //     \"uno\": 1, \\\n  //     \"dos\": 2  \\\n  // }'\n```\n\n### toJSON方法\n如果一个被序列化的对象拥有toJSON方法，那么该toJSON方法就会覆盖该对象默认的序列化行为：不是按个对象被序列化，而是调用toJSON方法后的返回值会被序列化，例如：\n```javascript\n  var obj = {\n    foo: 'foo',\n    toJSON: function(){\n      return 'bar';\n    }\n  };\n\n  JSON.stringify(obj);  //'\"bar\"'\n  JSON.stringify({x: obj});  //'{\"x\": \"bar\"}'\n```\n\n### 使用JSON.stringify结合localStorage的例子\n一些时候，你想存储用户创建的一个对象，并且即使在浏览器被关闭后仍能恢复该对象。下面的例子是JSON.stringify适用于这种情形的一个样板：\n```javascript\n  //创建一个示例数据\n  var session = {\n    'screens': [],\n    'state': true\n  };\n  session.screens.push({\"name\":\"screenA\", \"width\":450, \"height\":250});\n  session.screens.push({\"name\":\"screenB\", \"width\":650, \"height\":350});\n  session.screens.push({\"name\":\"screenC\", \"width\":750, \"height\":120});\n  session.screens.push({\"name\":\"screenD\", \"width\":250, \"height\":60});\n  session.screens.push({\"name\":\"screenE\", \"width\":390, \"height\":120});\n  session.screens.push({\"name\":\"screenF\", \"width\":1240, \"height\":650});\n\n  //使用JSON.stringify转换为JSON字符串\n  //然后使用localStorage保存在session名称里\n  localStorage.setItem('session', JSON.stringify(session));\n\n  //然后是如何转换通过JSON.stringify生成的字符串，该字符串以JSON格式保存在localStorage里\n  var restoreSession = JSON.parse(localStorage.getItem('session'));\n\n  //现在restoreSession 包含了保存在localStorage里的对象\n  console.log(restoreSession);\n```\n\n## JSON.parse()概述\nJSON.parse()方法可以将一个JSON字符串解析成为一个javascript值。在解析过程中，还可以选择性的修改某些属性的原始解析值。\n`JSON.parse(text[, reviver])`\n\n### 参数\ntext -- 要解析的JSON字符串\nreviver -- 一个函数，用来转换解析出的属性值\n\n### 返回值\n从text字符串解析出的一个Object\n\n### 异常\n如果解析的JSON字符串包含语法错误，则会抛出SyntaxError异常。\n\n## 示例\n### 使用JSON.parse()\n```javascript\n  JSON.parse('{}');              // {}\n  JSON.parse('true');            // true\n  JSON.parse('\"foo\"');           // \"foo\"\n  JSON.parse('[1, 5, \"false\"]'); // [1, 5, \"false\"]\n  JSON.parse('null');            // null\n```\n\n### 使用reviver函数\n如果指定了reviver函数，则解析出的javascript值(解析值)会经过一次转换后才将被最终返回(返回值)。更具体点就是：解析值本身以及它所包含的所有属性，会按照一定的顺序(从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身)分别的去调用reviver函数，在调用过程中，当前属性所属的对象回作为this值，当前属性名和属性值会分别作为第一个和第二个参数传入reviver中。如果reviver返回undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。\n\n当遍历到最顶层的值(解析值)时，传入reviver函数的参数会是空字符串\"\"(因为此时已经没有真正的属性)和当前的解析值(有可能已经被修改过)，当前的this值会是{\"\":修改过得解析值}，在编写reviver函数时，要注意到这个特例。\n\n```javascript\n  JSON.parse('{\"p\":5}', function(k,v){\n    if(k === '') return v;  // 如果到了最顶层，则直接返回属性值，\n    return v*2;             // 否则将属性值变为原来的 2 倍。\n  })                        // { p: 10 }\n\n  JSON.parse('{\"1\": 1, \"2\": 2,\"3\": {\"4\": 4, \"5\": {\"6\": 6}}}', function (k, v) {\n    console.log(k); // 输出当前的属性名，从而得知遍历顺序是从内向外的，\n                    // 最后一个属性名会是个空字符串。\n    return v;       // 返回原始属性值，相当于没有传递 reviver 参数。\n  });\n\n  // 1\n  // 2\n  // 4\n  // 6\n  // 5\n  // 3\n  // \"\"\n```\n\n### JSON.parse()不允许用逗号作为结尾\n```javascript\n  //both will throw a SyntaxError\n  JSON.parse(\"[1,2,3,4, ]\");\n  JSON.parse('{\"foo\":1, }');\n```\n","slug":"JSON-stringify-JSON-parse","published":1,"updated":"2016-06-23T09:02:19.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0em4000bb0dlpph7942x","content":"<blockquote>\n<p>When things go wrong, don’t go with them.</p>\n</blockquote>\n<h2 id=\"JSON-stringify-概述\"><a href=\"#JSON-stringify-概述\" class=\"headerlink\" title=\"JSON.stringify()概述\"></a>JSON.stringify()概述</h2><p>JSON.stringify()方法可以将任意的javascript值序列化成JSON字符串。<br><code>JSON.stringify(value[, replacer [, space]])</code></p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>value – 将要序列化成JSON字符串的值。<br>replacer – (可选)如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中。<br>space – (可选)指定缩进用的空白字符，用于美化输出(pretty-print)。</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>关于序列化，有下面五点注意事项：</p>\n<ul>\n<li>非数组对象的属性不能保证以特定的顺序出现序列化后的字符串中。</li>\n<li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li>\n<li>undefined、任意的函数以及symbol值，在序列化过程中会被忽略(出现在非数组对象的属性值中时)或者被转换成null(出现在数组中时)。</li>\n<li>所有以symbol为属性键的属性都会被完全忽略掉，即便replacer参数中强制指定包含了它们。</li>\n<li>不可枚举的属性会被忽略。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;&#125;);   <span class=\"comment\">//'&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>);   <span class=\"comment\">//'true'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">\"foo\"</span>);   <span class=\"comment\">//'\"foo\"'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify([<span class=\"number\">1</span>, <span class=\"string\">\"false\"</span>, <span class=\"literal\">false</span>]);   <span class=\"comment\">//'[1, \"false\", false]'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x:<span class=\"number\">5</span>&#125;);    <span class=\"comment\">//'&#123;\"x\":5&#125;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x: <span class=\"number\">5</span>, y: <span class=\"number\">6</span>&#125;);              </span><br><span class=\"line\"><span class=\"comment\">// '&#123;\"x\":5,\"y\":6&#125;' 或者 '&#123;\"y\":6,\"x\":5&#125;' 都可能</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify([<span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"false\"</span>), <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>)]);</span><br><span class=\"line\"><span class=\"comment\">// '[1,\"false\",false]'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x: <span class=\"literal\">undefined</span>, y: <span class=\"built_in\">Object</span>, z: <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"\"</span>)&#125;);</span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify([<span class=\"literal\">undefined</span>, <span class=\"built_in\">Object</span>, <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"\"</span>)]);          </span><br><span class=\"line\"><span class=\"comment\">// '[null,null,null]'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"foo\"</span>)]: <span class=\"string\">\"foo\"</span>&#125;);                 </span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>)]: <span class=\"string\">\"foo\"</span>&#125;, [<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>)]);</span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>)]: <span class=\"string\">\"foo\"</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k, v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> k === <span class=\"string\">\"symbol\"</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"a symbol\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不可枚举的属性默认会被忽略：</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify( <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>, &#123; x: &#123; value: <span class=\"string\">'x'</span>, enumerable: <span class=\"literal\">false</span> &#125;, y: &#123; value: <span class=\"string\">'y'</span>, enumerable: <span class=\"literal\">true</span> &#125; &#125;) );</span><br><span class=\"line\"><span class=\"comment\">// '&#123;\"y\":\"y\"&#125;'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"space参数\"><a href=\"#space参数\" class=\"headerlink\" title=\"space参数\"></a>space参数</h3><p>space参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格(最多10个空格);如果是一个字符串，则每一级别会比上一级别多缩进用该字符串(或该字符串的前十个字符)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;a: <span class=\"number\">2</span>&#125;, <span class=\"literal\">null</span>, <span class=\"string\">' '</span>);    <span class=\"comment\">//'&#123;\\n\"a\": 2\\n&#125;'</span></span><br></pre></td></tr></table></figure></p>\n<p>使用制表符(\\t)来缩进<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;uno: <span class=\"number\">1</span>, doc: <span class=\"number\">2</span>&#125;, <span class=\"literal\">null</span>, <span class=\"string\">'\\t'</span>);</span><br><span class=\"line\"><span class=\"comment\">// '&#123;            \\</span></span><br><span class=\"line\"><span class=\"comment\">//     \"uno\": 1, \\</span></span><br><span class=\"line\"><span class=\"comment\">//     \"dos\": 2  \\</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"toJSON方法\"><a href=\"#toJSON方法\" class=\"headerlink\" title=\"toJSON方法\"></a>toJSON方法</h3><p>如果一个被序列化的对象拥有toJSON方法，那么该toJSON方法就会覆盖该对象默认的序列化行为：不是按个对象被序列化，而是调用toJSON方法后的返回值会被序列化，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">  toJSON: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(obj);  <span class=\"comment\">//'\"bar\"'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x: obj&#125;);  <span class=\"comment\">//'&#123;\"x\": \"bar\"&#125;'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用JSON-stringify结合localStorage的例子\"><a href=\"#使用JSON-stringify结合localStorage的例子\" class=\"headerlink\" title=\"使用JSON.stringify结合localStorage的例子\"></a>使用JSON.stringify结合localStorage的例子</h3><p>一些时候，你想存储用户创建的一个对象，并且即使在浏览器被关闭后仍能恢复该对象。下面的例子是JSON.stringify适用于这种情形的一个样板：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个示例数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> session = &#123;</span><br><span class=\"line\">  <span class=\"string\">'screens'</span>: [],</span><br><span class=\"line\">  <span class=\"string\">'state'</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenA\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">450</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">250</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenB\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">650</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">350</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenC\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">750</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">120</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenD\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">250</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">60</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenE\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">390</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">120</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenF\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">1240</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">650</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用JSON.stringify转换为JSON字符串</span></span><br><span class=\"line\"><span class=\"comment\">//然后使用localStorage保存在session名称里</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">'session'</span>, <span class=\"built_in\">JSON</span>.stringify(session));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//然后是如何转换通过JSON.stringify生成的字符串，该字符串以JSON格式保存在localStorage里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restoreSession = <span class=\"built_in\">JSON</span>.parse(localStorage.getItem(<span class=\"string\">'session'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在restoreSession 包含了保存在localStorage里的对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restoreSession);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JSON-parse-概述\"><a href=\"#JSON-parse-概述\" class=\"headerlink\" title=\"JSON.parse()概述\"></a>JSON.parse()概述</h2><p>JSON.parse()方法可以将一个JSON字符串解析成为一个javascript值。在解析过程中，还可以选择性的修改某些属性的原始解析值。<br><code>JSON.parse(text[, reviver])</code></p>\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>text – 要解析的JSON字符串<br>reviver – 一个函数，用来转换解析出的属性值</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>从text字符串解析出的一个Object</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>如果解析的JSON字符串包含语法错误，则会抛出SyntaxError异常。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"使用JSON-parse\"><a href=\"#使用JSON-parse\" class=\"headerlink\" title=\"使用JSON.parse()\"></a>使用JSON.parse()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;&#125;'</span>);              <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'true'</span>);            <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'\"foo\"'</span>);           <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'[1, 5, \"false\"]'</span>); <span class=\"comment\">// [1, 5, \"false\"]</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'null'</span>);            <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用reviver函数\"><a href=\"#使用reviver函数\" class=\"headerlink\" title=\"使用reviver函数\"></a>使用reviver函数</h3><p>如果指定了reviver函数，则解析出的javascript值(解析值)会经过一次转换后才将被最终返回(返回值)。更具体点就是：解析值本身以及它所包含的所有属性，会按照一定的顺序(从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身)分别的去调用reviver函数，在调用过程中，当前属性所属的对象回作为this值，当前属性名和属性值会分别作为第一个和第二个参数传入reviver中。如果reviver返回undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。</p>\n<p>当遍历到最顶层的值(解析值)时，传入reviver函数的参数会是空字符串””(因为此时已经没有真正的属性)和当前的解析值(有可能已经被修改过)，当前的this值会是{“”:修改过得解析值}，在编写reviver函数时，要注意到这个特例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"p\":5&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">k,v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(k === <span class=\"string\">''</span>) <span class=\"keyword\">return</span> v;  <span class=\"comment\">// 如果到了最顶层，则直接返回属性值，</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> v*<span class=\"number\">2</span>;             <span class=\"comment\">// 否则将属性值变为原来的 2 倍。</span></span><br><span class=\"line\">&#125;)                        <span class=\"comment\">// &#123; p: 10 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"1\": 1, \"2\": 2,\"3\": &#123;\"4\": 4, \"5\": &#123;\"6\": 6&#125;&#125;&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k, v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(k); <span class=\"comment\">// 输出当前的属性名，从而得知遍历顺序是从内向外的，</span></span><br><span class=\"line\">                  <span class=\"comment\">// 最后一个属性名会是个空字符串。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> v;       <span class=\"comment\">// 返回原始属性值，相当于没有传递 reviver 参数。</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// \"\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-parse-不允许用逗号作为结尾\"><a href=\"#JSON-parse-不允许用逗号作为结尾\" class=\"headerlink\" title=\"JSON.parse()不允许用逗号作为结尾\"></a>JSON.parse()不允许用逗号作为结尾</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//both will throw a SyntaxError</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">\"[1,2,3,4, ]\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"foo\":1, &#125;'</span>);</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>When things go wrong, don’t go with them.</p>\n</blockquote>\n<h2 id=\"JSON-stringify-概述\"><a href=\"#JSON-stringify-概述\" class=\"headerlink\" title=\"JSON.stringify()概述\"></a>JSON.stringify()概述</h2><p>JSON.stringify()方法可以将任意的javascript值序列化成JSON字符串。<br><code>JSON.stringify(value[, replacer [, space]])</code></p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>value – 将要序列化成JSON字符串的值。<br>replacer – (可选)如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的JSON字符串中。<br>space – (可选)指定缩进用的空白字符，用于美化输出(pretty-print)。</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>关于序列化，有下面五点注意事项：</p>\n<ul>\n<li>非数组对象的属性不能保证以特定的顺序出现序列化后的字符串中。</li>\n<li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</li>\n<li>undefined、任意的函数以及symbol值，在序列化过程中会被忽略(出现在非数组对象的属性值中时)或者被转换成null(出现在数组中时)。</li>\n<li>所有以symbol为属性键的属性都会被完全忽略掉，即便replacer参数中强制指定包含了它们。</li>\n<li>不可枚举的属性会被忽略。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;&#125;);   <span class=\"comment\">//'&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(<span class=\"literal\">true</span>);   <span class=\"comment\">//'true'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(<span class=\"string\">\"foo\"</span>);   <span class=\"comment\">//'\"foo\"'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify([<span class=\"number\">1</span>, <span class=\"string\">\"false\"</span>, <span class=\"literal\">false</span>]);   <span class=\"comment\">//'[1, \"false\", false]'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x:<span class=\"number\">5</span>&#125;);    <span class=\"comment\">//'&#123;\"x\":5&#125;'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x: <span class=\"number\">5</span>, y: <span class=\"number\">6</span>&#125;);              </span><br><span class=\"line\"><span class=\"comment\">// '&#123;\"x\":5,\"y\":6&#125;' 或者 '&#123;\"y\":6,\"x\":5&#125;' 都可能</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify([<span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>), <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">\"false\"</span>), <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>)]);</span><br><span class=\"line\"><span class=\"comment\">// '[1,\"false\",false]'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x: <span class=\"literal\">undefined</span>, y: <span class=\"built_in\">Object</span>, z: <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"\"</span>)&#125;);</span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify([<span class=\"literal\">undefined</span>, <span class=\"built_in\">Object</span>, <span class=\"built_in\">Symbol</span>(<span class=\"string\">\"\"</span>)]);          </span><br><span class=\"line\"><span class=\"comment\">// '[null,null,null]'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>(<span class=\"string\">\"foo\"</span>)]: <span class=\"string\">\"foo\"</span>&#125;);                 </span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>)]: <span class=\"string\">\"foo\"</span>&#125;, [<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>)]);</span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;[<span class=\"built_in\">Symbol</span>.for(<span class=\"string\">\"foo\"</span>)]: <span class=\"string\">\"foo\"</span>&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k, v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> k === <span class=\"string\">\"symbol\"</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"a symbol\"</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// '&#123;&#125;'  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 不可枚举的属性默认会被忽略：</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify( <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>, &#123; x: &#123; value: <span class=\"string\">'x'</span>, enumerable: <span class=\"literal\">false</span> &#125;, y: &#123; value: <span class=\"string\">'y'</span>, enumerable: <span class=\"literal\">true</span> &#125; &#125;) );</span><br><span class=\"line\"><span class=\"comment\">// '&#123;\"y\":\"y\"&#125;'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"space参数\"><a href=\"#space参数\" class=\"headerlink\" title=\"space参数\"></a>space参数</h3><p>space参数用来控制结果字符串里面的间距。如果是一个数字，则在字符串化时每一级别会比上一级别缩进多这个数字值的空格(最多10个空格);如果是一个字符串，则每一级别会比上一级别多缩进用该字符串(或该字符串的前十个字符)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;a: <span class=\"number\">2</span>&#125;, <span class=\"literal\">null</span>, <span class=\"string\">' '</span>);    <span class=\"comment\">//'&#123;\\n\"a\": 2\\n&#125;'</span></span><br></pre></td></tr></table></figure></p>\n<p>使用制表符(\\t)来缩进<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;uno: <span class=\"number\">1</span>, doc: <span class=\"number\">2</span>&#125;, <span class=\"literal\">null</span>, <span class=\"string\">'\\t'</span>);</span><br><span class=\"line\"><span class=\"comment\">// '&#123;            \\</span></span><br><span class=\"line\"><span class=\"comment\">//     \"uno\": 1, \\</span></span><br><span class=\"line\"><span class=\"comment\">//     \"dos\": 2  \\</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"toJSON方法\"><a href=\"#toJSON方法\" class=\"headerlink\" title=\"toJSON方法\"></a>toJSON方法</h3><p>如果一个被序列化的对象拥有toJSON方法，那么该toJSON方法就会覆盖该对象默认的序列化行为：不是按个对象被序列化，而是调用toJSON方法后的返回值会被序列化，例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  foo: <span class=\"string\">'foo'</span>,</span><br><span class=\"line\">  toJSON: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'bar'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(obj);  <span class=\"comment\">//'\"bar\"'</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.stringify(&#123;x: obj&#125;);  <span class=\"comment\">//'&#123;\"x\": \"bar\"&#125;'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用JSON-stringify结合localStorage的例子\"><a href=\"#使用JSON-stringify结合localStorage的例子\" class=\"headerlink\" title=\"使用JSON.stringify结合localStorage的例子\"></a>使用JSON.stringify结合localStorage的例子</h3><p>一些时候，你想存储用户创建的一个对象，并且即使在浏览器被关闭后仍能恢复该对象。下面的例子是JSON.stringify适用于这种情形的一个样板：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建一个示例数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> session = &#123;</span><br><span class=\"line\">  <span class=\"string\">'screens'</span>: [],</span><br><span class=\"line\">  <span class=\"string\">'state'</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenA\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">450</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">250</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenB\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">650</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">350</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenC\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">750</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">120</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenD\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">250</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">60</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenE\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">390</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">120</span>&#125;);</span><br><span class=\"line\">session.screens.push(&#123;<span class=\"string\">\"name\"</span>:<span class=\"string\">\"screenF\"</span>, <span class=\"string\">\"width\"</span>:<span class=\"number\">1240</span>, <span class=\"string\">\"height\"</span>:<span class=\"number\">650</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用JSON.stringify转换为JSON字符串</span></span><br><span class=\"line\"><span class=\"comment\">//然后使用localStorage保存在session名称里</span></span><br><span class=\"line\">localStorage.setItem(<span class=\"string\">'session'</span>, <span class=\"built_in\">JSON</span>.stringify(session));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//然后是如何转换通过JSON.stringify生成的字符串，该字符串以JSON格式保存在localStorage里</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> restoreSession = <span class=\"built_in\">JSON</span>.parse(localStorage.getItem(<span class=\"string\">'session'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在restoreSession 包含了保存在localStorage里的对象</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(restoreSession);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"JSON-parse-概述\"><a href=\"#JSON-parse-概述\" class=\"headerlink\" title=\"JSON.parse()概述\"></a>JSON.parse()概述</h2><p>JSON.parse()方法可以将一个JSON字符串解析成为一个javascript值。在解析过程中，还可以选择性的修改某些属性的原始解析值。<br><code>JSON.parse(text[, reviver])</code></p>\n<h3 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>text – 要解析的JSON字符串<br>reviver – 一个函数，用来转换解析出的属性值</p>\n<h3 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h3><p>从text字符串解析出的一个Object</p>\n<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>如果解析的JSON字符串包含语法错误，则会抛出SyntaxError异常。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"使用JSON-parse\"><a href=\"#使用JSON-parse\" class=\"headerlink\" title=\"使用JSON.parse()\"></a>使用JSON.parse()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;&#125;'</span>);              <span class=\"comment\">// &#123;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'true'</span>);            <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'\"foo\"'</span>);           <span class=\"comment\">// \"foo\"</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'[1, 5, \"false\"]'</span>); <span class=\"comment\">// [1, 5, \"false\"]</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'null'</span>);            <span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用reviver函数\"><a href=\"#使用reviver函数\" class=\"headerlink\" title=\"使用reviver函数\"></a>使用reviver函数</h3><p>如果指定了reviver函数，则解析出的javascript值(解析值)会经过一次转换后才将被最终返回(返回值)。更具体点就是：解析值本身以及它所包含的所有属性，会按照一定的顺序(从最最里层的属性开始，一级级往外，最终到达顶层，也就是解析值本身)分别的去调用reviver函数，在调用过程中，当前属性所属的对象回作为this值，当前属性名和属性值会分别作为第一个和第二个参数传入reviver中。如果reviver返回undefined，则当前属性会从所属对象中删除，如果返回了其他值，则返回的值会成为当前属性新的属性值。</p>\n<p>当遍历到最顶层的值(解析值)时，传入reviver函数的参数会是空字符串””(因为此时已经没有真正的属性)和当前的解析值(有可能已经被修改过)，当前的this值会是{“”:修改过得解析值}，在编写reviver函数时，要注意到这个特例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"p\":5&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">k,v</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(k === <span class=\"string\">''</span>) <span class=\"keyword\">return</span> v;  <span class=\"comment\">// 如果到了最顶层，则直接返回属性值，</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> v*<span class=\"number\">2</span>;             <span class=\"comment\">// 否则将属性值变为原来的 2 倍。</span></span><br><span class=\"line\">&#125;)                        <span class=\"comment\">// &#123; p: 10 &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"1\": 1, \"2\": 2,\"3\": &#123;\"4\": 4, \"5\": &#123;\"6\": 6&#125;&#125;&#125;'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">k, v</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(k); <span class=\"comment\">// 输出当前的属性名，从而得知遍历顺序是从内向外的，</span></span><br><span class=\"line\">                  <span class=\"comment\">// 最后一个属性名会是个空字符串。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> v;       <span class=\"comment\">// 返回原始属性值，相当于没有传递 reviver 参数。</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"comment\">// 6</span></span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"><span class=\"comment\">// \"\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"JSON-parse-不允许用逗号作为结尾\"><a href=\"#JSON-parse-不允许用逗号作为结尾\" class=\"headerlink\" title=\"JSON.parse()不允许用逗号作为结尾\"></a>JSON.parse()不允许用逗号作为结尾</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//both will throw a SyntaxError</span></span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">\"[1,2,3,4, ]\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">JSON</span>.parse(<span class=\"string\">'&#123;\"foo\":1, &#125;'</span>);</span><br></pre></td></tr></table></figure>\n"},{"title":"es6系列教程一","date":"2016-06-01T09:03:45.000Z","_content":"\n> Our lives stretched out ahead of us, like a perpetual sunrise.\n\n# let\n开门见山我们先来尝尝一个例子：\n\n```javascript\n  var list = document.getElementById(\"list\");\n\n  for (var i = 1; i <= 5; i++) {\n    var item = document.createElement(\"li\");\n    item.appendChild(document.createTextNode(\"Item \" + i));\n\n    var j = i; //注意这里使用的是var\n\n    item.onclick = function (ev) {\n       console.log(\"Item \" + j + \" is clicked.\");\n     };\n    list.appendChild(item);\n  }\n```\n上面这段代码的意图是创建5个li，并且点击它们的时候能够打印出当前的序号。但是由于使用了var定义j变量，所以我们发现打印出来的结果都是`Item 5 is clicked.`,这是因为这里var定义的j是函数级变量，5个内部函数都指向了同一个j，而j最后一次赋值是5.而我们流弊的前辈们变相的引入了块级作用域，并轻松解决了上面的问题，具体如下：\n\n```javascript\nvar list = document.getElementById(\"list\");\n\nfor (var i = 1; i <= 5; i++) {\n  var item = document.createElement(\"li\");\n  item.appendChild(document.createTextNode(\"Item \" + i));\n\n  (function(i){\n    var j = i;\n    item.onclick = function (ev) {\n       console.log(\"Item \" + j + \" is clicked.\");\n     };\n  })(i)\n\n  list.appendChild(item);\n}\n```\n这样的话，问题就迎刃而解。因为每循环一次都会产生新的块级作用域(也就是形如`(function(){})()`这样的写法，没进入一次就生成新的跨级作用域)，在新的块级作用域中5个内部函数指向了不同的j。\n\n现在，该我们的主角出场了。为了实现块级作用域，es6引入了let声明变量的方法，这样的话上面的例子，可以直接简化成：\n\n```javascript\nvar list = document.getElementById(\"list\");\n\nfor (var i = 1; i <= 5; i++) {\n  var item = document.createElement(\"li\");\n  item.appendChild(document.createTextNode(\"Item \" + i));\n\n  let j = i; //这里直接使用let\n\n  item.onclick = function (ev) {\n     console.log(\"Item \" + j + \" is clicked.\");\n   };\n  list.appendChild(item);\n}\n```\n\n由此可以看出let与var的区别，let允许把变量限制在块级域中，而var申明的变量要么是全局的，要么是函数级的，而无法是块级的，这是其中之一的区别。\n\n## 作用域规则\n下面我们看看let和var在作用域上规则上的区别。用let定义的变量的作用域是定义在它们的块内，以及包含在这个块中的子块；而var定义的变量的作用域是定义在它们的函数内：\n\n```javascript\n  function varTest(){\n    var x = 31;\n    if(true){\n      var x = 71; //相同的变量\n      console.log(x); //71\n    }\n    console.log(x); //71    \n  }\n\n  function letTest(){\n    let x = 31;\n    if(true){\n      let x = 71; //不同的变量\n      console.log(x); //71\n    }\n    console.log(x); //31\n  }\n```\n\n在程序或函数的顶层，let的表现就像var一样：\n\n```javascript\n  var x = 'global';\n  let y = 'global';\n  console.log(this.x);\n  console.log(this.y);  \n```\n上面这段代码的运行后会显示两次\"global\"。\n\n## let的暂存死区与错误\n在同一个函数或同一个作用域中用let重复定义一个变量将引起TypeError\n\n```javascript\n  if(x){\n    let foo;\n    let foo; //TypeError\n  }\n```\n\n在es6中，let将会提升这个变量到语句块的顶部。然而，在这个语句块中，在变量声明之前引用这个变量会导致一个ReferenceError的结果，因为let变量在“暂存死区”（从块的开始到声明这段）。\n\n```javascript\n  function do_something(){\n    console.log(foo); //ReferenceError\n    let foo = 2;\n  }\n```\n\n在switch申明中你可能会遇到这样的错误，因为一个switch只有一个作用快。\n\n```javascript\n  switch(x){\n    case 0:\n      let foo;\n      break;\n    case 1:\n      let foo; //TypeError for redeclaration\n      break;\n  }\n```\n\n## 循环定义中的let作用域\n循环体中是可以引用在for申明时用let定义的变量，尽管let不是出现在大括号之间。\n\n```javascript\n  var i = 0;\n  for(let i=i; i< 10; i++){\n    console.log(i);\n  }\n```\n\n```javascript\n  注：以上let申明的i将会变成undefined; chrome版本50.0.2661.102(64-bit); 推荐一下写法：\n  var i = 0;\n  for(let l=i;l<10;l++){\n    console.log(l);\n  }\n```\n\n域作用规则\n`for (let expr1;expr2;expr3) statement`\n在这个例子中，expr2,expr3和statement都是包含在一个隐含域块中，其中也包含了expr1\n\n## 再看些例子\n### let 对比 var\nlet的作用域是块，var的作用域是函数\n\n```javascript\n  var a = 5;\n  var b = 10;\n\n  if(a===5){\n    let a = 4; //The scope is inside the if-block\n    var b = 1; //The scope is inside the function\n\n    console.log(a); //4\n    console.log(b); //1\n  }\n\n  console.log(a); //5\n  console.log(b); //1\n```\n\n### let在循环中\n可以用let来代替var，在for定义块中使用块级变量\n\n```javascript\n  for(let i=0;i<10;i++){\n    console.log(i); // 0,1,2,3,4,5,6,7,8,9\n  }\n  console.log(i); //i is not defined\n```\n\n# const\nconst声明创建一个只读的常量。这不意味着常量指向的值不可变，而是变量标识符的只能赋值一次。这个声明创建了一个常量，可以在全局作用域或者函数内声明常量，常量需要被初始化。也就是说，在定义常量的同时必须初始化(这是有意义的，鉴于变量的值在初始化后就不能改变)。\n\n常量拥有块作用域，和使用let 定义的变量十分相似。常量的值不能通过再赋值改变，也不能再次声明。\n\n一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。\n\n## 例子\n下面的例子演示了常量的特征。\n```javascript\n  // 注意: 常量在声明的时候可以使用大小写，但通常情况下会使用全部大写英文。\n\n  // 定义常量MY_FAV并赋值7\n  const MY_FAV = 7;\n\n  // 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功)\n  MY_FAV = 20;\n\n  // 输出 7\n  console.log(\"my favorite number is: \" + MY_FAV);\n\n  // 尝试重新声明会报错\n  const MY_FAV = 20;\n\n  //  MY_FAV 保留给上面的常量，这个操作会失败\n  var MY_FAV = 20;\n\n  // MY_FAV 依旧为7\n  console.log(\"my favorite number is \" + MY_FAV);\n\n  // 下面是一个语法错误\n  const A = 1; A = 2;\n\n  // 常量要求一个初始值\n  const FOO; // SyntaxError: missing = in const declaration\n\n  // 常量可以定义成对象\n  const MY_OBJECT = {\"key\": \"value\"};\n\n  // 重写对象和上面一样会失败\n  MY_OBJECT = {\"OTHER_KEY\": \"value\"};\n\n  // 对象属性并不在保护的范围内，下面这个声明会成功执行\n  MY_OBJECT.key = \"otherValue\";\n```\n\n# 箭头函数\n箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this,arguments,super和new.target等对象）。此外，箭头函数时匿名的。\n## 基本语法\n```javascript\n  (param1,param2,...,paramN) => { statements }\n  (param1,param2,...,paramN) => expression\n          // equivalent to => { return expression; }\n\n  //如果只有一个参数，圆括号是可选的\n  (singleParam) => { statements }\n  singleParam => { statements }\n\n  //无参数的函数需要使用圆括号\n  () => { statements }\n```\n\n## 高级语法\n```javascript\n  //返回对象字面量时应该用圆括号将其包起来：\n  params => {foo:bar}\n\n  //支持Rest parameters 和 default parameters:\n  (param1,param2,...rest) => { statements }\n  (param1 = defaultValue1,param2,...,paramN = defaultValueN) => { statements }\n\n  //Destructring within the parameter list is also supported\n  var f = ([a,b] = [1,2],{x:c} = {x:a+b}) => a + b +c;\n  f(); //6\n```\n\n## 描述\n箭头函数的引用有两个方面的影响：一是更简短的函数书写，二是对this的词法解析。\n\n### 更短的函数\n在一些函数式编程模式里，更短的函数书写方式很受欢迎。试比较：\n```javascript\n  var a = [\n    \"Hydrogen\",\n    \"Helium\",\n    \"Lithium\",\n    \"Beryl­lium\"\n  ];\n  var a2 = a.map(function(s){return s.length});\n\n  var a3 = a.map(s => s.length);\n```\n\n### this的词法\n在箭头函数出现之前，每个新定义的函数都有其自己的this值（例如，构造函数的this指向了一个新的对象；严格模式下的函数的this值为undefined；如果函数是作为对象的方法被调用的，则其this指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。\n\n```javascript\n  function Person(){\n    //构造函数Person()定义的`this`就是新实例对象自己\n    this.age = 0;\n    setInterval(function growUp(){\n      //在非严格模式下，growUp()函数定义了其内部的`this`\n      //在全局对象，不同于构造函数Person()的定义的`this`\n      this.age ++;\n    },1000)\n  }\n\n  var p = new Person();\n```\n\n在ECMAScript3/5中，这个问题可以通过新增一个变量来指向期望的this对象，然后将该变量放到闭包中来解决。\n\n```javascript\n  function Person(){\n    var self = this;\n    self.age = 0;\n\n    setInterval(function growUp(){\n      //回调里面的`self`变量就指向了期望的那个对象了\n      self.age ++;\n    },1000)\n  }\n```\n除此之外，还可以使用bound function,把期望的this值传递给growUp()函数。\n\n箭头函数则会捕获其所在上下文的this值，作为自己的this值，因此下面的代码将如运行。\n\n```javascript\n  function Person(){\n    this.age = 0;\n\n    setInterval(() => {\n      this.age ++; //this正确地指向了person对象\n    },1000)\n  }\n```\n\n### 与strict mode的关系\n考虑到this是词法层面上的，严格模式中与this相关的规则都将被忽略。\n\n```javascript\n  var f = () => {\n    `use strict`;\n    return this;\n  }\n  f() === window //或全局对象\n```\n\n### 使用call或apply调用\n由于this已经在词法层面完成了bound，通过call()或apply()方法调用一个函数时，只是传入了参数而已，对this并没有影响。\n\n```javascript\n  var adder = {\n    base: 1,\n\n    add: function(a){\n      var f = v => v + this.base;\n      return f(a);\n    },\n\n    addThruCall: function(a){\n      var f = v => v + this.base;\n      var b = {\n        base : 2\n      };\n\n      return f.call(b,a)\n    }\n  };\n\n  console.log(adder.add(1)); //输出2\n  console.log(adder.addThruCall(1)); //仍然输出2\n```\n\n## arguments的词法\n箭头函数不会在其内部暴露arguments对象：arguments.length,arguments[0],arguments[1]等等，\n都不会指向箭头函数arguments，而是指向了箭头函数所在作用域的一个名为arguments的值（如果真的有的话，否则，就是undefined）\n\n```javascript\n  var arguments = 42;\n  var arr = () => arguments;\n\n  arr(); //42\n\n  function foo(){\n    var f = () => arguments[0];\n    return f(2);\n  }\n\n  foo(1); //1\n```\n箭头函数没有自己的arguments对象，不过大多数情况下，rest参数可以给出一个解决方案：\n\n```javascript\n  function foo(){\n    var f = (...args) => args[0];\n    return f(2);\n  }\n\n  foo(1); //2\n```\n\n### 使用yield关键字\nyield关键字通常不在箭头函数中使用。因此，箭头函数不能用作Generator函数\n\n### 返回对象字面量\n请牢记，用params => {object:literal}这种简单的语法返回一个对象字面量是行不通的：\n\n```javascript\n  var func = () => { foo: 1 };\n  //calling func() returns undefined!\n\n  var func = () => { foo: function(){} };\n  //SyntaxError: function statement required a name\n```\n\n这是因为花括号(即{})里面的代码被解析为声明序列了(例如，foo被认为是一个label，而非对象字面量里的键)。\n\n所以，记得用圆括号把对象字面量包起来：\n`var func = () => ({foo:1})`\n\n## 示例\n```javascript\n  //一个空箭头函数，返回undefined\n  let empty = () => {};\n\n  (() => \"foobar\")() //返回\"foobar\"\n\n  var simple = a => a > 15 ? 15 : a;\n  simple(16); //15\n  simple(10); //10\n\n  let max = (a,b) => a > b ? a : b;\n\n  //Easy array filtering, mapping, ...\n  var arr = [5,6,13,0,1,18,23];\n  var sum = arr.reduce((a,b) => a + b); //66\n  var even = arr.filter(v => v % 2 == 0); //[6,0,18]\n  var double = arr.map(v => v * 2); //[10,12,26,0,2,36,46]\n```\n","source":"_posts/es6系列教程一.md","raw":"---\ntitle: es6系列教程一\ndate: 2016-06-01T17:03:45.000Z\ntags:\n  - es6\n  - javascript\ncategories: 原创\n---\n\n> Our lives stretched out ahead of us, like a perpetual sunrise.\n\n# let\n开门见山我们先来尝尝一个例子：\n\n```javascript\n  var list = document.getElementById(\"list\");\n\n  for (var i = 1; i <= 5; i++) {\n    var item = document.createElement(\"li\");\n    item.appendChild(document.createTextNode(\"Item \" + i));\n\n    var j = i; //注意这里使用的是var\n\n    item.onclick = function (ev) {\n       console.log(\"Item \" + j + \" is clicked.\");\n     };\n    list.appendChild(item);\n  }\n```\n上面这段代码的意图是创建5个li，并且点击它们的时候能够打印出当前的序号。但是由于使用了var定义j变量，所以我们发现打印出来的结果都是`Item 5 is clicked.`,这是因为这里var定义的j是函数级变量，5个内部函数都指向了同一个j，而j最后一次赋值是5.而我们流弊的前辈们变相的引入了块级作用域，并轻松解决了上面的问题，具体如下：\n\n```javascript\nvar list = document.getElementById(\"list\");\n\nfor (var i = 1; i <= 5; i++) {\n  var item = document.createElement(\"li\");\n  item.appendChild(document.createTextNode(\"Item \" + i));\n\n  (function(i){\n    var j = i;\n    item.onclick = function (ev) {\n       console.log(\"Item \" + j + \" is clicked.\");\n     };\n  })(i)\n\n  list.appendChild(item);\n}\n```\n这样的话，问题就迎刃而解。因为每循环一次都会产生新的块级作用域(也就是形如`(function(){})()`这样的写法，没进入一次就生成新的跨级作用域)，在新的块级作用域中5个内部函数指向了不同的j。\n\n现在，该我们的主角出场了。为了实现块级作用域，es6引入了let声明变量的方法，这样的话上面的例子，可以直接简化成：\n\n```javascript\nvar list = document.getElementById(\"list\");\n\nfor (var i = 1; i <= 5; i++) {\n  var item = document.createElement(\"li\");\n  item.appendChild(document.createTextNode(\"Item \" + i));\n\n  let j = i; //这里直接使用let\n\n  item.onclick = function (ev) {\n     console.log(\"Item \" + j + \" is clicked.\");\n   };\n  list.appendChild(item);\n}\n```\n\n由此可以看出let与var的区别，let允许把变量限制在块级域中，而var申明的变量要么是全局的，要么是函数级的，而无法是块级的，这是其中之一的区别。\n\n## 作用域规则\n下面我们看看let和var在作用域上规则上的区别。用let定义的变量的作用域是定义在它们的块内，以及包含在这个块中的子块；而var定义的变量的作用域是定义在它们的函数内：\n\n```javascript\n  function varTest(){\n    var x = 31;\n    if(true){\n      var x = 71; //相同的变量\n      console.log(x); //71\n    }\n    console.log(x); //71    \n  }\n\n  function letTest(){\n    let x = 31;\n    if(true){\n      let x = 71; //不同的变量\n      console.log(x); //71\n    }\n    console.log(x); //31\n  }\n```\n\n在程序或函数的顶层，let的表现就像var一样：\n\n```javascript\n  var x = 'global';\n  let y = 'global';\n  console.log(this.x);\n  console.log(this.y);  \n```\n上面这段代码的运行后会显示两次\"global\"。\n\n## let的暂存死区与错误\n在同一个函数或同一个作用域中用let重复定义一个变量将引起TypeError\n\n```javascript\n  if(x){\n    let foo;\n    let foo; //TypeError\n  }\n```\n\n在es6中，let将会提升这个变量到语句块的顶部。然而，在这个语句块中，在变量声明之前引用这个变量会导致一个ReferenceError的结果，因为let变量在“暂存死区”（从块的开始到声明这段）。\n\n```javascript\n  function do_something(){\n    console.log(foo); //ReferenceError\n    let foo = 2;\n  }\n```\n\n在switch申明中你可能会遇到这样的错误，因为一个switch只有一个作用快。\n\n```javascript\n  switch(x){\n    case 0:\n      let foo;\n      break;\n    case 1:\n      let foo; //TypeError for redeclaration\n      break;\n  }\n```\n\n## 循环定义中的let作用域\n循环体中是可以引用在for申明时用let定义的变量，尽管let不是出现在大括号之间。\n\n```javascript\n  var i = 0;\n  for(let i=i; i< 10; i++){\n    console.log(i);\n  }\n```\n\n```javascript\n  注：以上let申明的i将会变成undefined; chrome版本50.0.2661.102(64-bit); 推荐一下写法：\n  var i = 0;\n  for(let l=i;l<10;l++){\n    console.log(l);\n  }\n```\n\n域作用规则\n`for (let expr1;expr2;expr3) statement`\n在这个例子中，expr2,expr3和statement都是包含在一个隐含域块中，其中也包含了expr1\n\n## 再看些例子\n### let 对比 var\nlet的作用域是块，var的作用域是函数\n\n```javascript\n  var a = 5;\n  var b = 10;\n\n  if(a===5){\n    let a = 4; //The scope is inside the if-block\n    var b = 1; //The scope is inside the function\n\n    console.log(a); //4\n    console.log(b); //1\n  }\n\n  console.log(a); //5\n  console.log(b); //1\n```\n\n### let在循环中\n可以用let来代替var，在for定义块中使用块级变量\n\n```javascript\n  for(let i=0;i<10;i++){\n    console.log(i); // 0,1,2,3,4,5,6,7,8,9\n  }\n  console.log(i); //i is not defined\n```\n\n# const\nconst声明创建一个只读的常量。这不意味着常量指向的值不可变，而是变量标识符的只能赋值一次。这个声明创建了一个常量，可以在全局作用域或者函数内声明常量，常量需要被初始化。也就是说，在定义常量的同时必须初始化(这是有意义的，鉴于变量的值在初始化后就不能改变)。\n\n常量拥有块作用域，和使用let 定义的变量十分相似。常量的值不能通过再赋值改变，也不能再次声明。\n\n一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。\n\n## 例子\n下面的例子演示了常量的特征。\n```javascript\n  // 注意: 常量在声明的时候可以使用大小写，但通常情况下会使用全部大写英文。\n\n  // 定义常量MY_FAV并赋值7\n  const MY_FAV = 7;\n\n  // 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功)\n  MY_FAV = 20;\n\n  // 输出 7\n  console.log(\"my favorite number is: \" + MY_FAV);\n\n  // 尝试重新声明会报错\n  const MY_FAV = 20;\n\n  //  MY_FAV 保留给上面的常量，这个操作会失败\n  var MY_FAV = 20;\n\n  // MY_FAV 依旧为7\n  console.log(\"my favorite number is \" + MY_FAV);\n\n  // 下面是一个语法错误\n  const A = 1; A = 2;\n\n  // 常量要求一个初始值\n  const FOO; // SyntaxError: missing = in const declaration\n\n  // 常量可以定义成对象\n  const MY_OBJECT = {\"key\": \"value\"};\n\n  // 重写对象和上面一样会失败\n  MY_OBJECT = {\"OTHER_KEY\": \"value\"};\n\n  // 对象属性并不在保护的范围内，下面这个声明会成功执行\n  MY_OBJECT.key = \"otherValue\";\n```\n\n# 箭头函数\n箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this,arguments,super和new.target等对象）。此外，箭头函数时匿名的。\n## 基本语法\n```javascript\n  (param1,param2,...,paramN) => { statements }\n  (param1,param2,...,paramN) => expression\n          // equivalent to => { return expression; }\n\n  //如果只有一个参数，圆括号是可选的\n  (singleParam) => { statements }\n  singleParam => { statements }\n\n  //无参数的函数需要使用圆括号\n  () => { statements }\n```\n\n## 高级语法\n```javascript\n  //返回对象字面量时应该用圆括号将其包起来：\n  params => {foo:bar}\n\n  //支持Rest parameters 和 default parameters:\n  (param1,param2,...rest) => { statements }\n  (param1 = defaultValue1,param2,...,paramN = defaultValueN) => { statements }\n\n  //Destructring within the parameter list is also supported\n  var f = ([a,b] = [1,2],{x:c} = {x:a+b}) => a + b +c;\n  f(); //6\n```\n\n## 描述\n箭头函数的引用有两个方面的影响：一是更简短的函数书写，二是对this的词法解析。\n\n### 更短的函数\n在一些函数式编程模式里，更短的函数书写方式很受欢迎。试比较：\n```javascript\n  var a = [\n    \"Hydrogen\",\n    \"Helium\",\n    \"Lithium\",\n    \"Beryl­lium\"\n  ];\n  var a2 = a.map(function(s){return s.length});\n\n  var a3 = a.map(s => s.length);\n```\n\n### this的词法\n在箭头函数出现之前，每个新定义的函数都有其自己的this值（例如，构造函数的this指向了一个新的对象；严格模式下的函数的this值为undefined；如果函数是作为对象的方法被调用的，则其this指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。\n\n```javascript\n  function Person(){\n    //构造函数Person()定义的`this`就是新实例对象自己\n    this.age = 0;\n    setInterval(function growUp(){\n      //在非严格模式下，growUp()函数定义了其内部的`this`\n      //在全局对象，不同于构造函数Person()的定义的`this`\n      this.age ++;\n    },1000)\n  }\n\n  var p = new Person();\n```\n\n在ECMAScript3/5中，这个问题可以通过新增一个变量来指向期望的this对象，然后将该变量放到闭包中来解决。\n\n```javascript\n  function Person(){\n    var self = this;\n    self.age = 0;\n\n    setInterval(function growUp(){\n      //回调里面的`self`变量就指向了期望的那个对象了\n      self.age ++;\n    },1000)\n  }\n```\n除此之外，还可以使用bound function,把期望的this值传递给growUp()函数。\n\n箭头函数则会捕获其所在上下文的this值，作为自己的this值，因此下面的代码将如运行。\n\n```javascript\n  function Person(){\n    this.age = 0;\n\n    setInterval(() => {\n      this.age ++; //this正确地指向了person对象\n    },1000)\n  }\n```\n\n### 与strict mode的关系\n考虑到this是词法层面上的，严格模式中与this相关的规则都将被忽略。\n\n```javascript\n  var f = () => {\n    `use strict`;\n    return this;\n  }\n  f() === window //或全局对象\n```\n\n### 使用call或apply调用\n由于this已经在词法层面完成了bound，通过call()或apply()方法调用一个函数时，只是传入了参数而已，对this并没有影响。\n\n```javascript\n  var adder = {\n    base: 1,\n\n    add: function(a){\n      var f = v => v + this.base;\n      return f(a);\n    },\n\n    addThruCall: function(a){\n      var f = v => v + this.base;\n      var b = {\n        base : 2\n      };\n\n      return f.call(b,a)\n    }\n  };\n\n  console.log(adder.add(1)); //输出2\n  console.log(adder.addThruCall(1)); //仍然输出2\n```\n\n## arguments的词法\n箭头函数不会在其内部暴露arguments对象：arguments.length,arguments[0],arguments[1]等等，\n都不会指向箭头函数arguments，而是指向了箭头函数所在作用域的一个名为arguments的值（如果真的有的话，否则，就是undefined）\n\n```javascript\n  var arguments = 42;\n  var arr = () => arguments;\n\n  arr(); //42\n\n  function foo(){\n    var f = () => arguments[0];\n    return f(2);\n  }\n\n  foo(1); //1\n```\n箭头函数没有自己的arguments对象，不过大多数情况下，rest参数可以给出一个解决方案：\n\n```javascript\n  function foo(){\n    var f = (...args) => args[0];\n    return f(2);\n  }\n\n  foo(1); //2\n```\n\n### 使用yield关键字\nyield关键字通常不在箭头函数中使用。因此，箭头函数不能用作Generator函数\n\n### 返回对象字面量\n请牢记，用params => {object:literal}这种简单的语法返回一个对象字面量是行不通的：\n\n```javascript\n  var func = () => { foo: 1 };\n  //calling func() returns undefined!\n\n  var func = () => { foo: function(){} };\n  //SyntaxError: function statement required a name\n```\n\n这是因为花括号(即{})里面的代码被解析为声明序列了(例如，foo被认为是一个label，而非对象字面量里的键)。\n\n所以，记得用圆括号把对象字面量包起来：\n`var func = () => ({foo:1})`\n\n## 示例\n```javascript\n  //一个空箭头函数，返回undefined\n  let empty = () => {};\n\n  (() => \"foobar\")() //返回\"foobar\"\n\n  var simple = a => a > 15 ? 15 : a;\n  simple(16); //15\n  simple(10); //10\n\n  let max = (a,b) => a > b ? a : b;\n\n  //Easy array filtering, mapping, ...\n  var arr = [5,6,13,0,1,18,23];\n  var sum = arr.reduce((a,b) => a + b); //66\n  var even = arr.filter(v => v % 2 == 0); //[6,0,18]\n  var double = arr.map(v => v * 2); //[10,12,26,0,2,36,46]\n```\n","slug":"es6系列教程一","published":1,"updated":"2016-06-02T02:51:50.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0ema000eb0dld4kijfg5","content":"<blockquote>\n<p>Our lives stretched out ahead of us, like a perpetual sunrise.</p>\n</blockquote>\n<h1 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h1><p>开门见山我们先来尝尝一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> j = i; <span class=\"comment\">//注意这里使用的是var</span></span><br><span class=\"line\"></span><br><span class=\"line\">  item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">  list.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的意图是创建5个li，并且点击它们的时候能够打印出当前的序号。但是由于使用了var定义j变量，所以我们发现打印出来的结果都是<code>Item 5 is clicked.</code>,这是因为这里var定义的j是函数级变量，5个内部函数都指向了同一个j，而j最后一次赋值是5.而我们流弊的前辈们变相的引入了块级作用域，并轻松解决了上面的问题，具体如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">    item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话，问题就迎刃而解。因为每循环一次都会产生新的块级作用域(也就是形如<code>(function(){})()</code>这样的写法，没进入一次就生成新的跨级作用域)，在新的块级作用域中5个内部函数指向了不同的j。</p>\n<p>现在，该我们的主角出场了。为了实现块级作用域，es6引入了let声明变量的方法，这样的话上面的例子，可以直接简化成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = i; <span class=\"comment\">//这里直接使用let</span></span><br><span class=\"line\"></span><br><span class=\"line\">  item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">  list.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可以看出let与var的区别，let允许把变量限制在块级域中，而var申明的变量要么是全局的，要么是函数级的，而无法是块级的，这是其中之一的区别。</p>\n<h2 id=\"作用域规则\"><a href=\"#作用域规则\" class=\"headerlink\" title=\"作用域规则\"></a>作用域规则</h2><p>下面我们看看let和var在作用域上规则上的区别。用let定义的变量的作用域是定义在它们的块内，以及包含在这个块中的子块；而var定义的变量的作用域是定义在它们的函数内：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">varTest</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">71</span>; <span class=\"comment\">//相同的变量</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//71</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//71    </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">letTest</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">71</span>; <span class=\"comment\">//不同的变量</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//71</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//31</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在程序或函数的顶层，let的表现就像var一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.y);</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的运行后会显示两次”global”。</p>\n<h2 id=\"let的暂存死区与错误\"><a href=\"#let的暂存死区与错误\" class=\"headerlink\" title=\"let的暂存死区与错误\"></a>let的暂存死区与错误</h2><p>在同一个函数或同一个作用域中用let重复定义一个变量将引起TypeError</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(x)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> foo;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> foo; <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在es6中，let将会提升这个变量到语句块的顶部。然而，在这个语句块中，在变量声明之前引用这个变量会导致一个ReferenceError的结果，因为let变量在“暂存死区”（从块的开始到声明这段）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do_something</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在switch申明中你可能会遇到这样的错误，因为一个switch只有一个作用快。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(x)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> foo;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> foo; <span class=\"comment\">//TypeError for redeclaration</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环定义中的let作用域\"><a href=\"#循环定义中的let作用域\" class=\"headerlink\" title=\"循环定义中的let作用域\"></a>循环定义中的let作用域</h2><p>循环体中是可以引用在for申明时用let定义的变量，尽管let不是出现在大括号之间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=i; i&lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：以上<span class=\"keyword\">let</span>申明的i将会变成<span class=\"literal\">undefined</span>; chrome版本<span class=\"number\">50.0</span><span class=\"number\">.2661</span><span class=\"number\">.102</span>(<span class=\"number\">64</span>-bit); 推荐一下写法：</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> l=i;l&lt;<span class=\"number\">10</span>;l++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>域作用规则<br><code>for (let expr1;expr2;expr3) statement</code><br>在这个例子中，expr2,expr3和statement都是包含在一个隐含域块中，其中也包含了expr1</p>\n<h2 id=\"再看些例子\"><a href=\"#再看些例子\" class=\"headerlink\" title=\"再看些例子\"></a>再看些例子</h2><h3 id=\"let-对比-var\"><a href=\"#let-对比-var\" class=\"headerlink\" title=\"let 对比 var\"></a>let 对比 var</h3><p>let的作用域是块，var的作用域是函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(a===<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">4</span>; <span class=\"comment\">//The scope is inside the if-block</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>; <span class=\"comment\">//The scope is inside the function</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//4</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"let在循环中\"><a href=\"#let在循环中\" class=\"headerlink\" title=\"let在循环中\"></a>let在循环中</h3><p>可以用let来代替var，在for定义块中使用块级变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 0,1,2,3,4,5,6,7,8,9</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">//i is not defined</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h1><p>const声明创建一个只读的常量。这不意味着常量指向的值不可变，而是变量标识符的只能赋值一次。这个声明创建了一个常量，可以在全局作用域或者函数内声明常量，常量需要被初始化。也就是说，在定义常量的同时必须初始化(这是有意义的，鉴于变量的值在初始化后就不能改变)。</p>\n<p>常量拥有块作用域，和使用let 定义的变量十分相似。常量的值不能通过再赋值改变，也不能再次声明。</p>\n<p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>下面的例子演示了常量的特征。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意: 常量在声明的时候可以使用大小写，但通常情况下会使用全部大写英文。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义常量MY_FAV并赋值7</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_FAV = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功)</span></span><br><span class=\"line\">MY_FAV = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"my favorite number is: \"</span> + MY_FAV);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试重新声明会报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_FAV = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  MY_FAV 保留给上面的常量，这个操作会失败</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MY_FAV = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MY_FAV 依旧为7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"my favorite number is \"</span> + MY_FAV);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面是一个语法错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = <span class=\"number\">1</span>; A = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常量要求一个初始值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FOO; <span class=\"comment\">// SyntaxError: missing = in const declaration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常量可以定义成对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_OBJECT = &#123;<span class=\"string\">\"key\"</span>: <span class=\"string\">\"value\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写对象和上面一样会失败</span></span><br><span class=\"line\">MY_OBJECT = &#123;<span class=\"string\">\"OTHER_KEY\"</span>: <span class=\"string\">\"value\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></span><br><span class=\"line\">MY_OBJECT.key = <span class=\"string\">\"otherValue\"</span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><p>箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this,arguments,super和new.target等对象）。此外，箭头函数时匿名的。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(param1,param2,...,paramN) =&gt; &#123; statements &#125;</span><br><span class=\"line\">(param1,param2,...,paramN) =&gt; expression</span><br><span class=\"line\">        <span class=\"comment\">// equivalent to =&gt; &#123; return expression; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果只有一个参数，圆括号是可选的</span></span><br><span class=\"line\">(singleParam) =&gt; &#123; statements &#125;</span><br><span class=\"line\">singleParam =&gt; &#123; statements &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//无参数的函数需要使用圆括号</span></span><br><span class=\"line\">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级语法\"><a href=\"#高级语法\" class=\"headerlink\" title=\"高级语法\"></a>高级语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回对象字面量时应该用圆括号将其包起来：</span></span><br><span class=\"line\">params =&gt; &#123;foo:bar&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//支持Rest parameters 和 default parameters:</span></span><br><span class=\"line\">(param1,param2,...rest) =&gt; &#123; statements &#125;</span><br><span class=\"line\">(param1 = defaultValue1,param2,...,paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Destructring within the parameter list is also supported</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = ([a,b] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>],&#123;x:c&#125; = &#123;x:a+b&#125;) =&gt; a + b +c;</span><br><span class=\"line\">f(); <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>箭头函数的引用有两个方面的影响：一是更简短的函数书写，二是对this的词法解析。</p>\n<h3 id=\"更短的函数\"><a href=\"#更短的函数\" class=\"headerlink\" title=\"更短的函数\"></a>更短的函数</h3><p>在一些函数式编程模式里，更短的函数书写方式很受欢迎。试比较：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [</span><br><span class=\"line\">  <span class=\"string\">\"Hydrogen\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Helium\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Lithium\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Beryl­lium\"</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = a.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;<span class=\"keyword\">return</span> s.length&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a3 = a.map(s =&gt; s.length);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"this的词法\"><a href=\"#this的词法\" class=\"headerlink\" title=\"this的词法\"></a>this的词法</h3><p>在箭头函数出现之前，每个新定义的函数都有其自己的this值（例如，构造函数的this指向了一个新的对象；严格模式下的函数的this值为undefined；如果函数是作为对象的方法被调用的，则其this指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//构造函数Person()定义的`this`就是新实例对象自己</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在非严格模式下，growUp()函数定义了其内部的`this`</span></span><br><span class=\"line\">    <span class=\"comment\">//在全局对象，不同于构造函数Person()的定义的`this`</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age ++;</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n<p>在ECMAScript3/5中，这个问题可以通过新增一个变量来指向期望的this对象，然后将该变量放到闭包中来解决。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  self.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//回调里面的`self`变量就指向了期望的那个对象了</span></span><br><span class=\"line\">    self.age ++;</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，还可以使用bound function,把期望的this值传递给growUp()函数。</p>\n<p>箭头函数则会捕获其所在上下文的this值，作为自己的this值，因此下面的代码将如运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(() =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age ++; <span class=\"comment\">//this正确地指向了person对象</span></span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"与strict-mode的关系\"><a href=\"#与strict-mode的关系\" class=\"headerlink\" title=\"与strict mode的关系\"></a>与strict mode的关系</h3><p>考虑到this是词法层面上的，严格模式中与this相关的规则都将被忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"string\">`use strict`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() === <span class=\"built_in\">window</span> <span class=\"comment\">//或全局对象</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用call或apply调用\"><a href=\"#使用call或apply调用\" class=\"headerlink\" title=\"使用call或apply调用\"></a>使用call或apply调用</h3><p>由于this已经在词法层面完成了bound，通过call()或apply()方法调用一个函数时，只是传入了参数而已，对this并没有影响。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> adder = &#123;</span><br><span class=\"line\">  base: <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  add: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = v =&gt; v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(a);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addThruCall: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = v =&gt; v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">      base : <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(b,a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.add(<span class=\"number\">1</span>)); <span class=\"comment\">//输出2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.addThruCall(<span class=\"number\">1</span>)); <span class=\"comment\">//仍然输出2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"arguments的词法\"><a href=\"#arguments的词法\" class=\"headerlink\" title=\"arguments的词法\"></a>arguments的词法</h2><p>箭头函数不会在其内部暴露arguments对象：arguments.length,arguments[0],arguments[1]等等，<br>都不会指向箭头函数arguments，而是指向了箭头函数所在作用域的一个名为arguments的值（如果真的有的话，否则，就是undefined）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">arguments</span> = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = () =&gt; <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">arr(); <span class=\"comment\">//42</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = () =&gt; <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">1</span>); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数没有自己的arguments对象，不过大多数情况下，rest参数可以给出一个解决方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = (...args) =&gt; args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">1</span>); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用yield关键字\"><a href=\"#使用yield关键字\" class=\"headerlink\" title=\"使用yield关键字\"></a>使用yield关键字</h3><p>yield关键字通常不在箭头函数中使用。因此，箭头函数不能用作Generator函数</p>\n<h3 id=\"返回对象字面量\"><a href=\"#返回对象字面量\" class=\"headerlink\" title=\"返回对象字面量\"></a>返回对象字面量</h3><p>请牢记，用params =&gt; {object:literal}这种简单的语法返回一个对象字面量是行不通的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = () =&gt; &#123; foo: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">//calling func() returns undefined!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = () =&gt; &#123; foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">//SyntaxError: function statement required a name</span></span><br></pre></td></tr></table></figure>\n<p>这是因为花括号(即{})里面的代码被解析为声明序列了(例如，foo被认为是一个label，而非对象字面量里的键)。</p>\n<p>所以，记得用圆括号把对象字面量包起来：<br><code>var func = () =&gt; ({foo:1})</code></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个空箭头函数，返回undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> empty = () =&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(() =&gt; <span class=\"string\">\"foobar\"</span>)() <span class=\"comment\">//返回\"foobar\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> simple = a =&gt; a &gt; <span class=\"number\">15</span> ? <span class=\"number\">15</span> : a;</span><br><span class=\"line\">simple(<span class=\"number\">16</span>); <span class=\"comment\">//15</span></span><br><span class=\"line\">simple(<span class=\"number\">10</span>); <span class=\"comment\">//10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> max = (a,b) =&gt; a &gt; b ? a : b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Easy array filtering, mapping, ...</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">13</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">18</span>,<span class=\"number\">23</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = arr.reduce((a,b) =&gt; a + b); <span class=\"comment\">//66</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> even = arr.filter(v =&gt; v % <span class=\"number\">2</span> == <span class=\"number\">0</span>); <span class=\"comment\">//[6,0,18]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> double = arr.map(v =&gt; v * <span class=\"number\">2</span>); <span class=\"comment\">//[10,12,26,0,2,36,46]</span></span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>Our lives stretched out ahead of us, like a perpetual sunrise.</p>\n</blockquote>\n<h1 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h1><p>开门见山我们先来尝尝一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> j = i; <span class=\"comment\">//注意这里使用的是var</span></span><br><span class=\"line\"></span><br><span class=\"line\">  item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">  list.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的意图是创建5个li，并且点击它们的时候能够打印出当前的序号。但是由于使用了var定义j变量，所以我们发现打印出来的结果都是<code>Item 5 is clicked.</code>,这是因为这里var定义的j是函数级变量，5个内部函数都指向了同一个j，而j最后一次赋值是5.而我们流弊的前辈们变相的引入了块级作用域，并轻松解决了上面的问题，具体如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">i</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> j = i;</span><br><span class=\"line\">    item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">  &#125;)(i)</span><br><span class=\"line\"></span><br><span class=\"line\">  list.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话，问题就迎刃而解。因为每循环一次都会产生新的块级作用域(也就是形如<code>(function(){})()</code>这样的写法，没进入一次就生成新的跨级作用域)，在新的块级作用域中5个内部函数指向了不同的j。</p>\n<p>现在，该我们的主角出场了。为了实现块级作用域，es6引入了let声明变量的方法，这样的话上面的例子，可以直接简化成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"list\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> item = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  item.appendChild(<span class=\"built_in\">document</span>.createTextNode(<span class=\"string\">\"Item \"</span> + i));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> j = i; <span class=\"comment\">//这里直接使用let</span></span><br><span class=\"line\"></span><br><span class=\"line\">  item.onclick = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ev</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Item \"</span> + j + <span class=\"string\">\" is clicked.\"</span>);</span><br><span class=\"line\">   &#125;;</span><br><span class=\"line\">  list.appendChild(item);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由此可以看出let与var的区别，let允许把变量限制在块级域中，而var申明的变量要么是全局的，要么是函数级的，而无法是块级的，这是其中之一的区别。</p>\n<h2 id=\"作用域规则\"><a href=\"#作用域规则\" class=\"headerlink\" title=\"作用域规则\"></a>作用域规则</h2><p>下面我们看看let和var在作用域上规则上的区别。用let定义的变量的作用域是定义在它们的块内，以及包含在这个块中的子块；而var定义的变量的作用域是定义在它们的函数内：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">varTest</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">71</span>; <span class=\"comment\">//相同的变量</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//71</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//71    </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">letTest</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">31</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">71</span>; <span class=\"comment\">//不同的变量</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//71</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//31</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在程序或函数的顶层，let的表现就像var一样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> y = <span class=\"string\">'global'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.y);</span><br></pre></td></tr></table></figure>\n<p>上面这段代码的运行后会显示两次”global”。</p>\n<h2 id=\"let的暂存死区与错误\"><a href=\"#let的暂存死区与错误\" class=\"headerlink\" title=\"let的暂存死区与错误\"></a>let的暂存死区与错误</h2><p>在同一个函数或同一个作用域中用let重复定义一个变量将引起TypeError</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(x)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> foo;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> foo; <span class=\"comment\">//TypeError</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在es6中，let将会提升这个变量到语句块的顶部。然而，在这个语句块中，在变量声明之前引用这个变量会导致一个ReferenceError的结果，因为let变量在“暂存死区”（从块的开始到声明这段）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">do_something</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在switch申明中你可能会遇到这样的错误，因为一个switch只有一个作用快。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(x)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> foo;</span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    <span class=\"keyword\">let</span> foo; <span class=\"comment\">//TypeError for redeclaration</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"循环定义中的let作用域\"><a href=\"#循环定义中的let作用域\" class=\"headerlink\" title=\"循环定义中的let作用域\"></a>循环定义中的let作用域</h2><p>循环体中是可以引用在for申明时用let定义的变量，尽管let不是出现在大括号之间。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=i; i&lt; <span class=\"number\">10</span>; i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：以上<span class=\"keyword\">let</span>申明的i将会变成<span class=\"literal\">undefined</span>; chrome版本<span class=\"number\">50.0</span><span class=\"number\">.2661</span><span class=\"number\">.102</span>(<span class=\"number\">64</span>-bit); 推荐一下写法：</span><br><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> l=i;l&lt;<span class=\"number\">10</span>;l++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(l);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>域作用规则<br><code>for (let expr1;expr2;expr3) statement</code><br>在这个例子中，expr2,expr3和statement都是包含在一个隐含域块中，其中也包含了expr1</p>\n<h2 id=\"再看些例子\"><a href=\"#再看些例子\" class=\"headerlink\" title=\"再看些例子\"></a>再看些例子</h2><h3 id=\"let-对比-var\"><a href=\"#let-对比-var\" class=\"headerlink\" title=\"let 对比 var\"></a>let 对比 var</h3><p>let的作用域是块，var的作用域是函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(a===<span class=\"number\">5</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">4</span>; <span class=\"comment\">//The scope is inside the if-block</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>; <span class=\"comment\">//The scope is inside the function</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//4</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a); <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"let在循环中\"><a href=\"#let在循环中\" class=\"headerlink\" title=\"let在循环中\"></a>let在循环中</h3><p>可以用let来代替var，在for定义块中使用块级变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">10</span>;i++)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(i); <span class=\"comment\">// 0,1,2,3,4,5,6,7,8,9</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(i); <span class=\"comment\">//i is not defined</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h1><p>const声明创建一个只读的常量。这不意味着常量指向的值不可变，而是变量标识符的只能赋值一次。这个声明创建了一个常量，可以在全局作用域或者函数内声明常量，常量需要被初始化。也就是说，在定义常量的同时必须初始化(这是有意义的，鉴于变量的值在初始化后就不能改变)。</p>\n<p>常量拥有块作用域，和使用let 定义的变量十分相似。常量的值不能通过再赋值改变，也不能再次声明。</p>\n<p>一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>下面的例子演示了常量的特征。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 注意: 常量在声明的时候可以使用大小写，但通常情况下会使用全部大写英文。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义常量MY_FAV并赋值7</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_FAV = <span class=\"number\">7</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在 Firefox 和 Chrome 这会失败但不会报错(在 Safari这个赋值会成功)</span></span><br><span class=\"line\">MY_FAV = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"my favorite number is: \"</span> + MY_FAV);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 尝试重新声明会报错</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_FAV = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  MY_FAV 保留给上面的常量，这个操作会失败</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> MY_FAV = <span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// MY_FAV 依旧为7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"my favorite number is \"</span> + MY_FAV);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下面是一个语法错误</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> A = <span class=\"number\">1</span>; A = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常量要求一个初始值</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> FOO; <span class=\"comment\">// SyntaxError: missing = in const declaration</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 常量可以定义成对象</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> MY_OBJECT = &#123;<span class=\"string\">\"key\"</span>: <span class=\"string\">\"value\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重写对象和上面一样会失败</span></span><br><span class=\"line\">MY_OBJECT = &#123;<span class=\"string\">\"OTHER_KEY\"</span>: <span class=\"string\">\"value\"</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象属性并不在保护的范围内，下面这个声明会成功执行</span></span><br><span class=\"line\">MY_OBJECT.key = <span class=\"string\">\"otherValue\"</span>;</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h1><p>箭头函数就是个简写形式的函数表达式，并且它拥有词法作用域的this值（即不会新产生自己作用域下的this,arguments,super和new.target等对象）。此外，箭头函数时匿名的。</p>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(param1,param2,...,paramN) =&gt; &#123; statements &#125;</span><br><span class=\"line\">(param1,param2,...,paramN) =&gt; expression</span><br><span class=\"line\">        <span class=\"comment\">// equivalent to =&gt; &#123; return expression; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果只有一个参数，圆括号是可选的</span></span><br><span class=\"line\">(singleParam) =&gt; &#123; statements &#125;</span><br><span class=\"line\">singleParam =&gt; &#123; statements &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//无参数的函数需要使用圆括号</span></span><br><span class=\"line\">() =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"高级语法\"><a href=\"#高级语法\" class=\"headerlink\" title=\"高级语法\"></a>高级语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回对象字面量时应该用圆括号将其包起来：</span></span><br><span class=\"line\">params =&gt; &#123;foo:bar&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//支持Rest parameters 和 default parameters:</span></span><br><span class=\"line\">(param1,param2,...rest) =&gt; &#123; statements &#125;</span><br><span class=\"line\">(param1 = defaultValue1,param2,...,paramN = defaultValueN) =&gt; &#123; statements &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Destructring within the parameter list is also supported</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = ([a,b] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>],&#123;x:c&#125; = &#123;x:a+b&#125;) =&gt; a + b +c;</span><br><span class=\"line\">f(); <span class=\"comment\">//6</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>箭头函数的引用有两个方面的影响：一是更简短的函数书写，二是对this的词法解析。</p>\n<h3 id=\"更短的函数\"><a href=\"#更短的函数\" class=\"headerlink\" title=\"更短的函数\"></a>更短的函数</h3><p>在一些函数式编程模式里，更短的函数书写方式很受欢迎。试比较：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [</span><br><span class=\"line\">  <span class=\"string\">\"Hydrogen\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Helium\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Lithium\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Beryl­lium\"</span></span><br><span class=\"line\">];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a2 = a.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>)</span>&#123;<span class=\"keyword\">return</span> s.length&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a3 = a.map(s =&gt; s.length);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"this的词法\"><a href=\"#this的词法\" class=\"headerlink\" title=\"this的词法\"></a>this的词法</h3><p>在箭头函数出现之前，每个新定义的函数都有其自己的this值（例如，构造函数的this指向了一个新的对象；严格模式下的函数的this值为undefined；如果函数是作为对象的方法被调用的，则其this指向了那个调用它的对象）。在面向对象风格的编程中，这被证明是非常恼人的事情。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//构造函数Person()定义的`this`就是新实例对象自己</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//在非严格模式下，growUp()函数定义了其内部的`this`</span></span><br><span class=\"line\">    <span class=\"comment\">//在全局对象，不同于构造函数Person()的定义的`this`</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age ++;</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Person();</span><br></pre></td></tr></table></figure>\n<p>在ECMAScript3/5中，这个问题可以通过新增一个变量来指向期望的this对象，然后将该变量放到闭包中来解决。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  self.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">growUp</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//回调里面的`self`变量就指向了期望的那个对象了</span></span><br><span class=\"line\">    self.age ++;</span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除此之外，还可以使用bound function,把期望的this值传递给growUp()函数。</p>\n<p>箭头函数则会捕获其所在上下文的this值，作为自己的this值，因此下面的代码将如运行。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  setInterval(() =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age ++; <span class=\"comment\">//this正确地指向了person对象</span></span><br><span class=\"line\">  &#125;,<span class=\"number\">1000</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"与strict-mode的关系\"><a href=\"#与strict-mode的关系\" class=\"headerlink\" title=\"与strict mode的关系\"></a>与strict mode的关系</h3><p>考虑到this是词法层面上的，严格模式中与this相关的规则都将被忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"string\">`use strict`</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f() === <span class=\"built_in\">window</span> <span class=\"comment\">//或全局对象</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用call或apply调用\"><a href=\"#使用call或apply调用\" class=\"headerlink\" title=\"使用call或apply调用\"></a>使用call或apply调用</h3><p>由于this已经在词法层面完成了bound，通过call()或apply()方法调用一个函数时，只是传入了参数而已，对this并没有影响。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> adder = &#123;</span><br><span class=\"line\">  base: <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  add: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = v =&gt; v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(a);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  addThruCall: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = v =&gt; v + <span class=\"keyword\">this</span>.base;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = &#123;</span><br><span class=\"line\">      base : <span class=\"number\">2</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(b,a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.add(<span class=\"number\">1</span>)); <span class=\"comment\">//输出2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(adder.addThruCall(<span class=\"number\">1</span>)); <span class=\"comment\">//仍然输出2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"arguments的词法\"><a href=\"#arguments的词法\" class=\"headerlink\" title=\"arguments的词法\"></a>arguments的词法</h2><p>箭头函数不会在其内部暴露arguments对象：arguments.length,arguments[0],arguments[1]等等，<br>都不会指向箭头函数arguments，而是指向了箭头函数所在作用域的一个名为arguments的值（如果真的有的话，否则，就是undefined）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"built_in\">arguments</span> = <span class=\"number\">42</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = () =&gt; <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">arr(); <span class=\"comment\">//42</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = () =&gt; <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">1</span>); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数没有自己的arguments对象，不过大多数情况下，rest参数可以给出一个解决方案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = (...args) =&gt; args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f(<span class=\"number\">2</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(<span class=\"number\">1</span>); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"使用yield关键字\"><a href=\"#使用yield关键字\" class=\"headerlink\" title=\"使用yield关键字\"></a>使用yield关键字</h3><p>yield关键字通常不在箭头函数中使用。因此，箭头函数不能用作Generator函数</p>\n<h3 id=\"返回对象字面量\"><a href=\"#返回对象字面量\" class=\"headerlink\" title=\"返回对象字面量\"></a>返回对象字面量</h3><p>请牢记，用params =&gt; {object:literal}这种简单的语法返回一个对象字面量是行不通的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = () =&gt; &#123; foo: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\"><span class=\"comment\">//calling func() returns undefined!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = () =&gt; &#123; foo: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"comment\">//SyntaxError: function statement required a name</span></span><br></pre></td></tr></table></figure>\n<p>这是因为花括号(即{})里面的代码被解析为声明序列了(例如，foo被认为是一个label，而非对象字面量里的键)。</p>\n<p>所以，记得用圆括号把对象字面量包起来：<br><code>var func = () =&gt; ({foo:1})</code></p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//一个空箭头函数，返回undefined</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> empty = () =&gt; &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">(() =&gt; <span class=\"string\">\"foobar\"</span>)() <span class=\"comment\">//返回\"foobar\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> simple = a =&gt; a &gt; <span class=\"number\">15</span> ? <span class=\"number\">15</span> : a;</span><br><span class=\"line\">simple(<span class=\"number\">16</span>); <span class=\"comment\">//15</span></span><br><span class=\"line\">simple(<span class=\"number\">10</span>); <span class=\"comment\">//10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> max = (a,b) =&gt; a &gt; b ? a : b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Easy array filtering, mapping, ...</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">13</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">18</span>,<span class=\"number\">23</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = arr.reduce((a,b) =&gt; a + b); <span class=\"comment\">//66</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> even = arr.filter(v =&gt; v % <span class=\"number\">2</span> == <span class=\"number\">0</span>); <span class=\"comment\">//[6,0,18]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> double = arr.map(v =&gt; v * <span class=\"number\">2</span>); <span class=\"comment\">//[10,12,26,0,2,36,46]</span></span><br></pre></td></tr></table></figure>\n"},{"title":"React-Redux文档","date":"2016-05-31T09:58:31.000Z","_content":"> It's an imperfect world, but it's the only one we've got.  \n\n# 快速开始\n在应用中，只有最顶层组件是对Redux可知（例如路由处理）。所有它们的子组件都应该是“笨拙的”，并且 通过props获取数据。\n\n|  | **容器组件** | **展示组件** |\n| ------ | :-------: | :----------- |\n| **位置**\t| 最顶层，路由处理 | 中间和子组件 |\n| **使用Redux**\t| 是 | 否 |\n| **读取数据**\t| 从Redux获取state | 从props获取数据 |\n| **修改数据**\t| 向Redux发起actions | 从props调用回调函数 |\n\n## 不使用Redux的展示组件\n让我们看下，我们拥有一个<Counter />的展示组件，它有一个通过props传过来的值，和一个函数onIncrement，当你点击\"Increment\"按钮时就会调用这个函数：\n```javascript\n  import { Component } from 'react';\n\n  export default class Counter extends Component {\n    render(){\n      return {\n        <button onClick={this.props.onIncrement}>\n          {this.props.value}\n        </button>\n      }\n    }\n  }\n```\n\n## 容器组件使用connect() 方法连接Redux\n我们用react-redux提供的connect()方法将“笨拙”的Counter转化成容器组件。connect()允许你从Redux store中指定准确的state到你想要获取的组件中。这让你能获取到任何级别颗粒度的数据。\n\n`containers/CounterContainer.js`\n\n```javascript\n  import { Compoennt } from 'react';\n  import { connect } from 'react-redux';\n\n  import Counter from '../components/Counter';\n  import { increment } from '../actionsCreators';\n\n  //哪些Redux全局的state是我们组件想要通过props获取的？\n  function mapStateToProps(state){\n    return {\n      value: state.counter\n    }\n  }\n\n  //哪些action创建函数是我们想要通过props获取的？\n  function mapDispatchToProps(dispatch){\n    return {\n      onIncrement: () => dispatch(increment())\n    };\n  }\n\n  export default connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(Counter);\n\n  //你可以传递一个对象，而不是定义一个`mapDispatchToProps`;\n  //export default connect(mapStateToProps, CounterActionCreators)(Counter);\n  //或者如果你想省略`mapDispatchToProps`,你可以通过传递一个`dispatch`作为一个props:\n  //export default connect(mapStateToProps)(Counter);\n\n```\n作为一个展示组件，无论是在同一个文件中调用connect()方法，还是分开调用，都取决于你。你应该考虑的是，是否重用这个组件半丁不同数据。\n\n## 嵌套\n在你的应用任何层次中，你可以拥有很多使用connect()的组件，甚至你可以把它们嵌套使用。的确如此，但是更好的做法是只在最顶层的组件中使用connect(),例如路由处理，这使得应用中的数据流是保持可预知的。\n\n## 修饰器的支持\n你可能会注意到，我们在调用connect()方法的时候使用了两个括号。这个叫做局部调用，并且这允许开发者使用ES7提供的修饰语法：\n```javascript\n  //这是还不稳定的写法！可能在实际的应用中被修改或摒弃\n  @conenct(mapStateToProps)\n  export default class CounterContainer {...}\n```\n不要忘了修饰器还在实验中！在以下的示范中，它们被提取出来，作为一个可以在任何地方调用的函数例子。\n\n## 额外的灵活性\n这是最基础的用法，但connect()也支持很多其他的模式：通过传递一个普通的dispatch()方法，绑定多个action创建函数，把它们传递到一个action prop中，选择一部分state和绑定的action创建函数依赖到props中。\n\n## 注入Redux store\n最后，我们实际上是怎么连接到 Redux store 的呢？我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。对于服务端渲染而言，你可以在处理请求中完成这个。\n\n关键是从 React Redux 将整个视图结构包装进 <Provider>。\n```javascript\n  import ReactDOM from 'react-dom';\n  import { Component } from 'react';\n  import { Provider } from 'react-redux';\n\n  class App extends Component {\n    render() {\n      // ...\n    }\n  }\n\n  const targetEl = document.getElementById('root');\n\n  ReactDOM.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    targetEl\n  );\n```\n\n# API\n## <Provider store>\n<Provider store>是组件层级中connect()方法都能获得Redux store。正常情况下，你的根组件应该嵌套在<Provider>中才能使用connect()方法。\n\n如果你真的不想把根组件嵌套在<Provider>中，你可以把store作为props传递到每一个被connect()包装的组件，但是我们只推荐您在单元测试中对store进行伪造(stub)或者在非完全基于React的代码中才这样做。正常情况下，你应该使用<Provider>\n\n## 属性\n - store(Redux Store): 应用程序中唯一的Redux store对象\n - children(ReactElement) 组件层级的根组件\n\n## 例子\n**React**\n```javascript\n  ReactDOM.render(\n    <Provider store={store}>\n      <MyRootComponent />\n    </Provider>,\n    rootEL\n  )\n```\n\n**React Router 1.0**\n```javascript\n  ReactDOM.render(\n    <Provider store={store}>\n      <Router history={history}>...</Router>\n    </Provider>,\n    targetEl\n  )\n```\n\n`connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])`\n连接React组件与Redux store.\n\n连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。\n\n## 参数\n - [mapStateToProps(state,[ownProps]): stateProps](Function): 如果定义该参数，组件将会监听Redux store的变化。任何时候，只要Redux store发生变化，mapStateToProps函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的props合并。如果你省略了这个参数，你的组件将不会监听Redux store。如果指定了该回调函数中的第二个参数ownProps，则该参数的值为传递到组件的props，而且只要组件接收到新的props，mapStateToProps也会被调用。\n - [mapDispatchToProps(dispatch,[ownProps]): dispatchProps](Object or Function)：如果传递的是一个对象，那么每个定义在该对象的函数都将被当作Redux action creator，而且这个对象会与Redux store绑定在一起，其中所定义的方法名将作为属性名，合并到组件的props中。如果传递的是一个函数，该函数将接收一个dispatch函数，然后由你来决定如何返回一个对象，这个对象通过dispatch函数与action creator以某种方式绑定在一起（提示：你也许会用到Redux的辅助函数bindActionCreators()）.如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。如果你指定了该回调函数中第二个参数ownPros，该参数的值未传递到组件的props，而且只要组件接收到新props，mapDispatchToProps也会被调用。\n - [mergeProps(stateProps,dispatchProps,ownPros): props](Function):如果指定了这个参数，mapStateToProps()与mapDispatchToProps()的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。你也许可以用这个回调函数，根据组件的props来筛选部分的state数据，或者把props中的某个特定变量与action creator绑定在一起。如果你省略这个参数，默认情况下返回Object.assign({},ownPros,stateProps,dispatchProps)的结果。\n - [options](Object) 如果指定这个参数，可以定制connector的行为。\n  - [pure = true](Boolean): 如果为true,connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个\"纯组件\"，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。\n  - [withRef = false](Boolean): 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过getWrappedInstance()方法获得。默认值为false\n\n## 返回值\n根据配置信息，返回一个注入了state和action creator的React组件。\n\n## 静态属性\n - WrappedComponent(Component): 传递到connect()函数的原始组件类。\n\n## 静态方法\n组件原来的静态方法都被提升到被包装的React组件。\n\n## 实例方法\ngetWrappedInstance(): ReactComponent\n仅当connect()函数的第四个参数options设置了{withRef: true}才返回被包装的组件示例。\n\n## 备注\n - 函数将被调用两次。第一次是设置参数，第二次是组件与React store连接：connect(mapStateToProps,mapDispatchToProps,mergeProps)(MyComponent).\n - connect函数不会修改传入的React组件，返回的是一个新的已与Redux store连接的组件，而且你应该使用这个新组件。\n - mapStateToProps函数接收整个Redux store的state作为props，然后返回一个传入到组件props的对象。该函数被称之为selector。参考使用reselect高效地组合多个selector，并对收集到的数据进行处理。\n\n## Example例子\n**只注入dispatch，不监听store**\n`export default conenct(){TodoApp};`\n\n**注入dispatch和全局state**\n> 不要这样做！这会导致每次action都触发整个TodoApp重新渲染，你做的所有性能优化都将付之东流。最好在多个组件上使用connect()，每个组件只监听它所关联的部分state.  \n\n`export default connect(state => state)(TodoApp)`\n\n**注入dispatch和todos**\n```javascript\n  function mapStateToProps(state){\n    return {\n      todos: state.todos\n    };\n  }\n\n  export default conenct(mapStateToProps)(TodoApp);\n```\n\n**注入todos和所有action creator(addTodo,completeTodo,...)**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n\n  function mapStateToProps(state){\n    return {\n      todos: state.todos\n    }\n  }\n\n  export default connect(mapStateToProps,actionsCreators)(TodoApp);\n```\n\n**注入todos并把所有action creator作为actions属性也注入组件中**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {todos: state.todos};\n  }\n\n  function mapDispatchToProps(dispatch){\n    return {actions: bindActionCreators(actionsCreators,dispatch)};\n  }\n\n  export dfault connect(mapStateToProps,mapDispatchToProps)(TodoApp)\n```\n\n**注入todos和指定的action creator(addTodo)**\n```javascript\n  import { addTodo } from './actionsCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {\n      todo: state.todos\n    }\n  }\n\n  function mapDispatchToProps(dispatch){\n    return bindActionCreators({addTodo},dispatch);\n  }\n\n  export default connect(mapStateToProps,mapDispatchToProps)(TodoApp);\n```\n\n**注入todos并把todoActionCreators作为todoActions属性、counterActionCreators作为counterActions属性注入到组件中**\n```javascript\n  import * as todoActionCreators from './todoActionCreators';\n  import * as counterActionCreators from './counterActionCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {todos: state.todo};\n  }\n\n  function mapDispatchToProps(dispatch){\n    return {\n      todoActions: bindActionCreators(todoActionCreators,dispatch),\n      counterActions: bindActionCreators(counterActionCreators,dispatch)\n    };\n  }\n\n  export default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n**注入todos并把todoActionCreators与counterActionCreators一同作为actions属性注入到组件中**\n```javascript\n  import * as todoActionCreators from './todoActionCreators';\n  import * as counterActionCreators from './counterActionCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return { todos: state.todos };\n  }\n\n  function mapDispatchToProps(dispatch){\n    return {\n      actions: bindActionCreators(Object.assign({},todoActionCreators,counterActionCreators),dispatch)\n    }\n  }\n\n  export default connect(mapStateToProps,mapDispatchToProps)(TodoApp);\n```\n\n**注入todos并把所有的todoActionCreators和counterActionCreators作为props注入到组件中**\n```javascript\n  import * as todoActionCreators from './todoActionCreators';\n  import * as counterActionCreators from './counterActionCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {todos: state.todo}\n  }\n\n  function mapDispatchToProps(dispatch){\n    return bindActionCreators(Object.assign({}, todoActionCreators,counterActionCreators),dispatch);\n  }\n\n  export default connect(mapStateToProps,mapDispatchToProps)(TodoApp);\n```\n\n**根据组件的props注入特定用户的todos**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n\n  function mapStateToProps(state,ownProps){\n    return {todos: state.todos[ownProps.userId]};\n  }\n\n  export default connect(mapStateToProps)(TodoApp);\n```\n\n**根据组件的props注入特定用户的todos并把props.userId传入到action中**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n\n  function mapStateToProps(state){\n    return {todos: state.todos};\n  }\n\n  function mergeProps(stateProps,dispatchProps,ownProps){\n    return Object.assign({},ownProps,{\n      todos: stateProps.todos[ownProps.userId],\n      addTodo: (text) => dispatchProps.addTodo(ownProps.userId,text)\n    });\n  }\n\n  export default connect(mapStateToProps,actionsCreators,mergeProps)(TodoApp);\n```\n\n# 排错\n这里会列出常见的问题和对应的解决方案。\n","source":"_posts/React-Redux文档.md","raw":"---\ntitle: React-Redux文档\ndate: 2016-05-31 17:58:31\ntags:\n  - react\n  - Redux\ncategories: 转载笔记\n---\n> It's an imperfect world, but it's the only one we've got.  \n\n# 快速开始\n在应用中，只有最顶层组件是对Redux可知（例如路由处理）。所有它们的子组件都应该是“笨拙的”，并且 通过props获取数据。\n\n|  | **容器组件** | **展示组件** |\n| ------ | :-------: | :----------- |\n| **位置**\t| 最顶层，路由处理 | 中间和子组件 |\n| **使用Redux**\t| 是 | 否 |\n| **读取数据**\t| 从Redux获取state | 从props获取数据 |\n| **修改数据**\t| 向Redux发起actions | 从props调用回调函数 |\n\n## 不使用Redux的展示组件\n让我们看下，我们拥有一个<Counter />的展示组件，它有一个通过props传过来的值，和一个函数onIncrement，当你点击\"Increment\"按钮时就会调用这个函数：\n```javascript\n  import { Component } from 'react';\n\n  export default class Counter extends Component {\n    render(){\n      return {\n        <button onClick={this.props.onIncrement}>\n          {this.props.value}\n        </button>\n      }\n    }\n  }\n```\n\n## 容器组件使用connect() 方法连接Redux\n我们用react-redux提供的connect()方法将“笨拙”的Counter转化成容器组件。connect()允许你从Redux store中指定准确的state到你想要获取的组件中。这让你能获取到任何级别颗粒度的数据。\n\n`containers/CounterContainer.js`\n\n```javascript\n  import { Compoennt } from 'react';\n  import { connect } from 'react-redux';\n\n  import Counter from '../components/Counter';\n  import { increment } from '../actionsCreators';\n\n  //哪些Redux全局的state是我们组件想要通过props获取的？\n  function mapStateToProps(state){\n    return {\n      value: state.counter\n    }\n  }\n\n  //哪些action创建函数是我们想要通过props获取的？\n  function mapDispatchToProps(dispatch){\n    return {\n      onIncrement: () => dispatch(increment())\n    };\n  }\n\n  export default connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(Counter);\n\n  //你可以传递一个对象，而不是定义一个`mapDispatchToProps`;\n  //export default connect(mapStateToProps, CounterActionCreators)(Counter);\n  //或者如果你想省略`mapDispatchToProps`,你可以通过传递一个`dispatch`作为一个props:\n  //export default connect(mapStateToProps)(Counter);\n\n```\n作为一个展示组件，无论是在同一个文件中调用connect()方法，还是分开调用，都取决于你。你应该考虑的是，是否重用这个组件半丁不同数据。\n\n## 嵌套\n在你的应用任何层次中，你可以拥有很多使用connect()的组件，甚至你可以把它们嵌套使用。的确如此，但是更好的做法是只在最顶层的组件中使用connect(),例如路由处理，这使得应用中的数据流是保持可预知的。\n\n## 修饰器的支持\n你可能会注意到，我们在调用connect()方法的时候使用了两个括号。这个叫做局部调用，并且这允许开发者使用ES7提供的修饰语法：\n```javascript\n  //这是还不稳定的写法！可能在实际的应用中被修改或摒弃\n  @conenct(mapStateToProps)\n  export default class CounterContainer {...}\n```\n不要忘了修饰器还在实验中！在以下的示范中，它们被提取出来，作为一个可以在任何地方调用的函数例子。\n\n## 额外的灵活性\n这是最基础的用法，但connect()也支持很多其他的模式：通过传递一个普通的dispatch()方法，绑定多个action创建函数，把它们传递到一个action prop中，选择一部分state和绑定的action创建函数依赖到props中。\n\n## 注入Redux store\n最后，我们实际上是怎么连接到 Redux store 的呢？我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。对于服务端渲染而言，你可以在处理请求中完成这个。\n\n关键是从 React Redux 将整个视图结构包装进 <Provider>。\n```javascript\n  import ReactDOM from 'react-dom';\n  import { Component } from 'react';\n  import { Provider } from 'react-redux';\n\n  class App extends Component {\n    render() {\n      // ...\n    }\n  }\n\n  const targetEl = document.getElementById('root');\n\n  ReactDOM.render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    targetEl\n  );\n```\n\n# API\n## <Provider store>\n<Provider store>是组件层级中connect()方法都能获得Redux store。正常情况下，你的根组件应该嵌套在<Provider>中才能使用connect()方法。\n\n如果你真的不想把根组件嵌套在<Provider>中，你可以把store作为props传递到每一个被connect()包装的组件，但是我们只推荐您在单元测试中对store进行伪造(stub)或者在非完全基于React的代码中才这样做。正常情况下，你应该使用<Provider>\n\n## 属性\n - store(Redux Store): 应用程序中唯一的Redux store对象\n - children(ReactElement) 组件层级的根组件\n\n## 例子\n**React**\n```javascript\n  ReactDOM.render(\n    <Provider store={store}>\n      <MyRootComponent />\n    </Provider>,\n    rootEL\n  )\n```\n\n**React Router 1.0**\n```javascript\n  ReactDOM.render(\n    <Provider store={store}>\n      <Router history={history}>...</Router>\n    </Provider>,\n    targetEl\n  )\n```\n\n`connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])`\n连接React组件与Redux store.\n\n连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。\n\n## 参数\n - [mapStateToProps(state,[ownProps]): stateProps](Function): 如果定义该参数，组件将会监听Redux store的变化。任何时候，只要Redux store发生变化，mapStateToProps函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的props合并。如果你省略了这个参数，你的组件将不会监听Redux store。如果指定了该回调函数中的第二个参数ownProps，则该参数的值为传递到组件的props，而且只要组件接收到新的props，mapStateToProps也会被调用。\n - [mapDispatchToProps(dispatch,[ownProps]): dispatchProps](Object or Function)：如果传递的是一个对象，那么每个定义在该对象的函数都将被当作Redux action creator，而且这个对象会与Redux store绑定在一起，其中所定义的方法名将作为属性名，合并到组件的props中。如果传递的是一个函数，该函数将接收一个dispatch函数，然后由你来决定如何返回一个对象，这个对象通过dispatch函数与action creator以某种方式绑定在一起（提示：你也许会用到Redux的辅助函数bindActionCreators()）.如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。如果你指定了该回调函数中第二个参数ownPros，该参数的值未传递到组件的props，而且只要组件接收到新props，mapDispatchToProps也会被调用。\n - [mergeProps(stateProps,dispatchProps,ownPros): props](Function):如果指定了这个参数，mapStateToProps()与mapDispatchToProps()的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。你也许可以用这个回调函数，根据组件的props来筛选部分的state数据，或者把props中的某个特定变量与action creator绑定在一起。如果你省略这个参数，默认情况下返回Object.assign({},ownPros,stateProps,dispatchProps)的结果。\n - [options](Object) 如果指定这个参数，可以定制connector的行为。\n  - [pure = true](Boolean): 如果为true,connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个\"纯组件\"，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。\n  - [withRef = false](Boolean): 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过getWrappedInstance()方法获得。默认值为false\n\n## 返回值\n根据配置信息，返回一个注入了state和action creator的React组件。\n\n## 静态属性\n - WrappedComponent(Component): 传递到connect()函数的原始组件类。\n\n## 静态方法\n组件原来的静态方法都被提升到被包装的React组件。\n\n## 实例方法\ngetWrappedInstance(): ReactComponent\n仅当connect()函数的第四个参数options设置了{withRef: true}才返回被包装的组件示例。\n\n## 备注\n - 函数将被调用两次。第一次是设置参数，第二次是组件与React store连接：connect(mapStateToProps,mapDispatchToProps,mergeProps)(MyComponent).\n - connect函数不会修改传入的React组件，返回的是一个新的已与Redux store连接的组件，而且你应该使用这个新组件。\n - mapStateToProps函数接收整个Redux store的state作为props，然后返回一个传入到组件props的对象。该函数被称之为selector。参考使用reselect高效地组合多个selector，并对收集到的数据进行处理。\n\n## Example例子\n**只注入dispatch，不监听store**\n`export default conenct(){TodoApp};`\n\n**注入dispatch和全局state**\n> 不要这样做！这会导致每次action都触发整个TodoApp重新渲染，你做的所有性能优化都将付之东流。最好在多个组件上使用connect()，每个组件只监听它所关联的部分state.  \n\n`export default connect(state => state)(TodoApp)`\n\n**注入dispatch和todos**\n```javascript\n  function mapStateToProps(state){\n    return {\n      todos: state.todos\n    };\n  }\n\n  export default conenct(mapStateToProps)(TodoApp);\n```\n\n**注入todos和所有action creator(addTodo,completeTodo,...)**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n\n  function mapStateToProps(state){\n    return {\n      todos: state.todos\n    }\n  }\n\n  export default connect(mapStateToProps,actionsCreators)(TodoApp);\n```\n\n**注入todos并把所有action creator作为actions属性也注入组件中**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {todos: state.todos};\n  }\n\n  function mapDispatchToProps(dispatch){\n    return {actions: bindActionCreators(actionsCreators,dispatch)};\n  }\n\n  export dfault connect(mapStateToProps,mapDispatchToProps)(TodoApp)\n```\n\n**注入todos和指定的action creator(addTodo)**\n```javascript\n  import { addTodo } from './actionsCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {\n      todo: state.todos\n    }\n  }\n\n  function mapDispatchToProps(dispatch){\n    return bindActionCreators({addTodo},dispatch);\n  }\n\n  export default connect(mapStateToProps,mapDispatchToProps)(TodoApp);\n```\n\n**注入todos并把todoActionCreators作为todoActions属性、counterActionCreators作为counterActions属性注入到组件中**\n```javascript\n  import * as todoActionCreators from './todoActionCreators';\n  import * as counterActionCreators from './counterActionCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {todos: state.todo};\n  }\n\n  function mapDispatchToProps(dispatch){\n    return {\n      todoActions: bindActionCreators(todoActionCreators,dispatch),\n      counterActions: bindActionCreators(counterActionCreators,dispatch)\n    };\n  }\n\n  export default connect(mapStateToProps, mapDispatchToProps)(TodoApp);\n```\n\n**注入todos并把todoActionCreators与counterActionCreators一同作为actions属性注入到组件中**\n```javascript\n  import * as todoActionCreators from './todoActionCreators';\n  import * as counterActionCreators from './counterActionCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return { todos: state.todos };\n  }\n\n  function mapDispatchToProps(dispatch){\n    return {\n      actions: bindActionCreators(Object.assign({},todoActionCreators,counterActionCreators),dispatch)\n    }\n  }\n\n  export default connect(mapStateToProps,mapDispatchToProps)(TodoApp);\n```\n\n**注入todos并把所有的todoActionCreators和counterActionCreators作为props注入到组件中**\n```javascript\n  import * as todoActionCreators from './todoActionCreators';\n  import * as counterActionCreators from './counterActionCreators';\n  import { bindActionCreators } from 'redux';\n\n  function mapStateToProps(state){\n    return {todos: state.todo}\n  }\n\n  function mapDispatchToProps(dispatch){\n    return bindActionCreators(Object.assign({}, todoActionCreators,counterActionCreators),dispatch);\n  }\n\n  export default connect(mapStateToProps,mapDispatchToProps)(TodoApp);\n```\n\n**根据组件的props注入特定用户的todos**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n\n  function mapStateToProps(state,ownProps){\n    return {todos: state.todos[ownProps.userId]};\n  }\n\n  export default connect(mapStateToProps)(TodoApp);\n```\n\n**根据组件的props注入特定用户的todos并把props.userId传入到action中**\n```javascript\n  import * as actionsCreators from './actionsCreators';\n\n  function mapStateToProps(state){\n    return {todos: state.todos};\n  }\n\n  function mergeProps(stateProps,dispatchProps,ownProps){\n    return Object.assign({},ownProps,{\n      todos: stateProps.todos[ownProps.userId],\n      addTodo: (text) => dispatchProps.addTodo(ownProps.userId,text)\n    });\n  }\n\n  export default connect(mapStateToProps,actionsCreators,mergeProps)(TodoApp);\n```\n\n# 排错\n这里会列出常见的问题和对应的解决方案。\n","slug":"React-Redux文档","published":1,"updated":"2016-06-01T07:46:03.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emf000gb0dl51elblh5","content":"<blockquote>\n<p>It’s an imperfect world, but it’s the only one we’ve got.  </p>\n</blockquote>\n<h1 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h1><p>在应用中，只有最顶层组件是对Redux可知（例如路由处理）。所有它们的子组件都应该是“笨拙的”，并且 通过props获取数据。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\"><strong>容器组件</strong></th>\n<th style=\"text-align:left\"><strong>展示组件</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>位置</strong></td>\n<td style=\"text-align:center\">最顶层，路由处理</td>\n<td style=\"text-align:left\">中间和子组件</td>\n</tr>\n<tr>\n<td><strong>使用Redux</strong></td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td><strong>读取数据</strong></td>\n<td style=\"text-align:center\">从Redux获取state</td>\n<td style=\"text-align:left\">从props获取数据</td>\n</tr>\n<tr>\n<td><strong>修改数据</strong></td>\n<td style=\"text-align:center\">向Redux发起actions</td>\n<td style=\"text-align:left\">从props调用回调函数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"不使用Redux的展示组件\"><a href=\"#不使用Redux的展示组件\" class=\"headerlink\" title=\"不使用Redux的展示组件\"></a>不使用Redux的展示组件</h2><p>让我们看下，我们拥有一个<counter>的展示组件，它有一个通过props传过来的值，和一个函数onIncrement，当你点击”Increment”按钮时就会调用这个函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;</span><br><span class=\"line\">        &#123;this.props.value&#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></counter></p>\n<h2 id=\"容器组件使用connect-方法连接Redux\"><a href=\"#容器组件使用connect-方法连接Redux\" class=\"headerlink\" title=\"容器组件使用connect() 方法连接Redux\"></a>容器组件使用connect() 方法连接Redux</h2><p>我们用react-redux提供的connect()方法将“笨拙”的Counter转化成容器组件。connect()允许你从Redux store中指定准确的state到你想要获取的组件中。这让你能获取到任何级别颗粒度的数据。</p>\n<p><code>containers/CounterContainer.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Compoennt &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; increment &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哪些Redux全局的state是我们组件想要通过props获取的？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    value: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哪些action创建函数是我们想要通过props获取的？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    onIncrement: () =&gt; dispatch(increment())</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Counter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//你可以传递一个对象，而不是定义一个`mapDispatchToProps`;</span></span><br><span class=\"line\"><span class=\"comment\">//export default connect(mapStateToProps, CounterActionCreators)(Counter);</span></span><br><span class=\"line\"><span class=\"comment\">//或者如果你想省略`mapDispatchToProps`,你可以通过传递一个`dispatch`作为一个props:</span></span><br><span class=\"line\"><span class=\"comment\">//export default connect(mapStateToProps)(Counter);</span></span><br></pre></td></tr></table></figure>\n<p>作为一个展示组件，无论是在同一个文件中调用connect()方法，还是分开调用，都取决于你。你应该考虑的是，是否重用这个组件半丁不同数据。</p>\n<h2 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h2><p>在你的应用任何层次中，你可以拥有很多使用connect()的组件，甚至你可以把它们嵌套使用。的确如此，但是更好的做法是只在最顶层的组件中使用connect(),例如路由处理，这使得应用中的数据流是保持可预知的。</p>\n<h2 id=\"修饰器的支持\"><a href=\"#修饰器的支持\" class=\"headerlink\" title=\"修饰器的支持\"></a>修饰器的支持</h2><p>你可能会注意到，我们在调用connect()方法的时候使用了两个括号。这个叫做局部调用，并且这允许开发者使用ES7提供的修饰语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是还不稳定的写法！可能在实际的应用中被修改或摒弃</span></span><br><span class=\"line\">@conenct(mapStateToProps)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterContainer</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不要忘了修饰器还在实验中！在以下的示范中，它们被提取出来，作为一个可以在任何地方调用的函数例子。</p>\n<h2 id=\"额外的灵活性\"><a href=\"#额外的灵活性\" class=\"headerlink\" title=\"额外的灵活性\"></a>额外的灵活性</h2><p>这是最基础的用法，但connect()也支持很多其他的模式：通过传递一个普通的dispatch()方法，绑定多个action创建函数，把它们传递到一个action prop中，选择一部分state和绑定的action创建函数依赖到props中。</p>\n<h2 id=\"注入Redux-store\"><a href=\"#注入Redux-store\" class=\"headerlink\" title=\"注入Redux store\"></a>注入Redux store</h2><p>最后，我们实际上是怎么连接到 Redux store 的呢？我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。对于服务端渲染而言，你可以在处理请求中完成这个。</p>\n<p>关键是从 React Redux 将整个视图结构包装进 <provider>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetEl = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  targetEl</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></provider></p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><provider store=\"\"></provider></h2><p><provider store=\"\">是组件层级中connect()方法都能获得Redux store。正常情况下，你的根组件应该嵌套在<provider>中才能使用connect()方法。</provider></provider></p>\n<p>如果你真的不想把根组件嵌套在<provider>中，你可以把store作为props传递到每一个被connect()包装的组件，但是我们只推荐您在单元测试中对store进行伪造(stub)或者在非完全基于React的代码中才这样做。正常情况下，你应该使用<provider></provider></provider></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li>store(Redux Store): 应用程序中唯一的Redux store对象</li>\n<li>children(ReactElement) 组件层级的根组件</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><strong>React</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;MyRootComponent /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  rootEL</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><strong>React Router 1.0</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  targetEl</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])</code><br>连接React组件与Redux store.</p>\n<p>连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li><a href=\"Function\">mapStateToProps(state,[ownProps]): stateProps</a>: 如果定义该参数，组件将会监听Redux store的变化。任何时候，只要Redux store发生变化，mapStateToProps函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的props合并。如果你省略了这个参数，你的组件将不会监听Redux store。如果指定了该回调函数中的第二个参数ownProps，则该参数的值为传递到组件的props，而且只要组件接收到新的props，mapStateToProps也会被调用。</li>\n<li><a href=\"Object or Function\">mapDispatchToProps(dispatch,[ownProps]): dispatchProps</a>：如果传递的是一个对象，那么每个定义在该对象的函数都将被当作Redux action creator，而且这个对象会与Redux store绑定在一起，其中所定义的方法名将作为属性名，合并到组件的props中。如果传递的是一个函数，该函数将接收一个dispatch函数，然后由你来决定如何返回一个对象，这个对象通过dispatch函数与action creator以某种方式绑定在一起（提示：你也许会用到Redux的辅助函数bindActionCreators()）.如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。如果你指定了该回调函数中第二个参数ownPros，该参数的值未传递到组件的props，而且只要组件接收到新props，mapDispatchToProps也会被调用。</li>\n<li><a href=\"Function\">mergeProps(stateProps,dispatchProps,ownPros): props</a>:如果指定了这个参数，mapStateToProps()与mapDispatchToProps()的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。你也许可以用这个回调函数，根据组件的props来筛选部分的state数据，或者把props中的某个特定变量与action creator绑定在一起。如果你省略这个参数，默认情况下返回Object.assign({},ownPros,stateProps,dispatchProps)的结果。</li>\n<li><a href=\"Object\">options</a> 如果指定这个参数，可以定制connector的行为。<ul>\n<li><a href=\"Boolean\">pure = true</a>: 如果为true,connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个”纯组件”，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。</li>\n<li><a href=\"Boolean\">withRef = false</a>: 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过getWrappedInstance()方法获得。默认值为false</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>根据配置信息，返回一个注入了state和action creator的React组件。</p>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ul>\n<li>WrappedComponent(Component): 传递到connect()函数的原始组件类。</li>\n</ul>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>组件原来的静态方法都被提升到被包装的React组件。</p>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><p>getWrappedInstance(): ReactComponent<br>仅当connect()函数的第四个参数options设置了{withRef: true}才返回被包装的组件示例。</p>\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><ul>\n<li>函数将被调用两次。第一次是设置参数，第二次是组件与React store连接：connect(mapStateToProps,mapDispatchToProps,mergeProps)(MyComponent).</li>\n<li>connect函数不会修改传入的React组件，返回的是一个新的已与Redux store连接的组件，而且你应该使用这个新组件。</li>\n<li>mapStateToProps函数接收整个Redux store的state作为props，然后返回一个传入到组件props的对象。该函数被称之为selector。参考使用reselect高效地组合多个selector，并对收集到的数据进行处理。</li>\n</ul>\n<h2 id=\"Example例子\"><a href=\"#Example例子\" class=\"headerlink\" title=\"Example例子\"></a>Example例子</h2><p><strong>只注入dispatch，不监听store</strong><br><code>export default conenct(){TodoApp};</code></p>\n<p><strong>注入dispatch和全局state</strong></p>\n<blockquote>\n<p>不要这样做！这会导致每次action都触发整个TodoApp重新渲染，你做的所有性能优化都将付之东流。最好在多个组件上使用connect()，每个组件只监听它所关联的部分state.  </p>\n</blockquote>\n<p><code>export default connect(state =&gt; state)(TodoApp)</code></p>\n<p><strong>注入dispatch和todos</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todos: state.todos</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> conenct(mapStateToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos和所有action creator(addTodo,completeTodo,…)</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todos: state.todos</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,actionsCreators)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把所有action creator作为actions属性也注入组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todos&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;actions: bindActionCreators(actionsCreators,dispatch)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> dfault connect(mapStateToProps,mapDispatchToProps)(TodoApp)</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos和指定的action creator(addTodo)</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; addTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todo: state.todos</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreators(&#123;addTodo&#125;,dispatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把todoActionCreators作为todoActions属性、counterActionCreators作为counterActions属性注入到组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> todoActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./todoActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> counterActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./counterActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todo&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todoActions: bindActionCreators(todoActionCreators,dispatch),</span><br><span class=\"line\">    counterActions: bindActionCreators(counterActionCreators,dispatch)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把todoActionCreators与counterActionCreators一同作为actions属性注入到组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> todoActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./todoActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> counterActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./counterActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; todos: state.todos &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    actions: bindActionCreators(<span class=\"built_in\">Object</span>.assign(&#123;&#125;,todoActionCreators,counterActionCreators),dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把所有的todoActionCreators和counterActionCreators作为props注入到组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> todoActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./todoActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> counterActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./counterActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todo&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreators(<span class=\"built_in\">Object</span>.assign(&#123;&#125;, todoActionCreators,counterActionCreators),dispatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>根据组件的props注入特定用户的todos</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state,ownProps</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todos[ownProps.userId]&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>根据组件的props注入特定用户的todos并把props.userId传入到action中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todos&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeProps</span>(<span class=\"params\">stateProps,dispatchProps,ownProps</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;,ownProps,&#123;</span><br><span class=\"line\">    todos: stateProps.todos[ownProps.userId],</span><br><span class=\"line\">    addTodo: (text) =&gt; dispatchProps.addTodo(ownProps.userId,text)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,actionsCreators,mergeProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"排错\"><a href=\"#排错\" class=\"headerlink\" title=\"排错\"></a>排错</h1><p>这里会列出常见的问题和对应的解决方案。</p>\n","excerpt":"","more":"<blockquote>\n<p>It’s an imperfect world, but it’s the only one we’ve got.  </p>\n</blockquote>\n<h1 id=\"快速开始\"><a href=\"#快速开始\" class=\"headerlink\" title=\"快速开始\"></a>快速开始</h1><p>在应用中，只有最顶层组件是对Redux可知（例如路由处理）。所有它们的子组件都应该是“笨拙的”，并且 通过props获取数据。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\"><strong>容器组件</strong></th>\n<th style=\"text-align:left\"><strong>展示组件</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>位置</strong></td>\n<td style=\"text-align:center\">最顶层，路由处理</td>\n<td style=\"text-align:left\">中间和子组件</td>\n</tr>\n<tr>\n<td><strong>使用Redux</strong></td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td><strong>读取数据</strong></td>\n<td style=\"text-align:center\">从Redux获取state</td>\n<td style=\"text-align:left\">从props获取数据</td>\n</tr>\n<tr>\n<td><strong>修改数据</strong></td>\n<td style=\"text-align:center\">向Redux发起actions</td>\n<td style=\"text-align:left\">从props调用回调函数</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"不使用Redux的展示组件\"><a href=\"#不使用Redux的展示组件\" class=\"headerlink\" title=\"不使用Redux的展示组件\"></a>不使用Redux的展示组件</h2><p>让我们看下，我们拥有一个<Counter />的展示组件，它有一个通过props传过来的值，和一个函数onIncrement，当你点击”Increment”按钮时就会调用这个函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;</span><br><span class=\"line\">        &#123;this.props.value&#125;</span><br><span class=\"line\">      &lt;/button&gt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"容器组件使用connect-方法连接Redux\"><a href=\"#容器组件使用connect-方法连接Redux\" class=\"headerlink\" title=\"容器组件使用connect() 方法连接Redux\"></a>容器组件使用connect() 方法连接Redux</h2><p>我们用react-redux提供的connect()方法将“笨拙”的Counter转化成容器组件。connect()允许你从Redux store中指定准确的state到你想要获取的组件中。这让你能获取到任何级别颗粒度的数据。</p>\n<p><code>containers/CounterContainer.js</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Compoennt &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Counter <span class=\"keyword\">from</span> <span class=\"string\">'../components/Counter'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; increment &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哪些Redux全局的state是我们组件想要通过props获取的？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    value: state.counter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//哪些action创建函数是我们想要通过props获取的？</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    onIncrement: () =&gt; dispatch(increment())</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(Counter);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//你可以传递一个对象，而不是定义一个`mapDispatchToProps`;</span></span><br><span class=\"line\"><span class=\"comment\">//export default connect(mapStateToProps, CounterActionCreators)(Counter);</span></span><br><span class=\"line\"><span class=\"comment\">//或者如果你想省略`mapDispatchToProps`,你可以通过传递一个`dispatch`作为一个props:</span></span><br><span class=\"line\"><span class=\"comment\">//export default connect(mapStateToProps)(Counter);</span></span><br></pre></td></tr></table></figure>\n<p>作为一个展示组件，无论是在同一个文件中调用connect()方法，还是分开调用，都取决于你。你应该考虑的是，是否重用这个组件半丁不同数据。</p>\n<h2 id=\"嵌套\"><a href=\"#嵌套\" class=\"headerlink\" title=\"嵌套\"></a>嵌套</h2><p>在你的应用任何层次中，你可以拥有很多使用connect()的组件，甚至你可以把它们嵌套使用。的确如此，但是更好的做法是只在最顶层的组件中使用connect(),例如路由处理，这使得应用中的数据流是保持可预知的。</p>\n<h2 id=\"修饰器的支持\"><a href=\"#修饰器的支持\" class=\"headerlink\" title=\"修饰器的支持\"></a>修饰器的支持</h2><p>你可能会注意到，我们在调用connect()方法的时候使用了两个括号。这个叫做局部调用，并且这允许开发者使用ES7提供的修饰语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是还不稳定的写法！可能在实际的应用中被修改或摒弃</span></span><br><span class=\"line\">@conenct(mapStateToProps)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterContainer</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>不要忘了修饰器还在实验中！在以下的示范中，它们被提取出来，作为一个可以在任何地方调用的函数例子。</p>\n<h2 id=\"额外的灵活性\"><a href=\"#额外的灵活性\" class=\"headerlink\" title=\"额外的灵活性\"></a>额外的灵活性</h2><p>这是最基础的用法，但connect()也支持很多其他的模式：通过传递一个普通的dispatch()方法，绑定多个action创建函数，把它们传递到一个action prop中，选择一部分state和绑定的action创建函数依赖到props中。</p>\n<h2 id=\"注入Redux-store\"><a href=\"#注入Redux-store\" class=\"headerlink\" title=\"注入Redux store\"></a>注入Redux store</h2><p>最后，我们实际上是怎么连接到 Redux store 的呢？我们需要在根组件中创建这个 store。对于客户端应用而言，根组件是一个很好的地方。对于服务端渲染而言，你可以在处理请求中完成这个。</p>\n<p>关键是从 React Redux 将整个视图结构包装进 <Provider>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> targetEl = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'root'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  targetEl</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><Provider store></h2><p><Provider store>是组件层级中connect()方法都能获得Redux store。正常情况下，你的根组件应该嵌套在<Provider>中才能使用connect()方法。</p>\n<p>如果你真的不想把根组件嵌套在<Provider>中，你可以把store作为props传递到每一个被connect()包装的组件，但是我们只推荐您在单元测试中对store进行伪造(stub)或者在非完全基于React的代码中才这样做。正常情况下，你应该使用<Provider></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li>store(Redux Store): 应用程序中唯一的Redux store对象</li>\n<li>children(ReactElement) 组件层级的根组件</li>\n</ul>\n<h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p><strong>React</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;MyRootComponent /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  rootEL</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><strong>React Router 1.0</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;Router history=&#123;history&#125;&gt;...&lt;/Router&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  targetEl</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options])</code><br>连接React组件与Redux store.</p>\n<p>连接操作不会改变原来的组件类，反而返回一个新的已与 Redux store 连接的组件类。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><ul>\n<li><a href=\"Function\">mapStateToProps(state,[ownProps]): stateProps</a>: 如果定义该参数，组件将会监听Redux store的变化。任何时候，只要Redux store发生变化，mapStateToProps函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的props合并。如果你省略了这个参数，你的组件将不会监听Redux store。如果指定了该回调函数中的第二个参数ownProps，则该参数的值为传递到组件的props，而且只要组件接收到新的props，mapStateToProps也会被调用。</li>\n<li><a href=\"Object or Function\">mapDispatchToProps(dispatch,[ownProps]): dispatchProps</a>：如果传递的是一个对象，那么每个定义在该对象的函数都将被当作Redux action creator，而且这个对象会与Redux store绑定在一起，其中所定义的方法名将作为属性名，合并到组件的props中。如果传递的是一个函数，该函数将接收一个dispatch函数，然后由你来决定如何返回一个对象，这个对象通过dispatch函数与action creator以某种方式绑定在一起（提示：你也许会用到Redux的辅助函数bindActionCreators()）.如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。如果你指定了该回调函数中第二个参数ownPros，该参数的值未传递到组件的props，而且只要组件接收到新props，mapDispatchToProps也会被调用。</li>\n<li><a href=\"Function\">mergeProps(stateProps,dispatchProps,ownPros): props</a>:如果指定了这个参数，mapStateToProps()与mapDispatchToProps()的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。你也许可以用这个回调函数，根据组件的props来筛选部分的state数据，或者把props中的某个特定变量与action creator绑定在一起。如果你省略这个参数，默认情况下返回Object.assign({},ownPros,stateProps,dispatchProps)的结果。</li>\n<li><a href=\"Object\">options</a> 如果指定这个参数，可以定制connector的行为。<ul>\n<li><a href=\"Boolean\">pure = true</a>: 如果为true,connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个”纯组件”，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。</li>\n<li><a href=\"Boolean\">withRef = false</a>: 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过getWrappedInstance()方法获得。默认值为false</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"返回值\"><a href=\"#返回值\" class=\"headerlink\" title=\"返回值\"></a>返回值</h2><p>根据配置信息，返回一个注入了state和action creator的React组件。</p>\n<h2 id=\"静态属性\"><a href=\"#静态属性\" class=\"headerlink\" title=\"静态属性\"></a>静态属性</h2><ul>\n<li>WrappedComponent(Component): 传递到connect()函数的原始组件类。</li>\n</ul>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><p>组件原来的静态方法都被提升到被包装的React组件。</p>\n<h2 id=\"实例方法\"><a href=\"#实例方法\" class=\"headerlink\" title=\"实例方法\"></a>实例方法</h2><p>getWrappedInstance(): ReactComponent<br>仅当connect()函数的第四个参数options设置了{withRef: true}才返回被包装的组件示例。</p>\n<h2 id=\"备注\"><a href=\"#备注\" class=\"headerlink\" title=\"备注\"></a>备注</h2><ul>\n<li>函数将被调用两次。第一次是设置参数，第二次是组件与React store连接：connect(mapStateToProps,mapDispatchToProps,mergeProps)(MyComponent).</li>\n<li>connect函数不会修改传入的React组件，返回的是一个新的已与Redux store连接的组件，而且你应该使用这个新组件。</li>\n<li>mapStateToProps函数接收整个Redux store的state作为props，然后返回一个传入到组件props的对象。该函数被称之为selector。参考使用reselect高效地组合多个selector，并对收集到的数据进行处理。</li>\n</ul>\n<h2 id=\"Example例子\"><a href=\"#Example例子\" class=\"headerlink\" title=\"Example例子\"></a>Example例子</h2><p><strong>只注入dispatch，不监听store</strong><br><code>export default conenct(){TodoApp};</code></p>\n<p><strong>注入dispatch和全局state</strong></p>\n<blockquote>\n<p>不要这样做！这会导致每次action都触发整个TodoApp重新渲染，你做的所有性能优化都将付之东流。最好在多个组件上使用connect()，每个组件只监听它所关联的部分state.  </p>\n</blockquote>\n<p><code>export default connect(state =&gt; state)(TodoApp)</code></p>\n<p><strong>注入dispatch和todos</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todos: state.todos</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> conenct(mapStateToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos和所有action creator(addTodo,completeTodo,…)</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todos: state.todos</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,actionsCreators)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把所有action creator作为actions属性也注入组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todos&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;actions: bindActionCreators(actionsCreators,dispatch)&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> dfault connect(mapStateToProps,mapDispatchToProps)(TodoApp)</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos和指定的action creator(addTodo)</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; addTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todo: state.todos</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreators(&#123;addTodo&#125;,dispatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把todoActionCreators作为todoActions属性、counterActionCreators作为counterActions属性注入到组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> todoActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./todoActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> counterActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./counterActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todo&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    todoActions: bindActionCreators(todoActionCreators,dispatch),</span><br><span class=\"line\">    counterActions: bindActionCreators(counterActionCreators,dispatch)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps, mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把todoActionCreators与counterActionCreators一同作为actions属性注入到组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> todoActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./todoActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> counterActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./counterActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123; todos: state.todos &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    actions: bindActionCreators(<span class=\"built_in\">Object</span>.assign(&#123;&#125;,todoActionCreators,counterActionCreators),dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>注入todos并把所有的todoActionCreators和counterActionCreators作为props注入到组件中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> todoActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./todoActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> counterActionCreators <span class=\"keyword\">from</span> <span class=\"string\">'./counterActionCreators'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; bindActionCreators &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todo&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreators(<span class=\"built_in\">Object</span>.assign(&#123;&#125;, todoActionCreators,counterActionCreators),dispatch);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,mapDispatchToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>根据组件的props注入特定用户的todos</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state,ownProps</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todos[ownProps.userId]&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<p><strong>根据组件的props注入特定用户的todos并把props.userId传入到action中</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> actionsCreators <span class=\"keyword\">from</span> <span class=\"string\">'./actionsCreators'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;todos: state.todos&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeProps</span>(<span class=\"params\">stateProps,dispatchProps,ownProps</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;,ownProps,&#123;</span><br><span class=\"line\">    todos: stateProps.todos[ownProps.userId],</span><br><span class=\"line\">    addTodo: (text) =&gt; dispatchProps.addTodo(ownProps.userId,text)</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(mapStateToProps,actionsCreators,mergeProps)(TodoApp);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"排错\"><a href=\"#排错\" class=\"headerlink\" title=\"排错\"></a>排错</h1><p>这里会列出常见的问题和对应的解决方案。</p>\n"},{"title":"es6系列教程三","date":"2016-06-02T12:45:03.000Z","_content":"> Experience is the mother.\n\n# Destructuring\n解构赋值(destructuring assignment)语法是一个Javascript表达式，它使得从数组或者对象中提取数据赋值给不同的变量成为可能。\n\n## 语法\n```javascript\n  [a,b] = [1,2];\n  [a,b,...rest] = [1,2,3,4,5];\n  {a,b} = {a:1,b:2}\n  {a,b,...rest} = {a:1,b:2,c:3,d:4} //ES7\n```\n\n> {a,b} = {a:1,b:2}作为独立语法是非法的，左侧的{a,b}会被当成块结构而不是一个对象。\n然而({a,b} = {a:1,b:2})的形式是允许的，其等价于var {a,b} = {a:1,b:2}.  \n\n## 简述\n对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。一旦你创建了这类数据组，你可以用任意的方法使用这些数据组，甚至从函数中返回它们。\n\n解构赋值的一个特别有用的功能是：你可以用一个表达式读取整个结构。你可以从后面的例子中了解到很多它的其他的有趣应用。\n\n解构赋值的作用类似于Perl和Python语言中的相似特性。\n\n## 解构数组\n### 简单例子\n```javascript\n  var foo = [\"one\",\"two\",\"three\"];\n\n  //没有解构赋值\n  var one = foo[0];\n  var two = foo[1];\n  var three = foo[2];\n\n  //解构赋值\n  var [one,two,three] = foo;\n```\n\n### 变换变量\n```javascript\n  var a = 1;\n  var b = 2;\n  [a,b] = [b,a];\n```\n执行这段代码后，b是1、a是3.没有解构赋值的情况下，交换两个变量需要一个临时变量.\n\n### 返回多值\n感谢解构赋值，函数现在可以返回多个值。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。\n```javascript\n  function f(){\n    return [1,2];\n  }\n```\n\n如你所见，两个返回值被括号括起来，用类似数组表示法的方式被返回。你可用这种方法返回任意量的变量。这个方法中，f()返回[1,2].\n```javascript\n  var a,b;\n  [a,b] = f();\n  console.log(\"A is \" + a + \" B is \" + b);\n```\n\n[a,b] = f()把函数的返回值按顺序赋值给括号中的变量：a赋值为1、b赋值为2.\n\n你也可以把返回值当作数组对待：\n```javascript\n  var a = f();\n  console.log(\"A is \" + a);\n```\n这样a就是一个包含1和2两个值的数组。\n\n### 忽略某些返回值\n你也可以忽略你不感兴趣的返回值：\n```javascript\n  function f(){\n    return [1,2,3];\n  }\n\n  var [a,b] = f();\n  console.log(\"A is \" + a + \" B is \" + b);\n```\n\n运行这段代码后，a是1、b是3。2这个值被忽略，你可以忽略任意(或全部)返回值。例如：\n```javascript\n  [,,] = f();\n```\n\n### 用正则表达式匹配提取值\n用正则表达式方法exec()匹配字符串返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串--如果不需要的话。\n```javascript\n  var url = \"https://developer.mozilla.org/en-US/Web/JavaScript\";\n\n  var parsedURL = /^(\\w+)\\:\\/\\/([]^\\/]+)\\/(.*)$/.exec(url);\n  var [,protocol,fullhost,fullpath] = parseURL;\n\n  console.log(protocol); //输出\"https:\"\n```\n\n## 解构对象\n### 简单示例\n```javascript\n  var o = {p:42,q:true};\n  var {p,q} = o;\n\n  console.log(p);\n  console.log(q);\n\n  //用新变量名赋值\n  var {p:foo,q:bar} = o;\n\n  console.log(foo); //42\n  console.log(bar); //true\n```\n\n### 函数参数默认值\nES5版本\n```javascript\n  function drawES5Chart(options) {\n    options = options === undefined ? {} : options;\n    var size = options.size === undefined ? 'big' : options.size;\n    var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords;\n    var radius = options.radius === undefined ? 25 : options.radius;\n    console.log(size, cords, radius);\n    // now finally do some chart drawing\n  }\n\n  drawES5Chart({\n    cords: { x: 18, y: 30 },\n    radius: 30\n  });\n```\n\nES6版本\n```javascript\n  function drawES6Chart({size = 'big',cords = {x:0,y:0},radius = 25} = {}){\n    console.log(size,cords,radius);\n  }\n\n  drawES6Chart({\n    cords: {x:18,y:30},\n    radius: 30\n  })\n```\n\n### 解构嵌套对象和数组\n```javascript\n  var metadata = {\n    title: \"Scratchpad\",\n    translations: [\n      {\n        locale: \"de\",\n        localization_tags: [ ],\n        last_edit: \"2014-04-14T08:43:37\",\n        url: \"/de/docs/Tools/Scratchpad\",\n        title: \"JavaScript-Umgebung\"\n      }\n    ],\n    url: \"/en-US/docs/Tools/Scratchpad\"\n  };\n\n  var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;\n\n  console.log(englishTitle); // \"Scratchpad\"\n  console.log(localeTitle);  // \"JavaScript-Umgebung\"\n```\n\n### For of迭代和解构\n```javascript\n  var people = [\n    {\n      name: \"Mike Smith\",\n      family: {\n        mother: \"Jane Smith\",\n        father: \"Harry Smith\",\n        sister: \"Samantha Smith\"\n      },\n      age: 35\n    },\n    {\n      name: \"Tom Jones\",\n      family: {\n        mother: \"Norah Jones\",\n        father: \"Richard Jones\",\n        brother: \"Howard Jones\"\n      },\n      age: 25\n    }\n  ];\n\n  for(var {name:n,family:{ father:f }} of people){\n    console.log(\"Name: \" + n + \",Father: \" + f);\n  }\n\n  // \"Name: Mike Smith, Father: Harry Smith\"\n  // \"Name: Tom Jones, Father: Richard Jones\"\n```\n\n### 从作为函数实参的对象中提取数据\n```javascript\n  function userId({id}) {\n    return id;\n  }\n\n  function whois({displayName: displayName, fullName: {firstName: name}}){\n    console.log(displayName + \" is \" + name);\n  }\n\n  var user = {\n    id: 42,\n    displayName: \"jdoe\",\n    fullName: {\n        firstName: \"John\",\n        lastName: \"Doe\"\n    }\n  };\n\n  console.log(\"userId: \" + userId(user)); // \"userId: 42\"\n  whois(user); // \"jdoe is John\"\n```\n这段代码从user对象中提取并输出id、displayName和firstName。\n\n### 对象属性计算名和解构\n计算属性名，如object literals，可以被解构。\n```javascript\n  let key = \"z\";\n  let { [key]:foo } = { z:\"bar\" };\n\n  console.log(foo); //\"bar\"\n```\n\n# Default + Rest + Spread\n## 默认参数\n如果一个参数没有被传入对应的实参或者传入了undefined，则该形参会被赋一个默认值。现在我们可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。\n```javascript\n  function sayHello(name){\n    //传统的指定默认参数的方式\n    var name = name || 'coffee';\n    console.log('Hello ' + name);\n  }\n\n  //运用ES6的默认参数\n  function sayHello2(name = 'coffee'){\n    console.log(`Hello ${name}`);\n  }\n\n  sayHello(); //输出：Hello coffee\n  sayHello('gaoquan'); //输出：Hello gaoquan\n  sayHello2(); //输出：Hello coffee\n  sayHello2('gaoquan'); //输出：Hello gaoquan\n```\n\n## Rest剩余参数\n在函数被调用时，剩余参数表示为一个数组名，该数组包含了那些没有对应形参的，长度不确定的剩余实参。\n\n### 语法\n```javascript\n  function (a,b, ...theArgs){\n    //...\n  }\n```\n\n### 简述\n如果一个函数的最后一个形参是以`...`为前缀的，则在函数被调用时，该形参会成为一个数组，数组中的元素都是传递给该函数的多出来的实参的值。\n\n在上例中，theArgs会包含传递给函数的从第三个实参开始到最后所有的实参(第一个实参映射到a，第二个实参映射到b).\n\n#### 剩余参数和arguments对象之间的区别\n剩余参数和arguments对象之间的区别主要有三个：\n - 剩余参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。\n - arguments对象不是一个真实的数组，而剩余参数是真实的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如sort、forEach、pop\n - arguments对象还有一些附加的属性(比如callee属性)\n\n#### arguments对象转换为剩余参数\n使用剩余参数可以避免将arguments转为数组的麻烦.\n```javascript\n  // 下面的代码模拟了剩余数组\n  function f(a,b){\n    var args = Array.prototype.slice.call(arguments,f.length);\n    // ...\n  }\n\n  //现在代码可以简化为这样了\n  function(a,b,...args){\n    // ...\n  }\n```\n\n### 例子\n因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：\n```javascript\n  function fun1(...theArgs){\n    alert(theArgs.length);\n  }\n\n  fun1(); //弹出\"0\"，因为theArgs没有元素\n  fun1(5); //弹出\"1\"，因为theArgs只有一个元素\n  fun1(5,6,7); //弹出\"3\"，因为theArgs有三个元素\n```\n\n下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：\n```javascript\n  function multiply(multiplier,...theArgs){\n    return theArgs.map(function(element){\n      return multiplier * element;\n    });\n  }\n\n  var arr = multiply(2,1,2,3);\n  console.log(arr); //弹出“2,4,6”\n```\n\n下例演示了你可以在剩余参数上使用任意的数组方法，而arguments对象不可以：\n```javascript\n  function sortRestArgs(...theArgs){\n    var sortedArgs = theArgs.sort();\n    return sortedArgs;\n  }\n\n  alert(sortRestArgs(5,3,7,1)); //弹出 1,3,5,7\n\n  function sortArguments() {\n    var sortedArgs = arguments.sort();\n    return sortedArgs; // 不会执行到这里\n  }\n\n  alert(sortArguments(5,3,7,1)); // 抛出TypeError异常:arguments.sort is not a function\n```\n如果想在arguments对象上使用数组方法，你首先得将它转换为真实的数组，比如使用 `[].slice.call(arguments)`\n\n## 展开运算符\n### 概述\n展开运算符允许一个表达式在某处展开，在多个参数(用于函数调用)或者多个元素(用于数组字面量)或者多个变量(用于解构赋值)的地方就会这样。\n\n### 语法\n用于函数调用：\n```javascript\n  myFunction(...iterableObj);\n```\n\n用于数组字面量：\n```javascript\n  [...iterableObj,4,5,6]\n```\n\n用于解构赋值：\n```javascript\n  [a,b,...iterableObj] = [1,2,3,4,5];\n```\n\n### 例子\n#### 更好的apply方法\n**例子：** 目前为止，我们都是使用`Function.prototype.apply`方法来将一个数组展开成多个参数：\n```javascript\n  function myFunction(x,y,z){ }\n  var args = [0,1,2];\n  myFunction.apply(null,args);\n```\n\n如果使用了ES6的展开运算符，你可以这么写：\n```javascript\n  function myFunction(x,y,z){ }\n  var args = [0,1,2];\n  myFunction(...args);\n```\n\n还可以使用多个数组：\n```javascript\n  function myFunction(v,w,x,y,z){ }\n  var args = [0,1];\n  myFunction(-1,...args,2,...[3]);\n```\n\n#### 更强大的数组字面量\n**例子：** 目前为止，如果你想创建一个包含某些已有数组里的元素的新数组，通常会用到push、splice、concat等数组方法。有了新的展开运算符，可以这样写：\n```javascript\n  var parts = ['shoulder','knees'];\n  var lyrics = ['head', ...parts, 'and', 'toes']; // [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"]\n```\n和函数调用一样，数组字面量中也可以使用...多次。\n\n#### 配合new运算符\n**例子：** 在ES5中，我们无法同时使用new运算符合apply方法(apply方法调用[[Call]]而不是[[Construct]])。在ES6中，我们可以使用展开运算符，和普通的函数调用一样。\n```javascript\n  var dataFields = readDateFields(database);\n  var d = new Date(...dataFields);\n```\n\n#### 更好的push方法\n**例子：** 在ES5中，我们可以使用push方法将一个数组添加到另一个数组的末尾：\n```javascript\n  var arr1 = [0,1,2];\n  var arr2 = [3,4,5];\n  //将arr2中的所有元素添加到arr1中\n  Array.prototype.push.apply(arr1,arr2);\n```\n\n在ES6中，可以这么写：\n```javascript\n  var arr1 = [0, 1, 2];\n  var arr2 = [3, 4, 5];\n  arr1.push(...arr2);\n```\n\n#### 将类数组对象转换成数组\n展开操作可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中，这样就可以得到一个真正的数组：\n```javascript\n  var nodeList = document.querySelectorAll('div');\n  var array = [...nodeList];\n```\n","source":"_posts/es6系列教程三.md","raw":"---\ntitle: es6系列教程三\ndate: 2016-06-02 20:45:03\ntags:\n  - es6\n  - javascript\ncategories: 原创\n---\n> Experience is the mother.\n\n# Destructuring\n解构赋值(destructuring assignment)语法是一个Javascript表达式，它使得从数组或者对象中提取数据赋值给不同的变量成为可能。\n\n## 语法\n```javascript\n  [a,b] = [1,2];\n  [a,b,...rest] = [1,2,3,4,5];\n  {a,b} = {a:1,b:2}\n  {a,b,...rest} = {a:1,b:2,c:3,d:4} //ES7\n```\n\n> {a,b} = {a:1,b:2}作为独立语法是非法的，左侧的{a,b}会被当成块结构而不是一个对象。\n然而({a,b} = {a:1,b:2})的形式是允许的，其等价于var {a,b} = {a:1,b:2}.  \n\n## 简述\n对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。一旦你创建了这类数据组，你可以用任意的方法使用这些数据组，甚至从函数中返回它们。\n\n解构赋值的一个特别有用的功能是：你可以用一个表达式读取整个结构。你可以从后面的例子中了解到很多它的其他的有趣应用。\n\n解构赋值的作用类似于Perl和Python语言中的相似特性。\n\n## 解构数组\n### 简单例子\n```javascript\n  var foo = [\"one\",\"two\",\"three\"];\n\n  //没有解构赋值\n  var one = foo[0];\n  var two = foo[1];\n  var three = foo[2];\n\n  //解构赋值\n  var [one,two,three] = foo;\n```\n\n### 变换变量\n```javascript\n  var a = 1;\n  var b = 2;\n  [a,b] = [b,a];\n```\n执行这段代码后，b是1、a是3.没有解构赋值的情况下，交换两个变量需要一个临时变量.\n\n### 返回多值\n感谢解构赋值，函数现在可以返回多个值。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。\n```javascript\n  function f(){\n    return [1,2];\n  }\n```\n\n如你所见，两个返回值被括号括起来，用类似数组表示法的方式被返回。你可用这种方法返回任意量的变量。这个方法中，f()返回[1,2].\n```javascript\n  var a,b;\n  [a,b] = f();\n  console.log(\"A is \" + a + \" B is \" + b);\n```\n\n[a,b] = f()把函数的返回值按顺序赋值给括号中的变量：a赋值为1、b赋值为2.\n\n你也可以把返回值当作数组对待：\n```javascript\n  var a = f();\n  console.log(\"A is \" + a);\n```\n这样a就是一个包含1和2两个值的数组。\n\n### 忽略某些返回值\n你也可以忽略你不感兴趣的返回值：\n```javascript\n  function f(){\n    return [1,2,3];\n  }\n\n  var [a,b] = f();\n  console.log(\"A is \" + a + \" B is \" + b);\n```\n\n运行这段代码后，a是1、b是3。2这个值被忽略，你可以忽略任意(或全部)返回值。例如：\n```javascript\n  [,,] = f();\n```\n\n### 用正则表达式匹配提取值\n用正则表达式方法exec()匹配字符串返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串--如果不需要的话。\n```javascript\n  var url = \"https://developer.mozilla.org/en-US/Web/JavaScript\";\n\n  var parsedURL = /^(\\w+)\\:\\/\\/([]^\\/]+)\\/(.*)$/.exec(url);\n  var [,protocol,fullhost,fullpath] = parseURL;\n\n  console.log(protocol); //输出\"https:\"\n```\n\n## 解构对象\n### 简单示例\n```javascript\n  var o = {p:42,q:true};\n  var {p,q} = o;\n\n  console.log(p);\n  console.log(q);\n\n  //用新变量名赋值\n  var {p:foo,q:bar} = o;\n\n  console.log(foo); //42\n  console.log(bar); //true\n```\n\n### 函数参数默认值\nES5版本\n```javascript\n  function drawES5Chart(options) {\n    options = options === undefined ? {} : options;\n    var size = options.size === undefined ? 'big' : options.size;\n    var cords = options.cords === undefined ? { x: 0, y: 0 } : options.cords;\n    var radius = options.radius === undefined ? 25 : options.radius;\n    console.log(size, cords, radius);\n    // now finally do some chart drawing\n  }\n\n  drawES5Chart({\n    cords: { x: 18, y: 30 },\n    radius: 30\n  });\n```\n\nES6版本\n```javascript\n  function drawES6Chart({size = 'big',cords = {x:0,y:0},radius = 25} = {}){\n    console.log(size,cords,radius);\n  }\n\n  drawES6Chart({\n    cords: {x:18,y:30},\n    radius: 30\n  })\n```\n\n### 解构嵌套对象和数组\n```javascript\n  var metadata = {\n    title: \"Scratchpad\",\n    translations: [\n      {\n        locale: \"de\",\n        localization_tags: [ ],\n        last_edit: \"2014-04-14T08:43:37\",\n        url: \"/de/docs/Tools/Scratchpad\",\n        title: \"JavaScript-Umgebung\"\n      }\n    ],\n    url: \"/en-US/docs/Tools/Scratchpad\"\n  };\n\n  var { title: englishTitle, translations: [{ title: localeTitle }] } = metadata;\n\n  console.log(englishTitle); // \"Scratchpad\"\n  console.log(localeTitle);  // \"JavaScript-Umgebung\"\n```\n\n### For of迭代和解构\n```javascript\n  var people = [\n    {\n      name: \"Mike Smith\",\n      family: {\n        mother: \"Jane Smith\",\n        father: \"Harry Smith\",\n        sister: \"Samantha Smith\"\n      },\n      age: 35\n    },\n    {\n      name: \"Tom Jones\",\n      family: {\n        mother: \"Norah Jones\",\n        father: \"Richard Jones\",\n        brother: \"Howard Jones\"\n      },\n      age: 25\n    }\n  ];\n\n  for(var {name:n,family:{ father:f }} of people){\n    console.log(\"Name: \" + n + \",Father: \" + f);\n  }\n\n  // \"Name: Mike Smith, Father: Harry Smith\"\n  // \"Name: Tom Jones, Father: Richard Jones\"\n```\n\n### 从作为函数实参的对象中提取数据\n```javascript\n  function userId({id}) {\n    return id;\n  }\n\n  function whois({displayName: displayName, fullName: {firstName: name}}){\n    console.log(displayName + \" is \" + name);\n  }\n\n  var user = {\n    id: 42,\n    displayName: \"jdoe\",\n    fullName: {\n        firstName: \"John\",\n        lastName: \"Doe\"\n    }\n  };\n\n  console.log(\"userId: \" + userId(user)); // \"userId: 42\"\n  whois(user); // \"jdoe is John\"\n```\n这段代码从user对象中提取并输出id、displayName和firstName。\n\n### 对象属性计算名和解构\n计算属性名，如object literals，可以被解构。\n```javascript\n  let key = \"z\";\n  let { [key]:foo } = { z:\"bar\" };\n\n  console.log(foo); //\"bar\"\n```\n\n# Default + Rest + Spread\n## 默认参数\n如果一个参数没有被传入对应的实参或者传入了undefined，则该形参会被赋一个默认值。现在我们可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。\n```javascript\n  function sayHello(name){\n    //传统的指定默认参数的方式\n    var name = name || 'coffee';\n    console.log('Hello ' + name);\n  }\n\n  //运用ES6的默认参数\n  function sayHello2(name = 'coffee'){\n    console.log(`Hello ${name}`);\n  }\n\n  sayHello(); //输出：Hello coffee\n  sayHello('gaoquan'); //输出：Hello gaoquan\n  sayHello2(); //输出：Hello coffee\n  sayHello2('gaoquan'); //输出：Hello gaoquan\n```\n\n## Rest剩余参数\n在函数被调用时，剩余参数表示为一个数组名，该数组包含了那些没有对应形参的，长度不确定的剩余实参。\n\n### 语法\n```javascript\n  function (a,b, ...theArgs){\n    //...\n  }\n```\n\n### 简述\n如果一个函数的最后一个形参是以`...`为前缀的，则在函数被调用时，该形参会成为一个数组，数组中的元素都是传递给该函数的多出来的实参的值。\n\n在上例中，theArgs会包含传递给函数的从第三个实参开始到最后所有的实参(第一个实参映射到a，第二个实参映射到b).\n\n#### 剩余参数和arguments对象之间的区别\n剩余参数和arguments对象之间的区别主要有三个：\n - 剩余参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。\n - arguments对象不是一个真实的数组，而剩余参数是真实的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如sort、forEach、pop\n - arguments对象还有一些附加的属性(比如callee属性)\n\n#### arguments对象转换为剩余参数\n使用剩余参数可以避免将arguments转为数组的麻烦.\n```javascript\n  // 下面的代码模拟了剩余数组\n  function f(a,b){\n    var args = Array.prototype.slice.call(arguments,f.length);\n    // ...\n  }\n\n  //现在代码可以简化为这样了\n  function(a,b,...args){\n    // ...\n  }\n```\n\n### 例子\n因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：\n```javascript\n  function fun1(...theArgs){\n    alert(theArgs.length);\n  }\n\n  fun1(); //弹出\"0\"，因为theArgs没有元素\n  fun1(5); //弹出\"1\"，因为theArgs只有一个元素\n  fun1(5,6,7); //弹出\"3\"，因为theArgs有三个元素\n```\n\n下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：\n```javascript\n  function multiply(multiplier,...theArgs){\n    return theArgs.map(function(element){\n      return multiplier * element;\n    });\n  }\n\n  var arr = multiply(2,1,2,3);\n  console.log(arr); //弹出“2,4,6”\n```\n\n下例演示了你可以在剩余参数上使用任意的数组方法，而arguments对象不可以：\n```javascript\n  function sortRestArgs(...theArgs){\n    var sortedArgs = theArgs.sort();\n    return sortedArgs;\n  }\n\n  alert(sortRestArgs(5,3,7,1)); //弹出 1,3,5,7\n\n  function sortArguments() {\n    var sortedArgs = arguments.sort();\n    return sortedArgs; // 不会执行到这里\n  }\n\n  alert(sortArguments(5,3,7,1)); // 抛出TypeError异常:arguments.sort is not a function\n```\n如果想在arguments对象上使用数组方法，你首先得将它转换为真实的数组，比如使用 `[].slice.call(arguments)`\n\n## 展开运算符\n### 概述\n展开运算符允许一个表达式在某处展开，在多个参数(用于函数调用)或者多个元素(用于数组字面量)或者多个变量(用于解构赋值)的地方就会这样。\n\n### 语法\n用于函数调用：\n```javascript\n  myFunction(...iterableObj);\n```\n\n用于数组字面量：\n```javascript\n  [...iterableObj,4,5,6]\n```\n\n用于解构赋值：\n```javascript\n  [a,b,...iterableObj] = [1,2,3,4,5];\n```\n\n### 例子\n#### 更好的apply方法\n**例子：** 目前为止，我们都是使用`Function.prototype.apply`方法来将一个数组展开成多个参数：\n```javascript\n  function myFunction(x,y,z){ }\n  var args = [0,1,2];\n  myFunction.apply(null,args);\n```\n\n如果使用了ES6的展开运算符，你可以这么写：\n```javascript\n  function myFunction(x,y,z){ }\n  var args = [0,1,2];\n  myFunction(...args);\n```\n\n还可以使用多个数组：\n```javascript\n  function myFunction(v,w,x,y,z){ }\n  var args = [0,1];\n  myFunction(-1,...args,2,...[3]);\n```\n\n#### 更强大的数组字面量\n**例子：** 目前为止，如果你想创建一个包含某些已有数组里的元素的新数组，通常会用到push、splice、concat等数组方法。有了新的展开运算符，可以这样写：\n```javascript\n  var parts = ['shoulder','knees'];\n  var lyrics = ['head', ...parts, 'and', 'toes']; // [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"]\n```\n和函数调用一样，数组字面量中也可以使用...多次。\n\n#### 配合new运算符\n**例子：** 在ES5中，我们无法同时使用new运算符合apply方法(apply方法调用[[Call]]而不是[[Construct]])。在ES6中，我们可以使用展开运算符，和普通的函数调用一样。\n```javascript\n  var dataFields = readDateFields(database);\n  var d = new Date(...dataFields);\n```\n\n#### 更好的push方法\n**例子：** 在ES5中，我们可以使用push方法将一个数组添加到另一个数组的末尾：\n```javascript\n  var arr1 = [0,1,2];\n  var arr2 = [3,4,5];\n  //将arr2中的所有元素添加到arr1中\n  Array.prototype.push.apply(arr1,arr2);\n```\n\n在ES6中，可以这么写：\n```javascript\n  var arr1 = [0, 1, 2];\n  var arr2 = [3, 4, 5];\n  arr1.push(...arr2);\n```\n\n#### 将类数组对象转换成数组\n展开操作可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中，这样就可以得到一个真正的数组：\n```javascript\n  var nodeList = document.querySelectorAll('div');\n  var array = [...nodeList];\n```\n","slug":"es6系列教程三","published":1,"updated":"2016-06-06T04:12:43.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emn000ib0dlvmn1vefy","content":"<blockquote>\n<p>Experience is the mother.</p>\n</blockquote>\n<h1 id=\"Destructuring\"><a href=\"#Destructuring\" class=\"headerlink\" title=\"Destructuring\"></a>Destructuring</h1><p>解构赋值(destructuring assignment)语法是一个Javascript表达式，它使得从数组或者对象中提取数据赋值给不同的变量成为可能。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[a,b] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">[a,b,...rest] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">&#123;a,b&#125; = &#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">&#123;a,b,...rest&#125; = &#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">2</span>,c:<span class=\"number\">3</span>,d:<span class=\"number\">4</span>&#125; <span class=\"comment\">//ES7</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>{a,b} = {a:1,b:2}作为独立语法是非法的，左侧的{a,b}会被当成块结构而不是一个对象。<br>然而({a,b} = {a:1,b:2})的形式是允许的，其等价于var {a,b} = {a:1,b:2}.  </p>\n</blockquote>\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。一旦你创建了这类数据组，你可以用任意的方法使用这些数据组，甚至从函数中返回它们。</p>\n<p>解构赋值的一个特别有用的功能是：你可以用一个表达式读取整个结构。你可以从后面的例子中了解到很多它的其他的有趣应用。</p>\n<p>解构赋值的作用类似于Perl和Python语言中的相似特性。</p>\n<h2 id=\"解构数组\"><a href=\"#解构数组\" class=\"headerlink\" title=\"解构数组\"></a>解构数组</h2><h3 id=\"简单例子\"><a href=\"#简单例子\" class=\"headerlink\" title=\"简单例子\"></a>简单例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = [<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//没有解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> one = foo[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> two = foo[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> three = foo[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [one,two,three] = foo;</span><br></pre></td></tr></table></figure>\n<h3 id=\"变换变量\"><a href=\"#变换变量\" class=\"headerlink\" title=\"变换变量\"></a>变换变量</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">[a,b] = [b,a];</span><br></pre></td></tr></table></figure>\n<p>执行这段代码后，b是1、a是3.没有解构赋值的情况下，交换两个变量需要一个临时变量.</p>\n<h3 id=\"返回多值\"><a href=\"#返回多值\" class=\"headerlink\" title=\"返回多值\"></a>返回多值</h3><p>感谢解构赋值，函数现在可以返回多个值。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，两个返回值被括号括起来，用类似数组表示法的方式被返回。你可用这种方法返回任意量的变量。这个方法中，f()返回[1,2].<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a,b;</span><br><span class=\"line\">[a,b] = f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A is \"</span> + a + <span class=\"string\">\" B is \"</span> + b);</span><br></pre></td></tr></table></figure></p>\n<p>[a,b] = f()把函数的返回值按顺序赋值给括号中的变量：a赋值为1、b赋值为2.</p>\n<p>你也可以把返回值当作数组对待：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A is \"</span> + a);</span><br></pre></td></tr></table></figure></p>\n<p>这样a就是一个包含1和2两个值的数组。</p>\n<h3 id=\"忽略某些返回值\"><a href=\"#忽略某些返回值\" class=\"headerlink\" title=\"忽略某些返回值\"></a>忽略某些返回值</h3><p>你也可以忽略你不感兴趣的返回值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [a,b] = f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A is \"</span> + a + <span class=\"string\">\" B is \"</span> + b);</span><br></pre></td></tr></table></figure></p>\n<p>运行这段代码后，a是1、b是3。2这个值被忽略，你可以忽略任意(或全部)返回值。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[,,] = f();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用正则表达式匹配提取值\"><a href=\"#用正则表达式匹配提取值\" class=\"headerlink\" title=\"用正则表达式匹配提取值\"></a>用正则表达式匹配提取值</h3><p>用正则表达式方法exec()匹配字符串返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串–如果不需要的话。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"https://developer.mozilla.org/en-US/Web/JavaScript\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parsedURL = <span class=\"regexp\">/^(\\w+)\\:\\/\\/([]^\\/]+)\\/(.*)$/</span>.exec(url);</span><br><span class=\"line\"><span class=\"keyword\">var</span> [,protocol,fullhost,fullpath] = parseURL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(protocol); <span class=\"comment\">//输出\"https:\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"解构对象\"><a href=\"#解构对象\" class=\"headerlink\" title=\"解构对象\"></a>解构对象</h2><h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;p:<span class=\"number\">42</span>,q:<span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;p,q&#125; = o;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用新变量名赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;p:foo,q:bar&#125; = o;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">//42</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数参数默认值\"><a href=\"#函数参数默认值\" class=\"headerlink\" title=\"函数参数默认值\"></a>函数参数默认值</h3><p>ES5版本<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawES5Chart</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  options = options === <span class=\"literal\">undefined</span> ? &#123;&#125; : options;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> size = options.size === <span class=\"literal\">undefined</span> ? <span class=\"string\">'big'</span> : options.size;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cords = options.cords === <span class=\"literal\">undefined</span> ? &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125; : options.cords;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> radius = options.radius === <span class=\"literal\">undefined</span> ? <span class=\"number\">25</span> : options.radius;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(size, cords, radius);</span><br><span class=\"line\">  <span class=\"comment\">// now finally do some chart drawing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drawES5Chart(&#123;</span><br><span class=\"line\">  cords: &#123; x: <span class=\"number\">18</span>, y: <span class=\"number\">30</span> &#125;,</span><br><span class=\"line\">  radius: <span class=\"number\">30</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>ES6版本<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawES6Chart</span>(<span class=\"params\">&#123;size = 'big',cords = &#123;x:0,y:0&#125;,radius = 25&#125; = &#123;&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(size,cords,radius);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drawES6Chart(&#123;</span><br><span class=\"line\">  cords: &#123;x:<span class=\"number\">18</span>,y:<span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">  radius: <span class=\"number\">30</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解构嵌套对象和数组\"><a href=\"#解构嵌套对象和数组\" class=\"headerlink\" title=\"解构嵌套对象和数组\"></a>解构嵌套对象和数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> metadata = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">\"Scratchpad\"</span>,</span><br><span class=\"line\">  translations: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      locale: <span class=\"string\">\"de\"</span>,</span><br><span class=\"line\">      localization_tags: [ ],</span><br><span class=\"line\">      last_edit: <span class=\"string\">\"2014-04-14T08:43:37\"</span>,</span><br><span class=\"line\">      url: <span class=\"string\">\"/de/docs/Tools/Scratchpad\"</span>,</span><br><span class=\"line\">      title: <span class=\"string\">\"JavaScript-Umgebung\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  url: <span class=\"string\">\"/en-US/docs/Tools/Scratchpad\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; title: englishTitle, translations: [&#123; title: localeTitle &#125;] &#125; = metadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(englishTitle); <span class=\"comment\">// \"Scratchpad\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(localeTitle);  <span class=\"comment\">// \"JavaScript-Umgebung\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"For-of迭代和解构\"><a href=\"#For-of迭代和解构\" class=\"headerlink\" title=\"For of迭代和解构\"></a>For of迭代和解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> people = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"Mike Smith\"</span>,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: <span class=\"string\">\"Jane Smith\"</span>,</span><br><span class=\"line\">      father: <span class=\"string\">\"Harry Smith\"</span>,</span><br><span class=\"line\">      sister: <span class=\"string\">\"Samantha Smith\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: <span class=\"number\">35</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"Tom Jones\"</span>,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: <span class=\"string\">\"Norah Jones\"</span>,</span><br><span class=\"line\">      father: <span class=\"string\">\"Richard Jones\"</span>,</span><br><span class=\"line\">      brother: <span class=\"string\">\"Howard Jones\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: <span class=\"number\">25</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> &#123;name:n,family:&#123; father:f &#125;&#125; <span class=\"keyword\">of</span> people)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Name: \"</span> + n + <span class=\"string\">\",Father: \"</span> + f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Name: Mike Smith, Father: Harry Smith\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"Name: Tom Jones, Father: Richard Jones\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从作为函数实参的对象中提取数据\"><a href=\"#从作为函数实参的对象中提取数据\" class=\"headerlink\" title=\"从作为函数实参的对象中提取数据\"></a>从作为函数实参的对象中提取数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">userId</span>(<span class=\"params\">&#123;id&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">whois</span>(<span class=\"params\">&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(displayName + <span class=\"string\">\" is \"</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">42</span>,</span><br><span class=\"line\">  displayName: <span class=\"string\">\"jdoe\"</span>,</span><br><span class=\"line\">  fullName: &#123;</span><br><span class=\"line\">      firstName: <span class=\"string\">\"John\"</span>,</span><br><span class=\"line\">      lastName: <span class=\"string\">\"Doe\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"userId: \"</span> + userId(user)); <span class=\"comment\">// \"userId: 42\"</span></span><br><span class=\"line\">whois(user); <span class=\"comment\">// \"jdoe is John\"</span></span><br></pre></td></tr></table></figure>\n<p>这段代码从user对象中提取并输出id、displayName和firstName。</p>\n<h3 id=\"对象属性计算名和解构\"><a href=\"#对象属性计算名和解构\" class=\"headerlink\" title=\"对象属性计算名和解构\"></a>对象属性计算名和解构</h3><p>计算属性名，如object literals，可以被解构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> key = <span class=\"string\">\"z\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; [key]:foo &#125; = &#123; z:<span class=\"string\">\"bar\"</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">//\"bar\"</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Default-Rest-Spread\"><a href=\"#Default-Rest-Spread\" class=\"headerlink\" title=\"Default + Rest + Spread\"></a>Default + Rest + Spread</h1><h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>如果一个参数没有被传入对应的实参或者传入了undefined，则该形参会被赋一个默认值。现在我们可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//传统的指定默认参数的方式</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = name || <span class=\"string\">'coffee'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运用ES6的默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello2</span>(<span class=\"params\">name = 'coffee'</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayHello(); <span class=\"comment\">//输出：Hello coffee</span></span><br><span class=\"line\">sayHello(<span class=\"string\">'gaoquan'</span>); <span class=\"comment\">//输出：Hello gaoquan</span></span><br><span class=\"line\">sayHello2(); <span class=\"comment\">//输出：Hello coffee</span></span><br><span class=\"line\">sayHello2(<span class=\"string\">'gaoquan'</span>); <span class=\"comment\">//输出：Hello gaoquan</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Rest剩余参数\"><a href=\"#Rest剩余参数\" class=\"headerlink\" title=\"Rest剩余参数\"></a>Rest剩余参数</h2><p>在函数被调用时，剩余参数表示为一个数组名，该数组包含了那些没有对应形参的，长度不确定的剩余实参。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b, ...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简述-1\"><a href=\"#简述-1\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>如果一个函数的最后一个形参是以<code>...</code>为前缀的，则在函数被调用时，该形参会成为一个数组，数组中的元素都是传递给该函数的多出来的实参的值。</p>\n<p>在上例中，theArgs会包含传递给函数的从第三个实参开始到最后所有的实参(第一个实参映射到a，第二个实参映射到b).</p>\n<h4 id=\"剩余参数和arguments对象之间的区别\"><a href=\"#剩余参数和arguments对象之间的区别\" class=\"headerlink\" title=\"剩余参数和arguments对象之间的区别\"></a>剩余参数和arguments对象之间的区别</h4><p>剩余参数和arguments对象之间的区别主要有三个：</p>\n<ul>\n<li>剩余参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。</li>\n<li>arguments对象不是一个真实的数组，而剩余参数是真实的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如sort、forEach、pop</li>\n<li>arguments对象还有一些附加的属性(比如callee属性)</li>\n</ul>\n<h4 id=\"arguments对象转换为剩余参数\"><a href=\"#arguments对象转换为剩余参数\" class=\"headerlink\" title=\"arguments对象转换为剩余参数\"></a>arguments对象转换为剩余参数</h4><p>使用剩余参数可以避免将arguments转为数组的麻烦.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面的代码模拟了剩余数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,f.length);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在代码可以简化为这样了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b,...args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\">...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  alert(theArgs.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fun1(); <span class=\"comment\">//弹出\"0\"，因为theArgs没有元素</span></span><br><span class=\"line\">fun1(<span class=\"number\">5</span>); <span class=\"comment\">//弹出\"1\"，因为theArgs只有一个元素</span></span><br><span class=\"line\">fun1(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>); <span class=\"comment\">//弹出\"3\"，因为theArgs有三个元素</span></span><br></pre></td></tr></table></figure></p>\n<p>下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">multiplier,...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> theArgs.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiplier * element;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = multiply(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//弹出“2,4,6”</span></span><br></pre></td></tr></table></figure></p>\n<p>下例演示了你可以在剩余参数上使用任意的数组方法，而arguments对象不可以：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortRestArgs</span>(<span class=\"params\">...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sortedArgs = theArgs.sort();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArgs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sortRestArgs(<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>)); <span class=\"comment\">//弹出 1,3,5,7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sortedArgs = <span class=\"built_in\">arguments</span>.sort();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArgs; <span class=\"comment\">// 不会执行到这里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sortArguments(<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>)); <span class=\"comment\">// 抛出TypeError异常:arguments.sort is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>如果想在arguments对象上使用数组方法，你首先得将它转换为真实的数组，比如使用 <code>[].slice.call(arguments)</code></p>\n<h2 id=\"展开运算符\"><a href=\"#展开运算符\" class=\"headerlink\" title=\"展开运算符\"></a>展开运算符</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>展开运算符允许一个表达式在某处展开，在多个参数(用于函数调用)或者多个元素(用于数组字面量)或者多个变量(用于解构赋值)的地方就会这样。</p>\n<h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>用于函数调用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myFunction(...iterableObj);</span><br></pre></td></tr></table></figure></p>\n<p>用于数组字面量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...iterableObj,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure></p>\n<p>用于解构赋值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[a,b,...iterableObj] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"更好的apply方法\"><a href=\"#更好的apply方法\" class=\"headerlink\" title=\"更好的apply方法\"></a>更好的apply方法</h4><p><strong>例子：</strong> 目前为止，我们都是使用<code>Function.prototype.apply</code>方法来将一个数组展开成多个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">x,y,z</span>)</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">myFunction.apply(<span class=\"literal\">null</span>,args);</span><br></pre></td></tr></table></figure></p>\n<p>如果使用了ES6的展开运算符，你可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">x,y,z</span>)</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">myFunction(...args);</span><br></pre></td></tr></table></figure></p>\n<p>还可以使用多个数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">v,w,x,y,z</span>)</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\">myFunction(<span class=\"number\">-1</span>,...args,<span class=\"number\">2</span>,...[<span class=\"number\">3</span>]);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更强大的数组字面量\"><a href=\"#更强大的数组字面量\" class=\"headerlink\" title=\"更强大的数组字面量\"></a>更强大的数组字面量</h4><p><strong>例子：</strong> 目前为止，如果你想创建一个包含某些已有数组里的元素的新数组，通常会用到push、splice、concat等数组方法。有了新的展开运算符，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parts = [<span class=\"string\">'shoulder'</span>,<span class=\"string\">'knees'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> lyrics = [<span class=\"string\">'head'</span>, ...parts, <span class=\"string\">'and'</span>, <span class=\"string\">'toes'</span>]; <span class=\"comment\">// [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>和函数调用一样，数组字面量中也可以使用…多次。</p>\n<h4 id=\"配合new运算符\"><a href=\"#配合new运算符\" class=\"headerlink\" title=\"配合new运算符\"></a>配合new运算符</h4><p><strong>例子：</strong> 在ES5中，我们无法同时使用new运算符合apply方法(apply方法调用[[Call]]而不是[[Construct]])。在ES6中，我们可以使用展开运算符，和普通的函数调用一样。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dataFields = readDateFields(database);</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(...dataFields);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更好的push方法\"><a href=\"#更好的push方法\" class=\"headerlink\" title=\"更好的push方法\"></a>更好的push方法</h4><p><strong>例子：</strong> 在ES5中，我们可以使用push方法将一个数组添加到另一个数组的末尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"comment\">//将arr2中的所有元素添加到arr1中</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(arr1,arr2);</span><br></pre></td></tr></table></figure></p>\n<p>在ES6中，可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"将类数组对象转换成数组\"><a href=\"#将类数组对象转换成数组\" class=\"headerlink\" title=\"将类数组对象转换成数组\"></a>将类数组对象转换成数组</h4><p>展开操作可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中，这样就可以得到一个真正的数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodeList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>Experience is the mother.</p>\n</blockquote>\n<h1 id=\"Destructuring\"><a href=\"#Destructuring\" class=\"headerlink\" title=\"Destructuring\"></a>Destructuring</h1><p>解构赋值(destructuring assignment)语法是一个Javascript表达式，它使得从数组或者对象中提取数据赋值给不同的变量成为可能。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[a,b] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">[a,b,...rest] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\">&#123;a,b&#125; = &#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">2</span>&#125;</span><br><span class=\"line\">&#123;a,b,...rest&#125; = &#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">2</span>,c:<span class=\"number\">3</span>,d:<span class=\"number\">4</span>&#125; <span class=\"comment\">//ES7</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>{a,b} = {a:1,b:2}作为独立语法是非法的，左侧的{a,b}会被当成块结构而不是一个对象。<br>然而({a,b} = {a:1,b:2})的形式是允许的，其等价于var {a,b} = {a:1,b:2}.  </p>\n</blockquote>\n<h2 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h2><p>对象字面量和数组字面量提供了一种简单的定义一个特定的数据组的方法。一旦你创建了这类数据组，你可以用任意的方法使用这些数据组，甚至从函数中返回它们。</p>\n<p>解构赋值的一个特别有用的功能是：你可以用一个表达式读取整个结构。你可以从后面的例子中了解到很多它的其他的有趣应用。</p>\n<p>解构赋值的作用类似于Perl和Python语言中的相似特性。</p>\n<h2 id=\"解构数组\"><a href=\"#解构数组\" class=\"headerlink\" title=\"解构数组\"></a>解构数组</h2><h3 id=\"简单例子\"><a href=\"#简单例子\" class=\"headerlink\" title=\"简单例子\"></a>简单例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = [<span class=\"string\">\"one\"</span>,<span class=\"string\">\"two\"</span>,<span class=\"string\">\"three\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//没有解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> one = foo[<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> two = foo[<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> three = foo[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> [one,two,three] = foo;</span><br></pre></td></tr></table></figure>\n<h3 id=\"变换变量\"><a href=\"#变换变量\" class=\"headerlink\" title=\"变换变量\"></a>变换变量</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">2</span>;</span><br><span class=\"line\">[a,b] = [b,a];</span><br></pre></td></tr></table></figure>\n<p>执行这段代码后，b是1、a是3.没有解构赋值的情况下，交换两个变量需要一个临时变量.</p>\n<h3 id=\"返回多值\"><a href=\"#返回多值\" class=\"headerlink\" title=\"返回多值\"></a>返回多值</h3><p>感谢解构赋值，函数现在可以返回多个值。尽管函数一直都可以返回一个数组，但现在这样做有更多的灵活性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，两个返回值被括号括起来，用类似数组表示法的方式被返回。你可用这种方法返回任意量的变量。这个方法中，f()返回[1,2].<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a,b;</span><br><span class=\"line\">[a,b] = f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A is \"</span> + a + <span class=\"string\">\" B is \"</span> + b);</span><br></pre></td></tr></table></figure></p>\n<p>[a,b] = f()把函数的返回值按顺序赋值给括号中的变量：a赋值为1、b赋值为2.</p>\n<p>你也可以把返回值当作数组对待：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A is \"</span> + a);</span><br></pre></td></tr></table></figure></p>\n<p>这样a就是一个包含1和2两个值的数组。</p>\n<h3 id=\"忽略某些返回值\"><a href=\"#忽略某些返回值\" class=\"headerlink\" title=\"忽略某些返回值\"></a>忽略某些返回值</h3><p>你也可以忽略你不感兴趣的返回值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> [a,b] = f();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"A is \"</span> + a + <span class=\"string\">\" B is \"</span> + b);</span><br></pre></td></tr></table></figure></p>\n<p>运行这段代码后，a是1、b是3。2这个值被忽略，你可以忽略任意(或全部)返回值。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[,,] = f();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"用正则表达式匹配提取值\"><a href=\"#用正则表达式匹配提取值\" class=\"headerlink\" title=\"用正则表达式匹配提取值\"></a>用正则表达式匹配提取值</h3><p>用正则表达式方法exec()匹配字符串返回一个数组，该数组第一个值是完全匹配正则表达式的字符串，然后的值是匹配正则表达式括号内内容部分。解构赋值允许你轻易地提取出需要的部分，忽略完全匹配的字符串–如果不需要的话。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">\"https://developer.mozilla.org/en-US/Web/JavaScript\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> parsedURL = <span class=\"regexp\">/^(\\w+)\\:\\/\\/([]^\\/]+)\\/(.*)$/</span>.exec(url);</span><br><span class=\"line\"><span class=\"keyword\">var</span> [,protocol,fullhost,fullpath] = parseURL;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(protocol); <span class=\"comment\">//输出\"https:\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"解构对象\"><a href=\"#解构对象\" class=\"headerlink\" title=\"解构对象\"></a>解构对象</h2><h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> o = &#123;p:<span class=\"number\">42</span>,q:<span class=\"literal\">true</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;p,q&#125; = o;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用新变量名赋值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;p:foo,q:bar&#125; = o;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">//42</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bar); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数参数默认值\"><a href=\"#函数参数默认值\" class=\"headerlink\" title=\"函数参数默认值\"></a>函数参数默认值</h3><p>ES5版本<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawES5Chart</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  options = options === <span class=\"literal\">undefined</span> ? &#123;&#125; : options;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> size = options.size === <span class=\"literal\">undefined</span> ? <span class=\"string\">'big'</span> : options.size;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cords = options.cords === <span class=\"literal\">undefined</span> ? &#123; x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span> &#125; : options.cords;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> radius = options.radius === <span class=\"literal\">undefined</span> ? <span class=\"number\">25</span> : options.radius;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(size, cords, radius);</span><br><span class=\"line\">  <span class=\"comment\">// now finally do some chart drawing</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drawES5Chart(&#123;</span><br><span class=\"line\">  cords: &#123; x: <span class=\"number\">18</span>, y: <span class=\"number\">30</span> &#125;,</span><br><span class=\"line\">  radius: <span class=\"number\">30</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>ES6版本<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drawES6Chart</span>(<span class=\"params\">&#123;size = 'big',cords = &#123;x:0,y:0&#125;,radius = 25&#125; = &#123;&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(size,cords,radius);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">drawES6Chart(&#123;</span><br><span class=\"line\">  cords: &#123;x:<span class=\"number\">18</span>,y:<span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">  radius: <span class=\"number\">30</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解构嵌套对象和数组\"><a href=\"#解构嵌套对象和数组\" class=\"headerlink\" title=\"解构嵌套对象和数组\"></a>解构嵌套对象和数组</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> metadata = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">\"Scratchpad\"</span>,</span><br><span class=\"line\">  translations: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      locale: <span class=\"string\">\"de\"</span>,</span><br><span class=\"line\">      localization_tags: [ ],</span><br><span class=\"line\">      last_edit: <span class=\"string\">\"2014-04-14T08:43:37\"</span>,</span><br><span class=\"line\">      url: <span class=\"string\">\"/de/docs/Tools/Scratchpad\"</span>,</span><br><span class=\"line\">      title: <span class=\"string\">\"JavaScript-Umgebung\"</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  url: <span class=\"string\">\"/en-US/docs/Tools/Scratchpad\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; title: englishTitle, translations: [&#123; title: localeTitle &#125;] &#125; = metadata;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(englishTitle); <span class=\"comment\">// \"Scratchpad\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(localeTitle);  <span class=\"comment\">// \"JavaScript-Umgebung\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"For-of迭代和解构\"><a href=\"#For-of迭代和解构\" class=\"headerlink\" title=\"For of迭代和解构\"></a>For of迭代和解构</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> people = [</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"Mike Smith\"</span>,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: <span class=\"string\">\"Jane Smith\"</span>,</span><br><span class=\"line\">      father: <span class=\"string\">\"Harry Smith\"</span>,</span><br><span class=\"line\">      sister: <span class=\"string\">\"Samantha Smith\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: <span class=\"number\">35</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    name: <span class=\"string\">\"Tom Jones\"</span>,</span><br><span class=\"line\">    family: &#123;</span><br><span class=\"line\">      mother: <span class=\"string\">\"Norah Jones\"</span>,</span><br><span class=\"line\">      father: <span class=\"string\">\"Richard Jones\"</span>,</span><br><span class=\"line\">      brother: <span class=\"string\">\"Howard Jones\"</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    age: <span class=\"number\">25</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> &#123;name:n,family:&#123; father:f &#125;&#125; <span class=\"keyword\">of</span> people)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Name: \"</span> + n + <span class=\"string\">\",Father: \"</span> + f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// \"Name: Mike Smith, Father: Harry Smith\"</span></span><br><span class=\"line\"><span class=\"comment\">// \"Name: Tom Jones, Father: Richard Jones\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"从作为函数实参的对象中提取数据\"><a href=\"#从作为函数实参的对象中提取数据\" class=\"headerlink\" title=\"从作为函数实参的对象中提取数据\"></a>从作为函数实参的对象中提取数据</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">userId</span>(<span class=\"params\">&#123;id&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> id;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">whois</span>(<span class=\"params\">&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(displayName + <span class=\"string\">\" is \"</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> user = &#123;</span><br><span class=\"line\">  id: <span class=\"number\">42</span>,</span><br><span class=\"line\">  displayName: <span class=\"string\">\"jdoe\"</span>,</span><br><span class=\"line\">  fullName: &#123;</span><br><span class=\"line\">      firstName: <span class=\"string\">\"John\"</span>,</span><br><span class=\"line\">      lastName: <span class=\"string\">\"Doe\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"userId: \"</span> + userId(user)); <span class=\"comment\">// \"userId: 42\"</span></span><br><span class=\"line\">whois(user); <span class=\"comment\">// \"jdoe is John\"</span></span><br></pre></td></tr></table></figure>\n<p>这段代码从user对象中提取并输出id、displayName和firstName。</p>\n<h3 id=\"对象属性计算名和解构\"><a href=\"#对象属性计算名和解构\" class=\"headerlink\" title=\"对象属性计算名和解构\"></a>对象属性计算名和解构</h3><p>计算属性名，如object literals，可以被解构。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> key = <span class=\"string\">\"z\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> &#123; [key]:foo &#125; = &#123; z:<span class=\"string\">\"bar\"</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo); <span class=\"comment\">//\"bar\"</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Default-Rest-Spread\"><a href=\"#Default-Rest-Spread\" class=\"headerlink\" title=\"Default + Rest + Spread\"></a>Default + Rest + Spread</h1><h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>如果一个参数没有被传入对应的实参或者传入了undefined，则该形参会被赋一个默认值。现在我们可以在定义函数的时候指定参数的默认值，而不用像以前那样通过逻辑或操作符来达到目的了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//传统的指定默认参数的方式</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = name || <span class=\"string\">'coffee'</span>;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello '</span> + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//运用ES6的默认参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayHello2</span>(<span class=\"params\">name = 'coffee'</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`Hello <span class=\"subst\">$&#123;name&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">sayHello(); <span class=\"comment\">//输出：Hello coffee</span></span><br><span class=\"line\">sayHello(<span class=\"string\">'gaoquan'</span>); <span class=\"comment\">//输出：Hello gaoquan</span></span><br><span class=\"line\">sayHello2(); <span class=\"comment\">//输出：Hello coffee</span></span><br><span class=\"line\">sayHello2(<span class=\"string\">'gaoquan'</span>); <span class=\"comment\">//输出：Hello gaoquan</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Rest剩余参数\"><a href=\"#Rest剩余参数\" class=\"headerlink\" title=\"Rest剩余参数\"></a>Rest剩余参数</h2><p>在函数被调用时，剩余参数表示为一个数组名，该数组包含了那些没有对应形参的，长度不确定的剩余实参。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">a,b, ...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"简述-1\"><a href=\"#简述-1\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>如果一个函数的最后一个形参是以<code>...</code>为前缀的，则在函数被调用时，该形参会成为一个数组，数组中的元素都是传递给该函数的多出来的实参的值。</p>\n<p>在上例中，theArgs会包含传递给函数的从第三个实参开始到最后所有的实参(第一个实参映射到a，第二个实参映射到b).</p>\n<h4 id=\"剩余参数和arguments对象之间的区别\"><a href=\"#剩余参数和arguments对象之间的区别\" class=\"headerlink\" title=\"剩余参数和arguments对象之间的区别\"></a>剩余参数和arguments对象之间的区别</h4><p>剩余参数和arguments对象之间的区别主要有三个：</p>\n<ul>\n<li>剩余参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。</li>\n<li>arguments对象不是一个真实的数组，而剩余参数是真实的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如sort、forEach、pop</li>\n<li>arguments对象还有一些附加的属性(比如callee属性)</li>\n</ul>\n<h4 id=\"arguments对象转换为剩余参数\"><a href=\"#arguments对象转换为剩余参数\" class=\"headerlink\" title=\"arguments对象转换为剩余参数\"></a>arguments对象转换为剩余参数</h4><p>使用剩余参数可以避免将arguments转为数组的麻烦.<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下面的代码模拟了剩余数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>,f.length);</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在代码可以简化为这样了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b,...args</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>因为theArgs是个数组，所以你可以使用length属性得到剩余参数的个数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\">...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  alert(theArgs.length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fun1(); <span class=\"comment\">//弹出\"0\"，因为theArgs没有元素</span></span><br><span class=\"line\">fun1(<span class=\"number\">5</span>); <span class=\"comment\">//弹出\"1\"，因为theArgs只有一个元素</span></span><br><span class=\"line\">fun1(<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>); <span class=\"comment\">//弹出\"3\"，因为theArgs有三个元素</span></span><br></pre></td></tr></table></figure></p>\n<p>下例中，剩余参数包含了从第二个到最后的所有实参，然后用第一个实参依次乘以它们：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multiply</span>(<span class=\"params\">multiplier,...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> theArgs.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> multiplier * element;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = multiply(<span class=\"number\">2</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//弹出“2,4,6”</span></span><br></pre></td></tr></table></figure></p>\n<p>下例演示了你可以在剩余参数上使用任意的数组方法，而arguments对象不可以：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortRestArgs</span>(<span class=\"params\">...theArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sortedArgs = theArgs.sort();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArgs;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sortRestArgs(<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>)); <span class=\"comment\">//弹出 1,3,5,7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortArguments</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sortedArgs = <span class=\"built_in\">arguments</span>.sort();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sortedArgs; <span class=\"comment\">// 不会执行到这里</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">alert(sortArguments(<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>)); <span class=\"comment\">// 抛出TypeError异常:arguments.sort is not a function</span></span><br></pre></td></tr></table></figure></p>\n<p>如果想在arguments对象上使用数组方法，你首先得将它转换为真实的数组，比如使用 <code>[].slice.call(arguments)</code></p>\n<h2 id=\"展开运算符\"><a href=\"#展开运算符\" class=\"headerlink\" title=\"展开运算符\"></a>展开运算符</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>展开运算符允许一个表达式在某处展开，在多个参数(用于函数调用)或者多个元素(用于数组字面量)或者多个变量(用于解构赋值)的地方就会这样。</p>\n<h3 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h3><p>用于函数调用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myFunction(...iterableObj);</span><br></pre></td></tr></table></figure></p>\n<p>用于数组字面量：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[...iterableObj,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br></pre></td></tr></table></figure></p>\n<p>用于解构赋值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[a,b,...iterableObj] = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><h4 id=\"更好的apply方法\"><a href=\"#更好的apply方法\" class=\"headerlink\" title=\"更好的apply方法\"></a>更好的apply方法</h4><p><strong>例子：</strong> 目前为止，我们都是使用<code>Function.prototype.apply</code>方法来将一个数组展开成多个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">x,y,z</span>)</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">myFunction.apply(<span class=\"literal\">null</span>,args);</span><br></pre></td></tr></table></figure></p>\n<p>如果使用了ES6的展开运算符，你可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">x,y,z</span>)</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\">myFunction(...args);</span><br></pre></td></tr></table></figure></p>\n<p>还可以使用多个数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">v,w,x,y,z</span>)</span>&#123; &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> args = [<span class=\"number\">0</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\">myFunction(<span class=\"number\">-1</span>,...args,<span class=\"number\">2</span>,...[<span class=\"number\">3</span>]);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更强大的数组字面量\"><a href=\"#更强大的数组字面量\" class=\"headerlink\" title=\"更强大的数组字面量\"></a>更强大的数组字面量</h4><p><strong>例子：</strong> 目前为止，如果你想创建一个包含某些已有数组里的元素的新数组，通常会用到push、splice、concat等数组方法。有了新的展开运算符，可以这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> parts = [<span class=\"string\">'shoulder'</span>,<span class=\"string\">'knees'</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> lyrics = [<span class=\"string\">'head'</span>, ...parts, <span class=\"string\">'and'</span>, <span class=\"string\">'toes'</span>]; <span class=\"comment\">// [\"head\", \"shoulders\", \"knees\", \"and\", \"toes\"]</span></span><br></pre></td></tr></table></figure></p>\n<p>和函数调用一样，数组字面量中也可以使用…多次。</p>\n<h4 id=\"配合new运算符\"><a href=\"#配合new运算符\" class=\"headerlink\" title=\"配合new运算符\"></a>配合new运算符</h4><p><strong>例子：</strong> 在ES5中，我们无法同时使用new运算符合apply方法(apply方法调用[[Call]]而不是[[Construct]])。在ES6中，我们可以使用展开运算符，和普通的函数调用一样。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> dataFields = readDateFields(database);</span><br><span class=\"line\"><span class=\"keyword\">var</span> d = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(...dataFields);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"更好的push方法\"><a href=\"#更好的push方法\" class=\"headerlink\" title=\"更好的push方法\"></a>更好的push方法</h4><p><strong>例子：</strong> 在ES5中，我们可以使用push方法将一个数组添加到另一个数组的末尾：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"comment\">//将arr2中的所有元素添加到arr1中</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.apply(arr1,arr2);</span><br></pre></td></tr></table></figure></p>\n<p>在ES6中，可以这么写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr1.push(...arr2);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"将类数组对象转换成数组\"><a href=\"#将类数组对象转换成数组\" class=\"headerlink\" title=\"将类数组对象转换成数组\"></a>将类数组对象转换成数组</h4><p>展开操作可以将一个类数组对象中索引范围在[0,length)之间的所有属性的值添加到一个数组中，这样就可以得到一个真正的数组：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> nodeList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'div'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure></p>\n"},{"title":"es6系列教程二","date":"2016-06-02T02:06:25.000Z","_content":"> It's an imperfect world, but it's the only one we've got.\n\n# Class\n从ECMAScript 6开始，JavaScript有了类(class)这个概念。但是需要注意的是，这并不是说：JavaScript从此变得像其他基于面向对象语言一样，有了一种全新的继承模式。JavaScript中的类只是javascript现有的、基于原型的继承模型的一种语法包装(语法糖)，它能让我们用更简洁明了的语法实现继承。\n\n## 定义类\nES6中的类实际上就是个函数，而且正如函数的定义方式有函数声明和函数表达式两种一样，类的定义方式也有两种，分别是：\n - 类声明\n - 类表达式\n\n### 类声明\n类声明是定义类的一种方式，就像下面这样，使用class关键字后跟一个类名（这里是Polygon），就可以定义一个类。\n```javascript\n  class Polygon{\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n  }\n```\n\n#### 变量提升\n类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。也就是说，你必须先声明类，然后才能使用它，否则代码会抛出ReferenceError异常，像下面这样：\n\n```javascript\n  var p = new Polygon(); //ReferenceError\n\n  class Polygon{}\n```\n\n### 类表达式\n类表达式是定义类的另一种方式，就像函数表达式一样，在类表达式中，类名是可有可无的。如果定义了类名，则类名只有在类体内部才能访问。\n\n```javascript\n  //匿名类表达式\n  var Polygon = class {\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n  };\n\n  //命名类表达式\n  var Polygon = class Polygon{\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n  }\n```\n\n## 类体和方法定义\n类的成员需要定义在一对花括号{}里，花括号里的代码和花括号本身组成了类体。类成员包括类构造器和类方法(包括静态方法和实例方法)。\n\n### 严格模式\n类体中的代码都强制在严格模式中执行，即便你没有写\"use strict\"。\n\n### 构造器(constructor方法)\nconstructor方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化一个类的时候被调用。一个类只能拥有一个名为constructor的方法，否则会抛出SyntaxError异常。\n\n在子类的构造器中可以使用super关键字调用父类的构造器。\n\n### 原型方法\n```javascript\n  class Polygon {\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n\n    get area(){\n      return this.calcArea()\n    }\n\n    calcArea(){\n      return this.height * this.width;\n    }\n  }\n```\n\n### 静态方法\nstatic关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化，使用类名就可以直接访问的方法。静态方法经常用来作为工具函数。\n```javascript\n  class Point{\n    constructor(x,y){\n      this.x = x;\n      this.y = y;\n    }\n\n    static distance(a,b){\n      const dx = a*x - b*y;\n      const dy = a*y - b*y;\n\n      return Math.sqrt(dx*dx + dy*dy);\n    }\n  }\n\n  const p1 = new Point(5,5);\n  const p2 = new Point(10,10);\n\n  console.log(Point.distance(p1,p2));\n```\n\n## 使用extends关键字创建子类\nextends 关键字可以用来创建继承于某个类的子类。\n```javascript\n  class Animal {\n    constructor(name){\n      this.name = name;\n    }\n\n    speak(){\n      console.log(this.name + ' make a noise.');\n    }\n  }\n\n  class Dog extends Animal {\n    speak(){\n      console.log(this.name + ' barks.');\n    }\n  }\n```\n\n## 为内置对象类型(Array,RegExp等)创建子类\n### 使用super关键字引用父类\nsuper这个关键字。有两种用法，含义不同。\n 1. 作为函数调用时(即super(...args)),super代表父类的构造函数。\n 2. 作为对象调用时(即super.prop或super.method()),super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。\n\n```javascript\n  class B extends A {\n    get m(){\n      return this._p * super._p;\n    }\n    set m(){\n      throw new Error('该属性只读');\n    }\n  }\n```\n上面代码中，子类通过super关键字，调用父类实例的_p属性。\n\n由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\n\n```javascript\n  var obj = {\n    toString() {\n      return \"MyObject: \" + super.toString();\n    }\n  }\n\n  obj.toString(); //MyObject: [Object Object]\n```\n\n## Class的取值函数(getter)和存值函数(setter)\n与ES5一样，在class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n```javascript\n  class MyClass {\n    constructor(){...}\n\n    get prop(){\n      return 'getter';\n    }\n\n    set prop(value){\n      console.log('setter: ' + value);\n    }\n  }\n\n  let inst = new MyClass();\n\n  inst.prop = 123;\n  //setter: 123\n\n  inst.prop\n  //getter\n```\n上面的代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的descriptor对象上的。\n```javascript\n  class CustomHTMLElement{\n    constructor(element){\n      this.element = element;\n    }\n\n    get html(){\n      return this.element.innerHTML;\n    }\n\n    set html(value){\n      this.element.innerHTML = value;\n    }\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(\n    CustomHTMLElement.ptoperty,\"html\"\n  );\n\n  \"get\" in descriptor //ture\n  \"set\" in descriptor //true\n```\n上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。\n\n# Enhanced Object Literals 增强的对象字面量\n对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：\n - 可以在对象字面量里面定义原型\n - 定义方法可以不用function关键字\n - 直接调用父类方法\n\n这样一来，对象字面量与前面提到的类概念更加吻合，在编写面向对象的javascript时更加轻松方便。\n```javascript\n  //通过对象字面量创建对象\n  var human = {\n    breathe(){\n      console.log('breathing...');\n    }\n  };\n\n  var worker = {\n    __proto__: human, //设置此对象的原型为human，相当于继承human\n    company: 'freelancer',\n    work(){\n      console.log('working...');\n    }\n  };\n\n  human.breathe(); //输出‘breathing...’\n  //调用继承来的breathe方法\n  worker.breathe(); //输出‘breathing...’\n```\n\n# Template Strings 字符串模板\n模板字符串允许嵌入表达式，并且支持多行字符串和字符串插补特性。\n## 语法\n```javascript\n  `string text`\n\n  `string text line 1\n   string text line 2`\n\n   `string text ${expression} string text`\n\n   tag `string text ${expression} string text`\n```\n\n## 描述\n模板字符串使用反括号(` `)来代替普通字符串中的用双引号和单引号。模板字符串可以包含特性语法(${expression})的占位符。占位符中的表达式和周围的文本会在一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数对模板字符串来进行操作处理。\n\n### 多行字符串\n在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：\n```javascript\n  console.log(\"string text line 1 \\n\\\n  string text line 2\");\n  //\"string text line 1\n  // string text line 2\"\n```\n\n要获得同样效果的多行字符串，只需要使用代码：\n```javascript\n  console.log(`string text line 1\n  string text line 2`);\n  // \"string text line 1\n  // string text line 2\"\n```\n\n### 表达式插补\n在普通字符串中嵌入表达式，必须使用如下语法：\n```javascript\n  var a = 5;\n  var b = 10;\n  console.log(\"Fifteen is \" + (a+b) + \" and\\nnot \" + (2*a+b) + \".\");\n  // \"Fifteen is 15 and\n  // not 20.\"\n```\n\n现在通过模板字符串，我们可以使用一种更优雅的方式来表示：\n```javascript\n  var a = 5;\n  var b = 10;\n  console.log(`Fifteen is &{a+b} and\\nnot ${2*a + b}.`);\n  // \"Fifteen is 15 and\n  // not 20.\"\n```\n\n### 带标签的模板字符串\n模板字符串的一种更高级的形式称为带标签的模板字符串。它允许你通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式。最后，标签函数返回处理好的字符串。在后面的示例中，标签函数的名称可以为任意的合法标志符。\n```javascript\n  var a = 5;\n  var b = 10;\n\n  function tag(string,...values){\n    console.log(strings[0]); // \"Hello \"\n    console.log(strings[1]); // \" world \"\n    console.log(values[0]);  // 15\n    console.log(values[1]);  // 50\n\n    return \"Bazinga!\";\n  }\n\n  tag`Hello ${ a + b } world ${ a * b}`;\n  // \"Bazinga!\"\n```\n\n### 原始字符串\n在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。\n```javascript\n  function tag(strings, ...values) {\n  console.log(strings.raw[0]);\n  // \"string text line 1 \\\\n string text line 2\"\n  }\n\n  tag`string text line 1 \\n string text line 2`;\n```\n\n另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。\n```javascript\n  String.raw`Hi\\n${2+3}!`;\n  // \"Hi\\\\n5!\"\n```\n","source":"_posts/es6系列教程二.md","raw":"---\ntitle: es6系列教程二\ndate: 2016-06-02 10:06:25\ntags:\n  - es6\n  - javascript\ncategories: 原创\n---\n> It's an imperfect world, but it's the only one we've got.\n\n# Class\n从ECMAScript 6开始，JavaScript有了类(class)这个概念。但是需要注意的是，这并不是说：JavaScript从此变得像其他基于面向对象语言一样，有了一种全新的继承模式。JavaScript中的类只是javascript现有的、基于原型的继承模型的一种语法包装(语法糖)，它能让我们用更简洁明了的语法实现继承。\n\n## 定义类\nES6中的类实际上就是个函数，而且正如函数的定义方式有函数声明和函数表达式两种一样，类的定义方式也有两种，分别是：\n - 类声明\n - 类表达式\n\n### 类声明\n类声明是定义类的一种方式，就像下面这样，使用class关键字后跟一个类名（这里是Polygon），就可以定义一个类。\n```javascript\n  class Polygon{\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n  }\n```\n\n#### 变量提升\n类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。也就是说，你必须先声明类，然后才能使用它，否则代码会抛出ReferenceError异常，像下面这样：\n\n```javascript\n  var p = new Polygon(); //ReferenceError\n\n  class Polygon{}\n```\n\n### 类表达式\n类表达式是定义类的另一种方式，就像函数表达式一样，在类表达式中，类名是可有可无的。如果定义了类名，则类名只有在类体内部才能访问。\n\n```javascript\n  //匿名类表达式\n  var Polygon = class {\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n  };\n\n  //命名类表达式\n  var Polygon = class Polygon{\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n  }\n```\n\n## 类体和方法定义\n类的成员需要定义在一对花括号{}里，花括号里的代码和花括号本身组成了类体。类成员包括类构造器和类方法(包括静态方法和实例方法)。\n\n### 严格模式\n类体中的代码都强制在严格模式中执行，即便你没有写\"use strict\"。\n\n### 构造器(constructor方法)\nconstructor方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化一个类的时候被调用。一个类只能拥有一个名为constructor的方法，否则会抛出SyntaxError异常。\n\n在子类的构造器中可以使用super关键字调用父类的构造器。\n\n### 原型方法\n```javascript\n  class Polygon {\n    constructor(height,width){\n      this.height = height;\n      this.width = width;\n    }\n\n    get area(){\n      return this.calcArea()\n    }\n\n    calcArea(){\n      return this.height * this.width;\n    }\n  }\n```\n\n### 静态方法\nstatic关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化，使用类名就可以直接访问的方法。静态方法经常用来作为工具函数。\n```javascript\n  class Point{\n    constructor(x,y){\n      this.x = x;\n      this.y = y;\n    }\n\n    static distance(a,b){\n      const dx = a*x - b*y;\n      const dy = a*y - b*y;\n\n      return Math.sqrt(dx*dx + dy*dy);\n    }\n  }\n\n  const p1 = new Point(5,5);\n  const p2 = new Point(10,10);\n\n  console.log(Point.distance(p1,p2));\n```\n\n## 使用extends关键字创建子类\nextends 关键字可以用来创建继承于某个类的子类。\n```javascript\n  class Animal {\n    constructor(name){\n      this.name = name;\n    }\n\n    speak(){\n      console.log(this.name + ' make a noise.');\n    }\n  }\n\n  class Dog extends Animal {\n    speak(){\n      console.log(this.name + ' barks.');\n    }\n  }\n```\n\n## 为内置对象类型(Array,RegExp等)创建子类\n### 使用super关键字引用父类\nsuper这个关键字。有两种用法，含义不同。\n 1. 作为函数调用时(即super(...args)),super代表父类的构造函数。\n 2. 作为对象调用时(即super.prop或super.method()),super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。\n\n```javascript\n  class B extends A {\n    get m(){\n      return this._p * super._p;\n    }\n    set m(){\n      throw new Error('该属性只读');\n    }\n  }\n```\n上面代码中，子类通过super关键字，调用父类实例的_p属性。\n\n由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。\n\n```javascript\n  var obj = {\n    toString() {\n      return \"MyObject: \" + super.toString();\n    }\n  }\n\n  obj.toString(); //MyObject: [Object Object]\n```\n\n## Class的取值函数(getter)和存值函数(setter)\n与ES5一样，在class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。\n\n```javascript\n  class MyClass {\n    constructor(){...}\n\n    get prop(){\n      return 'getter';\n    }\n\n    set prop(value){\n      console.log('setter: ' + value);\n    }\n  }\n\n  let inst = new MyClass();\n\n  inst.prop = 123;\n  //setter: 123\n\n  inst.prop\n  //getter\n```\n上面的代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。\n\n存值函数和取值函数是设置在属性的descriptor对象上的。\n```javascript\n  class CustomHTMLElement{\n    constructor(element){\n      this.element = element;\n    }\n\n    get html(){\n      return this.element.innerHTML;\n    }\n\n    set html(value){\n      this.element.innerHTML = value;\n    }\n  }\n\n  var descriptor = Object.getOwnPropertyDescriptor(\n    CustomHTMLElement.ptoperty,\"html\"\n  );\n\n  \"get\" in descriptor //ture\n  \"set\" in descriptor //true\n```\n上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。\n\n# Enhanced Object Literals 增强的对象字面量\n对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：\n - 可以在对象字面量里面定义原型\n - 定义方法可以不用function关键字\n - 直接调用父类方法\n\n这样一来，对象字面量与前面提到的类概念更加吻合，在编写面向对象的javascript时更加轻松方便。\n```javascript\n  //通过对象字面量创建对象\n  var human = {\n    breathe(){\n      console.log('breathing...');\n    }\n  };\n\n  var worker = {\n    __proto__: human, //设置此对象的原型为human，相当于继承human\n    company: 'freelancer',\n    work(){\n      console.log('working...');\n    }\n  };\n\n  human.breathe(); //输出‘breathing...’\n  //调用继承来的breathe方法\n  worker.breathe(); //输出‘breathing...’\n```\n\n# Template Strings 字符串模板\n模板字符串允许嵌入表达式，并且支持多行字符串和字符串插补特性。\n## 语法\n```javascript\n  `string text`\n\n  `string text line 1\n   string text line 2`\n\n   `string text ${expression} string text`\n\n   tag `string text ${expression} string text`\n```\n\n## 描述\n模板字符串使用反括号(` `)来代替普通字符串中的用双引号和单引号。模板字符串可以包含特性语法(${expression})的占位符。占位符中的表达式和周围的文本会在一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数对模板字符串来进行操作处理。\n\n### 多行字符串\n在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：\n```javascript\n  console.log(\"string text line 1 \\n\\\n  string text line 2\");\n  //\"string text line 1\n  // string text line 2\"\n```\n\n要获得同样效果的多行字符串，只需要使用代码：\n```javascript\n  console.log(`string text line 1\n  string text line 2`);\n  // \"string text line 1\n  // string text line 2\"\n```\n\n### 表达式插补\n在普通字符串中嵌入表达式，必须使用如下语法：\n```javascript\n  var a = 5;\n  var b = 10;\n  console.log(\"Fifteen is \" + (a+b) + \" and\\nnot \" + (2*a+b) + \".\");\n  // \"Fifteen is 15 and\n  // not 20.\"\n```\n\n现在通过模板字符串，我们可以使用一种更优雅的方式来表示：\n```javascript\n  var a = 5;\n  var b = 10;\n  console.log(`Fifteen is &{a+b} and\\nnot ${2*a + b}.`);\n  // \"Fifteen is 15 and\n  // not 20.\"\n```\n\n### 带标签的模板字符串\n模板字符串的一种更高级的形式称为带标签的模板字符串。它允许你通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式。最后，标签函数返回处理好的字符串。在后面的示例中，标签函数的名称可以为任意的合法标志符。\n```javascript\n  var a = 5;\n  var b = 10;\n\n  function tag(string,...values){\n    console.log(strings[0]); // \"Hello \"\n    console.log(strings[1]); // \" world \"\n    console.log(values[0]);  // 15\n    console.log(values[1]);  // 50\n\n    return \"Bazinga!\";\n  }\n\n  tag`Hello ${ a + b } world ${ a * b}`;\n  // \"Bazinga!\"\n```\n\n### 原始字符串\n在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。\n```javascript\n  function tag(strings, ...values) {\n  console.log(strings.raw[0]);\n  // \"string text line 1 \\\\n string text line 2\"\n  }\n\n  tag`string text line 1 \\n string text line 2`;\n```\n\n另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。\n```javascript\n  String.raw`Hi\\n${2+3}!`;\n  // \"Hi\\\\n5!\"\n```\n","slug":"es6系列教程二","published":1,"updated":"2016-06-02T09:42:04.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emp000nb0dlinursj4d","content":"<blockquote>\n<p>It’s an imperfect world, but it’s the only one we’ve got.</p>\n</blockquote>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><p>从ECMAScript 6开始，JavaScript有了类(class)这个概念。但是需要注意的是，这并不是说：JavaScript从此变得像其他基于面向对象语言一样，有了一种全新的继承模式。JavaScript中的类只是javascript现有的、基于原型的继承模型的一种语法包装(语法糖)，它能让我们用更简洁明了的语法实现继承。</p>\n<h2 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h2><p>ES6中的类实际上就是个函数，而且正如函数的定义方式有函数声明和函数表达式两种一样，类的定义方式也有两种，分别是：</p>\n<ul>\n<li>类声明</li>\n<li>类表达式</li>\n</ul>\n<h3 id=\"类声明\"><a href=\"#类声明\" class=\"headerlink\" title=\"类声明\"></a>类声明</h3><p>类声明是定义类的一种方式，就像下面这样，使用class关键字后跟一个类名（这里是Polygon），就可以定义一个类。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><p>类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。也就是说，你必须先声明类，然后才能使用它，否则代码会抛出ReferenceError异常，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Polygon(); <span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类表达式\"><a href=\"#类表达式\" class=\"headerlink\" title=\"类表达式\"></a>类表达式</h3><p>类表达式是定义类的另一种方式，就像函数表达式一样，在类表达式中，类名是可有可无的。如果定义了类名，则类名只有在类体内部才能访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//匿名类表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Polygon = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//命名类表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Polygon = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类体和方法定义\"><a href=\"#类体和方法定义\" class=\"headerlink\" title=\"类体和方法定义\"></a>类体和方法定义</h2><p>类的成员需要定义在一对花括号{}里，花括号里的代码和花括号本身组成了类体。类成员包括类构造器和类方法(包括静态方法和实例方法)。</p>\n<h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>类体中的代码都强制在严格模式中执行，即便你没有写”use strict”。</p>\n<h3 id=\"构造器-constructor方法\"><a href=\"#构造器-constructor方法\" class=\"headerlink\" title=\"构造器(constructor方法)\"></a>构造器(constructor方法)</h3><p>constructor方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化一个类的时候被调用。一个类只能拥有一个名为constructor的方法，否则会抛出SyntaxError异常。</p>\n<p>在子类的构造器中可以使用super关键字调用父类的构造器。</p>\n<h3 id=\"原型方法\"><a href=\"#原型方法\" class=\"headerlink\" title=\"原型方法\"></a>原型方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get area()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.calcArea()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  calcArea()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>static关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化，使用类名就可以直接访问的方法。静态方法经常用来作为工具函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x,y)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> distance(a,b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dx = a*x - b*y;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dy = a*y - b*y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(dx*dx + dy*dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">5</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">10</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Point.distance(p1,p2));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用extends关键字创建子类\"><a href=\"#使用extends关键字创建子类\" class=\"headerlink\" title=\"使用extends关键字创建子类\"></a>使用extends关键字创建子类</h2><p>extends 关键字可以用来创建继承于某个类的子类。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' make a noise.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' barks.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"为内置对象类型-Array-RegExp等-创建子类\"><a href=\"#为内置对象类型-Array-RegExp等-创建子类\" class=\"headerlink\" title=\"为内置对象类型(Array,RegExp等)创建子类\"></a>为内置对象类型(Array,RegExp等)创建子类</h2><h3 id=\"使用super关键字引用父类\"><a href=\"#使用super关键字引用父类\" class=\"headerlink\" title=\"使用super关键字引用父类\"></a>使用super关键字引用父类</h3><p>super这个关键字。有两种用法，含义不同。</p>\n<ol>\n<li>作为函数调用时(即super(…args)),super代表父类的构造函数。</li>\n<li>作为对象调用时(即super.prop或super.method()),super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  get m()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._p * <span class=\"keyword\">super</span>._p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  set m()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该属性只读'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，子类通过super关键字，调用父类实例的_p属性。</p>\n<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"MyObject: \"</span> + <span class=\"keyword\">super</span>.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.toString(); <span class=\"comment\">//MyObject: [Object Object]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Class的取值函数-getter-和存值函数-setter\"><a href=\"#Class的取值函数-getter-和存值函数-setter\" class=\"headerlink\" title=\"Class的取值函数(getter)和存值函数(setter)\"></a>Class的取值函数(getter)和存值函数(setter)</h2><p>与ES5一样，在class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get prop()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set prop(value)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter: '</span> + value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">//setter: 123</span></span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop</span><br><span class=\"line\"><span class=\"comment\">//getter</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>\n<p>存值函数和取值函数是设置在属性的descriptor对象上的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomHTMLElement</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(element)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get html()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.element.innerHTML;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set html(value)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element.innerHTML = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(</span><br><span class=\"line\">  CustomHTMLElement.ptoperty,<span class=\"string\">\"html\"</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"get\"</span> <span class=\"keyword\">in</span> descriptor <span class=\"comment\">//ture</span></span><br><span class=\"line\"><span class=\"string\">\"set\"</span> <span class=\"keyword\">in</span> descriptor <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>\n<h1 id=\"Enhanced-Object-Literals-增强的对象字面量\"><a href=\"#Enhanced-Object-Literals-增强的对象字面量\" class=\"headerlink\" title=\"Enhanced Object Literals 增强的对象字面量\"></a>Enhanced Object Literals 增强的对象字面量</h1><p>对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：</p>\n<ul>\n<li>可以在对象字面量里面定义原型</li>\n<li>定义方法可以不用function关键字</li>\n<li>直接调用父类方法</li>\n</ul>\n<p>这样一来，对象字面量与前面提到的类概念更加吻合，在编写面向对象的javascript时更加轻松方便。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过对象字面量创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> human = &#123;</span><br><span class=\"line\">  breathe()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'breathing...'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> worker = &#123;</span><br><span class=\"line\">  __proto__: human, <span class=\"comment\">//设置此对象的原型为human，相当于继承human</span></span><br><span class=\"line\">  company: <span class=\"string\">'freelancer'</span>,</span><br><span class=\"line\">  work()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'working...'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">human.breathe(); <span class=\"comment\">//输出‘breathing...’</span></span><br><span class=\"line\"><span class=\"comment\">//调用继承来的breathe方法</span></span><br><span class=\"line\">worker.breathe(); <span class=\"comment\">//输出‘breathing...’</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Template-Strings-字符串模板\"><a href=\"#Template-Strings-字符串模板\" class=\"headerlink\" title=\"Template Strings 字符串模板\"></a>Template Strings 字符串模板</h1><p>模板字符串允许嵌入表达式，并且支持多行字符串和字符串插补特性。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`string text`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`string text line 1</span><br><span class=\"line\"> string text line 2`</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">`string text <span class=\"subst\">$&#123;expression&#125;</span> string text`</span></span><br><span class=\"line\"></span><br><span class=\"line\"> tag <span class=\"string\">`string text <span class=\"subst\">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>模板字符串使用反括号(<code> </code>)来代替普通字符串中的用双引号和单引号。模板字符串可以包含特性语法(${expression})的占位符。占位符中的表达式和周围的文本会在一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数对模板字符串来进行操作处理。</p>\n<h3 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h3><p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string text line 1 \\n\\</span><br><span class=\"line\">string text line 2\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//\"string text line 1</span></span><br><span class=\"line\"><span class=\"comment\">// string text line 2\"</span></span><br></pre></td></tr></table></figure></p>\n<p>要获得同样效果的多行字符串，只需要使用代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`string text line 1</span><br><span class=\"line\">string text line 2`</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"string text line 1</span></span><br><span class=\"line\"><span class=\"comment\">// string text line 2\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"表达式插补\"><a href=\"#表达式插补\" class=\"headerlink\" title=\"表达式插补\"></a>表达式插补</h3><p>在普通字符串中嵌入表达式，必须使用如下语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Fifteen is \"</span> + (a+b) + <span class=\"string\">\" and\\nnot \"</span> + (<span class=\"number\">2</span>*a+b) + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"Fifteen is 15 and</span></span><br><span class=\"line\"><span class=\"comment\">// not 20.\"</span></span><br></pre></td></tr></table></figure></p>\n<p>现在通过模板字符串，我们可以使用一种更优雅的方式来表示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Fifteen is &amp;&#123;a+b&#125; and\\nnot <span class=\"subst\">$&#123;2*a + b&#125;</span>.`</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"Fifteen is 15 and</span></span><br><span class=\"line\"><span class=\"comment\">// not 20.\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"带标签的模板字符串\"><a href=\"#带标签的模板字符串\" class=\"headerlink\" title=\"带标签的模板字符串\"></a>带标签的模板字符串</h3><p>模板字符串的一种更高级的形式称为带标签的模板字符串。它允许你通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式。最后，标签函数返回处理好的字符串。在后面的示例中，标签函数的名称可以为任意的合法标志符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">string,...values</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(strings[<span class=\"number\">0</span>]); <span class=\"comment\">// \"Hello \"</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(strings[<span class=\"number\">1</span>]); <span class=\"comment\">// \" world \"</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values[<span class=\"number\">0</span>]);  <span class=\"comment\">// 15</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values[<span class=\"number\">1</span>]);  <span class=\"comment\">// 50</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Bazinga!\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tag<span class=\"string\">`Hello <span class=\"subst\">$&#123; a + b &#125;</span> world <span class=\"subst\">$&#123; a * b&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"comment\">// \"Bazinga!\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"原始字符串\"><a href=\"#原始字符串\" class=\"headerlink\" title=\"原始字符串\"></a>原始字符串</h3><p>在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">strings, ...values</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strings.raw[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"comment\">// \"string text line 1 \\\\n string text line 2\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tag<span class=\"string\">`string text line 1 \\n string text line 2`</span>;</span><br></pre></td></tr></table></figure></p>\n<p>另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\n<span class=\"subst\">$&#123;2+3&#125;</span>!`</span>;</span><br><span class=\"line\"><span class=\"comment\">// \"Hi\\\\n5!\"</span></span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>It’s an imperfect world, but it’s the only one we’ve got.</p>\n</blockquote>\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><p>从ECMAScript 6开始，JavaScript有了类(class)这个概念。但是需要注意的是，这并不是说：JavaScript从此变得像其他基于面向对象语言一样，有了一种全新的继承模式。JavaScript中的类只是javascript现有的、基于原型的继承模型的一种语法包装(语法糖)，它能让我们用更简洁明了的语法实现继承。</p>\n<h2 id=\"定义类\"><a href=\"#定义类\" class=\"headerlink\" title=\"定义类\"></a>定义类</h2><p>ES6中的类实际上就是个函数，而且正如函数的定义方式有函数声明和函数表达式两种一样，类的定义方式也有两种，分别是：</p>\n<ul>\n<li>类声明</li>\n<li>类表达式</li>\n</ul>\n<h3 id=\"类声明\"><a href=\"#类声明\" class=\"headerlink\" title=\"类声明\"></a>类声明</h3><p>类声明是定义类的一种方式，就像下面这样，使用class关键字后跟一个类名（这里是Polygon），就可以定义一个类。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><p>类声明和函数声明不同的一点是，函数声明存在变量提升现象，而类声明不会。也就是说，你必须先声明类，然后才能使用它，否则代码会抛出ReferenceError异常，像下面这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> Polygon(); <span class=\"comment\">//ReferenceError</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类表达式\"><a href=\"#类表达式\" class=\"headerlink\" title=\"类表达式\"></a>类表达式</h3><p>类表达式是定义类的另一种方式，就像函数表达式一样，在类表达式中，类名是可有可无的。如果定义了类名，则类名只有在类体内部才能访问。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//匿名类表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Polygon = <span class=\"class\"><span class=\"keyword\">class</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//命名类表达式</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Polygon = <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"类体和方法定义\"><a href=\"#类体和方法定义\" class=\"headerlink\" title=\"类体和方法定义\"></a>类体和方法定义</h2><p>类的成员需要定义在一对花括号{}里，花括号里的代码和花括号本身组成了类体。类成员包括类构造器和类方法(包括静态方法和实例方法)。</p>\n<h3 id=\"严格模式\"><a href=\"#严格模式\" class=\"headerlink\" title=\"严格模式\"></a>严格模式</h3><p>类体中的代码都强制在严格模式中执行，即便你没有写”use strict”。</p>\n<h3 id=\"构造器-constructor方法\"><a href=\"#构造器-constructor方法\" class=\"headerlink\" title=\"构造器(constructor方法)\"></a>构造器(constructor方法)</h3><p>constructor方法是一个特殊的类方法，它既不是静态方法也不是实例方法，它仅在实例化一个类的时候被调用。一个类只能拥有一个名为constructor的方法，否则会抛出SyntaxError异常。</p>\n<p>在子类的构造器中可以使用super关键字调用父类的构造器。</p>\n<h3 id=\"原型方法\"><a href=\"#原型方法\" class=\"headerlink\" title=\"原型方法\"></a>原型方法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(height,width)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get area()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.calcArea()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  calcArea()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h3><p>static关键字用来定义类的静态方法。静态方法是指那些不需要对类进行实例化，使用类名就可以直接访问的方法。静态方法经常用来作为工具函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(x,y)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.x = x;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">static</span> distance(a,b)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dx = a*x - b*y;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dy = a*y - b*y;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.sqrt(dx*dx + dy*dy);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> p1 = <span class=\"keyword\">new</span> Point(<span class=\"number\">5</span>,<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> p2 = <span class=\"keyword\">new</span> Point(<span class=\"number\">10</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(Point.distance(p1,p2));</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用extends关键字创建子类\"><a href=\"#使用extends关键字创建子类\" class=\"headerlink\" title=\"使用extends关键字创建子类\"></a>使用extends关键字创建子类</h2><p>extends 关键字可以用来创建继承于某个类的子类。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' make a noise.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Animal</span> </span>&#123;</span><br><span class=\"line\">  speak()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name + <span class=\"string\">' barks.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"为内置对象类型-Array-RegExp等-创建子类\"><a href=\"#为内置对象类型-Array-RegExp等-创建子类\" class=\"headerlink\" title=\"为内置对象类型(Array,RegExp等)创建子类\"></a>为内置对象类型(Array,RegExp等)创建子类</h2><h3 id=\"使用super关键字引用父类\"><a href=\"#使用super关键字引用父类\" class=\"headerlink\" title=\"使用super关键字引用父类\"></a>使用super关键字引用父类</h3><p>super这个关键字。有两种用法，含义不同。</p>\n<ol>\n<li>作为函数调用时(即super(…args)),super代表父类的构造函数。</li>\n<li>作为对象调用时(即super.prop或super.method()),super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"keyword\">extends</span> <span class=\"title\">A</span> </span>&#123;</span><br><span class=\"line\">  get m()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._p * <span class=\"keyword\">super</span>._p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  set m()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'该属性只读'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面代码中，子类通过super关键字，调用父类实例的_p属性。</p>\n<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">\"MyObject: \"</span> + <span class=\"keyword\">super</span>.toString();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.toString(); <span class=\"comment\">//MyObject: [Object Object]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Class的取值函数-getter-和存值函数-setter\"><a href=\"#Class的取值函数-getter-和存值函数-setter\" class=\"headerlink\" title=\"Class的取值函数(getter)和存值函数(setter)\"></a>Class的取值函数(getter)和存值函数(setter)</h2><p>与ES5一样，在class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;...&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get prop()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'getter'</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set prop(value)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'setter: '</span> + value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> inst = <span class=\"keyword\">new</span> MyClass();</span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"comment\">//setter: 123</span></span><br><span class=\"line\"></span><br><span class=\"line\">inst.prop</span><br><span class=\"line\"><span class=\"comment\">//getter</span></span><br></pre></td></tr></table></figure>\n<p>上面的代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p>\n<p>存值函数和取值函数是设置在属性的descriptor对象上的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomHTMLElement</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(element)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get html()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.element.innerHTML;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set html(value)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element.innerHTML = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> descriptor = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(</span><br><span class=\"line\">  CustomHTMLElement.ptoperty,<span class=\"string\">\"html\"</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">\"get\"</span> <span class=\"keyword\">in</span> descriptor <span class=\"comment\">//ture</span></span><br><span class=\"line\"><span class=\"string\">\"set\"</span> <span class=\"keyword\">in</span> descriptor <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>\n<h1 id=\"Enhanced-Object-Literals-增强的对象字面量\"><a href=\"#Enhanced-Object-Literals-增强的对象字面量\" class=\"headerlink\" title=\"Enhanced Object Literals 增强的对象字面量\"></a>Enhanced Object Literals 增强的对象字面量</h1><p>对象字面量被增强了，写法更加简洁与灵活，同时在定义对象的时候能够做的事情更多了。具体表现在：</p>\n<ul>\n<li>可以在对象字面量里面定义原型</li>\n<li>定义方法可以不用function关键字</li>\n<li>直接调用父类方法</li>\n</ul>\n<p>这样一来，对象字面量与前面提到的类概念更加吻合，在编写面向对象的javascript时更加轻松方便。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过对象字面量创建对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> human = &#123;</span><br><span class=\"line\">  breathe()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'breathing...'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> worker = &#123;</span><br><span class=\"line\">  __proto__: human, <span class=\"comment\">//设置此对象的原型为human，相当于继承human</span></span><br><span class=\"line\">  company: <span class=\"string\">'freelancer'</span>,</span><br><span class=\"line\">  work()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'working...'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">human.breathe(); <span class=\"comment\">//输出‘breathing...’</span></span><br><span class=\"line\"><span class=\"comment\">//调用继承来的breathe方法</span></span><br><span class=\"line\">worker.breathe(); <span class=\"comment\">//输出‘breathing...’</span></span><br></pre></td></tr></table></figure></p>\n<h1 id=\"Template-Strings-字符串模板\"><a href=\"#Template-Strings-字符串模板\" class=\"headerlink\" title=\"Template Strings 字符串模板\"></a>Template Strings 字符串模板</h1><p>模板字符串允许嵌入表达式，并且支持多行字符串和字符串插补特性。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">`string text`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">`string text line 1</span><br><span class=\"line\"> string text line 2`</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"string\">`string text <span class=\"subst\">$&#123;expression&#125;</span> string text`</span></span><br><span class=\"line\"></span><br><span class=\"line\"> tag <span class=\"string\">`string text <span class=\"subst\">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>模板字符串使用反括号(<code> </code>)来代替普通字符串中的用双引号和单引号。模板字符串可以包含特性语法(${expression})的占位符。占位符中的表达式和周围的文本会在一起传递给一个默认函数，该函数负责将所有的部分连接起来，如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数对模板字符串来进行操作处理。</p>\n<h3 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h3><p>在新行中插入的任何字符都是模板字符串中的一部分，使用普通字符串，你可以通过以下的方式获得多行字符串：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"string text line 1 \\n\\</span><br><span class=\"line\">string text line 2\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//\"string text line 1</span></span><br><span class=\"line\"><span class=\"comment\">// string text line 2\"</span></span><br></pre></td></tr></table></figure></p>\n<p>要获得同样效果的多行字符串，只需要使用代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`string text line 1</span><br><span class=\"line\">string text line 2`</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"string text line 1</span></span><br><span class=\"line\"><span class=\"comment\">// string text line 2\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"表达式插补\"><a href=\"#表达式插补\" class=\"headerlink\" title=\"表达式插补\"></a>表达式插补</h3><p>在普通字符串中嵌入表达式，必须使用如下语法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"Fifteen is \"</span> + (a+b) + <span class=\"string\">\" and\\nnot \"</span> + (<span class=\"number\">2</span>*a+b) + <span class=\"string\">\".\"</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"Fifteen is 15 and</span></span><br><span class=\"line\"><span class=\"comment\">// not 20.\"</span></span><br></pre></td></tr></table></figure></p>\n<p>现在通过模板字符串，我们可以使用一种更优雅的方式来表示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`Fifteen is &amp;&#123;a+b&#125; and\\nnot <span class=\"subst\">$&#123;2*a + b&#125;</span>.`</span>);</span><br><span class=\"line\"><span class=\"comment\">// \"Fifteen is 15 and</span></span><br><span class=\"line\"><span class=\"comment\">// not 20.\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"带标签的模板字符串\"><a href=\"#带标签的模板字符串\" class=\"headerlink\" title=\"带标签的模板字符串\"></a>带标签的模板字符串</h3><p>模板字符串的一种更高级的形式称为带标签的模板字符串。它允许你通过标签函数修改模板字符串的输出。标签函数的第一个参数是一个包含了字符串字面值的数组；第二个参数，在第一个参数后的每一个参数，都是已经被处理好的替换表达式。最后，标签函数返回处理好的字符串。在后面的示例中，标签函数的名称可以为任意的合法标志符。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">string,...values</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(strings[<span class=\"number\">0</span>]); <span class=\"comment\">// \"Hello \"</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(strings[<span class=\"number\">1</span>]); <span class=\"comment\">// \" world \"</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values[<span class=\"number\">0</span>]);  <span class=\"comment\">// 15</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(values[<span class=\"number\">1</span>]);  <span class=\"comment\">// 50</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"Bazinga!\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tag<span class=\"string\">`Hello <span class=\"subst\">$&#123; a + b &#125;</span> world <span class=\"subst\">$&#123; a * b&#125;</span>`</span>;</span><br><span class=\"line\"><span class=\"comment\">// \"Bazinga!\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"原始字符串\"><a href=\"#原始字符串\" class=\"headerlink\" title=\"原始字符串\"></a>原始字符串</h3><p>在标签函数的第一个参数中，存在一个特殊的属性raw ，我们可以通过它来访问模板字符串的原始字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tag</span>(<span class=\"params\">strings, ...values</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(strings.raw[<span class=\"number\">0</span>]);</span><br><span class=\"line\"><span class=\"comment\">// \"string text line 1 \\\\n string text line 2\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">tag<span class=\"string\">`string text line 1 \\n string text line 2`</span>;</span><br></pre></td></tr></table></figure></p>\n<p>另外，使用String.raw() 方法创建原始字符串和使用默认模板函数和字符串连接创建是一样的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">String</span>.raw<span class=\"string\">`Hi\\n<span class=\"subst\">$&#123;2+3&#125;</span>!`</span>;</span><br><span class=\"line\"><span class=\"comment\">// \"Hi\\\\n5!\"</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"reduce的用法","date":"2016-05-09T15:05:47.000Z","_content":"> Real dream is the other shore of reality.\n\n## 概述\nreduce() 方法接收一个函数作为累加器(accumulator)，数组中的每个值（从左到右）开始合并，最终为一个值。\n\n## 语法\n```javascript\n    arr.reduce(callback,[initialValue])\n```\n\n### 参数\n执行数组中的每个值得函数，包含四个参数\n\npreviousValue -- 上一次回调函数返回的值，或者是提供的初始值(initialValue)\n\ncurrentValue -- 数组中当前被处理的元素\n\nindex -- 当前元素在数组中的索引\n\narray -- 调用reduce的数组\n\ninitialValue -- 作为第一次调用callback的第一个参数。\n\n## 描述\nreduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素，当前索引，调用reduce的数组。\n\n回调函数第一次执行时，preciousValue和currentValue可以是一个值，如果initialValue在调用reduce时被提供，那么第一个preciousValue等于initialValue，并且currentValue等于数组中的第一个值；如果initialValue未被提供，那么previousValue等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue，会抛出TypeError。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue，或者有提供initialValue但是数组为空，那么此唯一值将被返回并callback不会被执行。\n\n例如下面的代码\n\n```javascript\n    [0,1,2,3,4].reduce(function(previousValue,currentValue,index,array){\n        return previousValue + currentValue;\n    })\n```\n\n回调函数被执行了四次，每次的参数和返回值如下表\n\n|   | previousValue | currentValue | index | array | return value |\n| ----- | :-----: | :-----: | :-----: | :-----: | -----: |\n| first call | 0 | 1 | 1 | [0,1,2,3,4] | 1 |\n| second call | 1 | 2 | 2 | [0,1,2,3,4] | 3 |\n| third call | 3 | 3 | 3 | [0,1,2,3,4] | 6 |\n| fourth call | 6 | 4 | 4 | [0,1,2,3,4] | 10 |\n\nreduce 的返回值是回调函数的最后一次被调用的返回值10。\n\n如果把初始值作为第二个参数传入reduce，最终返回值变为20，结果如下：\n\n```javascript\n    [0,1,2,3,4].reduce(function(previousValue,currentValue,index,array){\n        return previousValue + currentValue;\n    },10);\n```\n\n## 栗子\n1. 将数组所有项相加\n\n```javascript\n    var total = [0,1,2,3].reduce(function(a,b){\n        return a + b;\n    });\n    //total 6\n```\n\n2. 将数组扁平化\n\n```javascript\n    var flattened = [[0,1],[2,3],[4,5],[6,7]].reduce(function(a,b){\n        return a.concat(b);\n    });\n    // flattened is [0,1,2,3,4,5]\n```\n\n## 兼容旧环境(Polyfill)\nArray.prototype.reduce 被添加到ECMA-262标准第5版；因此可能在某些环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未被原生支持reduce的实现环境中使用它。\n\n```javascript\n    if('function' !== typeof Array.prototype.reduce){\n        Array.prototype.reduce = function(callback,opt_initialValue){\n            'use strict'\n            if(null == this || 'undefined' === typeof this){\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n            if('function' !== typeof(callback)){\n                throw new TypeError(callback + 'is not a function');\n            }\n            var index, value, length = this.length >>> 0, isValueSet = false;\n            if(1<argument.length){\n                value = opt_initialValue;\n                isValueSet = true;\n            }\n            for(index = 0;length > index; ++index){\n                if(this.hasOwnProperty(index)){\n                    if(isValueSet){\n                        value = callback(value,this[index],index,this);\n                    }else{\n                        value = this[index];\n                        isValueSet = true;\n                    }\n                }\n            }\n            if(!isValueSet){\n                throw new TypeError('Reduce of empty with no initial value');\n                return value;\n            }\n        }\n    }\n```\n\n\n\n\n\n\n\n\n","source":"_posts/reduce的用法.md","raw":"---\ntitle: reduce的用法\ndate: 2016-05-09 23:05:47\ntags:\n- javascript\n- reduce\ncategories: 教程\n---\n> Real dream is the other shore of reality.\n\n## 概述\nreduce() 方法接收一个函数作为累加器(accumulator)，数组中的每个值（从左到右）开始合并，最终为一个值。\n\n## 语法\n```javascript\n    arr.reduce(callback,[initialValue])\n```\n\n### 参数\n执行数组中的每个值得函数，包含四个参数\n\npreviousValue -- 上一次回调函数返回的值，或者是提供的初始值(initialValue)\n\ncurrentValue -- 数组中当前被处理的元素\n\nindex -- 当前元素在数组中的索引\n\narray -- 调用reduce的数组\n\ninitialValue -- 作为第一次调用callback的第一个参数。\n\n## 描述\nreduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素，当前索引，调用reduce的数组。\n\n回调函数第一次执行时，preciousValue和currentValue可以是一个值，如果initialValue在调用reduce时被提供，那么第一个preciousValue等于initialValue，并且currentValue等于数组中的第一个值；如果initialValue未被提供，那么previousValue等于数组中的第一个值，currentValue等于数组中的第二个值。\n\n如果数组为空并且没有提供initialValue，会抛出TypeError。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue，或者有提供initialValue但是数组为空，那么此唯一值将被返回并callback不会被执行。\n\n例如下面的代码\n\n```javascript\n    [0,1,2,3,4].reduce(function(previousValue,currentValue,index,array){\n        return previousValue + currentValue;\n    })\n```\n\n回调函数被执行了四次，每次的参数和返回值如下表\n\n|   | previousValue | currentValue | index | array | return value |\n| ----- | :-----: | :-----: | :-----: | :-----: | -----: |\n| first call | 0 | 1 | 1 | [0,1,2,3,4] | 1 |\n| second call | 1 | 2 | 2 | [0,1,2,3,4] | 3 |\n| third call | 3 | 3 | 3 | [0,1,2,3,4] | 6 |\n| fourth call | 6 | 4 | 4 | [0,1,2,3,4] | 10 |\n\nreduce 的返回值是回调函数的最后一次被调用的返回值10。\n\n如果把初始值作为第二个参数传入reduce，最终返回值变为20，结果如下：\n\n```javascript\n    [0,1,2,3,4].reduce(function(previousValue,currentValue,index,array){\n        return previousValue + currentValue;\n    },10);\n```\n\n## 栗子\n1. 将数组所有项相加\n\n```javascript\n    var total = [0,1,2,3].reduce(function(a,b){\n        return a + b;\n    });\n    //total 6\n```\n\n2. 将数组扁平化\n\n```javascript\n    var flattened = [[0,1],[2,3],[4,5],[6,7]].reduce(function(a,b){\n        return a.concat(b);\n    });\n    // flattened is [0,1,2,3,4,5]\n```\n\n## 兼容旧环境(Polyfill)\nArray.prototype.reduce 被添加到ECMA-262标准第5版；因此可能在某些环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未被原生支持reduce的实现环境中使用它。\n\n```javascript\n    if('function' !== typeof Array.prototype.reduce){\n        Array.prototype.reduce = function(callback,opt_initialValue){\n            'use strict'\n            if(null == this || 'undefined' === typeof this){\n                throw new TypeError('Array.prototype.reduce called on null or undefined');\n            }\n            if('function' !== typeof(callback)){\n                throw new TypeError(callback + 'is not a function');\n            }\n            var index, value, length = this.length >>> 0, isValueSet = false;\n            if(1<argument.length){\n                value = opt_initialValue;\n                isValueSet = true;\n            }\n            for(index = 0;length > index; ++index){\n                if(this.hasOwnProperty(index)){\n                    if(isValueSet){\n                        value = callback(value,this[index],index,this);\n                    }else{\n                        value = this[index];\n                        isValueSet = true;\n                    }\n                }\n            }\n            if(!isValueSet){\n                throw new TypeError('Reduce of empty with no initial value');\n                return value;\n            }\n        }\n    }\n```\n\n\n\n\n\n\n\n\n","slug":"reduce的用法","published":1,"updated":"2016-05-16T02:11:32.475Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emq000qb0dlejmu0kl8","content":"<blockquote>\n<p>Real dream is the other shore of reality.</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>reduce() 方法接收一个函数作为累加器(accumulator)，数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>执行数组中的每个值得函数，包含四个参数</p>\n<p>previousValue – 上一次回调函数返回的值，或者是提供的初始值(initialValue)</p>\n<p>currentValue – 数组中当前被处理的元素</p>\n<p>index – 当前元素在数组中的索引</p>\n<p>array – 调用reduce的数组</p>\n<p>initialValue – 作为第一次调用callback的第一个参数。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>reduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素，当前索引，调用reduce的数组。</p>\n<p>回调函数第一次执行时，preciousValue和currentValue可以是一个值，如果initialValue在调用reduce时被提供，那么第一个preciousValue等于initialValue，并且currentValue等于数组中的第一个值；如果initialValue未被提供，那么previousValue等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n<p>如果数组为空并且没有提供initialValue，会抛出TypeError。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue，或者有提供initialValue但是数组为空，那么此唯一值将被返回并callback不会被执行。</p>\n<p>例如下面的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previousValue,currentValue,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previousValue + currentValue;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>回调函数被执行了四次，每次的参数和返回值如下表</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">previousValue</th>\n<th style=\"text-align:center\">currentValue</th>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">array</th>\n<th style=\"text-align:right\">return value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first call</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">1</td>\n</tr>\n<tr>\n<td>second call</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">3</td>\n</tr>\n<tr>\n<td>third call</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">6</td>\n</tr>\n<tr>\n<td>fourth call</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">10</td>\n</tr>\n</tbody>\n</table>\n<p>reduce 的返回值是回调函数的最后一次被调用的返回值10。</p>\n<p>如果把初始值作为第二个参数传入reduce，最终返回值变为20，结果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previousValue,currentValue,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previousValue + currentValue;</span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h2><ol>\n<li>将数组所有项相加</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//total 6</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>将数组扁平化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flattened = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">6</span>,<span class=\"number\">7</span>]].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.concat(b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// flattened is [0,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"兼容旧环境-Polyfill\"><a href=\"#兼容旧环境-Polyfill\" class=\"headerlink\" title=\"兼容旧环境(Polyfill)\"></a>兼容旧环境(Polyfill)</h2><p>Array.prototype.reduce 被添加到ECMA-262标准第5版；因此可能在某些环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未被原生支持reduce的实现环境中使用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">'function'</span> !== <span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.reduce)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.reduce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback,opt_initialValue</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">        'use strict'</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span> == <span class=\"keyword\">this</span> || <span class=\"string\">'undefined'</span> === <span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Array.prototype.reduce called on null or undefined'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">'function'</span> !== <span class=\"keyword\">typeof</span>(callback))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callback + <span class=\"string\">'is not a function'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index, value, length = <span class=\"keyword\">this</span>.length &gt;&gt;&gt; <span class=\"number\">0</span>, isValueSet = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">1</span>&lt;argument.length)&#123;</span><br><span class=\"line\">            value = opt_initialValue;</span><br><span class=\"line\">            isValueSet = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(index = <span class=\"number\">0</span>;length &gt; index; ++index)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.hasOwnProperty(index))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isValueSet)&#123;</span><br><span class=\"line\">                    value = callback(value,<span class=\"keyword\">this</span>[index],index,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    value = <span class=\"keyword\">this</span>[index];</span><br><span class=\"line\">                    isValueSet = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!isValueSet)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Reduce of empty with no initial value'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","excerpt":"","more":"<blockquote>\n<p>Real dream is the other shore of reality.</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>reduce() 方法接收一个函数作为累加器(accumulator)，数组中的每个值（从左到右）开始合并，最终为一个值。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.reduce(callback,[initialValue])</span><br></pre></td></tr></table></figure>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>执行数组中的每个值得函数，包含四个参数</p>\n<p>previousValue – 上一次回调函数返回的值，或者是提供的初始值(initialValue)</p>\n<p>currentValue – 数组中当前被处理的元素</p>\n<p>index – 当前元素在数组中的索引</p>\n<p>array – 调用reduce的数组</p>\n<p>initialValue – 作为第一次调用callback的第一个参数。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>reduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素，当前索引，调用reduce的数组。</p>\n<p>回调函数第一次执行时，preciousValue和currentValue可以是一个值，如果initialValue在调用reduce时被提供，那么第一个preciousValue等于initialValue，并且currentValue等于数组中的第一个值；如果initialValue未被提供，那么previousValue等于数组中的第一个值，currentValue等于数组中的第二个值。</p>\n<p>如果数组为空并且没有提供initialValue，会抛出TypeError。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue，或者有提供initialValue但是数组为空，那么此唯一值将被返回并callback不会被执行。</p>\n<p>例如下面的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previousValue,currentValue,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previousValue + currentValue;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>回调函数被执行了四次，每次的参数和返回值如下表</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th style=\"text-align:center\">previousValue</th>\n<th style=\"text-align:center\">currentValue</th>\n<th style=\"text-align:center\">index</th>\n<th style=\"text-align:center\">array</th>\n<th style=\"text-align:right\">return value</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>first call</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">1</td>\n</tr>\n<tr>\n<td>second call</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">3</td>\n</tr>\n<tr>\n<td>third call</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">3</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">6</td>\n</tr>\n<tr>\n<td>fourth call</td>\n<td style=\"text-align:center\">6</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">4</td>\n<td style=\"text-align:center\">[0,1,2,3,4]</td>\n<td style=\"text-align:right\">10</td>\n</tr>\n</tbody>\n</table>\n<p>reduce 的返回值是回调函数的最后一次被调用的返回值10。</p>\n<p>如果把初始值作为第二个参数传入reduce，最终返回值变为20，结果如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">previousValue,currentValue,index,array</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> previousValue + currentValue;</span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<h2 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h2><ol>\n<li>将数组所有项相加</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = [<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//total 6</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>将数组扁平化</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flattened = [[<span class=\"number\">0</span>,<span class=\"number\">1</span>],[<span class=\"number\">2</span>,<span class=\"number\">3</span>],[<span class=\"number\">4</span>,<span class=\"number\">5</span>],[<span class=\"number\">6</span>,<span class=\"number\">7</span>]].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.concat(b);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// flattened is [0,1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"兼容旧环境-Polyfill\"><a href=\"#兼容旧环境-Polyfill\" class=\"headerlink\" title=\"兼容旧环境(Polyfill)\"></a>兼容旧环境(Polyfill)</h2><p>Array.prototype.reduce 被添加到ECMA-262标准第5版；因此可能在某些环境中不被支持。可以将下面的代码插入到脚本开头来允许在那些未被原生支持reduce的实现环境中使用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"string\">'function'</span> !== <span class=\"keyword\">typeof</span> <span class=\"built_in\">Array</span>.prototype.reduce)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Array</span>.prototype.reduce = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback,opt_initialValue</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"meta\">        'use strict'</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"literal\">null</span> == <span class=\"keyword\">this</span> || <span class=\"string\">'undefined'</span> === <span class=\"keyword\">typeof</span> <span class=\"keyword\">this</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Array.prototype.reduce called on null or undefined'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"string\">'function'</span> !== <span class=\"keyword\">typeof</span>(callback))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callback + <span class=\"string\">'is not a function'</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> index, value, length = <span class=\"keyword\">this</span>.length &gt;&gt;&gt; <span class=\"number\">0</span>, isValueSet = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"number\">1</span>&lt;argument.length)&#123;</span><br><span class=\"line\">            value = opt_initialValue;</span><br><span class=\"line\">            isValueSet = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(index = <span class=\"number\">0</span>;length &gt; index; ++index)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.hasOwnProperty(index))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(isValueSet)&#123;</span><br><span class=\"line\">                    value = callback(value,<span class=\"keyword\">this</span>[index],index,<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                    value = <span class=\"keyword\">this</span>[index];</span><br><span class=\"line\">                    isValueSet = <span class=\"literal\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!isValueSet)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'Reduce of empty with no initial value'</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"zepto学习笔记","date":"2015-10-27T06:21:46.000Z","_content":"\n> Zepto的设计目的是有一个5-10K的通用库、下载并快速执行、有一个熟悉通用的API。\n\n| module | default | description |\n| ------ | :-------: | :----------- |\n| zepto\t| ✔\t| 核心模块；包含许多方法 |\n| event\t| ✔|\t通过on()& off()处理事件 |\n| ajax\t| ✔|\tXMLHttpRequest 和 JSONP 实用功能 |\n| form\t| ✔|\t序列化 & 提交web表单 |\n| ie\t|✔| \t增加支持桌面的Internet Explorer 10+和Windows Phone 8。 |\n| detect| |\t\t提供 $.os和 $.browser消息 |\n| fx\t\t| | The animate()方法 |\n| fx_methods|\t|\t以动画形式的 show, hide, toggle, 和 fade*()方法. |\n| assets|\t|\t实验性支持从DOM中移除image元素后清理iOS的内存。 |\n| data\t|\t|一个全面的 data()方法, 能够在内存中存储任意对象。 |\n|deferred |\t|\t提供 $.Deferredpromises API. 依赖\"callbacks\" 模块. 当包含这个模块时候, $.ajax() 支持promise接口链式的回调。 |\n| callbacks\t| |\t为\"deferred\"模块提供 $.Callbacks。 |\n| touch\t\t| | 在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的`touch`(iOS, Android)和`pointer`事件(Windows Phone)。 |\n| gesture\t| |\t在触摸设备上触发 pinch 手势事件。 |\n| stack\t\t| | 提供 andSelf& end()链式调用方法 |\n| ios3\t\t| | String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x. |\n\n## 如何自制zepto\n```\n    1.git clone https://github.com/madrobby/zepto.git\n    2.npm install 下载package.json里dependence\n    3.MODULES=\"zepto event data ...\" npm run-script dist\n    the resulting files are:\n    1.dist/zepto.js\n    2.dist/zepto.min.js\n```\n\n--- \n   \n### 整体上zeptojs的用法和jquery一样","source":"_posts/zepto学习笔记.md","raw":"title: zepto学习笔记\ndate: 2015-10-27 14:21:46\ntags:\n- zepto\n- 学习笔记\ncategories: 笔记\n---\n\n> Zepto的设计目的是有一个5-10K的通用库、下载并快速执行、有一个熟悉通用的API。\n\n| module | default | description |\n| ------ | :-------: | :----------- |\n| zepto\t| ✔\t| 核心模块；包含许多方法 |\n| event\t| ✔|\t通过on()& off()处理事件 |\n| ajax\t| ✔|\tXMLHttpRequest 和 JSONP 实用功能 |\n| form\t| ✔|\t序列化 & 提交web表单 |\n| ie\t|✔| \t增加支持桌面的Internet Explorer 10+和Windows Phone 8。 |\n| detect| |\t\t提供 $.os和 $.browser消息 |\n| fx\t\t| | The animate()方法 |\n| fx_methods|\t|\t以动画形式的 show, hide, toggle, 和 fade*()方法. |\n| assets|\t|\t实验性支持从DOM中移除image元素后清理iOS的内存。 |\n| data\t|\t|一个全面的 data()方法, 能够在内存中存储任意对象。 |\n|deferred |\t|\t提供 $.Deferredpromises API. 依赖\"callbacks\" 模块. 当包含这个模块时候, $.ajax() 支持promise接口链式的回调。 |\n| callbacks\t| |\t为\"deferred\"模块提供 $.Callbacks。 |\n| touch\t\t| | 在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的`touch`(iOS, Android)和`pointer`事件(Windows Phone)。 |\n| gesture\t| |\t在触摸设备上触发 pinch 手势事件。 |\n| stack\t\t| | 提供 andSelf& end()链式调用方法 |\n| ios3\t\t| | String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x. |\n\n## 如何自制zepto\n```\n    1.git clone https://github.com/madrobby/zepto.git\n    2.npm install 下载package.json里dependence\n    3.MODULES=\"zepto event data ...\" npm run-script dist\n    the resulting files are:\n    1.dist/zepto.js\n    2.dist/zepto.min.js\n```\n\n--- \n   \n### 整体上zeptojs的用法和jquery一样","slug":"zepto学习笔记","published":1,"updated":"2016-05-16T02:11:32.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emt000ub0dlfwaq5pc9","content":"<blockquote>\n<p>Zepto的设计目的是有一个5-10K的通用库、下载并快速执行、有一个熟悉通用的API。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>module</th>\n<th style=\"text-align:center\">default</th>\n<th style=\"text-align:left\">description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zepto</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">核心模块；包含许多方法</td>\n</tr>\n<tr>\n<td>event</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">通过on()&amp; off()处理事件</td>\n</tr>\n<tr>\n<td>ajax</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">XMLHttpRequest 和 JSONP 实用功能</td>\n</tr>\n<tr>\n<td>form</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">序列化 &amp; 提交web表单</td>\n</tr>\n<tr>\n<td>ie</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">增加支持桌面的Internet Explorer 10+和Windows Phone 8。</td>\n</tr>\n<tr>\n<td>detect</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">提供 $.os和 $.browser消息</td>\n</tr>\n<tr>\n<td>fx</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">The animate()方法</td>\n</tr>\n<tr>\n<td>fx_methods</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">以动画形式的 show, hide, toggle, 和 fade*()方法.</td>\n</tr>\n<tr>\n<td>assets</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">实验性支持从DOM中移除image元素后清理iOS的内存。</td>\n</tr>\n<tr>\n<td>data</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">一个全面的 data()方法, 能够在内存中存储任意对象。</td>\n</tr>\n<tr>\n<td>deferred</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">提供 $.Deferredpromises API. 依赖”callbacks” 模块. 当包含这个模块时候, $.ajax() 支持promise接口链式的回调。</td>\n</tr>\n<tr>\n<td>callbacks</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">为”deferred”模块提供 $.Callbacks。</td>\n</tr>\n<tr>\n<td>touch</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的<code>touch</code>(iOS, Android)和<code>pointer</code>事件(Windows Phone)。</td>\n</tr>\n<tr>\n<td>gesture</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">在触摸设备上触发 pinch 手势事件。</td>\n</tr>\n<tr>\n<td>stack</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">提供 andSelf&amp; end()链式调用方法</td>\n</tr>\n<tr>\n<td>ios3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"如何自制zepto\"><a href=\"#如何自制zepto\" class=\"headerlink\" title=\"如何自制zepto\"></a>如何自制zepto</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.git clone https://github.com/madrobby/zepto.git</span><br><span class=\"line\">2.npm install 下载package.json里dependence</span><br><span class=\"line\">3.MODULES=&quot;zepto event data ...&quot; npm run-script dist</span><br><span class=\"line\">the resulting files are:</span><br><span class=\"line\">1.dist/zepto.js</span><br><span class=\"line\">2.dist/zepto.min.js</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"整体上zeptojs的用法和jquery一样\"><a href=\"#整体上zeptojs的用法和jquery一样\" class=\"headerlink\" title=\"整体上zeptojs的用法和jquery一样\"></a>整体上zeptojs的用法和jquery一样</h3>","excerpt":"","more":"<blockquote>\n<p>Zepto的设计目的是有一个5-10K的通用库、下载并快速执行、有一个熟悉通用的API。</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>module</th>\n<th style=\"text-align:center\">default</th>\n<th style=\"text-align:left\">description</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>zepto</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">核心模块；包含许多方法</td>\n</tr>\n<tr>\n<td>event</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">通过on()&amp; off()处理事件</td>\n</tr>\n<tr>\n<td>ajax</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">XMLHttpRequest 和 JSONP 实用功能</td>\n</tr>\n<tr>\n<td>form</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">序列化 &amp; 提交web表单</td>\n</tr>\n<tr>\n<td>ie</td>\n<td style=\"text-align:center\">✔</td>\n<td style=\"text-align:left\">增加支持桌面的Internet Explorer 10+和Windows Phone 8。</td>\n</tr>\n<tr>\n<td>detect</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">提供 $.os和 $.browser消息</td>\n</tr>\n<tr>\n<td>fx</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">The animate()方法</td>\n</tr>\n<tr>\n<td>fx_methods</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">以动画形式的 show, hide, toggle, 和 fade*()方法.</td>\n</tr>\n<tr>\n<td>assets</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">实验性支持从DOM中移除image元素后清理iOS的内存。</td>\n</tr>\n<tr>\n<td>data</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">一个全面的 data()方法, 能够在内存中存储任意对象。</td>\n</tr>\n<tr>\n<td>deferred</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">提供 $.Deferredpromises API. 依赖”callbacks” 模块. 当包含这个模块时候, $.ajax() 支持promise接口链式的回调。</td>\n</tr>\n<tr>\n<td>callbacks</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">为”deferred”模块提供 $.Callbacks。</td>\n</tr>\n<tr>\n<td>touch</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">在触摸设备上触发tap– 和 swipe– 相关事件。这适用于所有的<code>touch</code>(iOS, Android)和<code>pointer</code>事件(Windows Phone)。</td>\n</tr>\n<tr>\n<td>gesture</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">在触摸设备上触发 pinch 手势事件。</td>\n</tr>\n<tr>\n<td>stack</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">提供 andSelf&amp; end()链式调用方法</td>\n</tr>\n<tr>\n<td>ios3</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:left\">String.prototype.trim 和 Array.prototype.reduce 方法 (如果他们不存在) ，以兼容 iOS 3.x.</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"如何自制zepto\"><a href=\"#如何自制zepto\" class=\"headerlink\" title=\"如何自制zepto\"></a>如何自制zepto</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.git clone https://github.com/madrobby/zepto.git</span><br><span class=\"line\">2.npm install 下载package.json里dependence</span><br><span class=\"line\">3.MODULES=&quot;zepto event data ...&quot; npm run-script dist</span><br><span class=\"line\">the resulting files are:</span><br><span class=\"line\">1.dist/zepto.js</span><br><span class=\"line\">2.dist/zepto.min.js</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"整体上zeptojs的用法和jquery一样\"><a href=\"#整体上zeptojs的用法和jquery一样\" class=\"headerlink\" title=\"整体上zeptojs的用法和jquery一样\"></a>整体上zeptojs的用法和jquery一样</h3>"},{"title":"webapck直接上手","date":"2016-03-22T06:26:43.000Z","_content":">True mastery of any skill takes a lifetime.\n\n写在前面的话，花了一天一夜学得的webpack，并且都把webapck.config.js配置完成了，leader不让用，还说不要盲目跟风。无语，遂把学得的东西贡献出来。\n\n## Getting started\n\n首先，全局下载[webpack](https://www.npmjs.com/package/webpack)和[live-server](https://www.npmjs.com/package/live-server)。  \n***ps***：这边可自行选择，[live-server](https://www.npmjs.com/package/live-server)或是[webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server)，我用的是live-server。\n\n```javascript\n$ npm install -g webpack live-server \n```\n\n然后，git直接clone本仓库以及依赖包\n\n```javascript\n$ git clone https://github.com/GaoQ1/webpack-start.git\n$ cd webpack-scaffold\n$ npm install\n```\n\n现在你可以试试webpack的效果了。\n\n```javascript\n$ webpack\n$ live-server\n```\n\n浏览器会自动打开，然后点击src，访问路径为[http://127.0.0.1:8080/src/](http://127.0.0.1:8080/src/)。 \n\n## 什么是webpack\n至于什么是webpack，网上有很多资料，我就不copy过来了，详细的可参考\n - [Webpack中文指南](http://zhaoda.net/webpack-handbook/)\n - [Webpack官网](http://webpack.github.io/docs/)\n\n还有关于webpack的常用的命令行有：\n```javascript\n $ webpack //用来一次性执行开发环境webpack\n $ webpack -p //用来一次性执行生产环境webpack\n $ webpack --watch //用来持续的执行webpack\n $ webpack -d //包含source maps文件\n $ webpack --colors //用来让wenbpack执行后的文件更优美\n```\n\n## 目录结构\n```javascript\n--- dist (webpac打包后的文件)\n    |--- ...\n--- images (图片文件)\n    |--- ...\n--- src (webpack打包前源文件)\n    |--- js (源文件组件文件夹)\n    |    |--- client.js (javascript文件)\n    |    |--- image.js (image文件)\n    |    |--- style.js (css文件)\n    | \t |...\n    |--- sass (sass文件夹)          \n    |    |--- app.scss (sass文件)\n    |    |---\n    |--- index.html (主页面)\n    |--- package.json (配置文件)\n    |--- webpack.config.js (webpack配置文件) \n```\n\n## 参考文章\n关于webpack.config.js的文件配置参考了\n - 阮大神的[webpack-demos](https://github.com/ruanyf/webpack-demos)\n - Petehunt大神的[webpack-howto](https://github.com/petehunt/webpack-howto)\n - [Webpack documents](https://webpack.github.io/docs/)\n - 鄙人的[blog](http://blog.gaoquan.wang)，会长期更新","source":"_posts/webapck配置指导.md","raw":"---\ntitle: webapck直接上手\ndate: 2016-03-22 14:26:43\ntags:\n- webpack\n- 快速上手\ncategories: 教程\n---\n>True mastery of any skill takes a lifetime.\n\n写在前面的话，花了一天一夜学得的webpack，并且都把webapck.config.js配置完成了，leader不让用，还说不要盲目跟风。无语，遂把学得的东西贡献出来。\n\n## Getting started\n\n首先，全局下载[webpack](https://www.npmjs.com/package/webpack)和[live-server](https://www.npmjs.com/package/live-server)。  \n***ps***：这边可自行选择，[live-server](https://www.npmjs.com/package/live-server)或是[webpack-dev-server](https://www.npmjs.com/package/webpack-dev-server)，我用的是live-server。\n\n```javascript\n$ npm install -g webpack live-server \n```\n\n然后，git直接clone本仓库以及依赖包\n\n```javascript\n$ git clone https://github.com/GaoQ1/webpack-start.git\n$ cd webpack-scaffold\n$ npm install\n```\n\n现在你可以试试webpack的效果了。\n\n```javascript\n$ webpack\n$ live-server\n```\n\n浏览器会自动打开，然后点击src，访问路径为[http://127.0.0.1:8080/src/](http://127.0.0.1:8080/src/)。 \n\n## 什么是webpack\n至于什么是webpack，网上有很多资料，我就不copy过来了，详细的可参考\n - [Webpack中文指南](http://zhaoda.net/webpack-handbook/)\n - [Webpack官网](http://webpack.github.io/docs/)\n\n还有关于webpack的常用的命令行有：\n```javascript\n $ webpack //用来一次性执行开发环境webpack\n $ webpack -p //用来一次性执行生产环境webpack\n $ webpack --watch //用来持续的执行webpack\n $ webpack -d //包含source maps文件\n $ webpack --colors //用来让wenbpack执行后的文件更优美\n```\n\n## 目录结构\n```javascript\n--- dist (webpac打包后的文件)\n    |--- ...\n--- images (图片文件)\n    |--- ...\n--- src (webpack打包前源文件)\n    |--- js (源文件组件文件夹)\n    |    |--- client.js (javascript文件)\n    |    |--- image.js (image文件)\n    |    |--- style.js (css文件)\n    | \t |...\n    |--- sass (sass文件夹)          \n    |    |--- app.scss (sass文件)\n    |    |---\n    |--- index.html (主页面)\n    |--- package.json (配置文件)\n    |--- webpack.config.js (webpack配置文件) \n```\n\n## 参考文章\n关于webpack.config.js的文件配置参考了\n - 阮大神的[webpack-demos](https://github.com/ruanyf/webpack-demos)\n - Petehunt大神的[webpack-howto](https://github.com/petehunt/webpack-howto)\n - [Webpack documents](https://webpack.github.io/docs/)\n - 鄙人的[blog](http://blog.gaoquan.wang)，会长期更新","slug":"webapck配置指导","published":1,"updated":"2016-05-16T02:11:32.476Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emu000vb0dl4hueiw5m","content":"<blockquote>\n<p>True mastery of any skill takes a lifetime.</p>\n</blockquote>\n<p>写在前面的话，花了一天一夜学得的webpack，并且都把webapck.config.js配置完成了，leader不让用，还说不要盲目跟风。无语，遂把学得的东西贡献出来。</p>\n<h2 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h2><p>首先，全局下载<a href=\"https://www.npmjs.com/package/webpack\" target=\"_blank\" rel=\"external\">webpack</a>和<a href=\"https://www.npmjs.com/package/live-server\" target=\"_blank\" rel=\"external\">live-server</a>。<br><strong><em>ps</em></strong>：这边可自行选择，<a href=\"https://www.npmjs.com/package/live-server\" target=\"_blank\" rel=\"external\">live-server</a>或是<a href=\"https://www.npmjs.com/package/webpack-dev-server\" target=\"_blank\" rel=\"external\">webpack-dev-server</a>，我用的是live-server。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g webpack live-server</span><br></pre></td></tr></table></figure>\n<p>然后，git直接clone本仓库以及依赖包</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:<span class=\"comment\">//github.com/GaoQ1/webpack-start.git</span></span><br><span class=\"line\">$ cd webpack-scaffold</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>现在你可以试试webpack的效果了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">$ live-server</span><br></pre></td></tr></table></figure>\n<p>浏览器会自动打开，然后点击src，访问路径为<a href=\"http://127.0.0.1:8080/src/\" target=\"_blank\" rel=\"external\">http://127.0.0.1:8080/src/</a>。 </p>\n<h2 id=\"什么是webpack\"><a href=\"#什么是webpack\" class=\"headerlink\" title=\"什么是webpack\"></a>什么是webpack</h2><p>至于什么是webpack，网上有很多资料，我就不copy过来了，详细的可参考</p>\n<ul>\n<li><a href=\"http://zhaoda.net/webpack-handbook/\" target=\"_blank\" rel=\"external\">Webpack中文指南</a></li>\n<li><a href=\"http://webpack.github.io/docs/\" target=\"_blank\" rel=\"external\">Webpack官网</a></li>\n</ul>\n<p>还有关于webpack的常用的命令行有：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack <span class=\"comment\">//用来一次性执行开发环境webpack</span></span><br><span class=\"line\">$ webpack -p <span class=\"comment\">//用来一次性执行生产环境webpack</span></span><br><span class=\"line\">$ webpack --watch <span class=\"comment\">//用来持续的执行webpack</span></span><br><span class=\"line\">$ webpack -d <span class=\"comment\">//包含source maps文件</span></span><br><span class=\"line\">$ webpack --colors <span class=\"comment\">//用来让wenbpack执行后的文件更优美</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- dist (webpac打包后的文件)</span><br><span class=\"line\">    |--- ...</span><br><span class=\"line\">--- images (图片文件)</span><br><span class=\"line\">    |--- ...</span><br><span class=\"line\">--- src (webpack打包前源文件)</span><br><span class=\"line\">    |--- js (源文件组件文件夹)</span><br><span class=\"line\">    |    |--- client.js (javascript文件)</span><br><span class=\"line\">    |    |--- image.js (image文件)</span><br><span class=\"line\">    |    |--- style.js (css文件)</span><br><span class=\"line\">    | \t |...</span><br><span class=\"line\">    |--- sass (sass文件夹)          </span><br><span class=\"line\">    |    |--- app.scss (sass文件)</span><br><span class=\"line\">    |    |---</span><br><span class=\"line\">    |--- index.html (主页面)</span><br><span class=\"line\">    |--- package.json (配置文件)</span><br><span class=\"line\">    |--- webpack.config.js (webpack配置文件)</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>关于webpack.config.js的文件配置参考了</p>\n<ul>\n<li>阮大神的<a href=\"https://github.com/ruanyf/webpack-demos\" target=\"_blank\" rel=\"external\">webpack-demos</a></li>\n<li>Petehunt大神的<a href=\"https://github.com/petehunt/webpack-howto\" target=\"_blank\" rel=\"external\">webpack-howto</a></li>\n<li><a href=\"https://webpack.github.io/docs/\" target=\"_blank\" rel=\"external\">Webpack documents</a></li>\n<li>鄙人的<a href=\"http://blog.gaoquan.wang\" target=\"_blank\" rel=\"external\">blog</a>，会长期更新</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>True mastery of any skill takes a lifetime.</p>\n</blockquote>\n<p>写在前面的话，花了一天一夜学得的webpack，并且都把webapck.config.js配置完成了，leader不让用，还说不要盲目跟风。无语，遂把学得的东西贡献出来。</p>\n<h2 id=\"Getting-started\"><a href=\"#Getting-started\" class=\"headerlink\" title=\"Getting started\"></a>Getting started</h2><p>首先，全局下载<a href=\"https://www.npmjs.com/package/webpack\">webpack</a>和<a href=\"https://www.npmjs.com/package/live-server\">live-server</a>。<br><strong><em>ps</em></strong>：这边可自行选择，<a href=\"https://www.npmjs.com/package/live-server\">live-server</a>或是<a href=\"https://www.npmjs.com/package/webpack-dev-server\">webpack-dev-server</a>，我用的是live-server。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ npm install -g webpack live-server</span><br></pre></td></tr></table></figure>\n<p>然后，git直接clone本仓库以及依赖包</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git clone https:<span class=\"comment\">//github.com/GaoQ1/webpack-start.git</span></span><br><span class=\"line\">$ cd webpack-scaffold</span><br><span class=\"line\">$ npm install</span><br></pre></td></tr></table></figure>\n<p>现在你可以试试webpack的效果了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack</span><br><span class=\"line\">$ live-server</span><br></pre></td></tr></table></figure>\n<p>浏览器会自动打开，然后点击src，访问路径为<a href=\"http://127.0.0.1:8080/src/\">http://127.0.0.1:8080/src/</a>。 </p>\n<h2 id=\"什么是webpack\"><a href=\"#什么是webpack\" class=\"headerlink\" title=\"什么是webpack\"></a>什么是webpack</h2><p>至于什么是webpack，网上有很多资料，我就不copy过来了，详细的可参考</p>\n<ul>\n<li><a href=\"http://zhaoda.net/webpack-handbook/\">Webpack中文指南</a></li>\n<li><a href=\"http://webpack.github.io/docs/\">Webpack官网</a></li>\n</ul>\n<p>还有关于webpack的常用的命令行有：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ webpack <span class=\"comment\">//用来一次性执行开发环境webpack</span></span><br><span class=\"line\">$ webpack -p <span class=\"comment\">//用来一次性执行生产环境webpack</span></span><br><span class=\"line\">$ webpack --watch <span class=\"comment\">//用来持续的执行webpack</span></span><br><span class=\"line\">$ webpack -d <span class=\"comment\">//包含source maps文件</span></span><br><span class=\"line\">$ webpack --colors <span class=\"comment\">//用来让wenbpack执行后的文件更优美</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- dist (webpac打包后的文件)</span><br><span class=\"line\">    |--- ...</span><br><span class=\"line\">--- images (图片文件)</span><br><span class=\"line\">    |--- ...</span><br><span class=\"line\">--- src (webpack打包前源文件)</span><br><span class=\"line\">    |--- js (源文件组件文件夹)</span><br><span class=\"line\">    |    |--- client.js (javascript文件)</span><br><span class=\"line\">    |    |--- image.js (image文件)</span><br><span class=\"line\">    |    |--- style.js (css文件)</span><br><span class=\"line\">    | \t |...</span><br><span class=\"line\">    |--- sass (sass文件夹)          </span><br><span class=\"line\">    |    |--- app.scss (sass文件)</span><br><span class=\"line\">    |    |---</span><br><span class=\"line\">    |--- index.html (主页面)</span><br><span class=\"line\">    |--- package.json (配置文件)</span><br><span class=\"line\">    |--- webpack.config.js (webpack配置文件)</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p>关于webpack.config.js的文件配置参考了</p>\n<ul>\n<li>阮大神的<a href=\"https://github.com/ruanyf/webpack-demos\">webpack-demos</a></li>\n<li>Petehunt大神的<a href=\"https://github.com/petehunt/webpack-howto\">webpack-howto</a></li>\n<li><a href=\"https://webpack.github.io/docs/\">Webpack documents</a></li>\n<li>鄙人的<a href=\"http://blog.gaoquan.wang\">blog</a>，会长期更新</li>\n</ul>\n"},{"title":"使用Flexible实现H5页面终端适配","date":"2016-03-24T05:50:47.000Z","_content":">The less you reveal the more people can wonder.\n\n一次偶然的机会在某技术群里听到手淘flexible.js能够解决移动端适配的问题，遂实践了一下。想来用这套方案也有一段时间了，今天就将自己的理解和实践做个总结。\n\n## 页面效果\n\n首先放一张设计完成的页面效果图：\n\n![页面效果图](/images/flexible/flexible01.png)\n\n就是这样一个简单的H5页面，虽然H5页面相对于PC端Web页面简单了很多，但是难点在于让页面适配众多不同的终端设备。而终端设备有哪些，详细参考[Device metrics](https://design.google.com/devices/)，看完之后会感觉很恶心，但仍想完美的解决，这时牛X的手淘团队总结了一套[Flexible解决方案](https://github.com/amfe/lib-flexible)\n\n## 手淘的方案\n\n#### 1. 直接上图看看手淘的适配协作模式：\n\n![手淘方案](/images/flexible/flexible02.png)\n\n对这张图我的理解让UI在750px设计并标注大小和坐标，再矢量放大1.5倍后切图，于是我得到了所谓的@3x切图\n\n![@3x切图](/images/flexible/flexible03.png)\n\n#### 2. 引入flexible.js\n\n[lib-flexible库](https://github.com/amfe/lib-flexible)使用方法非常简单，只需要在head头标签中添加对应的flexible_css.js,flexible.js文件。\n\n第一种方法是将文件下载到你的项目中，然后引入添加：\n\n```javascript\n<script src=\"./js/lib/flexible_css.debug.js\"></script>\n<script src=\"./js/lib/flexible.debug.js\"></script>\n```\n\n或者直接加载阿里CDN的文件：\n\n```javascript\n<script src=\"http://g.tbcdn.cn/mtb/lib-flexible/{{version}}/??flexible_css.js,flexible.js\"></script>\n```\n\n将代码中的***{{version}}***换成对应的版本号0.3.4.\n![flexible.js引入](/images/flexible/flexible04.png)\n\n注意使用lib-flexible，通常不要写：\n```javascript\n<meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"/>\n```\n交给flexible.js自己处理。\n\n我们来看看效果，在chrome中选择iphone6可以看到font-size:75px：\n![iphone6](/images/flexible/flexible05.png)\n\n#### 3. 把视觉搞中的px转换成rem\n\n什么是rem？\n>font size of the root element.\n\n当html中font-size能够动态给出，这样使用rem就十分简单了。而如何将750px下的标注搞转换成rem。这里简单的介绍下Flexible的做法。\n\n目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出：\n\n```\n1a   = 7.5px\n1rem = 75px \n```\n\n所以显而易见，只要将750px下的标注搞/75就是对应的rem的值，比如视觉稿中的图片大小为200px*200px，转换成为2.667rem*2.667rem。\n\n## 如何快速计算CSS\n\n关于这方面的工具有很多，手淘同学编写了各种工具，这里我使用的[PostCSS(px2rem)](https://www.npmjs.com/package/px2rem)，非常好用，在此谢过。gulpfile.js文件的编写如下：\n\n![gulpfile.js](/images/flexible/flexible06.png)\n\n配置完成后实际用的时候只要这样使用：\n\n![rem1.js](/images/flexible/flexible07.png)\n\npx2rem处理之后将会变成：\n\n![rem2.js](/images/flexible/flexible08.png)\n\n另外如果你是使用Sass或是Less，你也可以使用Sass函数、混合宏来实现：\n\n```javascript\n@function px2em($px, $base-font-size: 16px) {\n    @if (unitless($px)) {\n        @warn \"#{$px} 参数应该为像素\";\n        @return px2em($px + 0px);\n    } @else if (unit($px) == em) {\n        @return $px;\n    }\n    @return ($px / $base-font-size) * 1em;\n}\n```\n\n***需要注意的是字号不使用rem，还是用px***\n\n## 效果\n\n最后，直接看下效果吧。\nMobile S\n![Mobile S](/images/flexible/flexible09.png)\n\nMobile L\n![Mobile L](/images/flexible/flexible10.png)\n\n## 总结\n\n竟然写了这么长，这篇一来是对自己使用flexible的总结和感悟，总之用了之后很方便。其次也是最近有朋友问我是如何解决移动端适配，我直接说了flexible并扔了几个资料，把自己如何用的写出来估计会更好。有什么意见欢迎提出。","source":"_posts/使用Flexible实现H5页面终端适配.md","raw":"---\ntitle: 使用Flexible实现H5页面终端适配\ndate: 2016-03-24 13:50:47\ntags:\n- flexible\n- 终端适配\ncategories: 教程\n---\n>The less you reveal the more people can wonder.\n\n一次偶然的机会在某技术群里听到手淘flexible.js能够解决移动端适配的问题，遂实践了一下。想来用这套方案也有一段时间了，今天就将自己的理解和实践做个总结。\n\n## 页面效果\n\n首先放一张设计完成的页面效果图：\n\n![页面效果图](/images/flexible/flexible01.png)\n\n就是这样一个简单的H5页面，虽然H5页面相对于PC端Web页面简单了很多，但是难点在于让页面适配众多不同的终端设备。而终端设备有哪些，详细参考[Device metrics](https://design.google.com/devices/)，看完之后会感觉很恶心，但仍想完美的解决，这时牛X的手淘团队总结了一套[Flexible解决方案](https://github.com/amfe/lib-flexible)\n\n## 手淘的方案\n\n#### 1. 直接上图看看手淘的适配协作模式：\n\n![手淘方案](/images/flexible/flexible02.png)\n\n对这张图我的理解让UI在750px设计并标注大小和坐标，再矢量放大1.5倍后切图，于是我得到了所谓的@3x切图\n\n![@3x切图](/images/flexible/flexible03.png)\n\n#### 2. 引入flexible.js\n\n[lib-flexible库](https://github.com/amfe/lib-flexible)使用方法非常简单，只需要在head头标签中添加对应的flexible_css.js,flexible.js文件。\n\n第一种方法是将文件下载到你的项目中，然后引入添加：\n\n```javascript\n<script src=\"./js/lib/flexible_css.debug.js\"></script>\n<script src=\"./js/lib/flexible.debug.js\"></script>\n```\n\n或者直接加载阿里CDN的文件：\n\n```javascript\n<script src=\"http://g.tbcdn.cn/mtb/lib-flexible/{{version}}/??flexible_css.js,flexible.js\"></script>\n```\n\n将代码中的***{{version}}***换成对应的版本号0.3.4.\n![flexible.js引入](/images/flexible/flexible04.png)\n\n注意使用lib-flexible，通常不要写：\n```javascript\n<meta name=\"viewport\" content=\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"/>\n```\n交给flexible.js自己处理。\n\n我们来看看效果，在chrome中选择iphone6可以看到font-size:75px：\n![iphone6](/images/flexible/flexible05.png)\n\n#### 3. 把视觉搞中的px转换成rem\n\n什么是rem？\n>font size of the root element.\n\n当html中font-size能够动态给出，这样使用rem就十分简单了。而如何将750px下的标注搞转换成rem。这里简单的介绍下Flexible的做法。\n\n目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出：\n\n```\n1a   = 7.5px\n1rem = 75px \n```\n\n所以显而易见，只要将750px下的标注搞/75就是对应的rem的值，比如视觉稿中的图片大小为200px*200px，转换成为2.667rem*2.667rem。\n\n## 如何快速计算CSS\n\n关于这方面的工具有很多，手淘同学编写了各种工具，这里我使用的[PostCSS(px2rem)](https://www.npmjs.com/package/px2rem)，非常好用，在此谢过。gulpfile.js文件的编写如下：\n\n![gulpfile.js](/images/flexible/flexible06.png)\n\n配置完成后实际用的时候只要这样使用：\n\n![rem1.js](/images/flexible/flexible07.png)\n\npx2rem处理之后将会变成：\n\n![rem2.js](/images/flexible/flexible08.png)\n\n另外如果你是使用Sass或是Less，你也可以使用Sass函数、混合宏来实现：\n\n```javascript\n@function px2em($px, $base-font-size: 16px) {\n    @if (unitless($px)) {\n        @warn \"#{$px} 参数应该为像素\";\n        @return px2em($px + 0px);\n    } @else if (unit($px) == em) {\n        @return $px;\n    }\n    @return ($px / $base-font-size) * 1em;\n}\n```\n\n***需要注意的是字号不使用rem，还是用px***\n\n## 效果\n\n最后，直接看下效果吧。\nMobile S\n![Mobile S](/images/flexible/flexible09.png)\n\nMobile L\n![Mobile L](/images/flexible/flexible10.png)\n\n## 总结\n\n竟然写了这么长，这篇一来是对自己使用flexible的总结和感悟，总之用了之后很方便。其次也是最近有朋友问我是如何解决移动端适配，我直接说了flexible并扔了几个资料，把自己如何用的写出来估计会更好。有什么意见欢迎提出。","slug":"使用Flexible实现H5页面终端适配","published":1,"updated":"2016-05-16T02:11:32.477Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0emy0010b0dlsbqpksqu","content":"<blockquote>\n<p>The less you reveal the more people can wonder.</p>\n</blockquote>\n<p>一次偶然的机会在某技术群里听到手淘flexible.js能够解决移动端适配的问题，遂实践了一下。想来用这套方案也有一段时间了，今天就将自己的理解和实践做个总结。</p>\n<h2 id=\"页面效果\"><a href=\"#页面效果\" class=\"headerlink\" title=\"页面效果\"></a>页面效果</h2><p>首先放一张设计完成的页面效果图：</p>\n<p><img src=\"/images/flexible/flexible01.png\" alt=\"页面效果图\"></p>\n<p>就是这样一个简单的H5页面，虽然H5页面相对于PC端Web页面简单了很多，但是难点在于让页面适配众多不同的终端设备。而终端设备有哪些，详细参考<a href=\"https://design.google.com/devices/\" target=\"_blank\" rel=\"external\">Device metrics</a>，看完之后会感觉很恶心，但仍想完美的解决，这时牛X的手淘团队总结了一套<a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"external\">Flexible解决方案</a></p>\n<h2 id=\"手淘的方案\"><a href=\"#手淘的方案\" class=\"headerlink\" title=\"手淘的方案\"></a>手淘的方案</h2><h4 id=\"1-直接上图看看手淘的适配协作模式：\"><a href=\"#1-直接上图看看手淘的适配协作模式：\" class=\"headerlink\" title=\"1. 直接上图看看手淘的适配协作模式：\"></a>1. 直接上图看看手淘的适配协作模式：</h4><p><img src=\"/images/flexible/flexible02.png\" alt=\"手淘方案\"></p>\n<p>对这张图我的理解让UI在750px设计并标注大小和坐标，再矢量放大1.5倍后切图，于是我得到了所谓的@3x切图</p>\n<p><img src=\"/images/flexible/flexible03.png\" alt=\"@3x切图\"></p>\n<h4 id=\"2-引入flexible-js\"><a href=\"#2-引入flexible-js\" class=\"headerlink\" title=\"2. 引入flexible.js\"></a>2. 引入flexible.js</h4><p><a href=\"https://github.com/amfe/lib-flexible\" target=\"_blank\" rel=\"external\">lib-flexible库</a>使用方法非常简单，只需要在head头标签中添加对应的flexible_css.js,flexible.js文件。</p>\n<p>第一种方法是将文件下载到你的项目中，然后引入添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"./js/lib/flexible_css.debug.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"./js/lib/flexible.debug.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>或者直接加载阿里CDN的文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"http://g.tbcdn.cn/mtb/lib-flexible/&#123;&#123;version&#125;&#125;/??flexible_css.js,flexible.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>将代码中的<strong><em></em></strong>换成对应的版本号0.3.4.<br><img src=\"/images/flexible/flexible04.png\" alt=\"flexible.js引入\"></p>\n<p>注意使用lib-flexible，通常不要写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>交给flexible.js自己处理。</p>\n<p>我们来看看效果，在chrome中选择iphone6可以看到font-size:75px：<br><img src=\"/images/flexible/flexible05.png\" alt=\"iphone6\"></p>\n<h4 id=\"3-把视觉搞中的px转换成rem\"><a href=\"#3-把视觉搞中的px转换成rem\" class=\"headerlink\" title=\"3. 把视觉搞中的px转换成rem\"></a>3. 把视觉搞中的px转换成rem</h4><p>什么是rem？</p>\n<blockquote>\n<p>font size of the root element.</p>\n</blockquote>\n<p>当html中font-size能够动态给出，这样使用rem就十分简单了。而如何将750px下的标注搞转换成rem。这里简单的介绍下Flexible的做法。</p>\n<p>目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1a   = 7.5px</span><br><span class=\"line\">1rem = 75px</span><br></pre></td></tr></table></figure>\n<p>所以显而易见，只要将750px下的标注搞/75就是对应的rem的值，比如视觉稿中的图片大小为200px<em>200px，转换成为2.667rem</em>2.667rem。</p>\n<h2 id=\"如何快速计算CSS\"><a href=\"#如何快速计算CSS\" class=\"headerlink\" title=\"如何快速计算CSS\"></a>如何快速计算CSS</h2><p>关于这方面的工具有很多，手淘同学编写了各种工具，这里我使用的<a href=\"https://www.npmjs.com/package/px2rem\" target=\"_blank\" rel=\"external\">PostCSS(px2rem)</a>，非常好用，在此谢过。gulpfile.js文件的编写如下：</p>\n<p><img src=\"/images/flexible/flexible06.png\" alt=\"gulpfile.js\"></p>\n<p>配置完成后实际用的时候只要这样使用：</p>\n<p><img src=\"/images/flexible/flexible07.png\" alt=\"rem1.js\"></p>\n<p>px2rem处理之后将会变成：</p>\n<p><img src=\"/images/flexible/flexible08.png\" alt=\"rem2.js\"></p>\n<p>另外如果你是使用Sass或是Less，你也可以使用Sass函数、混合宏来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">px2em</span>(<span class=\"params\">$px, $base-font-size: 16px</span>) </span>&#123;</span><br><span class=\"line\">    @<span class=\"keyword\">if</span> (unitless($px)) &#123;</span><br><span class=\"line\">        @warn <span class=\"string\">\"#&#123;$px&#125; 参数应该为像素\"</span>;</span><br><span class=\"line\">        @<span class=\"keyword\">return</span> px2em($px + <span class=\"number\">0</span>px);</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (unit($px) == em) &#123;</span><br><span class=\"line\">        @<span class=\"keyword\">return</span> $px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> ($px / $base-font-size) * <span class=\"number\">1</span>em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>需要注意的是字号不使用rem，还是用px</em></strong></p>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>最后，直接看下效果吧。<br>Mobile S<br><img src=\"/images/flexible/flexible09.png\" alt=\"Mobile S\"></p>\n<p>Mobile L<br><img src=\"/images/flexible/flexible10.png\" alt=\"Mobile L\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>竟然写了这么长，这篇一来是对自己使用flexible的总结和感悟，总之用了之后很方便。其次也是最近有朋友问我是如何解决移动端适配，我直接说了flexible并扔了几个资料，把自己如何用的写出来估计会更好。有什么意见欢迎提出。</p>\n","excerpt":"","more":"<blockquote>\n<p>The less you reveal the more people can wonder.</p>\n</blockquote>\n<p>一次偶然的机会在某技术群里听到手淘flexible.js能够解决移动端适配的问题，遂实践了一下。想来用这套方案也有一段时间了，今天就将自己的理解和实践做个总结。</p>\n<h2 id=\"页面效果\"><a href=\"#页面效果\" class=\"headerlink\" title=\"页面效果\"></a>页面效果</h2><p>首先放一张设计完成的页面效果图：</p>\n<p><img src=\"/images/flexible/flexible01.png\" alt=\"页面效果图\"></p>\n<p>就是这样一个简单的H5页面，虽然H5页面相对于PC端Web页面简单了很多，但是难点在于让页面适配众多不同的终端设备。而终端设备有哪些，详细参考<a href=\"https://design.google.com/devices/\">Device metrics</a>，看完之后会感觉很恶心，但仍想完美的解决，这时牛X的手淘团队总结了一套<a href=\"https://github.com/amfe/lib-flexible\">Flexible解决方案</a></p>\n<h2 id=\"手淘的方案\"><a href=\"#手淘的方案\" class=\"headerlink\" title=\"手淘的方案\"></a>手淘的方案</h2><h4 id=\"1-直接上图看看手淘的适配协作模式：\"><a href=\"#1-直接上图看看手淘的适配协作模式：\" class=\"headerlink\" title=\"1. 直接上图看看手淘的适配协作模式：\"></a>1. 直接上图看看手淘的适配协作模式：</h4><p><img src=\"/images/flexible/flexible02.png\" alt=\"手淘方案\"></p>\n<p>对这张图我的理解让UI在750px设计并标注大小和坐标，再矢量放大1.5倍后切图，于是我得到了所谓的@3x切图</p>\n<p><img src=\"/images/flexible/flexible03.png\" alt=\"@3x切图\"></p>\n<h4 id=\"2-引入flexible-js\"><a href=\"#2-引入flexible-js\" class=\"headerlink\" title=\"2. 引入flexible.js\"></a>2. 引入flexible.js</h4><p><a href=\"https://github.com/amfe/lib-flexible\">lib-flexible库</a>使用方法非常简单，只需要在head头标签中添加对应的flexible_css.js,flexible.js文件。</p>\n<p>第一种方法是将文件下载到你的项目中，然后引入添加：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"./js/lib/flexible_css.debug.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"./js/lib/flexible.debug.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>或者直接加载阿里CDN的文件：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"http://g.tbcdn.cn/mtb/lib-flexible/&#123;&#123;version&#125;&#125;/??flexible_css.js,flexible.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>将代码中的<strong><em></em></strong>换成对应的版本号0.3.4.<br><img src=\"/images/flexible/flexible04.png\" alt=\"flexible.js引入\"></p>\n<p>注意使用lib-flexible，通常不要写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">\"viewport\"</span> content=<span class=\"string\">\"width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"</span>/&gt;</span><br></pre></td></tr></table></figure></p>\n<p>交给flexible.js自己处理。</p>\n<p>我们来看看效果，在chrome中选择iphone6可以看到font-size:75px：<br><img src=\"/images/flexible/flexible05.png\" alt=\"iphone6\"></p>\n<h4 id=\"3-把视觉搞中的px转换成rem\"><a href=\"#3-把视觉搞中的px转换成rem\" class=\"headerlink\" title=\"3. 把视觉搞中的px转换成rem\"></a>3. 把视觉搞中的px转换成rem</h4><p>什么是rem？</p>\n<blockquote>\n<p>font size of the root element.</p>\n</blockquote>\n<p>当html中font-size能够动态给出，这样使用rem就十分简单了。而如何将750px下的标注搞转换成rem。这里简单的介绍下Flexible的做法。</p>\n<p>目前Flexible会将视觉稿分成100份（主要为了以后能更好的兼容vh和vw），而每一份被称为一个单位a。同时1rem单位被认定为10a。针对我们这份视觉稿可以计算出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1a   = 7.5px</span><br><span class=\"line\">1rem = 75px</span><br></pre></td></tr></table></figure>\n<p>所以显而易见，只要将750px下的标注搞/75就是对应的rem的值，比如视觉稿中的图片大小为200px<em>200px，转换成为2.667rem</em>2.667rem。</p>\n<h2 id=\"如何快速计算CSS\"><a href=\"#如何快速计算CSS\" class=\"headerlink\" title=\"如何快速计算CSS\"></a>如何快速计算CSS</h2><p>关于这方面的工具有很多，手淘同学编写了各种工具，这里我使用的<a href=\"https://www.npmjs.com/package/px2rem\">PostCSS(px2rem)</a>，非常好用，在此谢过。gulpfile.js文件的编写如下：</p>\n<p><img src=\"/images/flexible/flexible06.png\" alt=\"gulpfile.js\"></p>\n<p>配置完成后实际用的时候只要这样使用：</p>\n<p><img src=\"/images/flexible/flexible07.png\" alt=\"rem1.js\"></p>\n<p>px2rem处理之后将会变成：</p>\n<p><img src=\"/images/flexible/flexible08.png\" alt=\"rem2.js\"></p>\n<p>另外如果你是使用Sass或是Less，你也可以使用Sass函数、混合宏来实现：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">px2em</span>(<span class=\"params\">$px, $base-font-size: 16px</span>) </span>&#123;</span><br><span class=\"line\">    @<span class=\"keyword\">if</span> (unitless($px)) &#123;</span><br><span class=\"line\">        @warn <span class=\"string\">\"#&#123;$px&#125; 参数应该为像素\"</span>;</span><br><span class=\"line\">        @<span class=\"keyword\">return</span> px2em($px + <span class=\"number\">0</span>px);</span><br><span class=\"line\">    &#125; @<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (unit($px) == em) &#123;</span><br><span class=\"line\">        @<span class=\"keyword\">return</span> $px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    @<span class=\"keyword\">return</span> ($px / $base-font-size) * <span class=\"number\">1</span>em;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong><em>需要注意的是字号不使用rem，还是用px</em></strong></p>\n<h2 id=\"效果\"><a href=\"#效果\" class=\"headerlink\" title=\"效果\"></a>效果</h2><p>最后，直接看下效果吧。<br>Mobile S<br><img src=\"/images/flexible/flexible09.png\" alt=\"Mobile S\"></p>\n<p>Mobile L<br><img src=\"/images/flexible/flexible10.png\" alt=\"Mobile L\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>竟然写了这么长，这篇一来是对自己使用flexible的总结和感悟，总之用了之后很方便。其次也是最近有朋友问我是如何解决移动端适配，我直接说了flexible并扔了几个资料，把自己如何用的写出来估计会更好。有什么意见欢迎提出。</p>\n"},{"title":"es6系列教程四","date":"2016-06-06T04:15:00.000Z","_content":"> Fading is true while flowering is past.  \n\n# Map,Set 和 WeakMap,WeakSet\n## Set\n### 概述\n集合(Set)对象允许你存储任意类型的唯一值(不能重复)，无论是原始数据还是对象引用。\n\n### 语法\n> new Set([iterable]);  \n\n#### 参数\niterable -- 一个可迭代对象，其中的所有元素都会被加入到Set中。null被视作undefined。\n\n### 简述\nSet对象是值的集合，你可以按照插入的顺序迭代它的元素。Set中的元素只会出现一次，即Set中的元素是唯一的。\n\n#### 值的相等\n因为Set中的值总是唯一的，所以需要判断两个值是否相等。判断相等的算法与严格相等(===操作符)不同。具体来说，对于Set, +0(+0严格相等于-0)和-0是不同的值。尽管在最新的ECMAScript6规范中这点已被更改。另外NaN和undefined都可被存储在Set中，NaN之间被视为相同的值(尽管NaN !== NaN)。\n\n### 属性\nSet.length -- length属性的值为0\n\nSet.prototype -- 表示Set构造器的原型，允许向所有Set对象添加新的属性。\n\n### Set实例\n所有的Set实例继承自Set.prototype。示例：使用Set对象。\n```javascript\n  var mySet = new Set();\n\n  mySet.add(1);\n  mySet.add(5);\n  mySet.add(\"Some text\");\n\n  mySet.has(1); //true\n  mySet.has(3); //false,3没有被添加到set中\n  mySet.has(5); //true\n  mySet.has(Math.sqrt(25));  // true\n  mySet.has(\"Some Text\".toLowerCase()); // true\n\n  mySet.size; // 3\n\n  mySet.delete(5); // 从set中移除5\n  mySet.has(5);    // false, 5已经被移除\n\n  mySet.size; // 2, 我们刚刚移除了一个值\n```\n\n示例：迭代Set\n```javascript\n  //迭代整个set\n  //按顺序输出：1, \"some text\"\n  for(let item of mySet) console.log(item);\n\n  //按顺序输出：1,,\"some text\"\n  for(let item of mySet.keys()) console.log(item);\n\n  //按顺序输出：1,\"some text\"\n  for(let item of mySet.values()) console.log(item);\n\n  //按顺序输出：1,\"some text\"(键与值相等)\n  for(let[key,value] of mySet.entries()) console.log(key);\n\n  //转换Set为Array(with Array coprehensions)\n  var myArr = [v for (v of mySet)]; //[1,\"some text\"]\n  //替代方案(with Array.from)\n  var myArr = Array.from(mySet); // [1,\"some text\"]\n\n  //如果在HTML文档中工作，也可以：\n  mySet.add(document.body);\n  mySet.has(document.querySelector(\"body\")); //true\n\n  //Set和Array转换\n  mySet2 = new Set([1,2,3,4]);\n  mySet2.size; //4\n  [...mySet2]; //[1,2,3,4]\n\n  //截取\n  var intersection = new Set([x for(x of set1) if (set2 has(x))]);\n\n  //用forEach迭代\n  mySet.forEach(function(value){\n    console.log(value);\n  });\n```\n\n示例：和Array对象的关系\n```javascript\n  var myArray = [\"value1\", \"value2\", \"value3\"];\n\n  //用Set构造器将Set转换为Array\n  var mySet = new Set(myArray);\n\n  mySet.has(\"value1\"); //returns true\n\n  //用...(展开操作符)操作符将Set转换为Array\n  alert(uneval([...mySet])); //与myArray完全一致\n```\n\n## Map\n### 概述\nMap对象就是简单的键/值映射。其中键和值可以是任意值(原始值或对象值).\n\n在判断两个值是否为同一个键的时候，使用的并不是===运算符，而是使用了一种称之为\"same-value\"的内部算法，该算法很特殊，对于Map对象来说,+0(按照以往的经验与-0是严格相等的)和-0是两个不同的键。而NaN在作为Map对象的键时和另外一个NaN是一个相同的键(尽管NaN !== NaN)\n\n### API\n| **Constructor** | **描述** |\n| ------ | :-------: |\n| new Map([iterable])\t| 返回一个新的Map对象。如果参数iterable是一个数组或者其他可迭代的对象 -- 它的元素是键值对，这样这些每一个键值对都可以添加到新的Map里面去 |\n| **方法** | **描述** |\n| myMap.get(key) | 返回键key关联的值，如果该键不存在则返回undefined |\n| myMap.set(key,value) | 设置键key在myMap中的值为value。返回undefined |\n| myMap.has(key) | 返回一个布尔值，表明键key是否存在于myMap中 |\n| myMap.delete(key) | 删除键key及对应的值.在这之后,myMap.has(key)将会返回false |\n| myMap.entries() | 返回一个迭代器，迭代器按照对象的插入顺序返回[key,value]; |\n| myMap.forEach(callbackFn[,thisArg]) | 循环执行函数并把键/值对作为参数;thisArg为可选的，如果有thisArg的话将会作为执行函数的上下文this; |\n| myMap.keys() | 返回一个迭代器，迭代器按照Map实例的插入顺序返回每一个key元素; |\n| myMap.clear() | 清空myMap中的所有键值对 |\n| **属性** | **描述** |\n| myMap.size | 返回myMap中键值对的数量。 |\n\n### 例子\n```javascript\n  var myMap = new Map();\n\n  var keyObj = {},\n      keyFunc = function(){},\n      keyString = \"a string\";\n\n  //添加键\n  myMap.set(keyString, \"和键'a string'关联的值\");\n  myMap.set(keyObj, \"和键keyObj关联的值\");\n  myMap.set(keyFunc, \"和键keyFunc关联的值\");\n\n  myMap.size; //3\n\n  //读取值\n  myMap.get(keyString); // \"和键'a string'关联的值\"\n  myMap.get(keyObj); // \"和键keyObj关联的值\"\n  myMap.get(keyFunc); //\"和键keyFunc关联的值\"\n\n  myMap.get(\"a string\"); //\"和键'a string'关联的值\"\n                         //因为keyString == \"a string\"\n  myMap.get({});         //undefined,因为keyObj !== {}\n  myMap.get(function(){})//undefined,因为keyFunc !== function(){}\n```\n\nNaN也可以作为Map对象的键。虽然NaN和任何值甚至和自己都不相等(NaN !== NaN返回true)，但下面的例子表明，两个NaN作为Map的键来说是没有区别的：\n```javascript\n  var myMap = new Map();\n  myMap.set(NaN,\"not a number\");\n\n  myMap.get(NaN); //\"not a number\"\n\n  var otherNaN = Number(\"foo\");\n  myMap.get(otherNaN); //\"not a number\"\n```\n\njavascript有两个0值，+0和-0.虽然+0 === -0,但是当这两个0作为Map的键时，被认为是两个不同的值。\n```javascript\n  var myMap = new Map();\n  myMap.set(0,\"正零\");\n  myMap.set(-0,\"负零\");\n\n  0 === -0; // true\n\n  myMap.get(-0); // \"负零\"\n  myMap.get(0);  // \"正零\"\n```\n\n### Object和Map的比较\nObject和Map类似的一点是，它们都允许你按键存取一个值，都可以删除键，还可以检测一个键是否绑定了值。因此，一直以来，我们都把对象当成Map来使用，现在有了Map,下面的区别解释了为什么使用Map更好点。\n - 一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键，不过，现在可以使用map = Object.create(null)来创建一个没有原型的对象。\n - 一个对象的键只能是字符串，但一个Map的键可以是任意值。\n - 你可以很容易的得到一个Map的键值对个数，而只能跟踪一个对象的键值对个数。\n\n## WeakSet\n### 概述\n一个WeakSet对象是一个无序的集合，可以用它来存储任意的对象值，并且对这些对象值保持弱引用。\n\n### 语法\n> new WeakSet([iterable]);  \n\n#### 参数\niterable -- 如果传入一个可迭代对象作为参数，则该对象的所有迭代值都会被自动添加进生成的WeakSet对象中。\n\n### 描述\nWeakSet对象是一些对象值的集合，并且其中的每个对象值都只能出现一次。\n\n它和Set对象的区别有两点：\n - WeakSet对象中只能存放对象值，不能存放原始值，而Set对象都可以。\n - WeakSet对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值，则这个对象值会被当成垃圾回收掉。正因为这样，WeakSet对象是无法被枚举的，没有办法拿到它包含的所有元素。\n\n### 属性\nWeakSet.length -- length属性的值为0\n\nWeakSet.prototype -- WeakSet实例的所有继承属性和继承方法都在该对象上。\n\n### WeakSet实例\n所有WeakSet实例都继承自WeakSet.prototype\n\n属性 -- WeakSet.prototype.constructor(返回构造函数即WeakSet本身)。\n\n方法\n - WeakSet.prototype.add(value) -- 在该 WeakSet 对象中添加一个新元素 value.\n - WeakSet.prototype.clear() -- 清空该 WeakSet 对象中的所有元素.\n - WeakSet.prototype.delete(value) -- 从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false.\n - WeakSet.prototype.has(value) -- 返回一个布尔值,  表示给定的值 value 是否存在于这个 WeakSet 中.\n\n### 示例\n```javascript\n  var ws = new WeakSet();\n  var obj = {};\n  var foo = {};\n\n  ws.add(window);\n  ws.add(obj);\n\n  ws.has(window); // true\n  ws.has(foo);    // false, 对象 foo 并没有被添加进 ws 中\n\n  ws.delete(window); // 从集合中删除 window 对象\n  ws.has(window);    // false, window 对象已经被删除了\n\n  ws.clear(); // 清空整个 WeakSet 对象\n```\n\n## WeakMap\n### 概述\nWeakMap对象就是简单的键/值映射。但键只能是对象值，不可以是原始值。\n\n### API\n| **方法** | **描述** |\n| ------ | :-------: |\n| myWeakMap.get(key [,defaultValue]) | 返回键key关联的值，如果该键不存在则返回默认值defaultValue |\n| myWeakMap.set(key,value) | 设置键key在myWeakMap中的值，返回undefined |\n| myWeakMap.has(key) | 返回一个布尔值来表明键key是否在myWeakMap中 |\n| myWeakMap.delete(key) | 删除键key及对应的值。在这之后，myWeakMap.has(key)将返回false |\n| myWeakMap.clear() | 清空myWeakMap中的所有的键值对，返回undefined |\n\n### 例子\n```javascript\n  var wm1 = new WeakMap(),\n      wm2 = new WeakMap(),\n      wm3 = new WeakMap();\n  var o1 = {},\n      o2 = function(){},\n      o3 = window;\n\n  wm1.set(o1, 37);\n  wm1.set(o2, \"azerty\");\n  wm2.set(o1, o2); // value可以是任意值,包括一个对象\n  wm2.set(o3, undefined);\n  wm2.set(wm1, wm2); // 键和值可以是任意对象,甚至另外一个WeakMap对象\n  wm1.get(o2); // \"azerty\"\n  wm2.get(o2); // undefined,wm2中没有o2这个键\n  wm2.get(o3); // undefined,值就是undefined\n\n  wm1.has(o2); // true\n  wm2.has(o2); // false\n  wm2.has(o3); // true (即使值是undefined)\n\n  wm3.set(o1, 37);\n  wm3.get(o1); // 37\n  wm3.clear();\n  wm3.get(o1); // undefined,wm3已被清空\n  wm1.has(o1);   // true\n  wm1.delete(o1);\n  wm1.has(o1);   // false  \n```\n\n### 为什么要使用WeakMap?\n经验丰富的JavaScript程序员会注意到，WeakMap完全通过两个数组(一个存放键，一个存放值)来实现。但这样的实现会有两个很大的缺点，首先是O(n)的时间复杂度(n是键值对的个数)。另外一个则可能或导致内存泄漏；在这种自己实现的WeakMap中，存放键的数组中的每个索引将会保持对所引用对象的引用，阻止他们被当做垃圾回收。而在原生的WeakMap中，每个键对自己所引用对象的引用是“弱引用”，这意味着，如果没有其他引用和该键引用同一个对象，这个对象将会被当做垃圾回收。\n\n正由于这样的弱引用, WeakMap 的keys是无法遍历的 (无法列举出所有的keys). 如果允许被遍历的话, 遍历的结果将会受垃圾回收的影响, 从而得到不确定的结果. 因此,如果你想得到所有keys的值,你应该自己管理他们. 另外ECMAScript提案中还介绍了另外两种集合类型,Map和Set,他们没有使用弱引用,所以是可遍历的.\n\n# Proxy 和 Reflect\n## 简介\nProxy对象用来为基础操作(例如：属性查找、赋值、枚举、方法调用等)定义用户自定义行为。\n\n## 术语\nhandler -- 包含traps的对象。\ntraps -- 提供访问属性的途径，与操作系统中的traps定义相似\ntarget -- 被代理虚拟化的对象，这个对象常常用作代理的存储后端。关于对象不可拓展性和不可修改属性的不变量会被代理拦截。\n\n## 语法\n> var p = new Proxy(target, handler);  \n\n### 参数\ntarget -- 目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。\nhandler -- 处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。\n\n## 方法\nProxy.revocable() -- 创建一个可撤销的代理对象。\n\n## handler对象的方法\nhandler是占位符对象，它包含代理的traps\n\n## 示例\n### 基础示例\n以下简单的例子中，当对象不存在属性名时，缺省返回数37.例子中使用了get处理器(get handler)\n```javascript\n  var handler = {\n    get: function(target,name){\n      return name in target? target[name] : 37;\n    }\n  };\n\n  var p = new Proxy({}, handler);\n  p.a = 1;\n  p.b = undefined;\n\n  console.log(p.a, p.b); // 1, undefined\n  console.log('c' in p, p.c); // false, 37\n```\n\n### 无操作转发代理\n在以下例子中，我们使用了一个原生JavaScript对象，代理会将所有应用到它的操作转发到这个对象上。\n```javascript\n  var target = {};\n  var p = new Proxy(target,{});\n\n  p.a = 37; //被转发到代理的操作\n  console.log(target.a); //37 操作已经被正确地转发。\n```\n\n### 验证\n通过代理，你可以轻松地验证向一个对象的传值。以下例子使用了set处理器(set handler)。\n```javascript\n  let validator = {\n    set: function(obj,prop,value){\n      if(pop === 'age'){\n        if(!Number.isInteger(value)){\n          throw new TypeError('The age is not an integer');\n        }\n        if(value > 200){\n          throw new RangeError('The age seems invalid');\n        }\n      }\n\n      //The default behavior to store the value\n      obj[prop] = value;\n    }\n  };\n\n  let person = new Proxy({}, validator);\n\n  person.age = 100;\n  console.log(person.age); //100\n  person.age = 'young'; //抛出异常\n  person.age = 300; //抛出异常\n```\n\n### 扩展构造函数\n方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。以下的例子中使用了constructor处理器(construct handler)和apply处理器(apply handler).\n```javascript\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n","source":"_posts/es6系列教程四.md","raw":"---\ntitle: es6系列教程四\ndate: 2016-06-06 12:15:00\ntags:\n  - es6\n  - javascript\ncategories: 原创\n---\n> Fading is true while flowering is past.  \n\n# Map,Set 和 WeakMap,WeakSet\n## Set\n### 概述\n集合(Set)对象允许你存储任意类型的唯一值(不能重复)，无论是原始数据还是对象引用。\n\n### 语法\n> new Set([iterable]);  \n\n#### 参数\niterable -- 一个可迭代对象，其中的所有元素都会被加入到Set中。null被视作undefined。\n\n### 简述\nSet对象是值的集合，你可以按照插入的顺序迭代它的元素。Set中的元素只会出现一次，即Set中的元素是唯一的。\n\n#### 值的相等\n因为Set中的值总是唯一的，所以需要判断两个值是否相等。判断相等的算法与严格相等(===操作符)不同。具体来说，对于Set, +0(+0严格相等于-0)和-0是不同的值。尽管在最新的ECMAScript6规范中这点已被更改。另外NaN和undefined都可被存储在Set中，NaN之间被视为相同的值(尽管NaN !== NaN)。\n\n### 属性\nSet.length -- length属性的值为0\n\nSet.prototype -- 表示Set构造器的原型，允许向所有Set对象添加新的属性。\n\n### Set实例\n所有的Set实例继承自Set.prototype。示例：使用Set对象。\n```javascript\n  var mySet = new Set();\n\n  mySet.add(1);\n  mySet.add(5);\n  mySet.add(\"Some text\");\n\n  mySet.has(1); //true\n  mySet.has(3); //false,3没有被添加到set中\n  mySet.has(5); //true\n  mySet.has(Math.sqrt(25));  // true\n  mySet.has(\"Some Text\".toLowerCase()); // true\n\n  mySet.size; // 3\n\n  mySet.delete(5); // 从set中移除5\n  mySet.has(5);    // false, 5已经被移除\n\n  mySet.size; // 2, 我们刚刚移除了一个值\n```\n\n示例：迭代Set\n```javascript\n  //迭代整个set\n  //按顺序输出：1, \"some text\"\n  for(let item of mySet) console.log(item);\n\n  //按顺序输出：1,,\"some text\"\n  for(let item of mySet.keys()) console.log(item);\n\n  //按顺序输出：1,\"some text\"\n  for(let item of mySet.values()) console.log(item);\n\n  //按顺序输出：1,\"some text\"(键与值相等)\n  for(let[key,value] of mySet.entries()) console.log(key);\n\n  //转换Set为Array(with Array coprehensions)\n  var myArr = [v for (v of mySet)]; //[1,\"some text\"]\n  //替代方案(with Array.from)\n  var myArr = Array.from(mySet); // [1,\"some text\"]\n\n  //如果在HTML文档中工作，也可以：\n  mySet.add(document.body);\n  mySet.has(document.querySelector(\"body\")); //true\n\n  //Set和Array转换\n  mySet2 = new Set([1,2,3,4]);\n  mySet2.size; //4\n  [...mySet2]; //[1,2,3,4]\n\n  //截取\n  var intersection = new Set([x for(x of set1) if (set2 has(x))]);\n\n  //用forEach迭代\n  mySet.forEach(function(value){\n    console.log(value);\n  });\n```\n\n示例：和Array对象的关系\n```javascript\n  var myArray = [\"value1\", \"value2\", \"value3\"];\n\n  //用Set构造器将Set转换为Array\n  var mySet = new Set(myArray);\n\n  mySet.has(\"value1\"); //returns true\n\n  //用...(展开操作符)操作符将Set转换为Array\n  alert(uneval([...mySet])); //与myArray完全一致\n```\n\n## Map\n### 概述\nMap对象就是简单的键/值映射。其中键和值可以是任意值(原始值或对象值).\n\n在判断两个值是否为同一个键的时候，使用的并不是===运算符，而是使用了一种称之为\"same-value\"的内部算法，该算法很特殊，对于Map对象来说,+0(按照以往的经验与-0是严格相等的)和-0是两个不同的键。而NaN在作为Map对象的键时和另外一个NaN是一个相同的键(尽管NaN !== NaN)\n\n### API\n| **Constructor** | **描述** |\n| ------ | :-------: |\n| new Map([iterable])\t| 返回一个新的Map对象。如果参数iterable是一个数组或者其他可迭代的对象 -- 它的元素是键值对，这样这些每一个键值对都可以添加到新的Map里面去 |\n| **方法** | **描述** |\n| myMap.get(key) | 返回键key关联的值，如果该键不存在则返回undefined |\n| myMap.set(key,value) | 设置键key在myMap中的值为value。返回undefined |\n| myMap.has(key) | 返回一个布尔值，表明键key是否存在于myMap中 |\n| myMap.delete(key) | 删除键key及对应的值.在这之后,myMap.has(key)将会返回false |\n| myMap.entries() | 返回一个迭代器，迭代器按照对象的插入顺序返回[key,value]; |\n| myMap.forEach(callbackFn[,thisArg]) | 循环执行函数并把键/值对作为参数;thisArg为可选的，如果有thisArg的话将会作为执行函数的上下文this; |\n| myMap.keys() | 返回一个迭代器，迭代器按照Map实例的插入顺序返回每一个key元素; |\n| myMap.clear() | 清空myMap中的所有键值对 |\n| **属性** | **描述** |\n| myMap.size | 返回myMap中键值对的数量。 |\n\n### 例子\n```javascript\n  var myMap = new Map();\n\n  var keyObj = {},\n      keyFunc = function(){},\n      keyString = \"a string\";\n\n  //添加键\n  myMap.set(keyString, \"和键'a string'关联的值\");\n  myMap.set(keyObj, \"和键keyObj关联的值\");\n  myMap.set(keyFunc, \"和键keyFunc关联的值\");\n\n  myMap.size; //3\n\n  //读取值\n  myMap.get(keyString); // \"和键'a string'关联的值\"\n  myMap.get(keyObj); // \"和键keyObj关联的值\"\n  myMap.get(keyFunc); //\"和键keyFunc关联的值\"\n\n  myMap.get(\"a string\"); //\"和键'a string'关联的值\"\n                         //因为keyString == \"a string\"\n  myMap.get({});         //undefined,因为keyObj !== {}\n  myMap.get(function(){})//undefined,因为keyFunc !== function(){}\n```\n\nNaN也可以作为Map对象的键。虽然NaN和任何值甚至和自己都不相等(NaN !== NaN返回true)，但下面的例子表明，两个NaN作为Map的键来说是没有区别的：\n```javascript\n  var myMap = new Map();\n  myMap.set(NaN,\"not a number\");\n\n  myMap.get(NaN); //\"not a number\"\n\n  var otherNaN = Number(\"foo\");\n  myMap.get(otherNaN); //\"not a number\"\n```\n\njavascript有两个0值，+0和-0.虽然+0 === -0,但是当这两个0作为Map的键时，被认为是两个不同的值。\n```javascript\n  var myMap = new Map();\n  myMap.set(0,\"正零\");\n  myMap.set(-0,\"负零\");\n\n  0 === -0; // true\n\n  myMap.get(-0); // \"负零\"\n  myMap.get(0);  // \"正零\"\n```\n\n### Object和Map的比较\nObject和Map类似的一点是，它们都允许你按键存取一个值，都可以删除键，还可以检测一个键是否绑定了值。因此，一直以来，我们都把对象当成Map来使用，现在有了Map,下面的区别解释了为什么使用Map更好点。\n - 一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键，不过，现在可以使用map = Object.create(null)来创建一个没有原型的对象。\n - 一个对象的键只能是字符串，但一个Map的键可以是任意值。\n - 你可以很容易的得到一个Map的键值对个数，而只能跟踪一个对象的键值对个数。\n\n## WeakSet\n### 概述\n一个WeakSet对象是一个无序的集合，可以用它来存储任意的对象值，并且对这些对象值保持弱引用。\n\n### 语法\n> new WeakSet([iterable]);  \n\n#### 参数\niterable -- 如果传入一个可迭代对象作为参数，则该对象的所有迭代值都会被自动添加进生成的WeakSet对象中。\n\n### 描述\nWeakSet对象是一些对象值的集合，并且其中的每个对象值都只能出现一次。\n\n它和Set对象的区别有两点：\n - WeakSet对象中只能存放对象值，不能存放原始值，而Set对象都可以。\n - WeakSet对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值，则这个对象值会被当成垃圾回收掉。正因为这样，WeakSet对象是无法被枚举的，没有办法拿到它包含的所有元素。\n\n### 属性\nWeakSet.length -- length属性的值为0\n\nWeakSet.prototype -- WeakSet实例的所有继承属性和继承方法都在该对象上。\n\n### WeakSet实例\n所有WeakSet实例都继承自WeakSet.prototype\n\n属性 -- WeakSet.prototype.constructor(返回构造函数即WeakSet本身)。\n\n方法\n - WeakSet.prototype.add(value) -- 在该 WeakSet 对象中添加一个新元素 value.\n - WeakSet.prototype.clear() -- 清空该 WeakSet 对象中的所有元素.\n - WeakSet.prototype.delete(value) -- 从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false.\n - WeakSet.prototype.has(value) -- 返回一个布尔值,  表示给定的值 value 是否存在于这个 WeakSet 中.\n\n### 示例\n```javascript\n  var ws = new WeakSet();\n  var obj = {};\n  var foo = {};\n\n  ws.add(window);\n  ws.add(obj);\n\n  ws.has(window); // true\n  ws.has(foo);    // false, 对象 foo 并没有被添加进 ws 中\n\n  ws.delete(window); // 从集合中删除 window 对象\n  ws.has(window);    // false, window 对象已经被删除了\n\n  ws.clear(); // 清空整个 WeakSet 对象\n```\n\n## WeakMap\n### 概述\nWeakMap对象就是简单的键/值映射。但键只能是对象值，不可以是原始值。\n\n### API\n| **方法** | **描述** |\n| ------ | :-------: |\n| myWeakMap.get(key [,defaultValue]) | 返回键key关联的值，如果该键不存在则返回默认值defaultValue |\n| myWeakMap.set(key,value) | 设置键key在myWeakMap中的值，返回undefined |\n| myWeakMap.has(key) | 返回一个布尔值来表明键key是否在myWeakMap中 |\n| myWeakMap.delete(key) | 删除键key及对应的值。在这之后，myWeakMap.has(key)将返回false |\n| myWeakMap.clear() | 清空myWeakMap中的所有的键值对，返回undefined |\n\n### 例子\n```javascript\n  var wm1 = new WeakMap(),\n      wm2 = new WeakMap(),\n      wm3 = new WeakMap();\n  var o1 = {},\n      o2 = function(){},\n      o3 = window;\n\n  wm1.set(o1, 37);\n  wm1.set(o2, \"azerty\");\n  wm2.set(o1, o2); // value可以是任意值,包括一个对象\n  wm2.set(o3, undefined);\n  wm2.set(wm1, wm2); // 键和值可以是任意对象,甚至另外一个WeakMap对象\n  wm1.get(o2); // \"azerty\"\n  wm2.get(o2); // undefined,wm2中没有o2这个键\n  wm2.get(o3); // undefined,值就是undefined\n\n  wm1.has(o2); // true\n  wm2.has(o2); // false\n  wm2.has(o3); // true (即使值是undefined)\n\n  wm3.set(o1, 37);\n  wm3.get(o1); // 37\n  wm3.clear();\n  wm3.get(o1); // undefined,wm3已被清空\n  wm1.has(o1);   // true\n  wm1.delete(o1);\n  wm1.has(o1);   // false  \n```\n\n### 为什么要使用WeakMap?\n经验丰富的JavaScript程序员会注意到，WeakMap完全通过两个数组(一个存放键，一个存放值)来实现。但这样的实现会有两个很大的缺点，首先是O(n)的时间复杂度(n是键值对的个数)。另外一个则可能或导致内存泄漏；在这种自己实现的WeakMap中，存放键的数组中的每个索引将会保持对所引用对象的引用，阻止他们被当做垃圾回收。而在原生的WeakMap中，每个键对自己所引用对象的引用是“弱引用”，这意味着，如果没有其他引用和该键引用同一个对象，这个对象将会被当做垃圾回收。\n\n正由于这样的弱引用, WeakMap 的keys是无法遍历的 (无法列举出所有的keys). 如果允许被遍历的话, 遍历的结果将会受垃圾回收的影响, 从而得到不确定的结果. 因此,如果你想得到所有keys的值,你应该自己管理他们. 另外ECMAScript提案中还介绍了另外两种集合类型,Map和Set,他们没有使用弱引用,所以是可遍历的.\n\n# Proxy 和 Reflect\n## 简介\nProxy对象用来为基础操作(例如：属性查找、赋值、枚举、方法调用等)定义用户自定义行为。\n\n## 术语\nhandler -- 包含traps的对象。\ntraps -- 提供访问属性的途径，与操作系统中的traps定义相似\ntarget -- 被代理虚拟化的对象，这个对象常常用作代理的存储后端。关于对象不可拓展性和不可修改属性的不变量会被代理拦截。\n\n## 语法\n> var p = new Proxy(target, handler);  \n\n### 参数\ntarget -- 目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。\nhandler -- 处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。\n\n## 方法\nProxy.revocable() -- 创建一个可撤销的代理对象。\n\n## handler对象的方法\nhandler是占位符对象，它包含代理的traps\n\n## 示例\n### 基础示例\n以下简单的例子中，当对象不存在属性名时，缺省返回数37.例子中使用了get处理器(get handler)\n```javascript\n  var handler = {\n    get: function(target,name){\n      return name in target? target[name] : 37;\n    }\n  };\n\n  var p = new Proxy({}, handler);\n  p.a = 1;\n  p.b = undefined;\n\n  console.log(p.a, p.b); // 1, undefined\n  console.log('c' in p, p.c); // false, 37\n```\n\n### 无操作转发代理\n在以下例子中，我们使用了一个原生JavaScript对象，代理会将所有应用到它的操作转发到这个对象上。\n```javascript\n  var target = {};\n  var p = new Proxy(target,{});\n\n  p.a = 37; //被转发到代理的操作\n  console.log(target.a); //37 操作已经被正确地转发。\n```\n\n### 验证\n通过代理，你可以轻松地验证向一个对象的传值。以下例子使用了set处理器(set handler)。\n```javascript\n  let validator = {\n    set: function(obj,prop,value){\n      if(pop === 'age'){\n        if(!Number.isInteger(value)){\n          throw new TypeError('The age is not an integer');\n        }\n        if(value > 200){\n          throw new RangeError('The age seems invalid');\n        }\n      }\n\n      //The default behavior to store the value\n      obj[prop] = value;\n    }\n  };\n\n  let person = new Proxy({}, validator);\n\n  person.age = 100;\n  console.log(person.age); //100\n  person.age = 'young'; //抛出异常\n  person.age = 300; //抛出异常\n```\n\n### 扩展构造函数\n方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。以下的例子中使用了constructor处理器(construct handler)和apply处理器(apply handler).\n```javascript\n\n```\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\n","slug":"es6系列教程四","published":1,"updated":"2016-06-20T03:37:20.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0en00013b0dl6rjvsp7v","content":"<blockquote>\n<p>Fading is true while flowering is past.  </p>\n</blockquote>\n<h1 id=\"Map-Set-和-WeakMap-WeakSet\"><a href=\"#Map-Set-和-WeakMap-WeakSet\" class=\"headerlink\" title=\"Map,Set 和 WeakMap,WeakSet\"></a>Map,Set 和 WeakMap,WeakSet</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>集合(Set)对象允许你存储任意类型的唯一值(不能重复)，无论是原始数据还是对象引用。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><blockquote>\n<p>new Set([iterable]);  </p>\n</blockquote>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>iterable – 一个可迭代对象，其中的所有元素都会被加入到Set中。null被视作undefined。</p>\n<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set中的元素只会出现一次，即Set中的元素是唯一的。</p>\n<h4 id=\"值的相等\"><a href=\"#值的相等\" class=\"headerlink\" title=\"值的相等\"></a>值的相等</h4><p>因为Set中的值总是唯一的，所以需要判断两个值是否相等。判断相等的算法与严格相等(===操作符)不同。具体来说，对于Set, +0(+0严格相等于-0)和-0是不同的值。尽管在最新的ECMAScript6规范中这点已被更改。另外NaN和undefined都可被存储在Set中，NaN之间被视为相同的值(尽管NaN !== NaN)。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>Set.length – length属性的值为0</p>\n<p>Set.prototype – 表示Set构造器的原型，允许向所有Set对象添加新的属性。</p>\n<h3 id=\"Set实例\"><a href=\"#Set实例\" class=\"headerlink\" title=\"Set实例\"></a>Set实例</h3><p>所有的Set实例继承自Set.prototype。示例：使用Set对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mySet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">mySet.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">mySet.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">mySet.add(<span class=\"string\">\"Some text\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mySet.has(<span class=\"number\">1</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">mySet.has(<span class=\"number\">3</span>); <span class=\"comment\">//false,3没有被添加到set中</span></span><br><span class=\"line\">mySet.has(<span class=\"number\">5</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">mySet.has(<span class=\"built_in\">Math</span>.sqrt(<span class=\"number\">25</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\">mySet.has(<span class=\"string\">\"Some Text\"</span>.toLowerCase()); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySet.size; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySet.delete(<span class=\"number\">5</span>); <span class=\"comment\">// 从set中移除5</span></span><br><span class=\"line\">mySet.has(<span class=\"number\">5</span>);    <span class=\"comment\">// false, 5已经被移除</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySet.size; <span class=\"comment\">// 2, 我们刚刚移除了一个值</span></span><br></pre></td></tr></table></figure></p>\n<p>示例：迭代Set<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代整个set</span></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1, \"some text\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> mySet) <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1,,\"some text\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> mySet.keys()) <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1,\"some text\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> mySet.values()) <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1,\"some text\"(键与值相等)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span>[key,value] <span class=\"keyword\">of</span> mySet.entries()) <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//转换Set为Array(with Array coprehensions)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArr = [v <span class=\"keyword\">for</span> (v <span class=\"keyword\">of</span> mySet)]; <span class=\"comment\">//[1,\"some text\"]</span></span><br><span class=\"line\"><span class=\"comment\">//替代方案(with Array.from)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArr = <span class=\"built_in\">Array</span>.from(mySet); <span class=\"comment\">// [1,\"some text\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果在HTML文档中工作，也可以：</span></span><br><span class=\"line\">mySet.add(<span class=\"built_in\">document</span>.body);</span><br><span class=\"line\">mySet.has(<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"body\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Set和Array转换</span></span><br><span class=\"line\">mySet2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\">mySet2.size; <span class=\"comment\">//4</span></span><br><span class=\"line\">[...mySet2]; <span class=\"comment\">//[1,2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//截取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> intersection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([x <span class=\"keyword\">for</span>(x <span class=\"keyword\">of</span> set1) <span class=\"keyword\">if</span> (set2 has(x))]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用forEach迭代</span></span><br><span class=\"line\">mySet.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>示例：和Array对象的关系<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"string\">\"value1\"</span>, <span class=\"string\">\"value2\"</span>, <span class=\"string\">\"value3\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用Set构造器将Set转换为Array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mySet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(myArray);</span><br><span class=\"line\"></span><br><span class=\"line\">mySet.has(<span class=\"string\">\"value1\"</span>); <span class=\"comment\">//returns true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用...(展开操作符)操作符将Set转换为Array</span></span><br><span class=\"line\">alert(uneval([...mySet])); <span class=\"comment\">//与myArray完全一致</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Map对象就是简单的键/值映射。其中键和值可以是任意值(原始值或对象值).</p>\n<p>在判断两个值是否为同一个键的时候，使用的并不是===运算符，而是使用了一种称之为”same-value”的内部算法，该算法很特殊，对于Map对象来说,+0(按照以往的经验与-0是严格相等的)和-0是两个不同的键。而NaN在作为Map对象的键时和另外一个NaN是一个相同的键(尽管NaN !== NaN)</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><table>\n<thead>\n<tr>\n<th><strong>Constructor</strong></th>\n<th style=\"text-align:center\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>new Map([iterable])</td>\n<td style=\"text-align:center\">返回一个新的Map对象。如果参数iterable是一个数组或者其他可迭代的对象 – 它的元素是键值对，这样这些每一个键值对都可以添加到新的Map里面去</td>\n</tr>\n<tr>\n<td><strong>方法</strong></td>\n<td style=\"text-align:center\"><strong>描述</strong></td>\n</tr>\n<tr>\n<td>myMap.get(key)</td>\n<td style=\"text-align:center\">返回键key关联的值，如果该键不存在则返回undefined</td>\n</tr>\n<tr>\n<td>myMap.set(key,value)</td>\n<td style=\"text-align:center\">设置键key在myMap中的值为value。返回undefined</td>\n</tr>\n<tr>\n<td>myMap.has(key)</td>\n<td style=\"text-align:center\">返回一个布尔值，表明键key是否存在于myMap中</td>\n</tr>\n<tr>\n<td>myMap.delete(key)</td>\n<td style=\"text-align:center\">删除键key及对应的值.在这之后,myMap.has(key)将会返回false</td>\n</tr>\n<tr>\n<td>myMap.entries()</td>\n<td style=\"text-align:center\">返回一个迭代器，迭代器按照对象的插入顺序返回[key,value];</td>\n</tr>\n<tr>\n<td>myMap.forEach(callbackFn[,thisArg])</td>\n<td style=\"text-align:center\">循环执行函数并把键/值对作为参数;thisArg为可选的，如果有thisArg的话将会作为执行函数的上下文this;</td>\n</tr>\n<tr>\n<td>myMap.keys()</td>\n<td style=\"text-align:center\">返回一个迭代器，迭代器按照Map实例的插入顺序返回每一个key元素;</td>\n</tr>\n<tr>\n<td>myMap.clear()</td>\n<td style=\"text-align:center\">清空myMap中的所有键值对</td>\n</tr>\n<tr>\n<td><strong>属性</strong></td>\n<td style=\"text-align:center\"><strong>描述</strong></td>\n</tr>\n<tr>\n<td>myMap.size</td>\n<td style=\"text-align:center\">返回myMap中键值对的数量。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> keyObj = &#123;&#125;,</span><br><span class=\"line\">    keyFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">    keyString = <span class=\"string\">\"a string\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加键</span></span><br><span class=\"line\">myMap.set(keyString, <span class=\"string\">\"和键'a string'关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyObj, <span class=\"string\">\"和键keyObj关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyFunc, <span class=\"string\">\"和键keyFunc关联的值\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.size; <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取值</span></span><br><span class=\"line\">myMap.get(keyString); <span class=\"comment\">// \"和键'a string'关联的值\"</span></span><br><span class=\"line\">myMap.get(keyObj); <span class=\"comment\">// \"和键keyObj关联的值\"</span></span><br><span class=\"line\">myMap.get(keyFunc); <span class=\"comment\">//\"和键keyFunc关联的值\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"string\">\"a string\"</span>); <span class=\"comment\">//\"和键'a string'关联的值\"</span></span><br><span class=\"line\">                       <span class=\"comment\">//因为keyString == \"a string\"</span></span><br><span class=\"line\">myMap.get(&#123;&#125;);         <span class=\"comment\">//undefined,因为keyObj !== &#123;&#125;</span></span><br><span class=\"line\">myMap.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)<span class=\"comment\">//undefined,因为keyFunc !== function()&#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>NaN也可以作为Map对象的键。虽然NaN和任何值甚至和自己都不相等(NaN !== NaN返回true)，但下面的例子表明，两个NaN作为Map的键来说是没有区别的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">myMap.set(<span class=\"literal\">NaN</span>,<span class=\"string\">\"not a number\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"literal\">NaN</span>); <span class=\"comment\">//\"not a number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherNaN = <span class=\"built_in\">Number</span>(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">myMap.get(otherNaN); <span class=\"comment\">//\"not a number\"</span></span><br></pre></td></tr></table></figure></p>\n<p>javascript有两个0值，+0和-0.虽然+0 === -0,但是当这两个0作为Map的键时，被认为是两个不同的值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">myMap.set(<span class=\"number\">0</span>,<span class=\"string\">\"正零\"</span>);</span><br><span class=\"line\">myMap.set(<span class=\"number\">-0</span>,<span class=\"string\">\"负零\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> === <span class=\"number\">-0</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"number\">-0</span>); <span class=\"comment\">// \"负零\"</span></span><br><span class=\"line\">myMap.get(<span class=\"number\">0</span>);  <span class=\"comment\">// \"正零\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Object和Map的比较\"><a href=\"#Object和Map的比较\" class=\"headerlink\" title=\"Object和Map的比较\"></a>Object和Map的比较</h3><p>Object和Map类似的一点是，它们都允许你按键存取一个值，都可以删除键，还可以检测一个键是否绑定了值。因此，一直以来，我们都把对象当成Map来使用，现在有了Map,下面的区别解释了为什么使用Map更好点。</p>\n<ul>\n<li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键，不过，现在可以使用map = Object.create(null)来创建一个没有原型的对象。</li>\n<li>一个对象的键只能是字符串，但一个Map的键可以是任意值。</li>\n<li>你可以很容易的得到一个Map的键值对个数，而只能跟踪一个对象的键值对个数。</li>\n</ul>\n<h2 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>一个WeakSet对象是一个无序的集合，可以用它来存储任意的对象值，并且对这些对象值保持弱引用。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><blockquote>\n<p>new WeakSet([iterable]);  </p>\n</blockquote>\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>iterable – 如果传入一个可迭代对象作为参数，则该对象的所有迭代值都会被自动添加进生成的WeakSet对象中。</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>WeakSet对象是一些对象值的集合，并且其中的每个对象值都只能出现一次。</p>\n<p>它和Set对象的区别有两点：</p>\n<ul>\n<li>WeakSet对象中只能存放对象值，不能存放原始值，而Set对象都可以。</li>\n<li>WeakSet对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值，则这个对象值会被当成垃圾回收掉。正因为这样，WeakSet对象是无法被枚举的，没有办法拿到它包含的所有元素。</li>\n</ul>\n<h3 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>WeakSet.length – length属性的值为0</p>\n<p>WeakSet.prototype – WeakSet实例的所有继承属性和继承方法都在该对象上。</p>\n<h3 id=\"WeakSet实例\"><a href=\"#WeakSet实例\" class=\"headerlink\" title=\"WeakSet实例\"></a>WeakSet实例</h3><p>所有WeakSet实例都继承自WeakSet.prototype</p>\n<p>属性 – WeakSet.prototype.constructor(返回构造函数即WeakSet本身)。</p>\n<p>方法</p>\n<ul>\n<li>WeakSet.prototype.add(value) – 在该 WeakSet 对象中添加一个新元素 value.</li>\n<li>WeakSet.prototype.clear() – 清空该 WeakSet 对象中的所有元素.</li>\n<li>WeakSet.prototype.delete(value) – 从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false.</li>\n<li>WeakSet.prototype.has(value) – 返回一个布尔值,  表示给定的值 value 是否存在于这个 WeakSet 中.</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.add(<span class=\"built_in\">window</span>);</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">ws.has(<span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">ws.has(foo);    <span class=\"comment\">// false, 对象 foo 并没有被添加进 ws 中</span></span><br><span class=\"line\"></span><br><span class=\"line\">ws.delete(<span class=\"built_in\">window</span>); <span class=\"comment\">// 从集合中删除 window 对象</span></span><br><span class=\"line\">ws.has(<span class=\"built_in\">window</span>);    <span class=\"comment\">// false, window 对象已经被删除了</span></span><br><span class=\"line\"></span><br><span class=\"line\">ws.clear(); <span class=\"comment\">// 清空整个 WeakSet 对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h2><h3 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>WeakMap对象就是简单的键/值映射。但键只能是对象值，不可以是原始值。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th style=\"text-align:center\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>myWeakMap.get(key [,defaultValue])</td>\n<td style=\"text-align:center\">返回键key关联的值，如果该键不存在则返回默认值defaultValue</td>\n</tr>\n<tr>\n<td>myWeakMap.set(key,value)</td>\n<td style=\"text-align:center\">设置键key在myWeakMap中的值，返回undefined</td>\n</tr>\n<tr>\n<td>myWeakMap.has(key)</td>\n<td style=\"text-align:center\">返回一个布尔值来表明键key是否在myWeakMap中</td>\n</tr>\n<tr>\n<td>myWeakMap.delete(key)</td>\n<td style=\"text-align:center\">删除键key及对应的值。在这之后，myWeakMap.has(key)将返回false</td>\n</tr>\n<tr>\n<td>myWeakMap.clear()</td>\n<td style=\"text-align:center\">清空myWeakMap中的所有的键值对，返回undefined</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wm1 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">    wm2 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">    wm3 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123;&#125;,</span><br><span class=\"line\">    o2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">    o3 = <span class=\"built_in\">window</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">wm1.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm1.set(o2, <span class=\"string\">\"azerty\"</span>);</span><br><span class=\"line\">wm2.set(o1, o2); <span class=\"comment\">// value可以是任意值,包括一个对象</span></span><br><span class=\"line\">wm2.set(o3, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">wm2.set(wm1, wm2); <span class=\"comment\">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class=\"line\">wm1.get(o2); <span class=\"comment\">// \"azerty\"</span></span><br><span class=\"line\">wm2.get(o2); <span class=\"comment\">// undefined,wm2中没有o2这个键</span></span><br><span class=\"line\">wm2.get(o3); <span class=\"comment\">// undefined,值就是undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.has(o2); <span class=\"comment\">// true</span></span><br><span class=\"line\">wm2.has(o2); <span class=\"comment\">// false</span></span><br><span class=\"line\">wm2.has(o3); <span class=\"comment\">// true (即使值是undefined)</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm3.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm3.get(o1); <span class=\"comment\">// 37</span></span><br><span class=\"line\">wm3.clear();</span><br><span class=\"line\">wm3.get(o1); <span class=\"comment\">// undefined,wm3已被清空</span></span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// true</span></span><br><span class=\"line\">wm1.delete(o1);</span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要使用WeakMap\"><a href=\"#为什么要使用WeakMap\" class=\"headerlink\" title=\"为什么要使用WeakMap?\"></a>为什么要使用WeakMap?</h3><p>经验丰富的JavaScript程序员会注意到，WeakMap完全通过两个数组(一个存放键，一个存放值)来实现。但这样的实现会有两个很大的缺点，首先是O(n)的时间复杂度(n是键值对的个数)。另外一个则可能或导致内存泄漏；在这种自己实现的WeakMap中，存放键的数组中的每个索引将会保持对所引用对象的引用，阻止他们被当做垃圾回收。而在原生的WeakMap中，每个键对自己所引用对象的引用是“弱引用”，这意味着，如果没有其他引用和该键引用同一个对象，这个对象将会被当做垃圾回收。</p>\n<p>正由于这样的弱引用, WeakMap 的keys是无法遍历的 (无法列举出所有的keys). 如果允许被遍历的话, 遍历的结果将会受垃圾回收的影响, 从而得到不确定的结果. 因此,如果你想得到所有keys的值,你应该自己管理他们. 另外ECMAScript提案中还介绍了另外两种集合类型,Map和Set,他们没有使用弱引用,所以是可遍历的.</p>\n<h1 id=\"Proxy-和-Reflect\"><a href=\"#Proxy-和-Reflect\" class=\"headerlink\" title=\"Proxy 和 Reflect\"></a>Proxy 和 Reflect</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Proxy对象用来为基础操作(例如：属性查找、赋值、枚举、方法调用等)定义用户自定义行为。</p>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>handler – 包含traps的对象。<br>traps – 提供访问属性的途径，与操作系统中的traps定义相似<br>target – 被代理虚拟化的对象，这个对象常常用作代理的存储后端。关于对象不可拓展性和不可修改属性的不变量会被代理拦截。</p>\n<h2 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h2><blockquote>\n<p>var p = new Proxy(target, handler);  </p>\n</blockquote>\n<h3 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>target – 目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。<br>handler – 处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Proxy.revocable() – 创建一个可撤销的代理对象。</p>\n<h2 id=\"handler对象的方法\"><a href=\"#handler对象的方法\" class=\"headerlink\" title=\"handler对象的方法\"></a>handler对象的方法</h2><p>handler是占位符对象，它包含代理的traps</p>\n<h2 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h3><p>以下简单的例子中，当对象不存在属性名时，缺省返回数37.例子中使用了get处理器(get handler)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target,name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name <span class=\"keyword\">in</span> target? target[name] : <span class=\"number\">37</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, handler);</span><br><span class=\"line\">p.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">p.b = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.a, p.b); <span class=\"comment\">// 1, undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span> <span class=\"keyword\">in</span> p, p.c); <span class=\"comment\">// false, 37</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"无操作转发代理\"><a href=\"#无操作转发代理\" class=\"headerlink\" title=\"无操作转发代理\"></a>无操作转发代理</h3><p>在以下例子中，我们使用了一个原生JavaScript对象，代理会将所有应用到它的操作转发到这个对象上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target,&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"number\">37</span>; <span class=\"comment\">//被转发到代理的操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target.a); <span class=\"comment\">//37 操作已经被正确地转发。</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>通过代理，你可以轻松地验证向一个对象的传值。以下例子使用了set处理器(set handler)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> validator = &#123;</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj,prop,value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pop === <span class=\"string\">'age'</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!<span class=\"built_in\">Number</span>.isInteger(value))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'The age is not an integer'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(value &gt; <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RangeError</span>(<span class=\"string\">'The age seems invalid'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//The default behavior to store the value</span></span><br><span class=\"line\">    obj[prop] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, validator);</span><br><span class=\"line\"></span><br><span class=\"line\">person.age = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.age); <span class=\"comment\">//100</span></span><br><span class=\"line\">person.age = <span class=\"string\">'young'</span>; <span class=\"comment\">//抛出异常</span></span><br><span class=\"line\">person.age = <span class=\"number\">300</span>; <span class=\"comment\">//抛出异常</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展构造函数\"><a href=\"#扩展构造函数\" class=\"headerlink\" title=\"扩展构造函数\"></a>扩展构造函数</h3><p>方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。以下的例子中使用了constructor处理器(construct handler)和apply处理器(apply handler).<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>\n","excerpt":"","more":"<blockquote>\n<p>Fading is true while flowering is past.  </p>\n</blockquote>\n<h1 id=\"Map-Set-和-WeakMap-WeakSet\"><a href=\"#Map-Set-和-WeakMap-WeakSet\" class=\"headerlink\" title=\"Map,Set 和 WeakMap,WeakSet\"></a>Map,Set 和 WeakMap,WeakSet</h1><h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>集合(Set)对象允许你存储任意类型的唯一值(不能重复)，无论是原始数据还是对象引用。</p>\n<h3 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h3><blockquote>\n<p>new Set([iterable]);  </p>\n</blockquote>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>iterable – 一个可迭代对象，其中的所有元素都会被加入到Set中。null被视作undefined。</p>\n<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>Set对象是值的集合，你可以按照插入的顺序迭代它的元素。Set中的元素只会出现一次，即Set中的元素是唯一的。</p>\n<h4 id=\"值的相等\"><a href=\"#值的相等\" class=\"headerlink\" title=\"值的相等\"></a>值的相等</h4><p>因为Set中的值总是唯一的，所以需要判断两个值是否相等。判断相等的算法与严格相等(===操作符)不同。具体来说，对于Set, +0(+0严格相等于-0)和-0是不同的值。尽管在最新的ECMAScript6规范中这点已被更改。另外NaN和undefined都可被存储在Set中，NaN之间被视为相同的值(尽管NaN !== NaN)。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>Set.length – length属性的值为0</p>\n<p>Set.prototype – 表示Set构造器的原型，允许向所有Set对象添加新的属性。</p>\n<h3 id=\"Set实例\"><a href=\"#Set实例\" class=\"headerlink\" title=\"Set实例\"></a>Set实例</h3><p>所有的Set实例继承自Set.prototype。示例：使用Set对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mySet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">mySet.add(<span class=\"number\">1</span>);</span><br><span class=\"line\">mySet.add(<span class=\"number\">5</span>);</span><br><span class=\"line\">mySet.add(<span class=\"string\">\"Some text\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mySet.has(<span class=\"number\">1</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">mySet.has(<span class=\"number\">3</span>); <span class=\"comment\">//false,3没有被添加到set中</span></span><br><span class=\"line\">mySet.has(<span class=\"number\">5</span>); <span class=\"comment\">//true</span></span><br><span class=\"line\">mySet.has(<span class=\"built_in\">Math</span>.sqrt(<span class=\"number\">25</span>));  <span class=\"comment\">// true</span></span><br><span class=\"line\">mySet.has(<span class=\"string\">\"Some Text\"</span>.toLowerCase()); <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySet.size; <span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySet.delete(<span class=\"number\">5</span>); <span class=\"comment\">// 从set中移除5</span></span><br><span class=\"line\">mySet.has(<span class=\"number\">5</span>);    <span class=\"comment\">// false, 5已经被移除</span></span><br><span class=\"line\"></span><br><span class=\"line\">mySet.size; <span class=\"comment\">// 2, 我们刚刚移除了一个值</span></span><br></pre></td></tr></table></figure></p>\n<p>示例：迭代Set<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//迭代整个set</span></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1, \"some text\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> mySet) <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1,,\"some text\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> mySet.keys()) <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1,\"some text\"</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> item <span class=\"keyword\">of</span> mySet.values()) <span class=\"built_in\">console</span>.log(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//按顺序输出：1,\"some text\"(键与值相等)</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">let</span>[key,value] <span class=\"keyword\">of</span> mySet.entries()) <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//转换Set为Array(with Array coprehensions)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArr = [v <span class=\"keyword\">for</span> (v <span class=\"keyword\">of</span> mySet)]; <span class=\"comment\">//[1,\"some text\"]</span></span><br><span class=\"line\"><span class=\"comment\">//替代方案(with Array.from)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myArr = <span class=\"built_in\">Array</span>.from(mySet); <span class=\"comment\">// [1,\"some text\"]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果在HTML文档中工作，也可以：</span></span><br><span class=\"line\">mySet.add(<span class=\"built_in\">document</span>.body);</span><br><span class=\"line\">mySet.has(<span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"body\"</span>)); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Set和Array转换</span></span><br><span class=\"line\">mySet2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]);</span><br><span class=\"line\">mySet2.size; <span class=\"comment\">//4</span></span><br><span class=\"line\">[...mySet2]; <span class=\"comment\">//[1,2,3,4]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//截取</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> intersection = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([x <span class=\"keyword\">for</span>(x <span class=\"keyword\">of</span> set1) <span class=\"keyword\">if</span> (set2 has(x))]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用forEach迭代</span></span><br><span class=\"line\">mySet.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>示例：和Array对象的关系<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"string\">\"value1\"</span>, <span class=\"string\">\"value2\"</span>, <span class=\"string\">\"value3\"</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用Set构造器将Set转换为Array</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> mySet = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(myArray);</span><br><span class=\"line\"></span><br><span class=\"line\">mySet.has(<span class=\"string\">\"value1\"</span>); <span class=\"comment\">//returns true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用...(展开操作符)操作符将Set转换为Array</span></span><br><span class=\"line\">alert(uneval([...mySet])); <span class=\"comment\">//与myArray完全一致</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>Map对象就是简单的键/值映射。其中键和值可以是任意值(原始值或对象值).</p>\n<p>在判断两个值是否为同一个键的时候，使用的并不是===运算符，而是使用了一种称之为”same-value”的内部算法，该算法很特殊，对于Map对象来说,+0(按照以往的经验与-0是严格相等的)和-0是两个不同的键。而NaN在作为Map对象的键时和另外一个NaN是一个相同的键(尽管NaN !== NaN)</p>\n<h3 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h3><table>\n<thead>\n<tr>\n<th><strong>Constructor</strong></th>\n<th style=\"text-align:center\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>new Map([iterable])</td>\n<td style=\"text-align:center\">返回一个新的Map对象。如果参数iterable是一个数组或者其他可迭代的对象 – 它的元素是键值对，这样这些每一个键值对都可以添加到新的Map里面去</td>\n</tr>\n<tr>\n<td><strong>方法</strong></td>\n<td style=\"text-align:center\"><strong>描述</strong></td>\n</tr>\n<tr>\n<td>myMap.get(key)</td>\n<td style=\"text-align:center\">返回键key关联的值，如果该键不存在则返回undefined</td>\n</tr>\n<tr>\n<td>myMap.set(key,value)</td>\n<td style=\"text-align:center\">设置键key在myMap中的值为value。返回undefined</td>\n</tr>\n<tr>\n<td>myMap.has(key)</td>\n<td style=\"text-align:center\">返回一个布尔值，表明键key是否存在于myMap中</td>\n</tr>\n<tr>\n<td>myMap.delete(key)</td>\n<td style=\"text-align:center\">删除键key及对应的值.在这之后,myMap.has(key)将会返回false</td>\n</tr>\n<tr>\n<td>myMap.entries()</td>\n<td style=\"text-align:center\">返回一个迭代器，迭代器按照对象的插入顺序返回[key,value];</td>\n</tr>\n<tr>\n<td>myMap.forEach(callbackFn[,thisArg])</td>\n<td style=\"text-align:center\">循环执行函数并把键/值对作为参数;thisArg为可选的，如果有thisArg的话将会作为执行函数的上下文this;</td>\n</tr>\n<tr>\n<td>myMap.keys()</td>\n<td style=\"text-align:center\">返回一个迭代器，迭代器按照Map实例的插入顺序返回每一个key元素;</td>\n</tr>\n<tr>\n<td>myMap.clear()</td>\n<td style=\"text-align:center\">清空myMap中的所有键值对</td>\n</tr>\n<tr>\n<td><strong>属性</strong></td>\n<td style=\"text-align:center\"><strong>描述</strong></td>\n</tr>\n<tr>\n<td>myMap.size</td>\n<td style=\"text-align:center\">返回myMap中键值对的数量。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> keyObj = &#123;&#125;,</span><br><span class=\"line\">    keyFunc = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">    keyString = <span class=\"string\">\"a string\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//添加键</span></span><br><span class=\"line\">myMap.set(keyString, <span class=\"string\">\"和键'a string'关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyObj, <span class=\"string\">\"和键keyObj关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyFunc, <span class=\"string\">\"和键keyFunc关联的值\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.size; <span class=\"comment\">//3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//读取值</span></span><br><span class=\"line\">myMap.get(keyString); <span class=\"comment\">// \"和键'a string'关联的值\"</span></span><br><span class=\"line\">myMap.get(keyObj); <span class=\"comment\">// \"和键keyObj关联的值\"</span></span><br><span class=\"line\">myMap.get(keyFunc); <span class=\"comment\">//\"和键keyFunc关联的值\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"string\">\"a string\"</span>); <span class=\"comment\">//\"和键'a string'关联的值\"</span></span><br><span class=\"line\">                       <span class=\"comment\">//因为keyString == \"a string\"</span></span><br><span class=\"line\">myMap.get(&#123;&#125;);         <span class=\"comment\">//undefined,因为keyObj !== &#123;&#125;</span></span><br><span class=\"line\">myMap.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)<span class=\"comment\">//undefined,因为keyFunc !== function()&#123;&#125;</span></span><br></pre></td></tr></table></figure>\n<p>NaN也可以作为Map对象的键。虽然NaN和任何值甚至和自己都不相等(NaN !== NaN返回true)，但下面的例子表明，两个NaN作为Map的键来说是没有区别的：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">myMap.set(<span class=\"literal\">NaN</span>,<span class=\"string\">\"not a number\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"literal\">NaN</span>); <span class=\"comment\">//\"not a number\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherNaN = <span class=\"built_in\">Number</span>(<span class=\"string\">\"foo\"</span>);</span><br><span class=\"line\">myMap.get(otherNaN); <span class=\"comment\">//\"not a number\"</span></span><br></pre></td></tr></table></figure></p>\n<p>javascript有两个0值，+0和-0.虽然+0 === -0,但是当这两个0作为Map的键时，被认为是两个不同的值。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">myMap.set(<span class=\"number\">0</span>,<span class=\"string\">\"正零\"</span>);</span><br><span class=\"line\">myMap.set(<span class=\"number\">-0</span>,<span class=\"string\">\"负零\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span> === <span class=\"number\">-0</span>; <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"number\">-0</span>); <span class=\"comment\">// \"负零\"</span></span><br><span class=\"line\">myMap.get(<span class=\"number\">0</span>);  <span class=\"comment\">// \"正零\"</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Object和Map的比较\"><a href=\"#Object和Map的比较\" class=\"headerlink\" title=\"Object和Map的比较\"></a>Object和Map的比较</h3><p>Object和Map类似的一点是，它们都允许你按键存取一个值，都可以删除键，还可以检测一个键是否绑定了值。因此，一直以来，我们都把对象当成Map来使用，现在有了Map,下面的区别解释了为什么使用Map更好点。</p>\n<ul>\n<li>一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键，不过，现在可以使用map = Object.create(null)来创建一个没有原型的对象。</li>\n<li>一个对象的键只能是字符串，但一个Map的键可以是任意值。</li>\n<li>你可以很容易的得到一个Map的键值对个数，而只能跟踪一个对象的键值对个数。</li>\n</ul>\n<h2 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h2><h3 id=\"概述-2\"><a href=\"#概述-2\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>一个WeakSet对象是一个无序的集合，可以用它来存储任意的对象值，并且对这些对象值保持弱引用。</p>\n<h3 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h3><blockquote>\n<p>new WeakSet([iterable]);  </p>\n</blockquote>\n<h4 id=\"参数-1\"><a href=\"#参数-1\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>iterable – 如果传入一个可迭代对象作为参数，则该对象的所有迭代值都会被自动添加进生成的WeakSet对象中。</p>\n<h3 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h3><p>WeakSet对象是一些对象值的集合，并且其中的每个对象值都只能出现一次。</p>\n<p>它和Set对象的区别有两点：</p>\n<ul>\n<li>WeakSet对象中只能存放对象值，不能存放原始值，而Set对象都可以。</li>\n<li>WeakSet对象中存储的对象值都是被弱引用的，如果没有其他的变量或属性引用这个对象值，则这个对象值会被当成垃圾回收掉。正因为这样，WeakSet对象是无法被枚举的，没有办法拿到它包含的所有元素。</li>\n</ul>\n<h3 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>WeakSet.length – length属性的值为0</p>\n<p>WeakSet.prototype – WeakSet实例的所有继承属性和继承方法都在该对象上。</p>\n<h3 id=\"WeakSet实例\"><a href=\"#WeakSet实例\" class=\"headerlink\" title=\"WeakSet实例\"></a>WeakSet实例</h3><p>所有WeakSet实例都继承自WeakSet.prototype</p>\n<p>属性 – WeakSet.prototype.constructor(返回构造函数即WeakSet本身)。</p>\n<p>方法</p>\n<ul>\n<li>WeakSet.prototype.add(value) – 在该 WeakSet 对象中添加一个新元素 value.</li>\n<li>WeakSet.prototype.clear() – 清空该 WeakSet 对象中的所有元素.</li>\n<li>WeakSet.prototype.delete(value) – 从该 WeakSet 对象中删除 value 这个元素, 之后 WeakSet.prototype.has(value) 方法便会返回 false.</li>\n<li>WeakSet.prototype.has(value) – 返回一个布尔值,  表示给定的值 value 是否存在于这个 WeakSet 中.</li>\n</ul>\n<h3 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ws = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakSet</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">ws.add(<span class=\"built_in\">window</span>);</span><br><span class=\"line\">ws.add(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">ws.has(<span class=\"built_in\">window</span>); <span class=\"comment\">// true</span></span><br><span class=\"line\">ws.has(foo);    <span class=\"comment\">// false, 对象 foo 并没有被添加进 ws 中</span></span><br><span class=\"line\"></span><br><span class=\"line\">ws.delete(<span class=\"built_in\">window</span>); <span class=\"comment\">// 从集合中删除 window 对象</span></span><br><span class=\"line\">ws.has(<span class=\"built_in\">window</span>);    <span class=\"comment\">// false, window 对象已经被删除了</span></span><br><span class=\"line\"></span><br><span class=\"line\">ws.clear(); <span class=\"comment\">// 清空整个 WeakSet 对象</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h2><h3 id=\"概述-3\"><a href=\"#概述-3\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>WeakMap对象就是简单的键/值映射。但键只能是对象值，不可以是原始值。</p>\n<h3 id=\"API-1\"><a href=\"#API-1\" class=\"headerlink\" title=\"API\"></a>API</h3><table>\n<thead>\n<tr>\n<th><strong>方法</strong></th>\n<th style=\"text-align:center\"><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>myWeakMap.get(key [,defaultValue])</td>\n<td style=\"text-align:center\">返回键key关联的值，如果该键不存在则返回默认值defaultValue</td>\n</tr>\n<tr>\n<td>myWeakMap.set(key,value)</td>\n<td style=\"text-align:center\">设置键key在myWeakMap中的值，返回undefined</td>\n</tr>\n<tr>\n<td>myWeakMap.has(key)</td>\n<td style=\"text-align:center\">返回一个布尔值来表明键key是否在myWeakMap中</td>\n</tr>\n<tr>\n<td>myWeakMap.delete(key)</td>\n<td style=\"text-align:center\">删除键key及对应的值。在这之后，myWeakMap.has(key)将返回false</td>\n</tr>\n<tr>\n<td>myWeakMap.clear()</td>\n<td style=\"text-align:center\">清空myWeakMap中的所有的键值对，返回undefined</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"例子-1\"><a href=\"#例子-1\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> wm1 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">    wm2 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>(),</span><br><span class=\"line\">    wm3 = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>();</span><br><span class=\"line\"><span class=\"keyword\">var</span> o1 = &#123;&#125;,</span><br><span class=\"line\">    o2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</span><br><span class=\"line\">    o3 = <span class=\"built_in\">window</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">wm1.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm1.set(o2, <span class=\"string\">\"azerty\"</span>);</span><br><span class=\"line\">wm2.set(o1, o2); <span class=\"comment\">// value可以是任意值,包括一个对象</span></span><br><span class=\"line\">wm2.set(o3, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">wm2.set(wm1, wm2); <span class=\"comment\">// 键和值可以是任意对象,甚至另外一个WeakMap对象</span></span><br><span class=\"line\">wm1.get(o2); <span class=\"comment\">// \"azerty\"</span></span><br><span class=\"line\">wm2.get(o2); <span class=\"comment\">// undefined,wm2中没有o2这个键</span></span><br><span class=\"line\">wm2.get(o3); <span class=\"comment\">// undefined,值就是undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm1.has(o2); <span class=\"comment\">// true</span></span><br><span class=\"line\">wm2.has(o2); <span class=\"comment\">// false</span></span><br><span class=\"line\">wm2.has(o3); <span class=\"comment\">// true (即使值是undefined)</span></span><br><span class=\"line\"></span><br><span class=\"line\">wm3.set(o1, <span class=\"number\">37</span>);</span><br><span class=\"line\">wm3.get(o1); <span class=\"comment\">// 37</span></span><br><span class=\"line\">wm3.clear();</span><br><span class=\"line\">wm3.get(o1); <span class=\"comment\">// undefined,wm3已被清空</span></span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// true</span></span><br><span class=\"line\">wm1.delete(o1);</span><br><span class=\"line\">wm1.has(o1);   <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么要使用WeakMap\"><a href=\"#为什么要使用WeakMap\" class=\"headerlink\" title=\"为什么要使用WeakMap?\"></a>为什么要使用WeakMap?</h3><p>经验丰富的JavaScript程序员会注意到，WeakMap完全通过两个数组(一个存放键，一个存放值)来实现。但这样的实现会有两个很大的缺点，首先是O(n)的时间复杂度(n是键值对的个数)。另外一个则可能或导致内存泄漏；在这种自己实现的WeakMap中，存放键的数组中的每个索引将会保持对所引用对象的引用，阻止他们被当做垃圾回收。而在原生的WeakMap中，每个键对自己所引用对象的引用是“弱引用”，这意味着，如果没有其他引用和该键引用同一个对象，这个对象将会被当做垃圾回收。</p>\n<p>正由于这样的弱引用, WeakMap 的keys是无法遍历的 (无法列举出所有的keys). 如果允许被遍历的话, 遍历的结果将会受垃圾回收的影响, 从而得到不确定的结果. 因此,如果你想得到所有keys的值,你应该自己管理他们. 另外ECMAScript提案中还介绍了另外两种集合类型,Map和Set,他们没有使用弱引用,所以是可遍历的.</p>\n<h1 id=\"Proxy-和-Reflect\"><a href=\"#Proxy-和-Reflect\" class=\"headerlink\" title=\"Proxy 和 Reflect\"></a>Proxy 和 Reflect</h1><h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Proxy对象用来为基础操作(例如：属性查找、赋值、枚举、方法调用等)定义用户自定义行为。</p>\n<h2 id=\"术语\"><a href=\"#术语\" class=\"headerlink\" title=\"术语\"></a>术语</h2><p>handler – 包含traps的对象。<br>traps – 提供访问属性的途径，与操作系统中的traps定义相似<br>target – 被代理虚拟化的对象，这个对象常常用作代理的存储后端。关于对象不可拓展性和不可修改属性的不变量会被代理拦截。</p>\n<h2 id=\"语法-2\"><a href=\"#语法-2\" class=\"headerlink\" title=\"语法\"></a>语法</h2><blockquote>\n<p>var p = new Proxy(target, handler);  </p>\n</blockquote>\n<h3 id=\"参数-2\"><a href=\"#参数-2\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>target – 目标对象，可以是任意类型的对象，比如数组，函数，甚至是另外一个代理对象。<br>handler – 处理器对象，包含了一组代理方法，分别控制所生成代理对象的各种行为。</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Proxy.revocable() – 创建一个可撤销的代理对象。</p>\n<h2 id=\"handler对象的方法\"><a href=\"#handler对象的方法\" class=\"headerlink\" title=\"handler对象的方法\"></a>handler对象的方法</h2><p>handler是占位符对象，它包含代理的traps</p>\n<h2 id=\"示例-1\"><a href=\"#示例-1\" class=\"headerlink\" title=\"示例\"></a>示例</h2><h3 id=\"基础示例\"><a href=\"#基础示例\" class=\"headerlink\" title=\"基础示例\"></a>基础示例</h3><p>以下简单的例子中，当对象不存在属性名时，缺省返回数37.例子中使用了get处理器(get handler)<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> handler = &#123;</span><br><span class=\"line\">  get: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">target,name</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name <span class=\"keyword\">in</span> target? target[name] : <span class=\"number\">37</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, handler);</span><br><span class=\"line\">p.a = <span class=\"number\">1</span>;</span><br><span class=\"line\">p.b = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(p.a, p.b); <span class=\"comment\">// 1, undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'c'</span> <span class=\"keyword\">in</span> p, p.c); <span class=\"comment\">// false, 37</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"无操作转发代理\"><a href=\"#无操作转发代理\" class=\"headerlink\" title=\"无操作转发代理\"></a>无操作转发代理</h3><p>在以下例子中，我们使用了一个原生JavaScript对象，代理会将所有应用到它的操作转发到这个对象上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> target = &#123;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(target,&#123;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.a = <span class=\"number\">37</span>; <span class=\"comment\">//被转发到代理的操作</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(target.a); <span class=\"comment\">//37 操作已经被正确地转发。</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h3><p>通过代理，你可以轻松地验证向一个对象的传值。以下例子使用了set处理器(set handler)。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> validator = &#123;</span><br><span class=\"line\">  set: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj,prop,value</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pop === <span class=\"string\">'age'</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(!<span class=\"built_in\">Number</span>.isInteger(value))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">'The age is not an integer'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(value &gt; <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RangeError</span>(<span class=\"string\">'The age seems invalid'</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//The default behavior to store the value</span></span><br><span class=\"line\">    obj[prop] = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> person = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(&#123;&#125;, validator);</span><br><span class=\"line\"></span><br><span class=\"line\">person.age = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(person.age); <span class=\"comment\">//100</span></span><br><span class=\"line\">person.age = <span class=\"string\">'young'</span>; <span class=\"comment\">//抛出异常</span></span><br><span class=\"line\">person.age = <span class=\"number\">300</span>; <span class=\"comment\">//抛出异常</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"扩展构造函数\"><a href=\"#扩展构造函数\" class=\"headerlink\" title=\"扩展构造函数\"></a>扩展构造函数</h3><p>方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。以下的例子中使用了constructor处理器(construct handler)和apply处理器(apply handler).<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>\n"},{"title":"Immutable详解及React中实践","date":"2016-05-09T15:52:22.000Z","_content":"> Shared mutable state is the root of all evil\n\n有人说Immutable可以给React应用带来数十倍的提升，也有人说Immutable的引入是近期Javascript中伟大的发明，因为同期React太火，它的光芒被掩盖了。这些至少说明Immutable是很有价值的。\n\nJavascript中的对象一般是可变的(mutable)，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。虽然这样做可以节约内存，但是当应用复杂后，这就造成了非大的隐患，Mutable带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用shallowCopy(浅拷贝)或deepCopy(深拷贝)来避免被修改，但这样做造成了CPU和内存的浪费。\n\n而Immutable可以很好的解决这些问题。\n\n##什么是Immutable Data\nImmutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的Immutable对象。Immutable实现的原理是Persistent Data Structure(持久化数据结构)，也就是使用旧的数据创建新的数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy把所有的节点的都复制一遍带来的性能损耗，Immutable使用了Structure Sharing(结构共享)，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。\n\n目前流行的Immutable库有两个：\n\n### immutable.js\nFacebook工程师Lee Byron花费3年时间打造，与React同期出现，但没有被默认放到React工具库里(React提供了简化的Helper)。它内部实现了一套完整的Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq.有非常全面的map、filter、groupBy、reduce `find`函数式操作方法。同事API也尽量与Object或Array类似。\n其中有3种最重要的数据结构：\n- Map:键值对集合，对应于Object,ES6也有专门的Map对象\n- List: 有序可重复的列表，对应于Array\n- Set: 无序且不可重复的列表\n\n### seamless-immutable\n与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。\n\n下面是例子\n```javascript\n    //原来的写法\n    let foo = {a:{b:1}};\n    let bar = foo;\n    bar.a.b = 2;\n    console.log(foo.a.b); //2\n    console.log(foo === bar); //true\n    //使用immutable.js后\n    import Immutable from 'immutable';\n    foo = Immutable.fromJS({a:{b:1}});\n    bar = foo.setIn(['a','b'],2); // 使用setIn赋值\n    console.log(foo.getIn(['a','b'])); //1\n    console.log(foo === bar); // false\n    //使用seamless-immutable.js后\n    import SImmutable from 'seamless-immutable';\n    foo = SImmutable({a:{b:1}});\n    bar = foo.merge({a:{b:2}}); //使用merge赋值\n    console.log(foo.a.b); //1\n    console.log(foo === bar); //false\n```\n\n## Immutable优点\n1. Immutable降低了Mutable带来的复杂度\n可变(Mutable)数据耦合了Time和Value的概念，造成了数据很难被回溯。\n比如下面的一段代码：\n\n```javascript\n    function touchAndLog(touchFn){\n        let data = {key:'value'};\n        touchFn(data);\n        console.log(data.key);\n    }\n```\n\n在不查看touchFn的代码的情况下，因为不确定它对data做了什么，你是不可能知道会打印什么的。但是如果data是Immutable，你可以知道打印的是value。\n\n2. 节省内存\nImmutable.js使用了Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。\n\n```javascript\n    import {Map} from 'immutable';\n    let a = Map({\n        select: 'users',\n        filter: Map({name:'Tom'})\n    })\n    let b = a.set('select','people');\n    a===b; //false\n    a.get('filter') === b.get('filter') //true\n```\n\n上面的a和b共享了没有变化的filter节点。\n\n3. Undo/Redo, Copy/Paste, 甚至时间旅行这些功能做起来小菜一碟\n因为每次数据都是不一样的，只要把这些数据放到一个数组里存储起来，想回退到哪里就拿出对应的数据即可，很容易开发出撤销重做这种功能。\n\n4. 并发安全\n传统的并发非常难做，因为要处理各种数据不一致问题，因此有人就发明了各种锁来解决。但是使用了Immutable之后，数据天生是不可变的，并发锁就不需要了。\n\n然而现在并没有什么卵用，因为Javascript是单线程运行的，但未来可能会加入。\n\n5. 拥抱函数式编程\nImmutable本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。\n\n像ClojureScript,Elm等函数式编程语言中的数据类型天生都是Immutable的，这也是为什么ClojureScript基于React的框架，OM性能比React还要好的原因。\n\n## Immutable的缺点\n容易与原生的对象混淆\n这点使我们使用Immutable.js过程中遇到的最大的问题。写代码要做思维上的转变。\n\n虽然Immutable.js尽量尝试把API设计的原生对象类似，有的时候还是很难区别到底是Immutable对象还是原生对象，容易混淆操作。\n\nImmutable中的Map和List虽然对应原生Object和Array，但操作非常不同，比如你要用map.get('key')而不是map.key，array.get(0)而不是array[0]。另外Immutable每次修改都会返回新对象，很容易忘记赋值。\n\n当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。\n\n下面给出了一些办法来避免类似问题发生：\n1. 使用Flow或TypeScript这类有静态类型检查的工具。\n2. 约定变量命名规则：如所有Immutable类型对象以$$开头。\n3. 使用Immutable.fromJS而不是Immutable.Map或Immutable.List来创建对象，这样可以避免Immutable和原生对象间的混用。\n\n## 更多认识\n两个immutable对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回false\n\n```javascript\n    let map1 = Immutable.Map({a:1,b:1,c:1});\n    let map2 = Immutable.Map({a:1,b:1,c:1});\n    map1 === map2; //false\n```\n\n为了直接比较对象的值，immutable.js提供了Immutable.js来做值比较：\n\n```javascript\n    Immutable.is(map1,map2); //true\n```\n\nImmutable.is比较的是两个对象的hashCode或valueOf(对于javascript对象)。由于immutable内部使用了Tree数据结构来存储，只要两个对象的hashCode相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。\n\n后面会使用Immutable.js来减少React重复渲染，提高性能。\n\n与Object.freeze、const比较\nES6中新加入的Object.freeze和const都可以达到防止对象被篡改的功能，但是它们是shallowCopy的。对象层级一深就要特殊处理了。\n\nCursor的概念\n这个Cursor和数据库中的游标是完全不同的而概念。\n\n由于Immutable数据一般嵌套非常深，为了便于访问深层数据，Cursor提供了直接访问这个深层数据的引用。\n\n```javascript\n    import Immutable from 'immutable';\n    import Cursor from 'immutable/contrib/cursor';\n    let data = Immutable.fromJS({a:{b:{c:1}}});\n    //让cursor指向{c:1}\n    let cursor = Cursor.from(data,['a','b'],newData => {\n        //当cursor或其子cursor执行update时调用\n        console.log(newData);\n    });\n    cursor.get('c'); //1\n    cursor = cursor.update('c',x => x+1);\n    cursor.get('c'); //2\n```\n\n## 实践\n### 与React搭配使用，Pure Render\n\n熟悉React的都知道，React做性能优化时有一个避免重复渲染的大招，就是使用shouldComponentUpdate(),但它默认返回true，即始终会执行render()方法，然后做Virtual DOM比较，并得到是否需要做真实DOM更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。\n\n当然我们也可以在shouldComponentUpdate()中使用deepCopy和deepCompare来避免无必要的render(),但deepCopy和deepCompare一般都是非常耗性能。\n\nImmutable则提供了简洁高效的而判断数据是否变化的方法，只需 === 和is比较就能知道是否需要执行render(),而这个操作几乎0成本，所以可以极大提高性能。修改后的shouldComponentUpdate是这样的：\n\n```javascript\n    import {is} from 'immutable';\n    shouldComponentUpdate: (nextProps,nextState) => {\n        return !(this.props === nextProps || is(this.props,nextProps)) || !(this.state === nextState || is(this.state,nextState));\n    }\n```\n\n当然你也可以借助React.addons.PureRenderMixin 或支持class语法的pure-render-decorator来实现。\n\nsetState的一个技巧\n\nReact建议把this.state当作Immutable的，因此修改前需要做一个deepCopy,显得麻烦：\n\n```javascript\n    import '_' from 'lodash';\n    const Component = React.createClass({\n        getInitialState(){\n            return{\n                data:{times:0}\n            }\n        },\n        handleAdd(){\n            let data = _.cloneDeep(this.state.data);\n            data.times = data.times + 1;\n            this.setState({data:data});\n            //如果上面不做cloneDeep，下面打印的结果会是已经加1后的值。\n            console.log(this.state.data.times);\n        }\n    })\n```\n\n使用Immutable后：\n\n```javascript\n    getInitialState(){\n        return {\n            data: Map({times:0})\n        }\n    },\n    handleAdd(){\n        this.setState({data:this.state.data.update('times',v => v+1)});\n        //这时的times并不会改变\n        console.log(this.state.data.get('times'));\n    }\n```\n\n上面的handleAdd可以简写成：\n\n```javascript\n    handleAdd(){\n        this.setState(({data}) => ({\n            data: data.update('times', v => v+1)})\n        });\n    }\n```\n\n## 与Flux搭配使用\n由于Flux并没有限定Store中的数据类型，使用Immutable非常简单。\n下面是实现一个类似带有添加和撤销功能Store:\n\n```javascript\n    import {Map, OrderedMap} from 'immutable';\n    let todos = OrderedMap();\n    let history = []; //普通数组，存放每次操作后产生的数据\n    let TodoStore = createStore({\n        getAll(){\n            return todos;\n        }\n    });\n    Dispatcher.register(action => {\n        if(action.actionType === 'create'){\n            let id = createGUID();\n            history.push(todos); //记录当前操作前的数据，便于撤销\n            todos = todos.set(id,Map({\n                id: id,\n                complete: false,\n                text: action.text.trim()\n            }));\n            TodoStore.emitChange();\n        }else if(action.actionType === 'undo'){\n            if(history.length > 0){\n                todos = history.pop();\n            }\n            TodoStore.emitChange();\n        }\n    })\n```\n\n## 与Redux搭配使用\nRedux是目前最流行的Flux衍生库。它简化了Flux中多个Store的概念，只有一个Store，数据操作通过Reducer中实现；同时它提供了更简洁和清晰的单项数据流(View -> Action -> Middleware -> Reducer),也更易于开发同构应用。\n\n由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。\n\n幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。\n\n上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。\n\n## 总结\nImmutable可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把Immutable对象直接暴露在对外接口中。\n","source":"_posts/Immutable详解及React中实践.md","raw":"---\ntitle: Immutable详解及React中实践\ndate: 2016-05-09 23:52:22\ntags:\n- immutable\n- react\ncategories: 教程\n---\n> Shared mutable state is the root of all evil\n\n有人说Immutable可以给React应用带来数十倍的提升，也有人说Immutable的引入是近期Javascript中伟大的发明，因为同期React太火，它的光芒被掩盖了。这些至少说明Immutable是很有价值的。\n\nJavascript中的对象一般是可变的(mutable)，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。虽然这样做可以节约内存，但是当应用复杂后，这就造成了非大的隐患，Mutable带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用shallowCopy(浅拷贝)或deepCopy(深拷贝)来避免被修改，但这样做造成了CPU和内存的浪费。\n\n而Immutable可以很好的解决这些问题。\n\n##什么是Immutable Data\nImmutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的Immutable对象。Immutable实现的原理是Persistent Data Structure(持久化数据结构)，也就是使用旧的数据创建新的数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy把所有的节点的都复制一遍带来的性能损耗，Immutable使用了Structure Sharing(结构共享)，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。\n\n目前流行的Immutable库有两个：\n\n### immutable.js\nFacebook工程师Lee Byron花费3年时间打造，与React同期出现，但没有被默认放到React工具库里(React提供了简化的Helper)。它内部实现了一套完整的Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq.有非常全面的map、filter、groupBy、reduce `find`函数式操作方法。同事API也尽量与Object或Array类似。\n其中有3种最重要的数据结构：\n- Map:键值对集合，对应于Object,ES6也有专门的Map对象\n- List: 有序可重复的列表，对应于Array\n- Set: 无序且不可重复的列表\n\n### seamless-immutable\n与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。\n\n下面是例子\n```javascript\n    //原来的写法\n    let foo = {a:{b:1}};\n    let bar = foo;\n    bar.a.b = 2;\n    console.log(foo.a.b); //2\n    console.log(foo === bar); //true\n    //使用immutable.js后\n    import Immutable from 'immutable';\n    foo = Immutable.fromJS({a:{b:1}});\n    bar = foo.setIn(['a','b'],2); // 使用setIn赋值\n    console.log(foo.getIn(['a','b'])); //1\n    console.log(foo === bar); // false\n    //使用seamless-immutable.js后\n    import SImmutable from 'seamless-immutable';\n    foo = SImmutable({a:{b:1}});\n    bar = foo.merge({a:{b:2}}); //使用merge赋值\n    console.log(foo.a.b); //1\n    console.log(foo === bar); //false\n```\n\n## Immutable优点\n1. Immutable降低了Mutable带来的复杂度\n可变(Mutable)数据耦合了Time和Value的概念，造成了数据很难被回溯。\n比如下面的一段代码：\n\n```javascript\n    function touchAndLog(touchFn){\n        let data = {key:'value'};\n        touchFn(data);\n        console.log(data.key);\n    }\n```\n\n在不查看touchFn的代码的情况下，因为不确定它对data做了什么，你是不可能知道会打印什么的。但是如果data是Immutable，你可以知道打印的是value。\n\n2. 节省内存\nImmutable.js使用了Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。\n\n```javascript\n    import {Map} from 'immutable';\n    let a = Map({\n        select: 'users',\n        filter: Map({name:'Tom'})\n    })\n    let b = a.set('select','people');\n    a===b; //false\n    a.get('filter') === b.get('filter') //true\n```\n\n上面的a和b共享了没有变化的filter节点。\n\n3. Undo/Redo, Copy/Paste, 甚至时间旅行这些功能做起来小菜一碟\n因为每次数据都是不一样的，只要把这些数据放到一个数组里存储起来，想回退到哪里就拿出对应的数据即可，很容易开发出撤销重做这种功能。\n\n4. 并发安全\n传统的并发非常难做，因为要处理各种数据不一致问题，因此有人就发明了各种锁来解决。但是使用了Immutable之后，数据天生是不可变的，并发锁就不需要了。\n\n然而现在并没有什么卵用，因为Javascript是单线程运行的，但未来可能会加入。\n\n5. 拥抱函数式编程\nImmutable本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。\n\n像ClojureScript,Elm等函数式编程语言中的数据类型天生都是Immutable的，这也是为什么ClojureScript基于React的框架，OM性能比React还要好的原因。\n\n## Immutable的缺点\n容易与原生的对象混淆\n这点使我们使用Immutable.js过程中遇到的最大的问题。写代码要做思维上的转变。\n\n虽然Immutable.js尽量尝试把API设计的原生对象类似，有的时候还是很难区别到底是Immutable对象还是原生对象，容易混淆操作。\n\nImmutable中的Map和List虽然对应原生Object和Array，但操作非常不同，比如你要用map.get('key')而不是map.key，array.get(0)而不是array[0]。另外Immutable每次修改都会返回新对象，很容易忘记赋值。\n\n当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。\n\n下面给出了一些办法来避免类似问题发生：\n1. 使用Flow或TypeScript这类有静态类型检查的工具。\n2. 约定变量命名规则：如所有Immutable类型对象以$$开头。\n3. 使用Immutable.fromJS而不是Immutable.Map或Immutable.List来创建对象，这样可以避免Immutable和原生对象间的混用。\n\n## 更多认识\n两个immutable对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回false\n\n```javascript\n    let map1 = Immutable.Map({a:1,b:1,c:1});\n    let map2 = Immutable.Map({a:1,b:1,c:1});\n    map1 === map2; //false\n```\n\n为了直接比较对象的值，immutable.js提供了Immutable.js来做值比较：\n\n```javascript\n    Immutable.is(map1,map2); //true\n```\n\nImmutable.is比较的是两个对象的hashCode或valueOf(对于javascript对象)。由于immutable内部使用了Tree数据结构来存储，只要两个对象的hashCode相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。\n\n后面会使用Immutable.js来减少React重复渲染，提高性能。\n\n与Object.freeze、const比较\nES6中新加入的Object.freeze和const都可以达到防止对象被篡改的功能，但是它们是shallowCopy的。对象层级一深就要特殊处理了。\n\nCursor的概念\n这个Cursor和数据库中的游标是完全不同的而概念。\n\n由于Immutable数据一般嵌套非常深，为了便于访问深层数据，Cursor提供了直接访问这个深层数据的引用。\n\n```javascript\n    import Immutable from 'immutable';\n    import Cursor from 'immutable/contrib/cursor';\n    let data = Immutable.fromJS({a:{b:{c:1}}});\n    //让cursor指向{c:1}\n    let cursor = Cursor.from(data,['a','b'],newData => {\n        //当cursor或其子cursor执行update时调用\n        console.log(newData);\n    });\n    cursor.get('c'); //1\n    cursor = cursor.update('c',x => x+1);\n    cursor.get('c'); //2\n```\n\n## 实践\n### 与React搭配使用，Pure Render\n\n熟悉React的都知道，React做性能优化时有一个避免重复渲染的大招，就是使用shouldComponentUpdate(),但它默认返回true，即始终会执行render()方法，然后做Virtual DOM比较，并得到是否需要做真实DOM更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。\n\n当然我们也可以在shouldComponentUpdate()中使用deepCopy和deepCompare来避免无必要的render(),但deepCopy和deepCompare一般都是非常耗性能。\n\nImmutable则提供了简洁高效的而判断数据是否变化的方法，只需 === 和is比较就能知道是否需要执行render(),而这个操作几乎0成本，所以可以极大提高性能。修改后的shouldComponentUpdate是这样的：\n\n```javascript\n    import {is} from 'immutable';\n    shouldComponentUpdate: (nextProps,nextState) => {\n        return !(this.props === nextProps || is(this.props,nextProps)) || !(this.state === nextState || is(this.state,nextState));\n    }\n```\n\n当然你也可以借助React.addons.PureRenderMixin 或支持class语法的pure-render-decorator来实现。\n\nsetState的一个技巧\n\nReact建议把this.state当作Immutable的，因此修改前需要做一个deepCopy,显得麻烦：\n\n```javascript\n    import '_' from 'lodash';\n    const Component = React.createClass({\n        getInitialState(){\n            return{\n                data:{times:0}\n            }\n        },\n        handleAdd(){\n            let data = _.cloneDeep(this.state.data);\n            data.times = data.times + 1;\n            this.setState({data:data});\n            //如果上面不做cloneDeep，下面打印的结果会是已经加1后的值。\n            console.log(this.state.data.times);\n        }\n    })\n```\n\n使用Immutable后：\n\n```javascript\n    getInitialState(){\n        return {\n            data: Map({times:0})\n        }\n    },\n    handleAdd(){\n        this.setState({data:this.state.data.update('times',v => v+1)});\n        //这时的times并不会改变\n        console.log(this.state.data.get('times'));\n    }\n```\n\n上面的handleAdd可以简写成：\n\n```javascript\n    handleAdd(){\n        this.setState(({data}) => ({\n            data: data.update('times', v => v+1)})\n        });\n    }\n```\n\n## 与Flux搭配使用\n由于Flux并没有限定Store中的数据类型，使用Immutable非常简单。\n下面是实现一个类似带有添加和撤销功能Store:\n\n```javascript\n    import {Map, OrderedMap} from 'immutable';\n    let todos = OrderedMap();\n    let history = []; //普通数组，存放每次操作后产生的数据\n    let TodoStore = createStore({\n        getAll(){\n            return todos;\n        }\n    });\n    Dispatcher.register(action => {\n        if(action.actionType === 'create'){\n            let id = createGUID();\n            history.push(todos); //记录当前操作前的数据，便于撤销\n            todos = todos.set(id,Map({\n                id: id,\n                complete: false,\n                text: action.text.trim()\n            }));\n            TodoStore.emitChange();\n        }else if(action.actionType === 'undo'){\n            if(history.length > 0){\n                todos = history.pop();\n            }\n            TodoStore.emitChange();\n        }\n    })\n```\n\n## 与Redux搭配使用\nRedux是目前最流行的Flux衍生库。它简化了Flux中多个Store的概念，只有一个Store，数据操作通过Reducer中实现；同时它提供了更简洁和清晰的单项数据流(View -> Action -> Middleware -> Reducer),也更易于开发同构应用。\n\n由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。\n\n幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。\n\n上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。\n\n## 总结\nImmutable可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把Immutable对象直接暴露在对外接口中。\n","slug":"Immutable详解及React中实践","published":1,"updated":"2016-08-05T03:13:55.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0en60017b0dlyp6r8zn8","content":"<blockquote>\n<p>Shared mutable state is the root of all evil</p>\n</blockquote>\n<p>有人说Immutable可以给React应用带来数十倍的提升，也有人说Immutable的引入是近期Javascript中伟大的发明，因为同期React太火，它的光芒被掩盖了。这些至少说明Immutable是很有价值的。</p>\n<p>Javascript中的对象一般是可变的(mutable)，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。虽然这样做可以节约内存，但是当应用复杂后，这就造成了非大的隐患，Mutable带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用shallowCopy(浅拷贝)或deepCopy(深拷贝)来避免被修改，但这样做造成了CPU和内存的浪费。</p>\n<p>而Immutable可以很好的解决这些问题。</p>\n<p>##什么是Immutable Data<br>Immutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的Immutable对象。Immutable实现的原理是Persistent Data Structure(持久化数据结构)，也就是使用旧的数据创建新的数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy把所有的节点的都复制一遍带来的性能损耗，Immutable使用了Structure Sharing(结构共享)，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p>\n<p>目前流行的Immutable库有两个：</p>\n<h3 id=\"immutable-js\"><a href=\"#immutable-js\" class=\"headerlink\" title=\"immutable.js\"></a>immutable.js</h3><p>Facebook工程师Lee Byron花费3年时间打造，与React同期出现，但没有被默认放到React工具库里(React提供了简化的Helper)。它内部实现了一套完整的Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq.有非常全面的map、filter、groupBy、reduce <code>find</code>函数式操作方法。同事API也尽量与Object或Array类似。<br>其中有3种最重要的数据结构：</p>\n<ul>\n<li>Map:键值对集合，对应于Object,ES6也有专门的Map对象</li>\n<li>List: 有序可重复的列表，对应于Array</li>\n<li>Set: 无序且不可重复的列表</li>\n</ul>\n<h3 id=\"seamless-immutable\"><a href=\"#seamless-immutable\" class=\"headerlink\" title=\"seamless-immutable\"></a>seamless-immutable</h3><p>与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。</p>\n<p>下面是例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原来的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = foo;</span><br><span class=\"line\">bar.a.b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.a.b); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo === bar); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//使用immutable.js后</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Immutable <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\">foo = Immutable.fromJS(&#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;);</span><br><span class=\"line\">bar = foo.setIn([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>],<span class=\"number\">2</span>); <span class=\"comment\">// 使用setIn赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.getIn([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>])); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo === bar); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">//使用seamless-immutable.js后</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> SImmutable <span class=\"keyword\">from</span> <span class=\"string\">'seamless-immutable'</span>;</span><br><span class=\"line\">foo = SImmutable(&#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;);</span><br><span class=\"line\">bar = foo.merge(&#123;a:&#123;b:<span class=\"number\">2</span>&#125;&#125;); <span class=\"comment\">//使用merge赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.a.b); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo === bar); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Immutable优点\"><a href=\"#Immutable优点\" class=\"headerlink\" title=\"Immutable优点\"></a>Immutable优点</h2><ol>\n<li>Immutable降低了Mutable带来的复杂度<br>可变(Mutable)数据耦合了Time和Value的概念，造成了数据很难被回溯。<br>比如下面的一段代码：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">touchAndLog</span>(<span class=\"params\">touchFn</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;key:<span class=\"string\">'value'</span>&#125;;</span><br><span class=\"line\">    touchFn(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在不查看touchFn的代码的情况下，因为不确定它对data做了什么，你是不可能知道会打印什么的。但是如果data是Immutable，你可以知道打印的是value。</p>\n<ol>\n<li>节省内存<br>Immutable.js使用了Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"built_in\">Map</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">Map</span>(&#123;</span><br><span class=\"line\">    select: <span class=\"string\">'users'</span>,</span><br><span class=\"line\">    filter: <span class=\"built_in\">Map</span>(&#123;name:<span class=\"string\">'Tom'</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.set(<span class=\"string\">'select'</span>,<span class=\"string\">'people'</span>);</span><br><span class=\"line\">a===b; <span class=\"comment\">//false</span></span><br><span class=\"line\">a.get(<span class=\"string\">'filter'</span>) === b.get(<span class=\"string\">'filter'</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>上面的a和b共享了没有变化的filter节点。</p>\n<ol>\n<li><p>Undo/Redo, Copy/Paste, 甚至时间旅行这些功能做起来小菜一碟<br>因为每次数据都是不一样的，只要把这些数据放到一个数组里存储起来，想回退到哪里就拿出对应的数据即可，很容易开发出撤销重做这种功能。</p>\n</li>\n<li><p>并发安全<br>传统的并发非常难做，因为要处理各种数据不一致问题，因此有人就发明了各种锁来解决。但是使用了Immutable之后，数据天生是不可变的，并发锁就不需要了。</p>\n</li>\n</ol>\n<p>然而现在并没有什么卵用，因为Javascript是单线程运行的，但未来可能会加入。</p>\n<ol>\n<li>拥抱函数式编程<br>Immutable本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</li>\n</ol>\n<p>像ClojureScript,Elm等函数式编程语言中的数据类型天生都是Immutable的，这也是为什么ClojureScript基于React的框架，OM性能比React还要好的原因。</p>\n<h2 id=\"Immutable的缺点\"><a href=\"#Immutable的缺点\" class=\"headerlink\" title=\"Immutable的缺点\"></a>Immutable的缺点</h2><p>容易与原生的对象混淆<br>这点使我们使用Immutable.js过程中遇到的最大的问题。写代码要做思维上的转变。</p>\n<p>虽然Immutable.js尽量尝试把API设计的原生对象类似，有的时候还是很难区别到底是Immutable对象还是原生对象，容易混淆操作。</p>\n<p>Immutable中的Map和List虽然对应原生Object和Array，但操作非常不同，比如你要用map.get(‘key’)而不是map.key，array.get(0)而不是array[0]。另外Immutable每次修改都会返回新对象，很容易忘记赋值。</p>\n<p>当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。</p>\n<p>下面给出了一些办法来避免类似问题发生：</p>\n<ol>\n<li>使用Flow或TypeScript这类有静态类型检查的工具。</li>\n<li>约定变量命名规则：如所有Immutable类型对象以$$开头。</li>\n<li>使用Immutable.fromJS而不是Immutable.Map或Immutable.List来创建对象，这样可以避免Immutable和原生对象间的混用。</li>\n</ol>\n<h2 id=\"更多认识\"><a href=\"#更多认识\" class=\"headerlink\" title=\"更多认识\"></a>更多认识</h2><p>两个immutable对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map1 = Immutable.Map(&#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">1</span>,c:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = Immutable.Map(&#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">1</span>,c:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">map1 === map2; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>为了直接比较对象的值，immutable.js提供了Immutable.js来做值比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Immutable.is(map1,map2); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>Immutable.is比较的是两个对象的hashCode或valueOf(对于javascript对象)。由于immutable内部使用了Tree数据结构来存储，只要两个对象的hashCode相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p>\n<p>后面会使用Immutable.js来减少React重复渲染，提高性能。</p>\n<p>与Object.freeze、const比较<br>ES6中新加入的Object.freeze和const都可以达到防止对象被篡改的功能，但是它们是shallowCopy的。对象层级一深就要特殊处理了。</p>\n<p>Cursor的概念<br>这个Cursor和数据库中的游标是完全不同的而概念。</p>\n<p>由于Immutable数据一般嵌套非常深，为了便于访问深层数据，Cursor提供了直接访问这个深层数据的引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Immutable <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Cursor <span class=\"keyword\">from</span> <span class=\"string\">'immutable/contrib/cursor'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = Immutable.fromJS(&#123;a:&#123;b:&#123;c:<span class=\"number\">1</span>&#125;&#125;&#125;);</span><br><span class=\"line\"><span class=\"comment\">//让cursor指向&#123;c:1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cursor = Cursor.from(data,[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>],newData =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当cursor或其子cursor执行update时调用</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(newData);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cursor.get(<span class=\"string\">'c'</span>); <span class=\"comment\">//1</span></span><br><span class=\"line\">cursor = cursor.update(<span class=\"string\">'c'</span>,x =&gt; x+<span class=\"number\">1</span>);</span><br><span class=\"line\">cursor.get(<span class=\"string\">'c'</span>); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"与React搭配使用，Pure-Render\"><a href=\"#与React搭配使用，Pure-Render\" class=\"headerlink\" title=\"与React搭配使用，Pure Render\"></a>与React搭配使用，Pure Render</h3><p>熟悉React的都知道，React做性能优化时有一个避免重复渲染的大招，就是使用shouldComponentUpdate(),但它默认返回true，即始终会执行render()方法，然后做Virtual DOM比较，并得到是否需要做真实DOM更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。</p>\n<p>当然我们也可以在shouldComponentUpdate()中使用deepCopy和deepCompare来避免无必要的render(),但deepCopy和deepCompare一般都是非常耗性能。</p>\n<p>Immutable则提供了简洁高效的而判断数据是否变化的方法，只需 === 和is比较就能知道是否需要执行render(),而这个操作几乎0成本，所以可以极大提高性能。修改后的shouldComponentUpdate是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;is&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\">shouldComponentUpdate: (nextProps,nextState) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(<span class=\"keyword\">this</span>.props === nextProps || is(<span class=\"keyword\">this</span>.props,nextProps)) || !(<span class=\"keyword\">this</span>.state === nextState || is(<span class=\"keyword\">this</span>.state,nextState));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以借助React.addons.PureRenderMixin 或支持class语法的pure-render-decorator来实现。</p>\n<p>setState的一个技巧</p>\n<p>React建议把this.state当作Immutable的，因此修改前需要做一个deepCopy,显得麻烦：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'_'</span> <span class=\"keyword\">from</span> <span class=\"string\">'lodash'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">            data:&#123;times:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleAdd()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = _.cloneDeep(<span class=\"keyword\">this</span>.state.data);</span><br><span class=\"line\">        data.times = data.times + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;data:data&#125;);</span><br><span class=\"line\">        <span class=\"comment\">//如果上面不做cloneDeep，下面打印的结果会是已经加1后的值。</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.data.times);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>使用Immutable后：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getInitialState()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">Map</span>(&#123;times:<span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handleAdd()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;data:<span class=\"keyword\">this</span>.state.data.update(<span class=\"string\">'times'</span>,v =&gt; v+<span class=\"number\">1</span>)&#125;);</span><br><span class=\"line\">    <span class=\"comment\">//这时的times并不会改变</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.data.get(<span class=\"string\">'times'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的handleAdd可以简写成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleAdd()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState((&#123;data&#125;) =&gt; (&#123;</span><br><span class=\"line\">        data: data.update(<span class=\"string\">'times'</span>, v =&gt; v+<span class=\"number\">1</span>)&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"与Flux搭配使用\"><a href=\"#与Flux搭配使用\" class=\"headerlink\" title=\"与Flux搭配使用\"></a>与Flux搭配使用</h2><p>由于Flux并没有限定Store中的数据类型，使用Immutable非常简单。<br>下面是实现一个类似带有添加和撤销功能Store:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"built_in\">Map</span>, OrderedMap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> todos = OrderedMap();</span><br><span class=\"line\"><span class=\"keyword\">let</span> history = []; <span class=\"comment\">//普通数组，存放每次操作后产生的数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> TodoStore = createStore(&#123;</span><br><span class=\"line\">    getAll()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> todos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Dispatcher.register(action =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(action.actionType === <span class=\"string\">'create'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> id = createGUID();</span><br><span class=\"line\">        history.push(todos); <span class=\"comment\">//记录当前操作前的数据，便于撤销</span></span><br><span class=\"line\">        todos = todos.set(id,<span class=\"built_in\">Map</span>(&#123;</span><br><span class=\"line\">            id: id,</span><br><span class=\"line\">            complete: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            text: action.text.trim()</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        TodoStore.emitChange();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(action.actionType === <span class=\"string\">'undo'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(history.length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            todos = history.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TodoStore.emitChange();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"与Redux搭配使用\"><a href=\"#与Redux搭配使用\" class=\"headerlink\" title=\"与Redux搭配使用\"></a>与Redux搭配使用</h2><p>Redux是目前最流行的Flux衍生库。它简化了Flux中多个Store的概念，只有一个Store，数据操作通过Reducer中实现；同时它提供了更简洁和清晰的单项数据流(View -&gt; Action -&gt; Middleware -&gt; Reducer),也更易于开发同构应用。</p>\n<p>由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。</p>\n<p>幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。</p>\n<p>上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Immutable可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把Immutable对象直接暴露在对外接口中。</p>\n","excerpt":"","more":"<blockquote>\n<p>Shared mutable state is the root of all evil</p>\n</blockquote>\n<p>有人说Immutable可以给React应用带来数十倍的提升，也有人说Immutable的引入是近期Javascript中伟大的发明，因为同期React太火，它的光芒被掩盖了。这些至少说明Immutable是很有价值的。</p>\n<p>Javascript中的对象一般是可变的(mutable)，因为使用了引用赋值，新的对象简单的引用了原始对象，改变新的对象将影响到原始对象。虽然这样做可以节约内存，但是当应用复杂后，这就造成了非大的隐患，Mutable带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用shallowCopy(浅拷贝)或deepCopy(深拷贝)来避免被修改，但这样做造成了CPU和内存的浪费。</p>\n<p>而Immutable可以很好的解决这些问题。</p>\n<p>##什么是Immutable Data<br>Immutable Data就是一旦创建，就不能再被更改的数据。对Immutable对象的任何修改或添加删除操作都会返回一个新的Immutable对象。Immutable实现的原理是Persistent Data Structure(持久化数据结构)，也就是使用旧的数据创建新的数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy把所有的节点的都复制一遍带来的性能损耗，Immutable使用了Structure Sharing(结构共享)，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p>\n<p>目前流行的Immutable库有两个：</p>\n<h3 id=\"immutable-js\"><a href=\"#immutable-js\" class=\"headerlink\" title=\"immutable.js\"></a>immutable.js</h3><p>Facebook工程师Lee Byron花费3年时间打造，与React同期出现，但没有被默认放到React工具库里(React提供了简化的Helper)。它内部实现了一套完整的Persistent Data Structure，还有很多易用的数据类型。像Collection、List、Map、Set、Record、Seq.有非常全面的map、filter、groupBy、reduce <code>find</code>函数式操作方法。同事API也尽量与Object或Array类似。<br>其中有3种最重要的数据结构：</p>\n<ul>\n<li>Map:键值对集合，对应于Object,ES6也有专门的Map对象</li>\n<li>List: 有序可重复的列表，对应于Array</li>\n<li>Set: 无序且不可重复的列表</li>\n</ul>\n<h3 id=\"seamless-immutable\"><a href=\"#seamless-immutable\" class=\"headerlink\" title=\"seamless-immutable\"></a>seamless-immutable</h3><p>与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。</p>\n<p>下面是例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//原来的写法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = &#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = foo;</span><br><span class=\"line\">bar.a.b = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.a.b); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo === bar); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//使用immutable.js后</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Immutable <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\">foo = Immutable.fromJS(&#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;);</span><br><span class=\"line\">bar = foo.setIn([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>],<span class=\"number\">2</span>); <span class=\"comment\">// 使用setIn赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.getIn([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>])); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo === bar); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"comment\">//使用seamless-immutable.js后</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> SImmutable <span class=\"keyword\">from</span> <span class=\"string\">'seamless-immutable'</span>;</span><br><span class=\"line\">foo = SImmutable(&#123;a:&#123;b:<span class=\"number\">1</span>&#125;&#125;);</span><br><span class=\"line\">bar = foo.merge(&#123;a:&#123;b:<span class=\"number\">2</span>&#125;&#125;); <span class=\"comment\">//使用merge赋值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.a.b); <span class=\"comment\">//1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo === bar); <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Immutable优点\"><a href=\"#Immutable优点\" class=\"headerlink\" title=\"Immutable优点\"></a>Immutable优点</h2><ol>\n<li>Immutable降低了Mutable带来的复杂度<br>可变(Mutable)数据耦合了Time和Value的概念，造成了数据很难被回溯。<br>比如下面的一段代码：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">touchAndLog</span>(<span class=\"params\">touchFn</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> data = &#123;key:<span class=\"string\">'value'</span>&#125;;</span><br><span class=\"line\">    touchFn(data);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data.key);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在不查看touchFn的代码的情况下，因为不确定它对data做了什么，你是不可能知道会打印什么的。但是如果data是Immutable，你可以知道打印的是value。</p>\n<ol>\n<li>节省内存<br>Immutable.js使用了Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"built_in\">Map</span>&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"built_in\">Map</span>(&#123;</span><br><span class=\"line\">    select: <span class=\"string\">'users'</span>,</span><br><span class=\"line\">    filter: <span class=\"built_in\">Map</span>(&#123;name:<span class=\"string\">'Tom'</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = a.set(<span class=\"string\">'select'</span>,<span class=\"string\">'people'</span>);</span><br><span class=\"line\">a===b; <span class=\"comment\">//false</span></span><br><span class=\"line\">a.get(<span class=\"string\">'filter'</span>) === b.get(<span class=\"string\">'filter'</span>) <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>上面的a和b共享了没有变化的filter节点。</p>\n<ol>\n<li><p>Undo/Redo, Copy/Paste, 甚至时间旅行这些功能做起来小菜一碟<br>因为每次数据都是不一样的，只要把这些数据放到一个数组里存储起来，想回退到哪里就拿出对应的数据即可，很容易开发出撤销重做这种功能。</p>\n</li>\n<li><p>并发安全<br>传统的并发非常难做，因为要处理各种数据不一致问题，因此有人就发明了各种锁来解决。但是使用了Immutable之后，数据天生是不可变的，并发锁就不需要了。</p>\n</li>\n</ol>\n<p>然而现在并没有什么卵用，因为Javascript是单线程运行的，但未来可能会加入。</p>\n<ol>\n<li>拥抱函数式编程<br>Immutable本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</li>\n</ol>\n<p>像ClojureScript,Elm等函数式编程语言中的数据类型天生都是Immutable的，这也是为什么ClojureScript基于React的框架，OM性能比React还要好的原因。</p>\n<h2 id=\"Immutable的缺点\"><a href=\"#Immutable的缺点\" class=\"headerlink\" title=\"Immutable的缺点\"></a>Immutable的缺点</h2><p>容易与原生的对象混淆<br>这点使我们使用Immutable.js过程中遇到的最大的问题。写代码要做思维上的转变。</p>\n<p>虽然Immutable.js尽量尝试把API设计的原生对象类似，有的时候还是很难区别到底是Immutable对象还是原生对象，容易混淆操作。</p>\n<p>Immutable中的Map和List虽然对应原生Object和Array，但操作非常不同，比如你要用map.get(‘key’)而不是map.key，array.get(0)而不是array[0]。另外Immutable每次修改都会返回新对象，很容易忘记赋值。</p>\n<p>当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。</p>\n<p>下面给出了一些办法来避免类似问题发生：</p>\n<ol>\n<li>使用Flow或TypeScript这类有静态类型检查的工具。</li>\n<li>约定变量命名规则：如所有Immutable类型对象以$$开头。</li>\n<li>使用Immutable.fromJS而不是Immutable.Map或Immutable.List来创建对象，这样可以避免Immutable和原生对象间的混用。</li>\n</ol>\n<h2 id=\"更多认识\"><a href=\"#更多认识\" class=\"headerlink\" title=\"更多认识\"></a>更多认识</h2><p>两个immutable对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> map1 = Immutable.Map(&#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">1</span>,c:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\"><span class=\"keyword\">let</span> map2 = Immutable.Map(&#123;a:<span class=\"number\">1</span>,b:<span class=\"number\">1</span>,c:<span class=\"number\">1</span>&#125;);</span><br><span class=\"line\">map1 === map2; <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>为了直接比较对象的值，immutable.js提供了Immutable.js来做值比较：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Immutable.is(map1,map2); <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>Immutable.is比较的是两个对象的hashCode或valueOf(对于javascript对象)。由于immutable内部使用了Tree数据结构来存储，只要两个对象的hashCode相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p>\n<p>后面会使用Immutable.js来减少React重复渲染，提高性能。</p>\n<p>与Object.freeze、const比较<br>ES6中新加入的Object.freeze和const都可以达到防止对象被篡改的功能，但是它们是shallowCopy的。对象层级一深就要特殊处理了。</p>\n<p>Cursor的概念<br>这个Cursor和数据库中的游标是完全不同的而概念。</p>\n<p>由于Immutable数据一般嵌套非常深，为了便于访问深层数据，Cursor提供了直接访问这个深层数据的引用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Immutable <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Cursor <span class=\"keyword\">from</span> <span class=\"string\">'immutable/contrib/cursor'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> data = Immutable.fromJS(&#123;a:&#123;b:&#123;c:<span class=\"number\">1</span>&#125;&#125;&#125;);</span><br><span class=\"line\"><span class=\"comment\">//让cursor指向&#123;c:1&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> cursor = Cursor.from(data,[<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>],newData =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//当cursor或其子cursor执行update时调用</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(newData);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">cursor.get(<span class=\"string\">'c'</span>); <span class=\"comment\">//1</span></span><br><span class=\"line\">cursor = cursor.update(<span class=\"string\">'c'</span>,x =&gt; x+<span class=\"number\">1</span>);</span><br><span class=\"line\">cursor.get(<span class=\"string\">'c'</span>); <span class=\"comment\">//2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><h3 id=\"与React搭配使用，Pure-Render\"><a href=\"#与React搭配使用，Pure-Render\" class=\"headerlink\" title=\"与React搭配使用，Pure Render\"></a>与React搭配使用，Pure Render</h3><p>熟悉React的都知道，React做性能优化时有一个避免重复渲染的大招，就是使用shouldComponentUpdate(),但它默认返回true，即始终会执行render()方法，然后做Virtual DOM比较，并得到是否需要做真实DOM更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。</p>\n<p>当然我们也可以在shouldComponentUpdate()中使用deepCopy和deepCompare来避免无必要的render(),但deepCopy和deepCompare一般都是非常耗性能。</p>\n<p>Immutable则提供了简洁高效的而判断数据是否变化的方法，只需 === 和is比较就能知道是否需要执行render(),而这个操作几乎0成本，所以可以极大提高性能。修改后的shouldComponentUpdate是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;is&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\">shouldComponentUpdate: (nextProps,nextState) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(<span class=\"keyword\">this</span>.props === nextProps || is(<span class=\"keyword\">this</span>.props,nextProps)) || !(<span class=\"keyword\">this</span>.state === nextState || is(<span class=\"keyword\">this</span>.state,nextState));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然你也可以借助React.addons.PureRenderMixin 或支持class语法的pure-render-decorator来实现。</p>\n<p>setState的一个技巧</p>\n<p>React建议把this.state当作Immutable的，因此修改前需要做一个deepCopy,显得麻烦：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">'_'</span> <span class=\"keyword\">from</span> <span class=\"string\">'lodash'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Component = React.createClass(&#123;</span><br><span class=\"line\">    getInitialState()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">            data:&#123;times:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    handleAdd()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> data = _.cloneDeep(<span class=\"keyword\">this</span>.state.data);</span><br><span class=\"line\">        data.times = data.times + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.setState(&#123;data:data&#125;);</span><br><span class=\"line\">        <span class=\"comment\">//如果上面不做cloneDeep，下面打印的结果会是已经加1后的值。</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.data.times);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>使用Immutable后：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getInitialState()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        data: <span class=\"built_in\">Map</span>(&#123;times:<span class=\"number\">0</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">handleAdd()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState(&#123;data:<span class=\"keyword\">this</span>.state.data.update(<span class=\"string\">'times'</span>,v =&gt; v+<span class=\"number\">1</span>)&#125;);</span><br><span class=\"line\">    <span class=\"comment\">//这时的times并不会改变</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.state.data.get(<span class=\"string\">'times'</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的handleAdd可以简写成：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">handleAdd()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.setState((&#123;data&#125;) =&gt; (&#123;</span><br><span class=\"line\">        data: data.update(<span class=\"string\">'times'</span>, v =&gt; v+<span class=\"number\">1</span>)&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"与Flux搭配使用\"><a href=\"#与Flux搭配使用\" class=\"headerlink\" title=\"与Flux搭配使用\"></a>与Flux搭配使用</h2><p>由于Flux并没有限定Store中的数据类型，使用Immutable非常简单。<br>下面是实现一个类似带有添加和撤销功能Store:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;<span class=\"built_in\">Map</span>, OrderedMap&#125; <span class=\"keyword\">from</span> <span class=\"string\">'immutable'</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> todos = OrderedMap();</span><br><span class=\"line\"><span class=\"keyword\">let</span> history = []; <span class=\"comment\">//普通数组，存放每次操作后产生的数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> TodoStore = createStore(&#123;</span><br><span class=\"line\">    getAll()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> todos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Dispatcher.register(action =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(action.actionType === <span class=\"string\">'create'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> id = createGUID();</span><br><span class=\"line\">        history.push(todos); <span class=\"comment\">//记录当前操作前的数据，便于撤销</span></span><br><span class=\"line\">        todos = todos.set(id,<span class=\"built_in\">Map</span>(&#123;</span><br><span class=\"line\">            id: id,</span><br><span class=\"line\">            complete: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            text: action.text.trim()</span><br><span class=\"line\">        &#125;));</span><br><span class=\"line\">        TodoStore.emitChange();</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(action.actionType === <span class=\"string\">'undo'</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(history.length &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            todos = history.pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TodoStore.emitChange();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"与Redux搭配使用\"><a href=\"#与Redux搭配使用\" class=\"headerlink\" title=\"与Redux搭配使用\"></a>与Redux搭配使用</h2><p>Redux是目前最流行的Flux衍生库。它简化了Flux中多个Store的概念，只有一个Store，数据操作通过Reducer中实现；同时它提供了更简洁和清晰的单项数据流(View -&gt; Action -&gt; Middleware -&gt; Reducer),也更易于开发同构应用。</p>\n<p>由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。</p>\n<p>幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。</p>\n<p>上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Immutable可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把Immutable对象直接暴露在对外接口中。</p>\n"},{"title":"使用ServiceWorkers","date":"2016-07-27T15:02:50.000Z","_content":"> Don't let yesterday take up too much of today.\n\n`这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。`\n\n本文提供了使用service workers所需要的相关知识。包括它的基本结构、注册一个service worker、一个新的service worker的安装和激活流程、更新你的service worker、缓存管理和自定义响应内容。所有这些功能点都是基于一个场景：离线APP。\n\n## Service workers出现的背景\n有一个困扰web用户多年的难题：网络不可连接(离线)。即使是世界上最好的web app，如果你下载不了它，用户体验基本是毁的。已经有很多种技术尝试，来解决这一问题。随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制，来对缓存和网络请求进行控制。\n\n之前的尝试--APPCache看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞的一团糟。\n\n`注意：从FireFox44起，当使用APPCache来提供离线页面支持时，会提示一个警告消息，来建议开发者使用service workers来实现离线页面。`\n\nService workers应该最终解决了这些问题。Service Worker的语法比APPCache更加复杂，但带来的效果是你可以使用javascript，更加灵活和细粒度地控制你的应用的缓存资源。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。使用Service worker可以使你的应用先访问本地缓存，所以在离线状态时，在没有通过网络接收到更多数据前，仍可以提供基本的功能检验(一般称之为Offline First)。这是原生APP本来就支持的功能，这也是相比于web app，原生app更受青睐主要原因。\n\n## 使用Service workers前的设置\n在已经支持service workers的浏览器的较新版本中，很多service workers的特性默认没有开启支持。如果你发现示例代码当前版本的浏览器中怎么样都无法正常运行，你可能需要开启一下浏览器的相关配置：\n - FireFox Nightly：访问about:config 并设置dom.ServiceWorkers.enabled的值为true;重启浏览器；\n - Chrome Canary：访问chrome://flags并开启experimetal-web-platform-features;重启浏览器(注意：有些特性在Chrome中没有默认开启支持)；\n - Opera：访问opera://flags并开启ServiceWorker的支持；重启浏览器。\n\n另外，你需要通过HTTPS来访问你的页面代码--出于安全原因，Service Workers严格要求要在HTTPS下才能运行。Github是个用来测试的好地方，因为它就支持HTTPS.\n\n## 基本架构\n使用service workers，通常遵循以下基本步骤：\n 1. service worker,通过serviceWorkerContainer.register()来加载和注册(一个脚本URL)。\n 2. 如果注册成功，service worker在ServiceWorkerGlobalScope环境中运行；这是一个特殊的worker上下文运行环境，与脚本的运行线程相独立，同时没有访问DOM的能力。\n 3. service worker现在可以处理事件了。\n 4. 受service worker控制的页面打开后，service worker尝试安装。最先发送给service worker的事件，是安装事件(install event在这个事件里，可以开始IndexDB和Cache的相关操作流程)。这个流程同原生APP或者FireFox OS APP是一样的--让所有资源可离线访问。\n 5. 当oninstall事件的处理流程执行完毕后，可以认为service worker安装完成了。\n 6. 下一步是激活。当service worker安装完成后，会接收到一个激活事件(activate event)。激活事件的处理函数中，主要操作是清理旧版本的service worker脚本中使用资源。\n 7.Service Worker现在可以控制页面了，但是只针对在成功注册(register())了service worker后打开的页面。也就是说，页面打开是有没有service worker,决定了接下来页面的生命周期内受不受service worker控制。所以，只有当页面刷新后，之前不受service worker控制的页面才有可能被控制起来。\n ![Worker lifecycle](/images/serviceWorker/sw-lifecycle.png)\n\n 下图表示了service worker所有支持的事件：\n ![Events](/images/serviceWorker/sw-events.png)\n\n ## Promises\n [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)是一种非常适用于异步操作的机制，一个操作依赖于另一个操作的成功执行。这是service worker的核心工作机制。\n\n Promises可以做很多事情。但现在，你只需要知道，如果有什么返回了一个Promise，你可以在后面加上.then()来传入成功和失败的回调函数。或者，你可以在后面加上.catch()如果你想添加一个操作失败的回调函数。\n\n 接下来，让我们对比一下传统的同步回调结构，和异步promise结构，两者在功能上是等效的：\n\n**同步**\n```javascript\ntry{\n  var value = myFunction();\n  console.log(value);\n} catch(err){\n  console.log(err);\n}\n```\n\n**异步**\n```javascript\n  myFunction().then(function(value){\n    console.log(value);\n  }).catch(function(err){\n    console.log(err);\n  })\n```\n\n在上面第一个例子中，我们必须等待 myFunction( ) 执行完成，并返回 value值，在此之前，后续其它的代码无法执行。在第二个例子中，myFunction( ) 返回一个promise对象，下面的代码可以继续执行。当promise成功resolves后，then( ) 中的函数会异步地执行。\n\n现在来举下实际的例子 — 如果我们想动态地加载图片，而且要在图片下载完成后再展示到页面上，要怎么实现呢？这是一个比较常见的场景，但是实现起来会有点麻烦。我们可以使用 .onload 事件处理程序，来实现图片的加载完成后再展示。但是如果图片的 onload事件发生在我们监听这个事件之前呢？我们可以使用 .complete来解决这个问题，但是仍然不够简洁，如果是多个图片该怎么处理呢？并且，这种方法仍然是同步的操作，会阻塞主线程。\n\n```javascript\n  function imgLoad(url){\n    return new Promise(function(resolve,reject){\n      var request = new XMLHttpRequest();\n      request.open('Get',url);\n      request.responseType = 'blob';\n\n      request.onload = function(){\n        if(request.status == 200){\n          resolve(request.response);\n        }else{\n          reject(Error('Image didn\\'t load successfully; error code:' + request.statusText));\n        }\n      }\n\n      request.onerror = function(){\n        reject(Error('There was a network error.'));\n      }\n\n      request.send();\n    })\n  }\n```\n我们使用 Promise( ) 构造函数返回了一个新的promise对象，构造函数接收一个回调函数作为参数。这个回调函数包含两个参数，第一个为成功执行(resolve)的回调函数，第二个为执行失败(reject)的回调函数。我们将这两个回调函数在对应的时机执行。在这个例子中，resoleve会在请求返回状态码200的时候执行，reject会在请求返回码为非200的时候执行。上面代码的其余部分基本都是XHR的相关操作，现在不需要过多关注。\n\n当我们调用 imgLoad( ) 函数时，传入要加载的图片url作为参数。然后，后面的代码与同步方式会有点不同：\n```javascript\n  var body = document.querySelector('body');\n  var myImage = new Image();\n\n  imgLoad('myLittleVader.jpg').then(function(response) {\n  var imageURL = window.URL.createObjectURL(response);\n  myImage.src = imageURL;\n  body.appendChild(myImage);\n  }, function(Error) {\n  console.log(Error);\n  });\n```\n","source":"_posts/使用ServiceWorkers.md","raw":"---\ntitle: 使用ServiceWorkers\ndate: 2016-07-27 23:02:50\ntags:\n- javascript\n- service worker\ncategories: 笔记\n---\n> Don't let yesterday take up too much of today.\n\n`这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。`\n\n本文提供了使用service workers所需要的相关知识。包括它的基本结构、注册一个service worker、一个新的service worker的安装和激活流程、更新你的service worker、缓存管理和自定义响应内容。所有这些功能点都是基于一个场景：离线APP。\n\n## Service workers出现的背景\n有一个困扰web用户多年的难题：网络不可连接(离线)。即使是世界上最好的web app，如果你下载不了它，用户体验基本是毁的。已经有很多种技术尝试，来解决这一问题。随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制，来对缓存和网络请求进行控制。\n\n之前的尝试--APPCache看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞的一团糟。\n\n`注意：从FireFox44起，当使用APPCache来提供离线页面支持时，会提示一个警告消息，来建议开发者使用service workers来实现离线页面。`\n\nService workers应该最终解决了这些问题。Service Worker的语法比APPCache更加复杂，但带来的效果是你可以使用javascript，更加灵活和细粒度地控制你的应用的缓存资源。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。使用Service worker可以使你的应用先访问本地缓存，所以在离线状态时，在没有通过网络接收到更多数据前，仍可以提供基本的功能检验(一般称之为Offline First)。这是原生APP本来就支持的功能，这也是相比于web app，原生app更受青睐主要原因。\n\n## 使用Service workers前的设置\n在已经支持service workers的浏览器的较新版本中，很多service workers的特性默认没有开启支持。如果你发现示例代码当前版本的浏览器中怎么样都无法正常运行，你可能需要开启一下浏览器的相关配置：\n - FireFox Nightly：访问about:config 并设置dom.ServiceWorkers.enabled的值为true;重启浏览器；\n - Chrome Canary：访问chrome://flags并开启experimetal-web-platform-features;重启浏览器(注意：有些特性在Chrome中没有默认开启支持)；\n - Opera：访问opera://flags并开启ServiceWorker的支持；重启浏览器。\n\n另外，你需要通过HTTPS来访问你的页面代码--出于安全原因，Service Workers严格要求要在HTTPS下才能运行。Github是个用来测试的好地方，因为它就支持HTTPS.\n\n## 基本架构\n使用service workers，通常遵循以下基本步骤：\n 1. service worker,通过serviceWorkerContainer.register()来加载和注册(一个脚本URL)。\n 2. 如果注册成功，service worker在ServiceWorkerGlobalScope环境中运行；这是一个特殊的worker上下文运行环境，与脚本的运行线程相独立，同时没有访问DOM的能力。\n 3. service worker现在可以处理事件了。\n 4. 受service worker控制的页面打开后，service worker尝试安装。最先发送给service worker的事件，是安装事件(install event在这个事件里，可以开始IndexDB和Cache的相关操作流程)。这个流程同原生APP或者FireFox OS APP是一样的--让所有资源可离线访问。\n 5. 当oninstall事件的处理流程执行完毕后，可以认为service worker安装完成了。\n 6. 下一步是激活。当service worker安装完成后，会接收到一个激活事件(activate event)。激活事件的处理函数中，主要操作是清理旧版本的service worker脚本中使用资源。\n 7.Service Worker现在可以控制页面了，但是只针对在成功注册(register())了service worker后打开的页面。也就是说，页面打开是有没有service worker,决定了接下来页面的生命周期内受不受service worker控制。所以，只有当页面刷新后，之前不受service worker控制的页面才有可能被控制起来。\n ![Worker lifecycle](/images/serviceWorker/sw-lifecycle.png)\n\n 下图表示了service worker所有支持的事件：\n ![Events](/images/serviceWorker/sw-events.png)\n\n ## Promises\n [Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)是一种非常适用于异步操作的机制，一个操作依赖于另一个操作的成功执行。这是service worker的核心工作机制。\n\n Promises可以做很多事情。但现在，你只需要知道，如果有什么返回了一个Promise，你可以在后面加上.then()来传入成功和失败的回调函数。或者，你可以在后面加上.catch()如果你想添加一个操作失败的回调函数。\n\n 接下来，让我们对比一下传统的同步回调结构，和异步promise结构，两者在功能上是等效的：\n\n**同步**\n```javascript\ntry{\n  var value = myFunction();\n  console.log(value);\n} catch(err){\n  console.log(err);\n}\n```\n\n**异步**\n```javascript\n  myFunction().then(function(value){\n    console.log(value);\n  }).catch(function(err){\n    console.log(err);\n  })\n```\n\n在上面第一个例子中，我们必须等待 myFunction( ) 执行完成，并返回 value值，在此之前，后续其它的代码无法执行。在第二个例子中，myFunction( ) 返回一个promise对象，下面的代码可以继续执行。当promise成功resolves后，then( ) 中的函数会异步地执行。\n\n现在来举下实际的例子 — 如果我们想动态地加载图片，而且要在图片下载完成后再展示到页面上，要怎么实现呢？这是一个比较常见的场景，但是实现起来会有点麻烦。我们可以使用 .onload 事件处理程序，来实现图片的加载完成后再展示。但是如果图片的 onload事件发生在我们监听这个事件之前呢？我们可以使用 .complete来解决这个问题，但是仍然不够简洁，如果是多个图片该怎么处理呢？并且，这种方法仍然是同步的操作，会阻塞主线程。\n\n```javascript\n  function imgLoad(url){\n    return new Promise(function(resolve,reject){\n      var request = new XMLHttpRequest();\n      request.open('Get',url);\n      request.responseType = 'blob';\n\n      request.onload = function(){\n        if(request.status == 200){\n          resolve(request.response);\n        }else{\n          reject(Error('Image didn\\'t load successfully; error code:' + request.statusText));\n        }\n      }\n\n      request.onerror = function(){\n        reject(Error('There was a network error.'));\n      }\n\n      request.send();\n    })\n  }\n```\n我们使用 Promise( ) 构造函数返回了一个新的promise对象，构造函数接收一个回调函数作为参数。这个回调函数包含两个参数，第一个为成功执行(resolve)的回调函数，第二个为执行失败(reject)的回调函数。我们将这两个回调函数在对应的时机执行。在这个例子中，resoleve会在请求返回状态码200的时候执行，reject会在请求返回码为非200的时候执行。上面代码的其余部分基本都是XHR的相关操作，现在不需要过多关注。\n\n当我们调用 imgLoad( ) 函数时，传入要加载的图片url作为参数。然后，后面的代码与同步方式会有点不同：\n```javascript\n  var body = document.querySelector('body');\n  var myImage = new Image();\n\n  imgLoad('myLittleVader.jpg').then(function(response) {\n  var imageURL = window.URL.createObjectURL(response);\n  myImage.src = imageURL;\n  body.appendChild(myImage);\n  }, function(Error) {\n  console.log(Error);\n  });\n```\n","slug":"使用ServiceWorkers","published":1,"updated":"2016-07-28T05:53:27.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0en80019b0dlehu29xmt","content":"<blockquote>\n<p>Don’t let yesterday take up too much of today.</p>\n</blockquote>\n<p><code>这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</code></p>\n<p>本文提供了使用service workers所需要的相关知识。包括它的基本结构、注册一个service worker、一个新的service worker的安装和激活流程、更新你的service worker、缓存管理和自定义响应内容。所有这些功能点都是基于一个场景：离线APP。</p>\n<h2 id=\"Service-workers出现的背景\"><a href=\"#Service-workers出现的背景\" class=\"headerlink\" title=\"Service workers出现的背景\"></a>Service workers出现的背景</h2><p>有一个困扰web用户多年的难题：网络不可连接(离线)。即使是世界上最好的web app，如果你下载不了它，用户体验基本是毁的。已经有很多种技术尝试，来解决这一问题。随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制，来对缓存和网络请求进行控制。</p>\n<p>之前的尝试–APPCache看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞的一团糟。</p>\n<p><code>注意：从FireFox44起，当使用APPCache来提供离线页面支持时，会提示一个警告消息，来建议开发者使用service workers来实现离线页面。</code></p>\n<p>Service workers应该最终解决了这些问题。Service Worker的语法比APPCache更加复杂，但带来的效果是你可以使用javascript，更加灵活和细粒度地控制你的应用的缓存资源。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。使用Service worker可以使你的应用先访问本地缓存，所以在离线状态时，在没有通过网络接收到更多数据前，仍可以提供基本的功能检验(一般称之为Offline First)。这是原生APP本来就支持的功能，这也是相比于web app，原生app更受青睐主要原因。</p>\n<h2 id=\"使用Service-workers前的设置\"><a href=\"#使用Service-workers前的设置\" class=\"headerlink\" title=\"使用Service workers前的设置\"></a>使用Service workers前的设置</h2><p>在已经支持service workers的浏览器的较新版本中，很多service workers的特性默认没有开启支持。如果你发现示例代码当前版本的浏览器中怎么样都无法正常运行，你可能需要开启一下浏览器的相关配置：</p>\n<ul>\n<li>FireFox Nightly：访问about:config 并设置dom.ServiceWorkers.enabled的值为true;重启浏览器；</li>\n<li>Chrome Canary：访问chrome://flags并开启experimetal-web-platform-features;重启浏览器(注意：有些特性在Chrome中没有默认开启支持)；</li>\n<li>Opera：访问opera://flags并开启ServiceWorker的支持；重启浏览器。</li>\n</ul>\n<p>另外，你需要通过HTTPS来访问你的页面代码–出于安全原因，Service Workers严格要求要在HTTPS下才能运行。Github是个用来测试的好地方，因为它就支持HTTPS.</p>\n<h2 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h2><p>使用service workers，通常遵循以下基本步骤：</p>\n<ol>\n<li>service worker,通过serviceWorkerContainer.register()来加载和注册(一个脚本URL)。</li>\n<li>如果注册成功，service worker在ServiceWorkerGlobalScope环境中运行；这是一个特殊的worker上下文运行环境，与脚本的运行线程相独立，同时没有访问DOM的能力。</li>\n<li>service worker现在可以处理事件了。</li>\n<li>受service worker控制的页面打开后，service worker尝试安装。最先发送给service worker的事件，是安装事件(install event在这个事件里，可以开始IndexDB和Cache的相关操作流程)。这个流程同原生APP或者FireFox OS APP是一样的–让所有资源可离线访问。</li>\n<li>当oninstall事件的处理流程执行完毕后，可以认为service worker安装完成了。</li>\n<li><p>下一步是激活。当service worker安装完成后，会接收到一个激活事件(activate event)。激活事件的处理函数中，主要操作是清理旧版本的service worker脚本中使用资源。<br>7.Service Worker现在可以控制页面了，但是只针对在成功注册(register())了service worker后打开的页面。也就是说，页面打开是有没有service worker,决定了接下来页面的生命周期内受不受service worker控制。所以，只有当页面刷新后，之前不受service worker控制的页面才有可能被控制起来。<br><img src=\"/images/serviceWorker/sw-lifecycle.png\" alt=\"Worker lifecycle\"></p>\n<p>下图表示了service worker所有支持的事件：<br><img src=\"/images/serviceWorker/sw-events.png\" alt=\"Events\"></p>\n<h2 id=\"Promises\"><a href=\"#Promises\" class=\"headerlink\" title=\"Promises\"></a>Promises</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"external\">Promises</a>是一种非常适用于异步操作的机制，一个操作依赖于另一个操作的成功执行。这是service worker的核心工作机制。</p>\n<p>Promises可以做很多事情。但现在，你只需要知道，如果有什么返回了一个Promise，你可以在后面加上.then()来传入成功和失败的回调函数。或者，你可以在后面加上.catch()如果你想添加一个操作失败的回调函数。</p>\n<p>接下来，让我们对比一下传统的同步回调结构，和异步promise结构，两者在功能上是等效的：</p>\n</li>\n</ol>\n<p><strong>同步</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = myFunction();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>异步</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myFunction().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在上面第一个例子中，我们必须等待 myFunction( ) 执行完成，并返回 value值，在此之前，后续其它的代码无法执行。在第二个例子中，myFunction( ) 返回一个promise对象，下面的代码可以继续执行。当promise成功resolves后，then( ) 中的函数会异步地执行。</p>\n<p>现在来举下实际的例子 — 如果我们想动态地加载图片，而且要在图片下载完成后再展示到页面上，要怎么实现呢？这是一个比较常见的场景，但是实现起来会有点麻烦。我们可以使用 .onload 事件处理程序，来实现图片的加载完成后再展示。但是如果图片的 onload事件发生在我们监听这个事件之前呢？我们可以使用 .complete来解决这个问题，但是仍然不够简洁，如果是多个图片该怎么处理呢？并且，这种方法仍然是同步的操作，会阻塞主线程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">imgLoad</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    request.open(<span class=\"string\">'Get'</span>,url);</span><br><span class=\"line\">    request.responseType = <span class=\"string\">'blob'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(request.status == <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">        resolve(request.response);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        reject(<span class=\"built_in\">Error</span>(<span class=\"string\">'Image didn\\'t load successfully; error code:'</span> + request.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      reject(<span class=\"built_in\">Error</span>(<span class=\"string\">'There was a network error.'</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.send();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用 Promise( ) 构造函数返回了一个新的promise对象，构造函数接收一个回调函数作为参数。这个回调函数包含两个参数，第一个为成功执行(resolve)的回调函数，第二个为执行失败(reject)的回调函数。我们将这两个回调函数在对应的时机执行。在这个例子中，resoleve会在请求返回状态码200的时候执行，reject会在请求返回码为非200的时候执行。上面代码的其余部分基本都是XHR的相关操作，现在不需要过多关注。</p>\n<p>当我们调用 imgLoad( ) 函数时，传入要加载的图片url作为参数。然后，后面的代码与同步方式会有点不同：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> body = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'body'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myImage = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\"></span><br><span class=\"line\">imgLoad(<span class=\"string\">'myLittleVader.jpg'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> imageURL = <span class=\"built_in\">window</span>.URL.createObjectURL(response);</span><br><span class=\"line\">myImage.src = imageURL;</span><br><span class=\"line\">body.appendChild(myImage);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Error</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>Don’t let yesterday take up too much of today.</p>\n</blockquote>\n<p><code>这是一个实验中的功能，此功能某些浏览器尚在开发中，请参考浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</code></p>\n<p>本文提供了使用service workers所需要的相关知识。包括它的基本结构、注册一个service worker、一个新的service worker的安装和激活流程、更新你的service worker、缓存管理和自定义响应内容。所有这些功能点都是基于一个场景：离线APP。</p>\n<h2 id=\"Service-workers出现的背景\"><a href=\"#Service-workers出现的背景\" class=\"headerlink\" title=\"Service workers出现的背景\"></a>Service workers出现的背景</h2><p>有一个困扰web用户多年的难题：网络不可连接(离线)。即使是世界上最好的web app，如果你下载不了它，用户体验基本是毁的。已经有很多种技术尝试，来解决这一问题。随着离线页面的出现，一些问题已经得到了解决。但是，最重要的问题是，仍然没有一个好的统筹机制，来对缓存和网络请求进行控制。</p>\n<p>之前的尝试–APPCache看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是，这个方法假定了你使用时会遵循很多规则，如果你不严格遵循这些规则，它会把你的APP搞的一团糟。</p>\n<p><code>注意：从FireFox44起，当使用APPCache来提供离线页面支持时，会提示一个警告消息，来建议开发者使用service workers来实现离线页面。</code></p>\n<p>Service workers应该最终解决了这些问题。Service Worker的语法比APPCache更加复杂，但带来的效果是你可以使用javascript，更加灵活和细粒度地控制你的应用的缓存资源。有了它，你可以解决目前离线应用的问题，同时也可以做更多的事。使用Service worker可以使你的应用先访问本地缓存，所以在离线状态时，在没有通过网络接收到更多数据前，仍可以提供基本的功能检验(一般称之为Offline First)。这是原生APP本来就支持的功能，这也是相比于web app，原生app更受青睐主要原因。</p>\n<h2 id=\"使用Service-workers前的设置\"><a href=\"#使用Service-workers前的设置\" class=\"headerlink\" title=\"使用Service workers前的设置\"></a>使用Service workers前的设置</h2><p>在已经支持service workers的浏览器的较新版本中，很多service workers的特性默认没有开启支持。如果你发现示例代码当前版本的浏览器中怎么样都无法正常运行，你可能需要开启一下浏览器的相关配置：</p>\n<ul>\n<li>FireFox Nightly：访问about:config 并设置dom.ServiceWorkers.enabled的值为true;重启浏览器；</li>\n<li>Chrome Canary：访问chrome://flags并开启experimetal-web-platform-features;重启浏览器(注意：有些特性在Chrome中没有默认开启支持)；</li>\n<li>Opera：访问opera://flags并开启ServiceWorker的支持；重启浏览器。</li>\n</ul>\n<p>另外，你需要通过HTTPS来访问你的页面代码–出于安全原因，Service Workers严格要求要在HTTPS下才能运行。Github是个用来测试的好地方，因为它就支持HTTPS.</p>\n<h2 id=\"基本架构\"><a href=\"#基本架构\" class=\"headerlink\" title=\"基本架构\"></a>基本架构</h2><p>使用service workers，通常遵循以下基本步骤：</p>\n<ol>\n<li>service worker,通过serviceWorkerContainer.register()来加载和注册(一个脚本URL)。</li>\n<li>如果注册成功，service worker在ServiceWorkerGlobalScope环境中运行；这是一个特殊的worker上下文运行环境，与脚本的运行线程相独立，同时没有访问DOM的能力。</li>\n<li>service worker现在可以处理事件了。</li>\n<li>受service worker控制的页面打开后，service worker尝试安装。最先发送给service worker的事件，是安装事件(install event在这个事件里，可以开始IndexDB和Cache的相关操作流程)。这个流程同原生APP或者FireFox OS APP是一样的–让所有资源可离线访问。</li>\n<li>当oninstall事件的处理流程执行完毕后，可以认为service worker安装完成了。</li>\n<li><p>下一步是激活。当service worker安装完成后，会接收到一个激活事件(activate event)。激活事件的处理函数中，主要操作是清理旧版本的service worker脚本中使用资源。<br>7.Service Worker现在可以控制页面了，但是只针对在成功注册(register())了service worker后打开的页面。也就是说，页面打开是有没有service worker,决定了接下来页面的生命周期内受不受service worker控制。所以，只有当页面刷新后，之前不受service worker控制的页面才有可能被控制起来。<br><img src=\"/images/serviceWorker/sw-lifecycle.png\" alt=\"Worker lifecycle\"></p>\n<p>下图表示了service worker所有支持的事件：<br><img src=\"/images/serviceWorker/sw-events.png\" alt=\"Events\"></p>\n<h2 id=\"Promises\"><a href=\"#Promises\" class=\"headerlink\" title=\"Promises\"></a>Promises</h2><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\">Promises</a>是一种非常适用于异步操作的机制，一个操作依赖于另一个操作的成功执行。这是service worker的核心工作机制。</p>\n<p>Promises可以做很多事情。但现在，你只需要知道，如果有什么返回了一个Promise，你可以在后面加上.then()来传入成功和失败的回调函数。或者，你可以在后面加上.catch()如果你想添加一个操作失败的回调函数。</p>\n<p>接下来，让我们对比一下传统的同步回调结构，和异步promise结构，两者在功能上是等效的：</p>\n</li>\n</ol>\n<p><strong>同步</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = myFunction();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(err)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><strong>异步</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myFunction().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>在上面第一个例子中，我们必须等待 myFunction( ) 执行完成，并返回 value值，在此之前，后续其它的代码无法执行。在第二个例子中，myFunction( ) 返回一个promise对象，下面的代码可以继续执行。当promise成功resolves后，then( ) 中的函数会异步地执行。</p>\n<p>现在来举下实际的例子 — 如果我们想动态地加载图片，而且要在图片下载完成后再展示到页面上，要怎么实现呢？这是一个比较常见的场景，但是实现起来会有点麻烦。我们可以使用 .onload 事件处理程序，来实现图片的加载完成后再展示。但是如果图片的 onload事件发生在我们监听这个事件之前呢？我们可以使用 .complete来解决这个问题，但是仍然不够简洁，如果是多个图片该怎么处理呢？并且，这种方法仍然是同步的操作，会阻塞主线程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">imgLoad</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> request = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">    request.open(<span class=\"string\">'Get'</span>,url);</span><br><span class=\"line\">    request.responseType = <span class=\"string\">'blob'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(request.status == <span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">        resolve(request.response);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        reject(<span class=\"built_in\">Error</span>(<span class=\"string\">'Image didn\\'t load successfully; error code:'</span> + request.statusText));</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">      reject(<span class=\"built_in\">Error</span>(<span class=\"string\">'There was a network error.'</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    request.send();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们使用 Promise( ) 构造函数返回了一个新的promise对象，构造函数接收一个回调函数作为参数。这个回调函数包含两个参数，第一个为成功执行(resolve)的回调函数，第二个为执行失败(reject)的回调函数。我们将这两个回调函数在对应的时机执行。在这个例子中，resoleve会在请求返回状态码200的时候执行，reject会在请求返回码为非200的时候执行。上面代码的其余部分基本都是XHR的相关操作，现在不需要过多关注。</p>\n<p>当我们调用 imgLoad( ) 函数时，传入要加载的图片url作为参数。然后，后面的代码与同步方式会有点不同：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> body = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'body'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> myImage = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\"></span><br><span class=\"line\">imgLoad(<span class=\"string\">'myLittleVader.jpg'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> imageURL = <span class=\"built_in\">window</span>.URL.createObjectURL(response);</span><br><span class=\"line\">myImage.src = imageURL;</span><br><span class=\"line\">body.appendChild(myImage);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">Error</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Error</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"函数式编程基础(转)","date":"2016-05-18T03:50:30.000Z","_content":"> 在这章，会覆盖函数式编程的核心概念：\n - 使用函数和数组实现控制流\n - 编写纯函数、匿名函数、递归函数等等\n - 像对象那样传递函数\n - 利用map()、filter()和reduce()函数\n\n## char1.函数式编程语言\n函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。\n\n### 是什么让一个语言具有函数式特征？\n函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。\n\n同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。\n\n然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。\n\n| 特点 | 命令式 | 函数式 |\n| ----- | :-----: | :-----: |\n| 编程风格 | 一步一步地执行，并且要管理状态的变化 | 描述问题和所需的数据变化已解决问题 |\n| 状态变化 | 很重要 | 不存在 |\n| 执行顺序 | 很重要 | 不太重要 |\n| 主要的控制流 | 循环、条件、函数调用 | 函数调用和递归 |\n| 主要的操作单元 | 结构体和类对象 | 函数作为一等公民的对象和数据集 |\n\n函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。\n\n> 注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。\n\n### 优点\n当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。\n\n不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。\n\n总的来说，什么是使用函数式编程真正实际的优点呢？\n\n### 更加简洁的代码\n函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。\n\n例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：\n```javascript\n    function merge2dArrayIntoOne(arrays){\n        var count = arrays.length;\n        var merged = new Array(count);\n        var c = 0;\n        for(var i=0;i<count;i++){\n            for(var j=0,jlen = array[i].length;j<jlen;j++){\n                merged[c++] = arrays[i][j];\n            }\n        }\n        return merged;\n    }\n```\n\n现在使用函数式技术，可以写成这样：\n```javascript\n   var merge2dArrayIntoOne = function(arrays){\n    return arrays.reduce(function(p,n){\n        return p.concat(n);\n    });\n   };\n```\n\n这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。\n\n### 模块化\n函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。\n\n### 复用性\n由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。\n\n在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。\n\n### 减少耦合\n耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。\n\n### 数学正确性\n最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。\n\n### 非函数式世界中的函数式编程\n函数式和非函数式编程能混合在一起吗？\n\n这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。\n\n例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：\n\n```javascript\n    var words = [];count = 0;\n    text = myString.split(' ');\n    for(var i=0;count<4,i<text.length;i++){\n        if(!text[i].match(/[0-9]/)){\n            words = words.concat(text[i]);\n            count++;\n        }\n    }\n```\n\n函数式编程会这样写：\n\n```javascript\n    var words = [];\n    var words = myString.split(' ').filter(function(x){\n        return (!x.match(/[0-9]/));\n    }).slice(0,4);\n    console.log(words);\n```\n\n如果有一个函数式编程的工具库，代码可以进一步被简化：\n\n```javascript\n    var words = toSequence(myString).match(/[a-zA-Z]+/).first(4);\n```\n\n判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的\"words\"和\"count\"变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。\n\n### Javascript是函数式编程语言吗？\n现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？\n\nJavascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。\n\n它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：\n\n - Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。\n - Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。\n - Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。\n \n也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。\n\n关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。\n\n最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。\n\n## char2.与函数共舞\n> 有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 --John Carmack，游戏《毁灭战士》首席程序员\n\n函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。\n\n我们从Javascript的一个小尴尬开始。\n\n假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。\n\n```javascript\n    var obj1 = {value:1},\n        obj2 = {value:2},\n        obj2 = {value:3};\n    var values = [];\n    function accumulate(obj){\n        values.push(obj.value);\n    }\n    accumulate(obj1);\n    accumulate(obj2);\n    console.log(values); //Output: [obj1.value,obj2.value]\n```\n\n这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。\n\n但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。\n\n```javascript\n    function accumulate2(obj){\n        var values = [];\n        values.push(obj.value);\n        return values;\n    }\n    console.log(accumulate2(obj1)); // Returns: [obj1.value]\n    console.log(accumulate2(obj2)); // Returns: [obj2.value]\n    console.log(accumulate2(obj3)); // Returns: [obj3.value]\n```\n\n只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。\n\n```javascript\n    var ValueAccumulator = function(obj){\n        var values = [];\n        var accumulate = function(){\n            value.push(obj.value);\n        };\n        accumulate();\n        return values;\n    }\n```\n\n可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。\n\n我们需要的是一个自调用函数\n\n### 自调用函数和闭包\n如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。\n```javascript\n    var ValueAccumulator = function(){\n        var values = [];\n        var accumulate = function(obj){\n            if(obj){\n                values.push(obj.value);\n                return values;\n            }else{\n                return values;\n            }\n        };\n        return accumulates;\n    };\n    //This allows us to do this\n    var accumulator = ValueAccumulator();\n    accumulator(obj1);\n    accumulator(obj2);\n    console.log(accumulator()); //Output: [obj1.value,obj2.value]\n```\n\n```javascript\n    ValueAccumulator = ->\n     values = []\n     (obj) ->\n     values.push obj.value if obj\n     values\n```\n\n这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。\n\n> Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。\n\n闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。\n\n### 高阶函数\n自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。\n\n高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。\n\n这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。\n\n在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。\n\n来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：\n```javascript\n   // 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2\n   var accumulator2 = ValueAccumulator();\n   var objects = [obj1, obj2, obj3]; // 这个数组可以很大\n   objects.forEach(accumulator2);\n   console.log(accumulator2()); \n```\n\n### 纯函数\n纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。\n\n用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。\n\n纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。\n\n举例说明来对比一下非纯函数和纯函数。\n```javascript\n   // 把信息打印到屏幕中央的函数\n   var printCenter = function(str) {\n     var elem = document.createElement(\"div\");\n     elem.textContent = str;\n     elem.style.position = 'absolute';\n     elem.style.top = window.innerHeight / 2 + \"px\";\n     elem.style.left = window.innerWidth / 2 + \"px\";\n     document.body.appendChild(elem);\n   };\n   printCenter('hello world');\n   // 纯函数完成相同的事情\n   var printSomewhere = function(str, height, width) {\n     var elem = document.createElement(\"div\");\n     elem.textContent = str;\n     elem.style.position = 'absolute';\n     elem.style.top = height;\n     elem.style.left = width;\n     return elem;\n   };\n   document.body.appendChild(\n   printSomewhere('hello world',\n   window.innerHeight / 2) + 10 + \"px\",\n   window.innerWidth / 2) + 10 + \"px\"));\n```\n\n非纯函数依赖window对象的状态来计算宽度和高度，自给自足的纯函数则要求这些值作为参数传入。 实际上它就允许了信息打印到任何地方，这也让这个函数有了更多用途。\n\n非纯函数看起来是一个更容易的选择，因为它在自己内部实现了追加元素，而不是返回元素。 返回了值的纯函数printSomewhere()则会在跟其他函数式编程技术的配合下有更好的表现。\n\n```javascript\n    var messages = ['Hi', 'Hello', 'Sup', 'Hey', 'Hola'];\n    messages.map(function(s,i){\n        return printSomewhere(s,100*i*10,100*i*10);\n    }).forEach(function(element){\n        document.body.appendChild(element);\n    });\n```\n\n> 当一个函数是纯的，也就是不依赖于状态和环境，我们就不用管它实际是什么时候被计算出来。后面的惰性求职将讲到这个。\n\n### 匿名函数\n把函数作为头等对象的另一个好处就是匿名函数\n\n就想名字暗示的那样，匿名函数就是没有名字的函数。实际上不止这些，它允许了在现场定义临时逻辑的能力。通常这带来的好处就是方便：如果一个函数只用一次，没有必要给他浪费一变量名。\n\n下面是一些匿名函数的例子：\n```javascript\n    //写匿名函数的标准方式\n    function(){\n        return 'hello world'\n    };\n    //匿名函数可以赋值给变量\n    var anon = function(x,y){\n        return x + y;\n    };\n    //匿名函数用于代替具名回调函数，这是匿名函数的一个更常见的用处\n    setInterval(function(){\n        console.log(new Date().getTime())\n    },1000);\n    //Output:  1413249010672, 1413249010673, 1413249010674, ...\n    //如果没有把它包含在一个匿名函数中，他将立刻被执行，并且返回一个undefined作为回调函数\n    setInterval(console.log(new Date().getTime()),1000)\n    //Output:  1413249010671\n```\n\n下面是匿名函数和高阶函数配合使用的例子\n```javascript\n    function powersOf(x){\n        return function(y){\n            //this is an anonymous function!\n            return Math.pow(x,y);\n        };\n    }\n    powerOfTwo = powersOf(2);\n    console.log(powerOfTwo(1)); // 2\n    console.log(powerOfTwo(2)); // 4\n    console.log(powerOfTwo(3)); // 8\n    powerOfThree = powersOf(3);\n    console.log(powerOfThree(3)); // 9\n    console.log(powerOfThree(10)); // 59049\n```\n\n这里返回的那个函数不需要命名，它可以在powerOf()函数外的任何地方使用，这就是匿名函数。\n\n还记得累加器的那个函数吗？它可以用匿名函数重写\n```javascript\n   var obj1 = {value:1},\n       obj2 = {value:2},\n       obj2 = {value:3};\n   var values = (function(){\n    //匿名函数\n    var values = [];\n    return function(obj){\n        //有一个匿名函数！\n        if(obj){\n            values.push(obj.value);\n            return values;\n        }else{\n            return values;\n        }\n    }\n   })(); //让它自执行\n   console.log(values(obj1)); // Returns: [obj.value]\n   console.log(values(obj2)); // Returns: [obj.value, obj2.value]\n```\n\n真棒！一个高阶匿名纯函数。我们怎么这么幸运？实际上还不止这些，这里面还有个自执行的结构， (function(){...})();。函数后面跟的那个括号可以让函数立即执行。在上面的例子里， 给外面values赋的值是函数执行的结果。\n\n> 匿名函数不仅仅是语法糖，他们是lambda演算的化身。请听我说下去…… lambda演算早在计算机和计算机语言被发明的很久以前就出现了。它只是个研究函数的数学概念。 非同寻常的是，尽管它只定义了三种表达式：变量引用，函数调用和匿名函数，但它被发现是图灵完整的。 如今，lambda演算处于所有函数式语言的核心，包括javascript。由于这个原因，匿名函数往往被称作lambda表达式。\n\n匿名函数也有一个缺点，那就是他们在调用栈中难以被识别，这会对调试造成一些困难。要小心使用匿名函数。\n\n### 方法链\n在Javascript中，把方法链在一起很常见。如果你使用过jQuery，你应该用过这种技巧。它有时也被叫做“建造者模式”。\n\n这种技术用于简化多个函数一次应用于一个对象的代码。\n```javascript\n   // 每个函数占用一行来调用，不如……\n   arr = [1, 2, 3, 4];\n   arr1 = arr.reverse();\n   arr2 = arr1.concat([5, 6]);\n   arr3 = arr2.map(Math.sqrt);\n   // ……把它们串到一起放在一行里面\n   console.log([1, 2, 3, 4].reverse().concat([5, 6]).map(Math.sqrt));\n   // 括号也许可以说明是怎么回事\n   console.log(((([1, 2, 3, 4]).reverse()).concat([5, 6])).map(Math.sqrt)); \n```\n\n这只有在函数是目标对象所拥有的方法时才有效。如果你要创建自己的函数，比如要把两个数组zip到一起，你必须把它声明为Array.prototype对象的成员，看一下下面的代码片段：\n```javascript\n    Array.prototype.zip = function(){...}\n```\n\n这样我们就可以写成下面的样子\n```javascript\n   arr.zip([1,2,3,4]).map(function(n){\n    return n*2;\n   })\n```\n\n### 递归\n递归应该是最著名的函数式编程技术。就是一个函数调用它自己。\n\n当函数调用自己，有时候奇怪的事情就发生了。它的表明既是一个循环，多次执行同样的代码，也是一个函数栈。\n\n使用递归函数时必须十分小心地避免无限递归。就像循环一样，必须有个停止条件。这叫做基准情形(base case)。\n\n下面有个例子：\n```javascript\n    var foo = function(n){\n        if(n<0){\n            return 'hello';\n        }else{\n            return foo(n-1);\n        }\n    }\n    console.log(foo(5));\n```\n\n递归和循环可一个互相转换。但是递归算法往往更合适，甚至是必要的，因为有些情形用循环很费劲。\n\n一个明显的例子就是遍历树。\n```javascript\n    var getLeafs = function(node){\n        //base case\n        return node.innerText;\n    }else{\n        //recursive case\n        return node.childNodes.map(getLeafs);\n    }\n```\n\n### 分而治之\n递归不只是代替for和while循环的有趣的方式。有个叫分而治之的算法，他递归的把问题拆分成更小的情形，直到小到可以解决。\n\n历史上有个欧几里得算法用于找出两个数的最大公分母\n```javascript\n    function gcd(a,b){\n        if(b === 0){\n            //基准情形\n            return a;\n        }else{\n            return gcd(b,a%b);\n        }\n    }\n    console.log(gcd(12,8));\n```\n\n理论上来说，分而治之很牛逼，但是现实中有用吗？当然！用Javascript的函数对数组排序不是很好，它不但替换了原数组，也就是说数组不是不变的，并且他还不够可靠、灵活。通过分而治之，饿哦们可以做到更好。\n\n全部的实现代码大概要40行，这里只是展示伪代码：\n```javascript\n    var mergeSort = function(arr){\n        if(arr.length < 2){\n            //基准情形：只有0或1个元素的数组是不用排序的\n            return items;\n        }else{\n            //递归情形：把数组拆分、排序、合并\n            var middle = Math.floor(arr.length / 2);\n            // 分\n            var left = mergeSort(arr.slice(0, middle));\n            var right = mergeSort(arr.slice(middle));\n            // 治\n            // merge是一个辅助函数，返回一个新数组，它将两个数组合并到一起\n            return merge(left, right);\n        }\n    }\n```\n\n### 惰性求值\n惰性求值，也叫做非严格求值，它会按需调用并推迟执行，它是一种直到需要时才计算函数结果的求值策略， 这对函数式编程特别有用。比如有行代码是 x = func()，调用这个func()函数得到的返回值会赋值给x。 但是x等于什么一开始并不重要，直到需要用到x的时候。等到需要用x的时候才调用func()就是惰性求值。\n\n这一策略可以让性能明显增强，特别是当使用方法链和数组这些函数式程序员最喜爱的程序流技术的时候。 惰性求值让人兴奋的一个优点是让无限序列成为可能。因为在它实在无法继续延迟之前，什么都不需要被真正计算出来。 它可以是这个样子：\n\n```javascript\n    // 理想化的JavaScript伪代码:\n    var infinateNums = range(1 to infinity);\n    var tenPrimes = infinateNums.getPrimeNumbers().first(10);\n```\n\n这为很多可能性敞开了大门，比如异步执行、并行计算、组合，这只列举了一点。\n\n然而，还有个问题，Javascript本身并不支持惰性求值，也就是说存在让Javascript模拟惰性求值的函数库。\n\n## char3.函数式程序员的工具集\n如果你仔细看了到目前为止出现过的示例代码，你会发现这里面的一些方法不太熟悉。 它们是map()、filter()和reduce()函数，它们对任何语言的函数式编程都至关重要。 它们可以让你不必使用循环和语句，写出更简洁的代码。\n\nmap()、filter()和reduce()函数组成了函数式程序员工具集的核心部分，这个工具集包括一系列纯的、 高阶的函数，它们是函数式方法的主力。实际上，它们是纯函数和高阶函数的典型，它们以一个函数为输入， 返回一个输出结果，并且不产生副作用。\n\n然而它们是浏览器中ECMAScript 5.1的实现标准，它们只工作于数组。每次调用它们，一个新的数组会被创建并返回， 而原来存在的那个数组不会被改变。它们以函数为输入，经常使用匿名函数作为回调函数。它们遍历数组， 并对数组的每一个元素应用这个函数！\n\n```javascript\n   myArray = [1,2,3,4];\n   newArray = myArray.map(function(x) {return x*2});\n   console.log(myArray);  // Output: [1,2,3,4]\n   console.log(newArray); // Output: [2,4,6,8] \n```\n\n还有一点，它们只作用于数组，无法作用于其它可迭代的数据结构，比如对象。不用担心， 有很多库比如Underscore.js，Lazy.js，stream.js等等都实现了它们自己的更强大的map()、 filter()和reduce()。\n\n### 回调\n如果你以前从来没用过回调，那这个概念可能会让你有些迷惑。尤其是在javascript中，javascript给出了好几种声明函数的方式。\n\n回调函数用于传递给另一个函数供他们使用，这是一种像传递对象一样来传递逻辑的方式：\n```javascript\n    var myArray = [1,2,3];\n    function myCallback(x){return x + 1};\n    console.log(myArray.map(myCallback));\n```\n\n对于比较简单的任务可以用匿名函数：\n```javascript\n    console.log(myArray.map(function(x){return x+1}))\n```\n\n回调不仅用于函数式编程，在javascript中它们能干很多事情。仅作为例子，这有个callback()函数用于jquery的AJAX调用：\n```javascript\n    function myCallback(xhr){\n        console.log(xht.status);\n        return true;\n    }\n    $.ajax(myUrl).done(myCallback);\n```\n\n注意这里只用了函数的名字，因为我们并不是要调用函数而是传递函数，写成这样就错了：\n```javascript\n    $.ajax(myURI).fail(myCallback(xhr)); \n    // 或者\n    $.ajax(myURI).fail(myCallback());\n```\n\n如果我们调用了函数会发生什么？在这个例子里，myCallback(xhr)会尝试执行，控制台将打印“undefined”， 并会返回true。当ajax()完成调用时，它根据名字找到的回调函数将是一个\"true\"，然后就报错了。\n\n也就是说我们无法指定给回调函数传什么参数，如果我们的回调函数需要让ajax()函数传给他我们想要的参数， 我们可以把回到函数包在一个匿名函数里：\n```javascript\n   function myCallback(status) {\n     console.log(status);\n     return true;\n   }\n   $.ajax(myURI).done(function(xhr) {\n     myCallback(xhr.status)\n   });\n```\n\n### Array.prototype.map()\nmap()是这些函数的老大，它简单地对数组里的元素以此应用灰调函数。\n```javascript\n    语法：arr.map(callback[,thisArg]);\n```\n\n - callback():这个函数为新数组产生一个元素，它接受的参数：\n    - currentValue: 数组当前遍历到的元素\n    - index: 数组中当前元素序数\n    - array: 当前正在处理的数组\n - thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this\n \n例子：\n```javascript\n   var\n     integers = [1, -0, 9, -8, 3],\n     numbers = [1, 2, 3, 4],\n     str = 'hello world how ya doing?';\n    //将整数映射为他们自己知道的绝对值\n    console.log(integers.map(Math.abs));\n    //将数组中的元素与自己的位置序数相乘\n    console.log(numbers.map(function(x,i){return x*i}));\n    //单词隔一个变一个大写\n    console.log(str.split(' ').map(function(s,i){\n        if(i%2 === 0){\n            return s.toUpperCase();\n        }else{\n            return s;\n        }\n    }))\n```\n\n> 尽管Array.prototype.map方法是Javascript中数组对象的标准方法，你也可以很容易地扩展自己的对象。\nMyObject.prototype.map = function(f) {\n return new MyObject(f(this.value));\n};\n\n### Array.prototype.filter()\nfilter()函数用于把数组中的一些元素筛选出来。回调函数必须返回真(保留到新数组里)或假(扔掉)。用map()可以做类似的事情，就是你像扔掉的元素返回为null，不过filter()函数会在新数组里面删除这些不要的元素，而不是留个null占着位置。\n```javascript\n    语法：arr.filter(callback[,thisArg]);\n```\n\n - callback(): 这个函数用来测试数组中的每个元素，要保留返回真，否则返回假。他有这些参数：\n    - currentValue: 数组当前遍历到的元素\n    - index: 数组中当前元素的序数\n    - array: 当前正在处理的数组\n - thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this\n\n例子：\n```javascript\n    var myarray = [1, 2, 3, 4]\n    words = 'hello 123 world how 345 ya doing'.split(' ');\n    re = '[a-zA-Z]';\n    // 筛选整数\n    console.log([-2, -1, 0, 1, 2].filter(function(x) {\n      return x > 0\n    }));\n    // 筛选所有含字母的单词\n    console.log(words.filter(function(s) {\n      return s.match(re);\n    }));\n    // 随机移除数组中的元素\n    console.log(myarray.filter(function() {\n      return Math.floor(Math.random() * 2)\n    }));\n```\n\n### Array.prototype.reduce()\nreduce()函数，有时也称为fold，它用于把数组中的所有值聚集在一起。回调需要返回组合对象的逻辑。对于数字来说，他们往往会被加到一起或者乘到一起。对于字符串来说，他们往往是被追加到一起。\n```javascript\n    语法：arr.reduce(callback[,initialValue]);\n```\n\n参数：\n - callback()：此函数把两个对象合并成一个对象，并将其返回。参数有：\n    - previousValue：上一次回调函数被调用时返回的值，或者是初始值（如果有的话）\n    - currentValue：数组当前正在处理的元素\n    - index：数组中当前元素的序数\n    - array：当前正在处理的数组\n - initialValue：可选。第一次回调所传入参数的初始值\n\n例子：\n```javascript\n  var numbers = [1, 2, 3, 4];\n  // 把数组中所有的值加起来\n  console.log([1, 2, 3, 4, 5].reduce(function(x, y) {\n    return x + y\n  }, 0));\n  // 查找数组中最大的值\n  console.log(numbers.reduce(function(a, b) {\n      return Math.max(a, b) // max()函数只能有两个参数\n    }) \n  );  \n```\n\n### Array.prototype.forEach()\nforEach()函数本质上是map()函数的非纯版本，它会遍历整个数组，并对每个元素应用回调。 然而这些回调函数不返回值。它是实现for循环的一个更纯粹的方式。\n```javascript\n    语法：arr.forEach(callback[,initialValue]);\n```\n\n参数：\n - callback()：对数组中每一个元素所应用的。参数有：\n    - currentValue：数组当前正在处理的元素\n    - index：数组中当前元素的序数\n    - array：当前正在处理的数组\n - thisArg：可选。回调函数中作为this的值\n\n例子：\n```javascript\n  var arr = [1, 2, 3];\n  var nodes = arr.map(function(x) {\n    var elem = document.createElement(\"div\");\n    elem.textContent = x;\n    return elem;\n  });\n  // 对每一个元素的值输出日志\n  arr.forEach(function(x) {\n    console.log(x)\n  });\n  // 把节点追加到DOM上\n  nodes.forEach(function(x) {\n    document.body.appendChild(x)\n  });  \n```\n\n### Array.prototype.concat()\n如果不用for或while处理数组，你会经常需要把数组拼接起来。另一个Javascript内建函数concat就是专门干这事儿的。 concat函数会返回一个新数组但不改变旧数组。它可以把你传入的所有参数拼接到一起。\n```javascript\n    console.log([1, 2, 3].concat(['a','b','c']) // 拼接两个数组\n    // Output: [1, 2, 3, 'a','b','c']\n```\n\n它返回两个数组拼接成的数组，同时原来的那些数组没有被改变。这就意味着concat函数可以链式调用。\n\n```javascript\n    var arr1 = [1,2,3];\n    var arr2 = [4,5,6];\n    var arr3 = [7,8,9];\n    var x = arr1.concat(arr2, arr3);\n    var y = arr1.concat(arr2).concat(arr3));\n    var z = arr1.concat(arr2.concat(arr3)));\n    console.log(x);\n    console.log(y);\n    console.log(z); \n```\n\n### Array.prototype.reverse()\n这个Javascript内建函数是用于数组变形的。reverse函数用于将一个数组反转，也就是第个一元素会跑到最后， 而最后一个元素变成了第一个元素。\n\n然而，这个函数并不会返回一个新的数组，而是把原来的数组替换掉了。我们可以做个更好的。下面是一个纯的反转数组函数\n\n```javascript\n   var invert = function(arr) {\n     return arr.map(function(x, i, a) {\n       return a[a.length - (i + 1)];\n     });\n   };\n   var q = invert([1, 2, 3, 4]);\n   console.log(q); \n```\n\n### Array.prototype.sort()\n与map()、filter()和reduce()函数相似，排序函数sort()需要传入一个回调函数来定义数组如何排序。 但是，跟reverse()一样，它也会把原来的数组替换。这可不太好。\n\n```javascript\n   arr = [200, 12, 56, 7, 344];\n   console.log(arr.sort(function(a,b){return a–b}) );\n   // arr现在是: [7, 12, 56, 200, 344]; \n```\n\n我们可以写一个纯函数的sort()，但是排序算法的源代码很麻烦。对于特别大的数组，应当根据特定的数据结构来选用适合的算法， 比如快速排序、合并排序、冒泡排序等等\n\n### Array.prototype.every() && Array.prototype.some()\nArray.prototype.every() 和 Array.prototype.some() 都是纯的高阶函数，它们是Array对象的方法， 通过回调函数根据数组各元素返回的布尔值（或相当于布尔的值）来进行测试。如果数组中所有的元素通过回调函数计算都返回True， every()函数就返回true；如果数组中有一个元素返回True，some()函数就返回True。\n\n```javascript\n    function isNumber(n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n    console.log([1, 2, 3, 4].every(isNumber)); // Return: true\n    console.log([1, 2, 'a'].every(isNumber)); // Return: false\n    console.log([1, 2, 'a'].some(isNumber)); // Return: true\n```","source":"_posts/函数式编程基础-转.md","raw":"---\ntitle: 函数式编程基础(转)\ndate: 2016-05-18 11:50:30\ntags:\n- javascript\n- 函数式编程\ncategories: 转载笔记\n---\n> 在这章，会覆盖函数式编程的核心概念：\n - 使用函数和数组实现控制流\n - 编写纯函数、匿名函数、递归函数等等\n - 像对象那样传递函数\n - 利用map()、filter()和reduce()函数\n\n## char1.函数式编程语言\n函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。\n\n### 是什么让一个语言具有函数式特征？\n函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。\n\n同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。\n\n然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。\n\n| 特点 | 命令式 | 函数式 |\n| ----- | :-----: | :-----: |\n| 编程风格 | 一步一步地执行，并且要管理状态的变化 | 描述问题和所需的数据变化已解决问题 |\n| 状态变化 | 很重要 | 不存在 |\n| 执行顺序 | 很重要 | 不太重要 |\n| 主要的控制流 | 循环、条件、函数调用 | 函数调用和递归 |\n| 主要的操作单元 | 结构体和类对象 | 函数作为一等公民的对象和数据集 |\n\n函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。\n\n> 注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。\n\n### 优点\n当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。\n\n不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。\n\n总的来说，什么是使用函数式编程真正实际的优点呢？\n\n### 更加简洁的代码\n函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。\n\n例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：\n```javascript\n    function merge2dArrayIntoOne(arrays){\n        var count = arrays.length;\n        var merged = new Array(count);\n        var c = 0;\n        for(var i=0;i<count;i++){\n            for(var j=0,jlen = array[i].length;j<jlen;j++){\n                merged[c++] = arrays[i][j];\n            }\n        }\n        return merged;\n    }\n```\n\n现在使用函数式技术，可以写成这样：\n```javascript\n   var merge2dArrayIntoOne = function(arrays){\n    return arrays.reduce(function(p,n){\n        return p.concat(n);\n    });\n   };\n```\n\n这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。\n\n### 模块化\n函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。\n\n### 复用性\n由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。\n\n在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。\n\n### 减少耦合\n耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。\n\n### 数学正确性\n最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。\n\n### 非函数式世界中的函数式编程\n函数式和非函数式编程能混合在一起吗？\n\n这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。\n\n例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：\n\n```javascript\n    var words = [];count = 0;\n    text = myString.split(' ');\n    for(var i=0;count<4,i<text.length;i++){\n        if(!text[i].match(/[0-9]/)){\n            words = words.concat(text[i]);\n            count++;\n        }\n    }\n```\n\n函数式编程会这样写：\n\n```javascript\n    var words = [];\n    var words = myString.split(' ').filter(function(x){\n        return (!x.match(/[0-9]/));\n    }).slice(0,4);\n    console.log(words);\n```\n\n如果有一个函数式编程的工具库，代码可以进一步被简化：\n\n```javascript\n    var words = toSequence(myString).match(/[a-zA-Z]+/).first(4);\n```\n\n判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的\"words\"和\"count\"变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。\n\n### Javascript是函数式编程语言吗？\n现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？\n\nJavascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。\n\n它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：\n\n - Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。\n - Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。\n - Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。\n \n也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。\n\n关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。\n\n最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。\n\n## char2.与函数共舞\n> 有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 --John Carmack，游戏《毁灭战士》首席程序员\n\n函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。\n\n我们从Javascript的一个小尴尬开始。\n\n假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。\n\n```javascript\n    var obj1 = {value:1},\n        obj2 = {value:2},\n        obj2 = {value:3};\n    var values = [];\n    function accumulate(obj){\n        values.push(obj.value);\n    }\n    accumulate(obj1);\n    accumulate(obj2);\n    console.log(values); //Output: [obj1.value,obj2.value]\n```\n\n这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。\n\n但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。\n\n```javascript\n    function accumulate2(obj){\n        var values = [];\n        values.push(obj.value);\n        return values;\n    }\n    console.log(accumulate2(obj1)); // Returns: [obj1.value]\n    console.log(accumulate2(obj2)); // Returns: [obj2.value]\n    console.log(accumulate2(obj3)); // Returns: [obj3.value]\n```\n\n只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。\n\n```javascript\n    var ValueAccumulator = function(obj){\n        var values = [];\n        var accumulate = function(){\n            value.push(obj.value);\n        };\n        accumulate();\n        return values;\n    }\n```\n\n可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。\n\n我们需要的是一个自调用函数\n\n### 自调用函数和闭包\n如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。\n```javascript\n    var ValueAccumulator = function(){\n        var values = [];\n        var accumulate = function(obj){\n            if(obj){\n                values.push(obj.value);\n                return values;\n            }else{\n                return values;\n            }\n        };\n        return accumulates;\n    };\n    //This allows us to do this\n    var accumulator = ValueAccumulator();\n    accumulator(obj1);\n    accumulator(obj2);\n    console.log(accumulator()); //Output: [obj1.value,obj2.value]\n```\n\n```javascript\n    ValueAccumulator = ->\n     values = []\n     (obj) ->\n     values.push obj.value if obj\n     values\n```\n\n这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。\n\n> Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。\n\n闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。\n\n### 高阶函数\n自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。\n\n高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。\n\n这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。\n\n在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。\n\n来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：\n```javascript\n   // 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2\n   var accumulator2 = ValueAccumulator();\n   var objects = [obj1, obj2, obj3]; // 这个数组可以很大\n   objects.forEach(accumulator2);\n   console.log(accumulator2()); \n```\n\n### 纯函数\n纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。\n\n用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。\n\n纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。\n\n举例说明来对比一下非纯函数和纯函数。\n```javascript\n   // 把信息打印到屏幕中央的函数\n   var printCenter = function(str) {\n     var elem = document.createElement(\"div\");\n     elem.textContent = str;\n     elem.style.position = 'absolute';\n     elem.style.top = window.innerHeight / 2 + \"px\";\n     elem.style.left = window.innerWidth / 2 + \"px\";\n     document.body.appendChild(elem);\n   };\n   printCenter('hello world');\n   // 纯函数完成相同的事情\n   var printSomewhere = function(str, height, width) {\n     var elem = document.createElement(\"div\");\n     elem.textContent = str;\n     elem.style.position = 'absolute';\n     elem.style.top = height;\n     elem.style.left = width;\n     return elem;\n   };\n   document.body.appendChild(\n   printSomewhere('hello world',\n   window.innerHeight / 2) + 10 + \"px\",\n   window.innerWidth / 2) + 10 + \"px\"));\n```\n\n非纯函数依赖window对象的状态来计算宽度和高度，自给自足的纯函数则要求这些值作为参数传入。 实际上它就允许了信息打印到任何地方，这也让这个函数有了更多用途。\n\n非纯函数看起来是一个更容易的选择，因为它在自己内部实现了追加元素，而不是返回元素。 返回了值的纯函数printSomewhere()则会在跟其他函数式编程技术的配合下有更好的表现。\n\n```javascript\n    var messages = ['Hi', 'Hello', 'Sup', 'Hey', 'Hola'];\n    messages.map(function(s,i){\n        return printSomewhere(s,100*i*10,100*i*10);\n    }).forEach(function(element){\n        document.body.appendChild(element);\n    });\n```\n\n> 当一个函数是纯的，也就是不依赖于状态和环境，我们就不用管它实际是什么时候被计算出来。后面的惰性求职将讲到这个。\n\n### 匿名函数\n把函数作为头等对象的另一个好处就是匿名函数\n\n就想名字暗示的那样，匿名函数就是没有名字的函数。实际上不止这些，它允许了在现场定义临时逻辑的能力。通常这带来的好处就是方便：如果一个函数只用一次，没有必要给他浪费一变量名。\n\n下面是一些匿名函数的例子：\n```javascript\n    //写匿名函数的标准方式\n    function(){\n        return 'hello world'\n    };\n    //匿名函数可以赋值给变量\n    var anon = function(x,y){\n        return x + y;\n    };\n    //匿名函数用于代替具名回调函数，这是匿名函数的一个更常见的用处\n    setInterval(function(){\n        console.log(new Date().getTime())\n    },1000);\n    //Output:  1413249010672, 1413249010673, 1413249010674, ...\n    //如果没有把它包含在一个匿名函数中，他将立刻被执行，并且返回一个undefined作为回调函数\n    setInterval(console.log(new Date().getTime()),1000)\n    //Output:  1413249010671\n```\n\n下面是匿名函数和高阶函数配合使用的例子\n```javascript\n    function powersOf(x){\n        return function(y){\n            //this is an anonymous function!\n            return Math.pow(x,y);\n        };\n    }\n    powerOfTwo = powersOf(2);\n    console.log(powerOfTwo(1)); // 2\n    console.log(powerOfTwo(2)); // 4\n    console.log(powerOfTwo(3)); // 8\n    powerOfThree = powersOf(3);\n    console.log(powerOfThree(3)); // 9\n    console.log(powerOfThree(10)); // 59049\n```\n\n这里返回的那个函数不需要命名，它可以在powerOf()函数外的任何地方使用，这就是匿名函数。\n\n还记得累加器的那个函数吗？它可以用匿名函数重写\n```javascript\n   var obj1 = {value:1},\n       obj2 = {value:2},\n       obj2 = {value:3};\n   var values = (function(){\n    //匿名函数\n    var values = [];\n    return function(obj){\n        //有一个匿名函数！\n        if(obj){\n            values.push(obj.value);\n            return values;\n        }else{\n            return values;\n        }\n    }\n   })(); //让它自执行\n   console.log(values(obj1)); // Returns: [obj.value]\n   console.log(values(obj2)); // Returns: [obj.value, obj2.value]\n```\n\n真棒！一个高阶匿名纯函数。我们怎么这么幸运？实际上还不止这些，这里面还有个自执行的结构， (function(){...})();。函数后面跟的那个括号可以让函数立即执行。在上面的例子里， 给外面values赋的值是函数执行的结果。\n\n> 匿名函数不仅仅是语法糖，他们是lambda演算的化身。请听我说下去…… lambda演算早在计算机和计算机语言被发明的很久以前就出现了。它只是个研究函数的数学概念。 非同寻常的是，尽管它只定义了三种表达式：变量引用，函数调用和匿名函数，但它被发现是图灵完整的。 如今，lambda演算处于所有函数式语言的核心，包括javascript。由于这个原因，匿名函数往往被称作lambda表达式。\n\n匿名函数也有一个缺点，那就是他们在调用栈中难以被识别，这会对调试造成一些困难。要小心使用匿名函数。\n\n### 方法链\n在Javascript中，把方法链在一起很常见。如果你使用过jQuery，你应该用过这种技巧。它有时也被叫做“建造者模式”。\n\n这种技术用于简化多个函数一次应用于一个对象的代码。\n```javascript\n   // 每个函数占用一行来调用，不如……\n   arr = [1, 2, 3, 4];\n   arr1 = arr.reverse();\n   arr2 = arr1.concat([5, 6]);\n   arr3 = arr2.map(Math.sqrt);\n   // ……把它们串到一起放在一行里面\n   console.log([1, 2, 3, 4].reverse().concat([5, 6]).map(Math.sqrt));\n   // 括号也许可以说明是怎么回事\n   console.log(((([1, 2, 3, 4]).reverse()).concat([5, 6])).map(Math.sqrt)); \n```\n\n这只有在函数是目标对象所拥有的方法时才有效。如果你要创建自己的函数，比如要把两个数组zip到一起，你必须把它声明为Array.prototype对象的成员，看一下下面的代码片段：\n```javascript\n    Array.prototype.zip = function(){...}\n```\n\n这样我们就可以写成下面的样子\n```javascript\n   arr.zip([1,2,3,4]).map(function(n){\n    return n*2;\n   })\n```\n\n### 递归\n递归应该是最著名的函数式编程技术。就是一个函数调用它自己。\n\n当函数调用自己，有时候奇怪的事情就发生了。它的表明既是一个循环，多次执行同样的代码，也是一个函数栈。\n\n使用递归函数时必须十分小心地避免无限递归。就像循环一样，必须有个停止条件。这叫做基准情形(base case)。\n\n下面有个例子：\n```javascript\n    var foo = function(n){\n        if(n<0){\n            return 'hello';\n        }else{\n            return foo(n-1);\n        }\n    }\n    console.log(foo(5));\n```\n\n递归和循环可一个互相转换。但是递归算法往往更合适，甚至是必要的，因为有些情形用循环很费劲。\n\n一个明显的例子就是遍历树。\n```javascript\n    var getLeafs = function(node){\n        //base case\n        return node.innerText;\n    }else{\n        //recursive case\n        return node.childNodes.map(getLeafs);\n    }\n```\n\n### 分而治之\n递归不只是代替for和while循环的有趣的方式。有个叫分而治之的算法，他递归的把问题拆分成更小的情形，直到小到可以解决。\n\n历史上有个欧几里得算法用于找出两个数的最大公分母\n```javascript\n    function gcd(a,b){\n        if(b === 0){\n            //基准情形\n            return a;\n        }else{\n            return gcd(b,a%b);\n        }\n    }\n    console.log(gcd(12,8));\n```\n\n理论上来说，分而治之很牛逼，但是现实中有用吗？当然！用Javascript的函数对数组排序不是很好，它不但替换了原数组，也就是说数组不是不变的，并且他还不够可靠、灵活。通过分而治之，饿哦们可以做到更好。\n\n全部的实现代码大概要40行，这里只是展示伪代码：\n```javascript\n    var mergeSort = function(arr){\n        if(arr.length < 2){\n            //基准情形：只有0或1个元素的数组是不用排序的\n            return items;\n        }else{\n            //递归情形：把数组拆分、排序、合并\n            var middle = Math.floor(arr.length / 2);\n            // 分\n            var left = mergeSort(arr.slice(0, middle));\n            var right = mergeSort(arr.slice(middle));\n            // 治\n            // merge是一个辅助函数，返回一个新数组，它将两个数组合并到一起\n            return merge(left, right);\n        }\n    }\n```\n\n### 惰性求值\n惰性求值，也叫做非严格求值，它会按需调用并推迟执行，它是一种直到需要时才计算函数结果的求值策略， 这对函数式编程特别有用。比如有行代码是 x = func()，调用这个func()函数得到的返回值会赋值给x。 但是x等于什么一开始并不重要，直到需要用到x的时候。等到需要用x的时候才调用func()就是惰性求值。\n\n这一策略可以让性能明显增强，特别是当使用方法链和数组这些函数式程序员最喜爱的程序流技术的时候。 惰性求值让人兴奋的一个优点是让无限序列成为可能。因为在它实在无法继续延迟之前，什么都不需要被真正计算出来。 它可以是这个样子：\n\n```javascript\n    // 理想化的JavaScript伪代码:\n    var infinateNums = range(1 to infinity);\n    var tenPrimes = infinateNums.getPrimeNumbers().first(10);\n```\n\n这为很多可能性敞开了大门，比如异步执行、并行计算、组合，这只列举了一点。\n\n然而，还有个问题，Javascript本身并不支持惰性求值，也就是说存在让Javascript模拟惰性求值的函数库。\n\n## char3.函数式程序员的工具集\n如果你仔细看了到目前为止出现过的示例代码，你会发现这里面的一些方法不太熟悉。 它们是map()、filter()和reduce()函数，它们对任何语言的函数式编程都至关重要。 它们可以让你不必使用循环和语句，写出更简洁的代码。\n\nmap()、filter()和reduce()函数组成了函数式程序员工具集的核心部分，这个工具集包括一系列纯的、 高阶的函数，它们是函数式方法的主力。实际上，它们是纯函数和高阶函数的典型，它们以一个函数为输入， 返回一个输出结果，并且不产生副作用。\n\n然而它们是浏览器中ECMAScript 5.1的实现标准，它们只工作于数组。每次调用它们，一个新的数组会被创建并返回， 而原来存在的那个数组不会被改变。它们以函数为输入，经常使用匿名函数作为回调函数。它们遍历数组， 并对数组的每一个元素应用这个函数！\n\n```javascript\n   myArray = [1,2,3,4];\n   newArray = myArray.map(function(x) {return x*2});\n   console.log(myArray);  // Output: [1,2,3,4]\n   console.log(newArray); // Output: [2,4,6,8] \n```\n\n还有一点，它们只作用于数组，无法作用于其它可迭代的数据结构，比如对象。不用担心， 有很多库比如Underscore.js，Lazy.js，stream.js等等都实现了它们自己的更强大的map()、 filter()和reduce()。\n\n### 回调\n如果你以前从来没用过回调，那这个概念可能会让你有些迷惑。尤其是在javascript中，javascript给出了好几种声明函数的方式。\n\n回调函数用于传递给另一个函数供他们使用，这是一种像传递对象一样来传递逻辑的方式：\n```javascript\n    var myArray = [1,2,3];\n    function myCallback(x){return x + 1};\n    console.log(myArray.map(myCallback));\n```\n\n对于比较简单的任务可以用匿名函数：\n```javascript\n    console.log(myArray.map(function(x){return x+1}))\n```\n\n回调不仅用于函数式编程，在javascript中它们能干很多事情。仅作为例子，这有个callback()函数用于jquery的AJAX调用：\n```javascript\n    function myCallback(xhr){\n        console.log(xht.status);\n        return true;\n    }\n    $.ajax(myUrl).done(myCallback);\n```\n\n注意这里只用了函数的名字，因为我们并不是要调用函数而是传递函数，写成这样就错了：\n```javascript\n    $.ajax(myURI).fail(myCallback(xhr)); \n    // 或者\n    $.ajax(myURI).fail(myCallback());\n```\n\n如果我们调用了函数会发生什么？在这个例子里，myCallback(xhr)会尝试执行，控制台将打印“undefined”， 并会返回true。当ajax()完成调用时，它根据名字找到的回调函数将是一个\"true\"，然后就报错了。\n\n也就是说我们无法指定给回调函数传什么参数，如果我们的回调函数需要让ajax()函数传给他我们想要的参数， 我们可以把回到函数包在一个匿名函数里：\n```javascript\n   function myCallback(status) {\n     console.log(status);\n     return true;\n   }\n   $.ajax(myURI).done(function(xhr) {\n     myCallback(xhr.status)\n   });\n```\n\n### Array.prototype.map()\nmap()是这些函数的老大，它简单地对数组里的元素以此应用灰调函数。\n```javascript\n    语法：arr.map(callback[,thisArg]);\n```\n\n - callback():这个函数为新数组产生一个元素，它接受的参数：\n    - currentValue: 数组当前遍历到的元素\n    - index: 数组中当前元素序数\n    - array: 当前正在处理的数组\n - thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this\n \n例子：\n```javascript\n   var\n     integers = [1, -0, 9, -8, 3],\n     numbers = [1, 2, 3, 4],\n     str = 'hello world how ya doing?';\n    //将整数映射为他们自己知道的绝对值\n    console.log(integers.map(Math.abs));\n    //将数组中的元素与自己的位置序数相乘\n    console.log(numbers.map(function(x,i){return x*i}));\n    //单词隔一个变一个大写\n    console.log(str.split(' ').map(function(s,i){\n        if(i%2 === 0){\n            return s.toUpperCase();\n        }else{\n            return s;\n        }\n    }))\n```\n\n> 尽管Array.prototype.map方法是Javascript中数组对象的标准方法，你也可以很容易地扩展自己的对象。\nMyObject.prototype.map = function(f) {\n return new MyObject(f(this.value));\n};\n\n### Array.prototype.filter()\nfilter()函数用于把数组中的一些元素筛选出来。回调函数必须返回真(保留到新数组里)或假(扔掉)。用map()可以做类似的事情，就是你像扔掉的元素返回为null，不过filter()函数会在新数组里面删除这些不要的元素，而不是留个null占着位置。\n```javascript\n    语法：arr.filter(callback[,thisArg]);\n```\n\n - callback(): 这个函数用来测试数组中的每个元素，要保留返回真，否则返回假。他有这些参数：\n    - currentValue: 数组当前遍历到的元素\n    - index: 数组中当前元素的序数\n    - array: 当前正在处理的数组\n - thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this\n\n例子：\n```javascript\n    var myarray = [1, 2, 3, 4]\n    words = 'hello 123 world how 345 ya doing'.split(' ');\n    re = '[a-zA-Z]';\n    // 筛选整数\n    console.log([-2, -1, 0, 1, 2].filter(function(x) {\n      return x > 0\n    }));\n    // 筛选所有含字母的单词\n    console.log(words.filter(function(s) {\n      return s.match(re);\n    }));\n    // 随机移除数组中的元素\n    console.log(myarray.filter(function() {\n      return Math.floor(Math.random() * 2)\n    }));\n```\n\n### Array.prototype.reduce()\nreduce()函数，有时也称为fold，它用于把数组中的所有值聚集在一起。回调需要返回组合对象的逻辑。对于数字来说，他们往往会被加到一起或者乘到一起。对于字符串来说，他们往往是被追加到一起。\n```javascript\n    语法：arr.reduce(callback[,initialValue]);\n```\n\n参数：\n - callback()：此函数把两个对象合并成一个对象，并将其返回。参数有：\n    - previousValue：上一次回调函数被调用时返回的值，或者是初始值（如果有的话）\n    - currentValue：数组当前正在处理的元素\n    - index：数组中当前元素的序数\n    - array：当前正在处理的数组\n - initialValue：可选。第一次回调所传入参数的初始值\n\n例子：\n```javascript\n  var numbers = [1, 2, 3, 4];\n  // 把数组中所有的值加起来\n  console.log([1, 2, 3, 4, 5].reduce(function(x, y) {\n    return x + y\n  }, 0));\n  // 查找数组中最大的值\n  console.log(numbers.reduce(function(a, b) {\n      return Math.max(a, b) // max()函数只能有两个参数\n    }) \n  );  \n```\n\n### Array.prototype.forEach()\nforEach()函数本质上是map()函数的非纯版本，它会遍历整个数组，并对每个元素应用回调。 然而这些回调函数不返回值。它是实现for循环的一个更纯粹的方式。\n```javascript\n    语法：arr.forEach(callback[,initialValue]);\n```\n\n参数：\n - callback()：对数组中每一个元素所应用的。参数有：\n    - currentValue：数组当前正在处理的元素\n    - index：数组中当前元素的序数\n    - array：当前正在处理的数组\n - thisArg：可选。回调函数中作为this的值\n\n例子：\n```javascript\n  var arr = [1, 2, 3];\n  var nodes = arr.map(function(x) {\n    var elem = document.createElement(\"div\");\n    elem.textContent = x;\n    return elem;\n  });\n  // 对每一个元素的值输出日志\n  arr.forEach(function(x) {\n    console.log(x)\n  });\n  // 把节点追加到DOM上\n  nodes.forEach(function(x) {\n    document.body.appendChild(x)\n  });  \n```\n\n### Array.prototype.concat()\n如果不用for或while处理数组，你会经常需要把数组拼接起来。另一个Javascript内建函数concat就是专门干这事儿的。 concat函数会返回一个新数组但不改变旧数组。它可以把你传入的所有参数拼接到一起。\n```javascript\n    console.log([1, 2, 3].concat(['a','b','c']) // 拼接两个数组\n    // Output: [1, 2, 3, 'a','b','c']\n```\n\n它返回两个数组拼接成的数组，同时原来的那些数组没有被改变。这就意味着concat函数可以链式调用。\n\n```javascript\n    var arr1 = [1,2,3];\n    var arr2 = [4,5,6];\n    var arr3 = [7,8,9];\n    var x = arr1.concat(arr2, arr3);\n    var y = arr1.concat(arr2).concat(arr3));\n    var z = arr1.concat(arr2.concat(arr3)));\n    console.log(x);\n    console.log(y);\n    console.log(z); \n```\n\n### Array.prototype.reverse()\n这个Javascript内建函数是用于数组变形的。reverse函数用于将一个数组反转，也就是第个一元素会跑到最后， 而最后一个元素变成了第一个元素。\n\n然而，这个函数并不会返回一个新的数组，而是把原来的数组替换掉了。我们可以做个更好的。下面是一个纯的反转数组函数\n\n```javascript\n   var invert = function(arr) {\n     return arr.map(function(x, i, a) {\n       return a[a.length - (i + 1)];\n     });\n   };\n   var q = invert([1, 2, 3, 4]);\n   console.log(q); \n```\n\n### Array.prototype.sort()\n与map()、filter()和reduce()函数相似，排序函数sort()需要传入一个回调函数来定义数组如何排序。 但是，跟reverse()一样，它也会把原来的数组替换。这可不太好。\n\n```javascript\n   arr = [200, 12, 56, 7, 344];\n   console.log(arr.sort(function(a,b){return a–b}) );\n   // arr现在是: [7, 12, 56, 200, 344]; \n```\n\n我们可以写一个纯函数的sort()，但是排序算法的源代码很麻烦。对于特别大的数组，应当根据特定的数据结构来选用适合的算法， 比如快速排序、合并排序、冒泡排序等等\n\n### Array.prototype.every() && Array.prototype.some()\nArray.prototype.every() 和 Array.prototype.some() 都是纯的高阶函数，它们是Array对象的方法， 通过回调函数根据数组各元素返回的布尔值（或相当于布尔的值）来进行测试。如果数组中所有的元素通过回调函数计算都返回True， every()函数就返回true；如果数组中有一个元素返回True，some()函数就返回True。\n\n```javascript\n    function isNumber(n) {\n      return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n    console.log([1, 2, 3, 4].every(isNumber)); // Return: true\n    console.log([1, 2, 'a'].every(isNumber)); // Return: false\n    console.log([1, 2, 'a'].some(isNumber)); // Return: true\n```","slug":"函数式编程基础-转","published":1,"updated":"2016-05-19T02:17:18.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0ena001db0dlxqfcj8y2","content":"<blockquote>\n<p>在这章，会覆盖函数式编程的核心概念：</p>\n<ul>\n<li>使用函数和数组实现控制流</li>\n<li>编写纯函数、匿名函数、递归函数等等</li>\n<li>像对象那样传递函数</li>\n<li>利用map()、filter()和reduce()函数</li>\n</ul>\n</blockquote>\n<h2 id=\"char1-函数式编程语言\"><a href=\"#char1-函数式编程语言\" class=\"headerlink\" title=\"char1.函数式编程语言\"></a>char1.函数式编程语言</h2><p>函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。</p>\n<h3 id=\"是什么让一个语言具有函数式特征？\"><a href=\"#是什么让一个语言具有函数式特征？\" class=\"headerlink\" title=\"是什么让一个语言具有函数式特征？\"></a>是什么让一个语言具有函数式特征？</h3><p>函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。</p>\n<p>同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。</p>\n<p>然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th style=\"text-align:center\">命令式</th>\n<th style=\"text-align:center\">函数式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编程风格</td>\n<td style=\"text-align:center\">一步一步地执行，并且要管理状态的变化</td>\n<td style=\"text-align:center\">描述问题和所需的数据变化已解决问题</td>\n</tr>\n<tr>\n<td>状态变化</td>\n<td style=\"text-align:center\">很重要</td>\n<td style=\"text-align:center\">不存在</td>\n</tr>\n<tr>\n<td>执行顺序</td>\n<td style=\"text-align:center\">很重要</td>\n<td style=\"text-align:center\">不太重要</td>\n</tr>\n<tr>\n<td>主要的控制流</td>\n<td style=\"text-align:center\">循环、条件、函数调用</td>\n<td style=\"text-align:center\">函数调用和递归</td>\n</tr>\n<tr>\n<td>主要的操作单元</td>\n<td style=\"text-align:center\">结构体和类对象</td>\n<td style=\"text-align:center\">函数作为一等公民的对象和数据集</td>\n</tr>\n</tbody>\n</table>\n<p>函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。</p>\n<blockquote>\n<p>注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。</p>\n</blockquote>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。</p>\n<p>不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。</p>\n<p>总的来说，什么是使用函数式编程真正实际的优点呢？</p>\n<h3 id=\"更加简洁的代码\"><a href=\"#更加简洁的代码\" class=\"headerlink\" title=\"更加简洁的代码\"></a>更加简洁的代码</h3><p>函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。</p>\n<p>例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge2dArrayIntoOne</span>(<span class=\"params\">arrays</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = arrays.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(count);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;count;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>,jlen = array[i].length;j&lt;jlen;j++)&#123;</span><br><span class=\"line\">            merged[c++] = arrays[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用函数式技术，可以写成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge2dArrayIntoOne = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arrays</span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> arrays.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p,n</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> p.concat(n);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。</p>\n<h3 id=\"复用性\"><a href=\"#复用性\" class=\"headerlink\" title=\"复用性\"></a>复用性</h3><p>由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。</p>\n<p>在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。</p>\n<h3 id=\"减少耦合\"><a href=\"#减少耦合\" class=\"headerlink\" title=\"减少耦合\"></a>减少耦合</h3><p>耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。</p>\n<h3 id=\"数学正确性\"><a href=\"#数学正确性\" class=\"headerlink\" title=\"数学正确性\"></a>数学正确性</h3><p>最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。</p>\n<h3 id=\"非函数式世界中的函数式编程\"><a href=\"#非函数式世界中的函数式编程\" class=\"headerlink\" title=\"非函数式世界中的函数式编程\"></a>非函数式世界中的函数式编程</h3><p>函数式和非函数式编程能混合在一起吗？</p>\n<p>这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。</p>\n<p>例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = [];count = <span class=\"number\">0</span>;</span><br><span class=\"line\">text = myString.split(<span class=\"string\">' '</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;count&lt;<span class=\"number\">4</span>,i&lt;text.length;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!text[i].match(<span class=\"regexp\">/[0-9]/</span>))&#123;</span><br><span class=\"line\">        words = words.concat(text[i]);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数式编程会这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> words = myString.split(<span class=\"string\">' '</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (!x.match(<span class=\"regexp\">/[0-9]/</span>));</span><br><span class=\"line\">&#125;).slice(<span class=\"number\">0</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(words);</span><br></pre></td></tr></table></figure>\n<p>如果有一个函数式编程的工具库，代码可以进一步被简化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = toSequence(myString).match(<span class=\"regexp\">/[a-zA-Z]+/</span>).first(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的”words”和”count”变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。</p>\n<h3 id=\"Javascript是函数式编程语言吗？\"><a href=\"#Javascript是函数式编程语言吗？\" class=\"headerlink\" title=\"Javascript是函数式编程语言吗？\"></a>Javascript是函数式编程语言吗？</h3><p>现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？</p>\n<p>Javascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。</p>\n<p>它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：</p>\n<ul>\n<li>Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。</li>\n<li>Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。</li>\n<li>Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。</li>\n</ul>\n<p>也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。</p>\n<p>关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。</p>\n<p>最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。</p>\n<h2 id=\"char2-与函数共舞\"><a href=\"#char2-与函数共舞\" class=\"headerlink\" title=\"char2.与函数共舞\"></a>char2.与函数共舞</h2><blockquote>\n<p>有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 –John Carmack，游戏《毁灭战士》首席程序员</p>\n</blockquote>\n<p>函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。</p>\n<p>我们从Javascript的一个小尴尬开始。</p>\n<p>假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;value:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">accumulate</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    values.push(obj.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">accumulate(obj1);</span><br><span class=\"line\">accumulate(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values); <span class=\"comment\">//Output: [obj1.value,obj2.value]</span></span><br></pre></td></tr></table></figure>\n<p>这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。</p>\n<p>但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">accumulate2</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">    values.push(obj.value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulate2(obj1)); <span class=\"comment\">// Returns: [obj1.value]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulate2(obj2)); <span class=\"comment\">// Returns: [obj2.value]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulate2(obj3)); <span class=\"comment\">// Returns: [obj3.value]</span></span><br></pre></td></tr></table></figure>\n<p>只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValueAccumulator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> accumulate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        value.push(obj.value);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    accumulate();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。</p>\n<p>我们需要的是一个自调用函数</p>\n<h3 id=\"自调用函数和闭包\"><a href=\"#自调用函数和闭包\" class=\"headerlink\" title=\"自调用函数和闭包\"></a>自调用函数和闭包</h3><p>如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValueAccumulator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> accumulate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obj)&#123;</span><br><span class=\"line\">            values.push(obj.value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> accumulates;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//This allows us to do this</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> accumulator = ValueAccumulator();</span><br><span class=\"line\">accumulator(obj1);</span><br><span class=\"line\">accumulator(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulator()); <span class=\"comment\">//Output: [obj1.value,obj2.value]</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ValueAccumulator = -&gt;</span><br><span class=\"line\"> values = []</span><br><span class=\"line\"> (obj) -&gt;</span><br><span class=\"line\"> values.push obj.value <span class=\"keyword\">if</span> obj</span><br><span class=\"line\"> values</span><br></pre></td></tr></table></figure>\n<p>这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。</p>\n<blockquote>\n<p>Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。</p>\n</blockquote>\n<p>闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。</p>\n<p>高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。</p>\n<p>这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。</p>\n<p>在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。</p>\n<p>来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> accumulator2 = ValueAccumulator();</span><br><span class=\"line\"><span class=\"keyword\">var</span> objects = [obj1, obj2, obj3]; <span class=\"comment\">// 这个数组可以很大</span></span><br><span class=\"line\">objects.forEach(accumulator2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulator2());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h3><p>纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。</p>\n<p>用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。</p>\n<p>纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。</p>\n<p>举例说明来对比一下非纯函数和纯函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把信息打印到屏幕中央的函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> printCenter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  elem.textContent = str;</span><br><span class=\"line\">  elem.style.position = <span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">  elem.style.top = <span class=\"built_in\">window</span>.innerHeight / <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  elem.style.left = <span class=\"built_in\">window</span>.innerWidth / <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(elem);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printCenter(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 纯函数完成相同的事情</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> printSomewhere = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str, height, width</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  elem.textContent = str;</span><br><span class=\"line\">  elem.style.position = <span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">  elem.style.top = height;</span><br><span class=\"line\">  elem.style.left = width;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> elem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(</span><br><span class=\"line\">printSomewhere(<span class=\"string\">'hello world'</span>,</span><br><span class=\"line\"><span class=\"built_in\">window</span>.innerHeight / <span class=\"number\">2</span>) + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>,</span><br><span class=\"line\"><span class=\"built_in\">window</span>.innerWidth / <span class=\"number\">2</span>) + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>非纯函数依赖window对象的状态来计算宽度和高度，自给自足的纯函数则要求这些值作为参数传入。 实际上它就允许了信息打印到任何地方，这也让这个函数有了更多用途。</p>\n<p>非纯函数看起来是一个更容易的选择，因为它在自己内部实现了追加元素，而不是返回元素。 返回了值的纯函数printSomewhere()则会在跟其他函数式编程技术的配合下有更好的表现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> messages = [<span class=\"string\">'Hi'</span>, <span class=\"string\">'Hello'</span>, <span class=\"string\">'Sup'</span>, <span class=\"string\">'Hey'</span>, <span class=\"string\">'Hola'</span>];</span><br><span class=\"line\">messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s,i</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> printSomewhere(s,<span class=\"number\">100</span>*i*<span class=\"number\">10</span>,<span class=\"number\">100</span>*i*<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(element);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当一个函数是纯的，也就是不依赖于状态和环境，我们就不用管它实际是什么时候被计算出来。后面的惰性求职将讲到这个。</p>\n</blockquote>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><p>把函数作为头等对象的另一个好处就是匿名函数</p>\n<p>就想名字暗示的那样，匿名函数就是没有名字的函数。实际上不止这些，它允许了在现场定义临时逻辑的能力。通常这带来的好处就是方便：如果一个函数只用一次，没有必要给他浪费一变量名。</p>\n<p>下面是一些匿名函数的例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//写匿名函数的标准方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//匿名函数可以赋值给变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> anon = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//匿名函数用于代替具名回调函数，这是匿名函数的一个更常见的用处</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime())</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//Output:  1413249010672, 1413249010673, 1413249010674, ...</span></span><br><span class=\"line\"><span class=\"comment\">//如果没有把它包含在一个匿名函数中，他将立刻被执行，并且返回一个undefined作为回调函数</span></span><br><span class=\"line\">setInterval(<span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()),<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"comment\">//Output:  1413249010671</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是匿名函数和高阶函数配合使用的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">powersOf</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//this is an anonymous function!</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(x,y);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">powerOfTwo = powersOf(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfTwo(<span class=\"number\">1</span>)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfTwo(<span class=\"number\">2</span>)); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfTwo(<span class=\"number\">3</span>)); <span class=\"comment\">// 8</span></span><br><span class=\"line\">powerOfThree = powersOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfThree(<span class=\"number\">3</span>)); <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfThree(<span class=\"number\">10</span>)); <span class=\"comment\">// 59049</span></span><br></pre></td></tr></table></figure></p>\n<p>这里返回的那个函数不需要命名，它可以在powerOf()函数外的任何地方使用，这就是匿名函数。</p>\n<p>还记得累加器的那个函数吗？它可以用匿名函数重写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;value:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> values = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//匿名函数</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//有一个匿名函数！</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(obj)&#123;</span><br><span class=\"line\">         values.push(obj.value);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">     &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)(); <span class=\"comment\">//让它自执行</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values(obj1)); <span class=\"comment\">// Returns: [obj.value]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values(obj2)); <span class=\"comment\">// Returns: [obj.value, obj2.value]</span></span><br></pre></td></tr></table></figure></p>\n<p>真棒！一个高阶匿名纯函数。我们怎么这么幸运？实际上还不止这些，这里面还有个自执行的结构， (function(){…})();。函数后面跟的那个括号可以让函数立即执行。在上面的例子里， 给外面values赋的值是函数执行的结果。</p>\n<blockquote>\n<p>匿名函数不仅仅是语法糖，他们是lambda演算的化身。请听我说下去…… lambda演算早在计算机和计算机语言被发明的很久以前就出现了。它只是个研究函数的数学概念。 非同寻常的是，尽管它只定义了三种表达式：变量引用，函数调用和匿名函数，但它被发现是图灵完整的。 如今，lambda演算处于所有函数式语言的核心，包括javascript。由于这个原因，匿名函数往往被称作lambda表达式。</p>\n</blockquote>\n<p>匿名函数也有一个缺点，那就是他们在调用栈中难以被识别，这会对调试造成一些困难。要小心使用匿名函数。</p>\n<h3 id=\"方法链\"><a href=\"#方法链\" class=\"headerlink\" title=\"方法链\"></a>方法链</h3><p>在Javascript中，把方法链在一起很常见。如果你使用过jQuery，你应该用过这种技巧。它有时也被叫做“建造者模式”。</p>\n<p>这种技术用于简化多个函数一次应用于一个对象的代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个函数占用一行来调用，不如……</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">arr1 = arr.reverse();</span><br><span class=\"line\">arr2 = arr1.concat([<span class=\"number\">5</span>, <span class=\"number\">6</span>]);</span><br><span class=\"line\">arr3 = arr2.map(<span class=\"built_in\">Math</span>.sqrt);</span><br><span class=\"line\"><span class=\"comment\">// ……把它们串到一起放在一行里面</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].reverse().concat([<span class=\"number\">5</span>, <span class=\"number\">6</span>]).map(<span class=\"built_in\">Math</span>.sqrt));</span><br><span class=\"line\"><span class=\"comment\">// 括号也许可以说明是怎么回事</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(((([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]).reverse()).concat([<span class=\"number\">5</span>, <span class=\"number\">6</span>])).map(<span class=\"built_in\">Math</span>.sqrt));</span><br></pre></td></tr></table></figure></p>\n<p>这只有在函数是目标对象所拥有的方法时才有效。如果你要创建自己的函数，比如要把两个数组zip到一起，你必须把它声明为Array.prototype对象的成员，看一下下面的代码片段：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.zip = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就可以写成下面的样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.zip([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> n*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>递归应该是最著名的函数式编程技术。就是一个函数调用它自己。</p>\n<p>当函数调用自己，有时候奇怪的事情就发生了。它的表明既是一个循环，多次执行同样的代码，也是一个函数栈。</p>\n<p>使用递归函数时必须十分小心地避免无限递归。就像循环一样，必须有个停止条件。这叫做基准情形(base case)。</p>\n<p>下面有个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> foo(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></p>\n<p>递归和循环可一个互相转换。但是递归算法往往更合适，甚至是必要的，因为有些情形用循环很费劲。</p>\n<p>一个明显的例子就是遍历树。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getLeafs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//base case</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.innerText;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//recursive case</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.childNodes.map(getLeafs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h3><p>递归不只是代替for和while循环的有趣的方式。有个叫分而治之的算法，他递归的把问题拆分成更小的情形，直到小到可以解决。</p>\n<p>历史上有个欧几里得算法用于找出两个数的最大公分母<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gcd</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b === <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//基准情形</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gcd(b,a%b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gcd(<span class=\"number\">12</span>,<span class=\"number\">8</span>));</span><br></pre></td></tr></table></figure></p>\n<p>理论上来说，分而治之很牛逼，但是现实中有用吗？当然！用Javascript的函数对数组排序不是很好，它不但替换了原数组，也就是说数组不是不变的，并且他还不够可靠、灵活。通过分而治之，饿哦们可以做到更好。</p>\n<p>全部的实现代码大概要40行，这里只是展示伪代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mergeSort = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt; <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//基准情形：只有0或1个元素的数组是不用排序的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> items;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归情形：把数组拆分、排序、合并</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> middle = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 分</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> left = mergeSort(arr.slice(<span class=\"number\">0</span>, middle));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> right = mergeSort(arr.slice(middle));</span><br><span class=\"line\">        <span class=\"comment\">// 治</span></span><br><span class=\"line\">        <span class=\"comment\">// merge是一个辅助函数，返回一个新数组，它将两个数组合并到一起</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"惰性求值\"><a href=\"#惰性求值\" class=\"headerlink\" title=\"惰性求值\"></a>惰性求值</h3><p>惰性求值，也叫做非严格求值，它会按需调用并推迟执行，它是一种直到需要时才计算函数结果的求值策略， 这对函数式编程特别有用。比如有行代码是 x = func()，调用这个func()函数得到的返回值会赋值给x。 但是x等于什么一开始并不重要，直到需要用到x的时候。等到需要用x的时候才调用func()就是惰性求值。</p>\n<p>这一策略可以让性能明显增强，特别是当使用方法链和数组这些函数式程序员最喜爱的程序流技术的时候。 惰性求值让人兴奋的一个优点是让无限序列成为可能。因为在它实在无法继续延迟之前，什么都不需要被真正计算出来。 它可以是这个样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 理想化的JavaScript伪代码:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> infinateNums = range(<span class=\"number\">1</span> to infinity);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tenPrimes = infinateNums.getPrimeNumbers().first(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>这为很多可能性敞开了大门，比如异步执行、并行计算、组合，这只列举了一点。</p>\n<p>然而，还有个问题，Javascript本身并不支持惰性求值，也就是说存在让Javascript模拟惰性求值的函数库。</p>\n<h2 id=\"char3-函数式程序员的工具集\"><a href=\"#char3-函数式程序员的工具集\" class=\"headerlink\" title=\"char3.函数式程序员的工具集\"></a>char3.函数式程序员的工具集</h2><p>如果你仔细看了到目前为止出现过的示例代码，你会发现这里面的一些方法不太熟悉。 它们是map()、filter()和reduce()函数，它们对任何语言的函数式编程都至关重要。 它们可以让你不必使用循环和语句，写出更简洁的代码。</p>\n<p>map()、filter()和reduce()函数组成了函数式程序员工具集的核心部分，这个工具集包括一系列纯的、 高阶的函数，它们是函数式方法的主力。实际上，它们是纯函数和高阶函数的典型，它们以一个函数为输入， 返回一个输出结果，并且不产生副作用。</p>\n<p>然而它们是浏览器中ECMAScript 5.1的实现标准，它们只工作于数组。每次调用它们，一个新的数组会被创建并返回， 而原来存在的那个数组不会被改变。它们以函数为输入，经常使用匿名函数作为回调函数。它们遍历数组， 并对数组的每一个元素应用这个函数！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">newArray = myArray.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x*<span class=\"number\">2</span>&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray);  <span class=\"comment\">// Output: [1,2,3,4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray); <span class=\"comment\">// Output: [2,4,6,8]</span></span><br></pre></td></tr></table></figure>\n<p>还有一点，它们只作用于数组，无法作用于其它可迭代的数据结构，比如对象。不用担心， 有很多库比如Underscore.js，Lazy.js，stream.js等等都实现了它们自己的更强大的map()、 filter()和reduce()。</p>\n<h3 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h3><p>如果你以前从来没用过回调，那这个概念可能会让你有些迷惑。尤其是在javascript中，javascript给出了好几种声明函数的方式。</p>\n<p>回调函数用于传递给另一个函数供他们使用，这是一种像传递对象一样来传递逻辑的方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.map(myCallback));</span><br></pre></td></tr></table></figure></p>\n<p>对于比较简单的任务可以用匿名函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x+<span class=\"number\">1</span>&#125;))</span><br></pre></td></tr></table></figure></p>\n<p>回调不仅用于函数式编程，在javascript中它们能干很多事情。仅作为例子，这有个callback()函数用于jquery的AJAX调用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\">xhr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(xht.status);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(myUrl).done(myCallback);</span><br></pre></td></tr></table></figure></p>\n<p>注意这里只用了函数的名字，因为我们并不是要调用函数而是传递函数，写成这样就错了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(myURI).fail(myCallback(xhr)); </span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\">$.ajax(myURI).fail(myCallback());</span><br></pre></td></tr></table></figure></p>\n<p>如果我们调用了函数会发生什么？在这个例子里，myCallback(xhr)会尝试执行，控制台将打印“undefined”， 并会返回true。当ajax()完成调用时，它根据名字找到的回调函数将是一个”true”，然后就报错了。</p>\n<p>也就是说我们无法指定给回调函数传什么参数，如果我们的回调函数需要让ajax()函数传给他我们想要的参数， 我们可以把回到函数包在一个匿名函数里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(status);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(myURI).done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xhr</span>) </span>&#123;</span><br><span class=\"line\">  myCallback(xhr.status)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-map\"><a href=\"#Array-prototype-map\" class=\"headerlink\" title=\"Array.prototype.map()\"></a>Array.prototype.map()</h3><p>map()是这些函数的老大，它简单地对数组里的元素以此应用灰调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.map(callback[,thisArg]);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>callback():这个函数为新数组产生一个元素，它接受的参数：<ul>\n<li>currentValue: 数组当前遍历到的元素</li>\n<li>index: 数组中当前元素序数</li>\n<li>array: 当前正在处理的数组</li>\n</ul>\n</li>\n<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span></span><br><span class=\"line\">  integers = [<span class=\"number\">1</span>, <span class=\"number\">-0</span>, <span class=\"number\">9</span>, <span class=\"number\">-8</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">  str = <span class=\"string\">'hello world how ya doing?'</span>;</span><br><span class=\"line\"> <span class=\"comment\">//将整数映射为他们自己知道的绝对值</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(integers.map(<span class=\"built_in\">Math</span>.abs));</span><br><span class=\"line\"> <span class=\"comment\">//将数组中的元素与自己的位置序数相乘</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(numbers.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,i</span>)</span>&#123;<span class=\"keyword\">return</span> x*i&#125;));</span><br><span class=\"line\"> <span class=\"comment\">//单词隔一个变一个大写</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(str.split(<span class=\"string\">' '</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s,i</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span> === <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s.toUpperCase();</span><br><span class=\"line\">     &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;))</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>尽管Array.prototype.map方法是Javascript中数组对象的标准方法，你也可以很容易地扩展自己的对象。<br>MyObject.prototype.map = function(f) {<br> return new MyObject(f(this.value));<br>};</p>\n</blockquote>\n<h3 id=\"Array-prototype-filter\"><a href=\"#Array-prototype-filter\" class=\"headerlink\" title=\"Array.prototype.filter()\"></a>Array.prototype.filter()</h3><p>filter()函数用于把数组中的一些元素筛选出来。回调函数必须返回真(保留到新数组里)或假(扔掉)。用map()可以做类似的事情，就是你像扔掉的元素返回为null，不过filter()函数会在新数组里面删除这些不要的元素，而不是留个null占着位置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.filter(callback[,thisArg]);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>callback(): 这个函数用来测试数组中的每个元素，要保留返回真，否则返回假。他有这些参数：<ul>\n<li>currentValue: 数组当前遍历到的元素</li>\n<li>index: 数组中当前元素的序数</li>\n<li>array: 当前正在处理的数组</li>\n</ul>\n</li>\n<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myarray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">words = <span class=\"string\">'hello 123 world how 345 ya doing'</span>.split(<span class=\"string\">' '</span>);</span><br><span class=\"line\">re = <span class=\"string\">'[a-zA-Z]'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 筛选整数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"><span class=\"comment\">// 筛选所有含字母的单词</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(words.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.match(re);</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"><span class=\"comment\">// 随机移除数组中的元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myarray.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-reduce\"><a href=\"#Array-prototype-reduce\" class=\"headerlink\" title=\"Array.prototype.reduce()\"></a>Array.prototype.reduce()</h3><p>reduce()函数，有时也称为fold，它用于把数组中的所有值聚集在一起。回调需要返回组合对象的逻辑。对于数字来说，他们往往会被加到一起或者乘到一起。对于字符串来说，他们往往是被追加到一起。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.reduce(callback[,initialValue]);</span><br></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li>callback()：此函数把两个对象合并成一个对象，并将其返回。参数有：<ul>\n<li>previousValue：上一次回调函数被调用时返回的值，或者是初始值（如果有的话）</li>\n<li>currentValue：数组当前正在处理的元素</li>\n<li>index：数组中当前元素的序数</li>\n<li>array：当前正在处理的数组</li>\n</ul>\n</li>\n<li>initialValue：可选。第一次回调所传入参数的初始值</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 把数组中所有的值加起来</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 查找数组中最大的值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(a, b) <span class=\"comment\">// max()函数只能有两个参数</span></span><br><span class=\"line\">  &#125;) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-forEach\"><a href=\"#Array-prototype-forEach\" class=\"headerlink\" title=\"Array.prototype.forEach()\"></a>Array.prototype.forEach()</h3><p>forEach()函数本质上是map()函数的非纯版本，它会遍历整个数组，并对每个元素应用回调。 然而这些回调函数不返回值。它是实现for循环的一个更纯粹的方式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.forEach(callback[,initialValue]);</span><br></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li>callback()：对数组中每一个元素所应用的。参数有：<ul>\n<li>currentValue：数组当前正在处理的元素</li>\n<li>index：数组中当前元素的序数</li>\n<li>array：当前正在处理的数组</li>\n</ul>\n</li>\n<li>thisArg：可选。回调函数中作为this的值</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> nodes = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  elem.textContent = x;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> elem;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 对每一个元素的值输出日志</span></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 把节点追加到DOM上</span></span><br><span class=\"line\">nodes.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(x)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-concat\"><a href=\"#Array-prototype-concat\" class=\"headerlink\" title=\"Array.prototype.concat()\"></a>Array.prototype.concat()</h3><p>如果不用for或while处理数组，你会经常需要把数组拼接起来。另一个Javascript内建函数concat就是专门干这事儿的。 concat函数会返回一个新数组但不改变旧数组。它可以把你传入的所有参数拼接到一起。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].concat([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>]) <span class=\"comment\">// 拼接两个数组</span></span><br><span class=\"line\"><span class=\"comment\">// Output: [1, 2, 3, 'a','b','c']</span></span><br></pre></td></tr></table></figure></p>\n<p>它返回两个数组拼接成的数组，同时原来的那些数组没有被改变。这就意味着concat函数可以链式调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = arr1.concat(arr2, arr3);</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = arr1.concat(arr2).concat(arr3));</span><br><span class=\"line\"><span class=\"keyword\">var</span> z = arr1.concat(arr2.concat(arr3)));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-reverse\"><a href=\"#Array-prototype-reverse\" class=\"headerlink\" title=\"Array.prototype.reverse()\"></a>Array.prototype.reverse()</h3><p>这个Javascript内建函数是用于数组变形的。reverse函数用于将一个数组反转，也就是第个一元素会跑到最后， 而最后一个元素变成了第一个元素。</p>\n<p>然而，这个函数并不会返回一个新的数组，而是把原来的数组替换掉了。我们可以做个更好的。下面是一个纯的反转数组函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> invert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, i, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a[a.length - (i + <span class=\"number\">1</span>)];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> q = invert([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h3><p>与map()、filter()和reduce()函数相似，排序函数sort()需要传入一个回调函数来定义数组如何排序。 但是，跟reverse()一样，它也会把原来的数组替换。这可不太好。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">200</span>, <span class=\"number\">12</span>, <span class=\"number\">56</span>, <span class=\"number\">7</span>, <span class=\"number\">344</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;<span class=\"keyword\">return</span> a–b&#125;) );</span><br><span class=\"line\"><span class=\"comment\">// arr现在是: [7, 12, 56, 200, 344];</span></span><br></pre></td></tr></table></figure>\n<p>我们可以写一个纯函数的sort()，但是排序算法的源代码很麻烦。对于特别大的数组，应当根据特定的数据结构来选用适合的算法， 比如快速排序、合并排序、冒泡排序等等</p>\n<h3 id=\"Array-prototype-every-amp-amp-Array-prototype-some\"><a href=\"#Array-prototype-every-amp-amp-Array-prototype-some\" class=\"headerlink\" title=\"Array.prototype.every() &amp;&amp; Array.prototype.some()\"></a>Array.prototype.every() &amp;&amp; Array.prototype.some()</h3><p>Array.prototype.every() 和 Array.prototype.some() 都是纯的高阶函数，它们是Array对象的方法， 通过回调函数根据数组各元素返回的布尔值（或相当于布尔的值）来进行测试。如果数组中所有的元素通过回调函数计算都返回True， every()函数就返回true；如果数组中有一个元素返回True，some()函数就返回True。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !<span class=\"built_in\">isNaN</span>(<span class=\"built_in\">parseFloat</span>(n)) &amp;&amp; <span class=\"built_in\">isFinite</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].every(isNumber)); <span class=\"comment\">// Return: true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'a'</span>].every(isNumber)); <span class=\"comment\">// Return: false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'a'</span>].some(isNumber)); <span class=\"comment\">// Return: true</span></span><br></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>在这章，会覆盖函数式编程的核心概念：</p>\n<ul>\n<li>使用函数和数组实现控制流</li>\n<li>编写纯函数、匿名函数、递归函数等等</li>\n<li>像对象那样传递函数</li>\n<li>利用map()、filter()和reduce()函数</li>\n</ul>\n</blockquote>\n<h2 id=\"char1-函数式编程语言\"><a href=\"#char1-函数式编程语言\" class=\"headerlink\" title=\"char1.函数式编程语言\"></a>char1.函数式编程语言</h2><p>函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。</p>\n<h3 id=\"是什么让一个语言具有函数式特征？\"><a href=\"#是什么让一个语言具有函数式特征？\" class=\"headerlink\" title=\"是什么让一个语言具有函数式特征？\"></a>是什么让一个语言具有函数式特征？</h3><p>函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。</p>\n<p>同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。</p>\n<p>然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th style=\"text-align:center\">命令式</th>\n<th style=\"text-align:center\">函数式</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>编程风格</td>\n<td style=\"text-align:center\">一步一步地执行，并且要管理状态的变化</td>\n<td style=\"text-align:center\">描述问题和所需的数据变化已解决问题</td>\n</tr>\n<tr>\n<td>状态变化</td>\n<td style=\"text-align:center\">很重要</td>\n<td style=\"text-align:center\">不存在</td>\n</tr>\n<tr>\n<td>执行顺序</td>\n<td style=\"text-align:center\">很重要</td>\n<td style=\"text-align:center\">不太重要</td>\n</tr>\n<tr>\n<td>主要的控制流</td>\n<td style=\"text-align:center\">循环、条件、函数调用</td>\n<td style=\"text-align:center\">函数调用和递归</td>\n</tr>\n<tr>\n<td>主要的操作单元</td>\n<td style=\"text-align:center\">结构体和类对象</td>\n<td style=\"text-align:center\">函数作为一等公民的对象和数据集</td>\n</tr>\n</tbody>\n</table>\n<p>函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。</p>\n<blockquote>\n<p>注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。</p>\n</blockquote>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。</p>\n<p>不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。</p>\n<p>总的来说，什么是使用函数式编程真正实际的优点呢？</p>\n<h3 id=\"更加简洁的代码\"><a href=\"#更加简洁的代码\" class=\"headerlink\" title=\"更加简洁的代码\"></a>更加简洁的代码</h3><p>函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。</p>\n<p>例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge2dArrayIntoOne</span>(<span class=\"params\">arrays</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> count = arrays.length;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(count);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;count;i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j=<span class=\"number\">0</span>,jlen = array[i].length;j&lt;jlen;j++)&#123;</span><br><span class=\"line\">            merged[c++] = arrays[i][j];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在使用函数式技术，可以写成这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> merge2dArrayIntoOne = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arrays</span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> arrays.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p,n</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> p.concat(n);</span><br><span class=\"line\"> &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。</p>\n<h3 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h3><p>函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。</p>\n<h3 id=\"复用性\"><a href=\"#复用性\" class=\"headerlink\" title=\"复用性\"></a>复用性</h3><p>由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。</p>\n<p>在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。</p>\n<h3 id=\"减少耦合\"><a href=\"#减少耦合\" class=\"headerlink\" title=\"减少耦合\"></a>减少耦合</h3><p>耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。</p>\n<h3 id=\"数学正确性\"><a href=\"#数学正确性\" class=\"headerlink\" title=\"数学正确性\"></a>数学正确性</h3><p>最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。</p>\n<h3 id=\"非函数式世界中的函数式编程\"><a href=\"#非函数式世界中的函数式编程\" class=\"headerlink\" title=\"非函数式世界中的函数式编程\"></a>非函数式世界中的函数式编程</h3><p>函数式和非函数式编程能混合在一起吗？</p>\n<p>这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。</p>\n<p>例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = [];count = <span class=\"number\">0</span>;</span><br><span class=\"line\">text = myString.split(<span class=\"string\">' '</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;count&lt;<span class=\"number\">4</span>,i&lt;text.length;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!text[i].match(<span class=\"regexp\">/[0-9]/</span>))&#123;</span><br><span class=\"line\">        words = words.concat(text[i]);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数式编程会这样写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> words = myString.split(<span class=\"string\">' '</span>).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (!x.match(<span class=\"regexp\">/[0-9]/</span>));</span><br><span class=\"line\">&#125;).slice(<span class=\"number\">0</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(words);</span><br></pre></td></tr></table></figure>\n<p>如果有一个函数式编程的工具库，代码可以进一步被简化：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> words = toSequence(myString).match(<span class=\"regexp\">/[a-zA-Z]+/</span>).first(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的”words”和”count”变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。</p>\n<h3 id=\"Javascript是函数式编程语言吗？\"><a href=\"#Javascript是函数式编程语言吗？\" class=\"headerlink\" title=\"Javascript是函数式编程语言吗？\"></a>Javascript是函数式编程语言吗？</h3><p>现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？</p>\n<p>Javascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。</p>\n<p>它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：</p>\n<ul>\n<li>Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。</li>\n<li>Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。</li>\n<li>Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。</li>\n</ul>\n<p>也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。</p>\n<p>关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。</p>\n<p>最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。</p>\n<h2 id=\"char2-与函数共舞\"><a href=\"#char2-与函数共舞\" class=\"headerlink\" title=\"char2.与函数共舞\"></a>char2.与函数共舞</h2><blockquote>\n<p>有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 –John Carmack，游戏《毁灭战士》首席程序员</p>\n</blockquote>\n<p>函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。</p>\n<p>我们从Javascript的一个小尴尬开始。</p>\n<p>假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;value:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">accumulate</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    values.push(obj.value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">accumulate(obj1);</span><br><span class=\"line\">accumulate(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values); <span class=\"comment\">//Output: [obj1.value,obj2.value]</span></span><br></pre></td></tr></table></figure>\n<p>这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。</p>\n<p>但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">accumulate2</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">    values.push(obj.value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulate2(obj1)); <span class=\"comment\">// Returns: [obj1.value]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulate2(obj2)); <span class=\"comment\">// Returns: [obj2.value]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulate2(obj3)); <span class=\"comment\">// Returns: [obj3.value]</span></span><br></pre></td></tr></table></figure>\n<p>只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValueAccumulator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> accumulate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        value.push(obj.value);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    accumulate();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。</p>\n<p>我们需要的是一个自调用函数</p>\n<h3 id=\"自调用函数和闭包\"><a href=\"#自调用函数和闭包\" class=\"headerlink\" title=\"自调用函数和闭包\"></a>自调用函数和闭包</h3><p>如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> ValueAccumulator = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> accumulate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(obj)&#123;</span><br><span class=\"line\">            values.push(obj.value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> accumulates;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//This allows us to do this</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> accumulator = ValueAccumulator();</span><br><span class=\"line\">accumulator(obj1);</span><br><span class=\"line\">accumulator(obj2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulator()); <span class=\"comment\">//Output: [obj1.value,obj2.value]</span></span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ValueAccumulator = -&gt;</span><br><span class=\"line\"> values = []</span><br><span class=\"line\"> (obj) -&gt;</span><br><span class=\"line\"> values.push obj.value <span class=\"keyword\">if</span> obj</span><br><span class=\"line\"> values</span><br></pre></td></tr></table></figure>\n<p>这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。</p>\n<blockquote>\n<p>Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。</p>\n</blockquote>\n<p>闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。</p>\n<p>高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。</p>\n<p>这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。</p>\n<p>在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。</p>\n<p>来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> accumulator2 = ValueAccumulator();</span><br><span class=\"line\"><span class=\"keyword\">var</span> objects = [obj1, obj2, obj3]; <span class=\"comment\">// 这个数组可以很大</span></span><br><span class=\"line\">objects.forEach(accumulator2);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(accumulator2());</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h3><p>纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。</p>\n<p>用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。</p>\n<p>纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。</p>\n<p>举例说明来对比一下非纯函数和纯函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 把信息打印到屏幕中央的函数</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> printCenter = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  elem.textContent = str;</span><br><span class=\"line\">  elem.style.position = <span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">  elem.style.top = <span class=\"built_in\">window</span>.innerHeight / <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  elem.style.left = <span class=\"built_in\">window</span>.innerWidth / <span class=\"number\">2</span> + <span class=\"string\">\"px\"</span>;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(elem);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">printCenter(<span class=\"string\">'hello world'</span>);</span><br><span class=\"line\"><span class=\"comment\">// 纯函数完成相同的事情</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> printSomewhere = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">str, height, width</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  elem.textContent = str;</span><br><span class=\"line\">  elem.style.position = <span class=\"string\">'absolute'</span>;</span><br><span class=\"line\">  elem.style.top = height;</span><br><span class=\"line\">  elem.style.left = width;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> elem;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">document</span>.body.appendChild(</span><br><span class=\"line\">printSomewhere(<span class=\"string\">'hello world'</span>,</span><br><span class=\"line\"><span class=\"built_in\">window</span>.innerHeight / <span class=\"number\">2</span>) + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>,</span><br><span class=\"line\"><span class=\"built_in\">window</span>.innerWidth / <span class=\"number\">2</span>) + <span class=\"number\">10</span> + <span class=\"string\">\"px\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>非纯函数依赖window对象的状态来计算宽度和高度，自给自足的纯函数则要求这些值作为参数传入。 实际上它就允许了信息打印到任何地方，这也让这个函数有了更多用途。</p>\n<p>非纯函数看起来是一个更容易的选择，因为它在自己内部实现了追加元素，而不是返回元素。 返回了值的纯函数printSomewhere()则会在跟其他函数式编程技术的配合下有更好的表现。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> messages = [<span class=\"string\">'Hi'</span>, <span class=\"string\">'Hello'</span>, <span class=\"string\">'Sup'</span>, <span class=\"string\">'Hey'</span>, <span class=\"string\">'Hola'</span>];</span><br><span class=\"line\">messages.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s,i</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> printSomewhere(s,<span class=\"number\">100</span>*i*<span class=\"number\">10</span>,<span class=\"number\">100</span>*i*<span class=\"number\">10</span>);</span><br><span class=\"line\">&#125;).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">element</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.body.appendChild(element);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>当一个函数是纯的，也就是不依赖于状态和环境，我们就不用管它实际是什么时候被计算出来。后面的惰性求职将讲到这个。</p>\n</blockquote>\n<h3 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h3><p>把函数作为头等对象的另一个好处就是匿名函数</p>\n<p>就想名字暗示的那样，匿名函数就是没有名字的函数。实际上不止这些，它允许了在现场定义临时逻辑的能力。通常这带来的好处就是方便：如果一个函数只用一次，没有必要给他浪费一变量名。</p>\n<p>下面是一些匿名函数的例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//写匿名函数的标准方式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'hello world'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//匿名函数可以赋值给变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> anon = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//匿名函数用于代替具名回调函数，这是匿名函数的一个更常见的用处</span></span><br><span class=\"line\">setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime())</span><br><span class=\"line\">&#125;,<span class=\"number\">1000</span>);</span><br><span class=\"line\"><span class=\"comment\">//Output:  1413249010672, 1413249010673, 1413249010674, ...</span></span><br><span class=\"line\"><span class=\"comment\">//如果没有把它包含在一个匿名函数中，他将立刻被执行，并且返回一个undefined作为回调函数</span></span><br><span class=\"line\">setInterval(<span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()),<span class=\"number\">1000</span>)</span><br><span class=\"line\"><span class=\"comment\">//Output:  1413249010671</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是匿名函数和高阶函数配合使用的例子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">powersOf</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//this is an anonymous function!</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.pow(x,y);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">powerOfTwo = powersOf(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfTwo(<span class=\"number\">1</span>)); <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfTwo(<span class=\"number\">2</span>)); <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfTwo(<span class=\"number\">3</span>)); <span class=\"comment\">// 8</span></span><br><span class=\"line\">powerOfThree = powersOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfThree(<span class=\"number\">3</span>)); <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powerOfThree(<span class=\"number\">10</span>)); <span class=\"comment\">// 59049</span></span><br></pre></td></tr></table></figure></p>\n<p>这里返回的那个函数不需要命名，它可以在powerOf()函数外的任何地方使用，这就是匿名函数。</p>\n<p>还记得累加器的那个函数吗？它可以用匿名函数重写<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;value:<span class=\"number\">1</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    obj2 = &#123;value:<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> values = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">//匿名函数</span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\"> <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">//有一个匿名函数！</span></span><br><span class=\"line\">     <span class=\"keyword\">if</span>(obj)&#123;</span><br><span class=\"line\">         values.push(obj.value);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">     &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)(); <span class=\"comment\">//让它自执行</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values(obj1)); <span class=\"comment\">// Returns: [obj.value]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(values(obj2)); <span class=\"comment\">// Returns: [obj.value, obj2.value]</span></span><br></pre></td></tr></table></figure></p>\n<p>真棒！一个高阶匿名纯函数。我们怎么这么幸运？实际上还不止这些，这里面还有个自执行的结构， (function(){…})();。函数后面跟的那个括号可以让函数立即执行。在上面的例子里， 给外面values赋的值是函数执行的结果。</p>\n<blockquote>\n<p>匿名函数不仅仅是语法糖，他们是lambda演算的化身。请听我说下去…… lambda演算早在计算机和计算机语言被发明的很久以前就出现了。它只是个研究函数的数学概念。 非同寻常的是，尽管它只定义了三种表达式：变量引用，函数调用和匿名函数，但它被发现是图灵完整的。 如今，lambda演算处于所有函数式语言的核心，包括javascript。由于这个原因，匿名函数往往被称作lambda表达式。</p>\n</blockquote>\n<p>匿名函数也有一个缺点，那就是他们在调用栈中难以被识别，这会对调试造成一些困难。要小心使用匿名函数。</p>\n<h3 id=\"方法链\"><a href=\"#方法链\" class=\"headerlink\" title=\"方法链\"></a>方法链</h3><p>在Javascript中，把方法链在一起很常见。如果你使用过jQuery，你应该用过这种技巧。它有时也被叫做“建造者模式”。</p>\n<p>这种技术用于简化多个函数一次应用于一个对象的代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个函数占用一行来调用，不如……</span></span><br><span class=\"line\">arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\">arr1 = arr.reverse();</span><br><span class=\"line\">arr2 = arr1.concat([<span class=\"number\">5</span>, <span class=\"number\">6</span>]);</span><br><span class=\"line\">arr3 = arr2.map(<span class=\"built_in\">Math</span>.sqrt);</span><br><span class=\"line\"><span class=\"comment\">// ……把它们串到一起放在一行里面</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].reverse().concat([<span class=\"number\">5</span>, <span class=\"number\">6</span>]).map(<span class=\"built_in\">Math</span>.sqrt));</span><br><span class=\"line\"><span class=\"comment\">// 括号也许可以说明是怎么回事</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(((([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]).reverse()).concat([<span class=\"number\">5</span>, <span class=\"number\">6</span>])).map(<span class=\"built_in\">Math</span>.sqrt));</span><br></pre></td></tr></table></figure></p>\n<p>这只有在函数是目标对象所拥有的方法时才有效。如果你要创建自己的函数，比如要把两个数组zip到一起，你必须把它声明为Array.prototype对象的成员，看一下下面的代码片段：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.zip = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们就可以写成下面的样子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr.zip([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>]).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> n*<span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>递归应该是最著名的函数式编程技术。就是一个函数调用它自己。</p>\n<p>当函数调用自己，有时候奇怪的事情就发生了。它的表明既是一个循环，多次执行同样的代码，也是一个函数栈。</p>\n<p>使用递归函数时必须十分小心地避免无限递归。就像循环一样，必须有个停止条件。这叫做基准情形(base case)。</p>\n<p>下面有个例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> foo(n<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></p>\n<p>递归和循环可一个互相转换。但是递归算法往往更合适，甚至是必要的，因为有些情形用循环很费劲。</p>\n<p>一个明显的例子就是遍历树。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getLeafs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">node</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//base case</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.innerText;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//recursive case</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node.childNodes.map(getLeafs);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"分而治之\"><a href=\"#分而治之\" class=\"headerlink\" title=\"分而治之\"></a>分而治之</h3><p>递归不只是代替for和while循环的有趣的方式。有个叫分而治之的算法，他递归的把问题拆分成更小的情形，直到小到可以解决。</p>\n<p>历史上有个欧几里得算法用于找出两个数的最大公分母<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">gcd</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(b === <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//基准情形</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> gcd(b,a%b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(gcd(<span class=\"number\">12</span>,<span class=\"number\">8</span>));</span><br></pre></td></tr></table></figure></p>\n<p>理论上来说，分而治之很牛逼，但是现实中有用吗？当然！用Javascript的函数对数组排序不是很好，它不但替换了原数组，也就是说数组不是不变的，并且他还不够可靠、灵活。通过分而治之，饿哦们可以做到更好。</p>\n<p>全部的实现代码大概要40行，这里只是展示伪代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mergeSort = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(arr.length &lt; <span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//基准情形：只有0或1个元素的数组是不用排序的</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> items;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归情形：把数组拆分、排序、合并</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> middle = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 分</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> left = mergeSort(arr.slice(<span class=\"number\">0</span>, middle));</span><br><span class=\"line\">        <span class=\"keyword\">var</span> right = mergeSort(arr.slice(middle));</span><br><span class=\"line\">        <span class=\"comment\">// 治</span></span><br><span class=\"line\">        <span class=\"comment\">// merge是一个辅助函数，返回一个新数组，它将两个数组合并到一起</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> merge(left, right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"惰性求值\"><a href=\"#惰性求值\" class=\"headerlink\" title=\"惰性求值\"></a>惰性求值</h3><p>惰性求值，也叫做非严格求值，它会按需调用并推迟执行，它是一种直到需要时才计算函数结果的求值策略， 这对函数式编程特别有用。比如有行代码是 x = func()，调用这个func()函数得到的返回值会赋值给x。 但是x等于什么一开始并不重要，直到需要用到x的时候。等到需要用x的时候才调用func()就是惰性求值。</p>\n<p>这一策略可以让性能明显增强，特别是当使用方法链和数组这些函数式程序员最喜爱的程序流技术的时候。 惰性求值让人兴奋的一个优点是让无限序列成为可能。因为在它实在无法继续延迟之前，什么都不需要被真正计算出来。 它可以是这个样子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 理想化的JavaScript伪代码:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> infinateNums = range(<span class=\"number\">1</span> to infinity);</span><br><span class=\"line\"><span class=\"keyword\">var</span> tenPrimes = infinateNums.getPrimeNumbers().first(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure>\n<p>这为很多可能性敞开了大门，比如异步执行、并行计算、组合，这只列举了一点。</p>\n<p>然而，还有个问题，Javascript本身并不支持惰性求值，也就是说存在让Javascript模拟惰性求值的函数库。</p>\n<h2 id=\"char3-函数式程序员的工具集\"><a href=\"#char3-函数式程序员的工具集\" class=\"headerlink\" title=\"char3.函数式程序员的工具集\"></a>char3.函数式程序员的工具集</h2><p>如果你仔细看了到目前为止出现过的示例代码，你会发现这里面的一些方法不太熟悉。 它们是map()、filter()和reduce()函数，它们对任何语言的函数式编程都至关重要。 它们可以让你不必使用循环和语句，写出更简洁的代码。</p>\n<p>map()、filter()和reduce()函数组成了函数式程序员工具集的核心部分，这个工具集包括一系列纯的、 高阶的函数，它们是函数式方法的主力。实际上，它们是纯函数和高阶函数的典型，它们以一个函数为输入， 返回一个输出结果，并且不产生副作用。</p>\n<p>然而它们是浏览器中ECMAScript 5.1的实现标准，它们只工作于数组。每次调用它们，一个新的数组会被创建并返回， 而原来存在的那个数组不会被改变。它们以函数为输入，经常使用匿名函数作为回调函数。它们遍历数组， 并对数组的每一个元素应用这个函数！</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\">newArray = myArray.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;<span class=\"keyword\">return</span> x*<span class=\"number\">2</span>&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray);  <span class=\"comment\">// Output: [1,2,3,4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newArray); <span class=\"comment\">// Output: [2,4,6,8]</span></span><br></pre></td></tr></table></figure>\n<p>还有一点，它们只作用于数组，无法作用于其它可迭代的数据结构，比如对象。不用担心， 有很多库比如Underscore.js，Lazy.js，stream.js等等都实现了它们自己的更强大的map()、 filter()和reduce()。</p>\n<h3 id=\"回调\"><a href=\"#回调\" class=\"headerlink\" title=\"回调\"></a>回调</h3><p>如果你以前从来没用过回调，那这个概念可能会让你有些迷惑。尤其是在javascript中，javascript给出了好几种声明函数的方式。</p>\n<p>回调函数用于传递给另一个函数供他们使用，这是一种像传递对象一样来传递逻辑的方式：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x + <span class=\"number\">1</span>&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.map(myCallback));</span><br></pre></td></tr></table></figure></p>\n<p>对于比较简单的任务可以用匿名函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(myArray.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> x+<span class=\"number\">1</span>&#125;))</span><br></pre></td></tr></table></figure></p>\n<p>回调不仅用于函数式编程，在javascript中它们能干很多事情。仅作为例子，这有个callback()函数用于jquery的AJAX调用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\">xhr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(xht.status);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(myUrl).done(myCallback);</span><br></pre></td></tr></table></figure></p>\n<p>注意这里只用了函数的名字，因为我们并不是要调用函数而是传递函数，写成这样就错了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.ajax(myURI).fail(myCallback(xhr)); </span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\">$.ajax(myURI).fail(myCallback());</span><br></pre></td></tr></table></figure></p>\n<p>如果我们调用了函数会发生什么？在这个例子里，myCallback(xhr)会尝试执行，控制台将打印“undefined”， 并会返回true。当ajax()完成调用时，它根据名字找到的回调函数将是一个”true”，然后就报错了。</p>\n<p>也就是说我们无法指定给回调函数传什么参数，如果我们的回调函数需要让ajax()函数传给他我们想要的参数， 我们可以把回到函数包在一个匿名函数里：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myCallback</span>(<span class=\"params\">status</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(status);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$.ajax(myURI).done(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">xhr</span>) </span>&#123;</span><br><span class=\"line\">  myCallback(xhr.status)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-map\"><a href=\"#Array-prototype-map\" class=\"headerlink\" title=\"Array.prototype.map()\"></a>Array.prototype.map()</h3><p>map()是这些函数的老大，它简单地对数组里的元素以此应用灰调函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.map(callback[,thisArg]);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>callback():这个函数为新数组产生一个元素，它接受的参数：<ul>\n<li>currentValue: 数组当前遍历到的元素</li>\n<li>index: 数组中当前元素序数</li>\n<li>array: 当前正在处理的数组</li>\n</ul>\n</li>\n<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span></span><br><span class=\"line\">  integers = [<span class=\"number\">1</span>, <span class=\"number\">-0</span>, <span class=\"number\">9</span>, <span class=\"number\">-8</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">  numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>],</span><br><span class=\"line\">  str = <span class=\"string\">'hello world how ya doing?'</span>;</span><br><span class=\"line\"> <span class=\"comment\">//将整数映射为他们自己知道的绝对值</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(integers.map(<span class=\"built_in\">Math</span>.abs));</span><br><span class=\"line\"> <span class=\"comment\">//将数组中的元素与自己的位置序数相乘</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(numbers.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x,i</span>)</span>&#123;<span class=\"keyword\">return</span> x*i&#125;));</span><br><span class=\"line\"> <span class=\"comment\">//单词隔一个变一个大写</span></span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(str.split(<span class=\"string\">' '</span>).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s,i</span>)</span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(i%<span class=\"number\">2</span> === <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s.toUpperCase();</span><br><span class=\"line\">     &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;))</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>尽管Array.prototype.map方法是Javascript中数组对象的标准方法，你也可以很容易地扩展自己的对象。<br>MyObject.prototype.map = function(f) {<br> return new MyObject(f(this.value));<br>};</p>\n</blockquote>\n<h3 id=\"Array-prototype-filter\"><a href=\"#Array-prototype-filter\" class=\"headerlink\" title=\"Array.prototype.filter()\"></a>Array.prototype.filter()</h3><p>filter()函数用于把数组中的一些元素筛选出来。回调函数必须返回真(保留到新数组里)或假(扔掉)。用map()可以做类似的事情，就是你像扔掉的元素返回为null，不过filter()函数会在新数组里面删除这些不要的元素，而不是留个null占着位置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.filter(callback[,thisArg]);</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>callback(): 这个函数用来测试数组中的每个元素，要保留返回真，否则返回假。他有这些参数：<ul>\n<li>currentValue: 数组当前遍历到的元素</li>\n<li>index: 数组中当前元素的序数</li>\n<li>array: 当前正在处理的数组</li>\n</ul>\n</li>\n<li>thisArg: 这是个可选参数，当执行回调的时候它作为回调函数的this</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myarray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">words = <span class=\"string\">'hello 123 world how 345 ya doing'</span>.split(<span class=\"string\">' '</span>);</span><br><span class=\"line\">re = <span class=\"string\">'[a-zA-Z]'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 筛选整数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">-2</span>, <span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>].filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &gt; <span class=\"number\">0</span></span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"><span class=\"comment\">// 筛选所有含字母的单词</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(words.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.match(re);</span><br><span class=\"line\">&#125;));</span><br><span class=\"line\"><span class=\"comment\">// 随机移除数组中的元素</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(myarray.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.random() * <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-reduce\"><a href=\"#Array-prototype-reduce\" class=\"headerlink\" title=\"Array.prototype.reduce()\"></a>Array.prototype.reduce()</h3><p>reduce()函数，有时也称为fold，它用于把数组中的所有值聚集在一起。回调需要返回组合对象的逻辑。对于数字来说，他们往往会被加到一起或者乘到一起。对于字符串来说，他们往往是被追加到一起。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.reduce(callback[,initialValue]);</span><br></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li>callback()：此函数把两个对象合并成一个对象，并将其返回。参数有：<ul>\n<li>previousValue：上一次回调函数被调用时返回的值，或者是初始值（如果有的话）</li>\n<li>currentValue：数组当前正在处理的元素</li>\n<li>index：数组中当前元素的序数</li>\n<li>array：当前正在处理的数组</li>\n</ul>\n</li>\n<li>initialValue：可选。第一次回调所传入参数的初始值</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"comment\">// 把数组中所有的值加起来</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>].reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"comment\">// 查找数组中最大的值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(numbers.reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.max(a, b) <span class=\"comment\">// max()函数只能有两个参数</span></span><br><span class=\"line\">  &#125;) </span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-forEach\"><a href=\"#Array-prototype-forEach\" class=\"headerlink\" title=\"Array.prototype.forEach()\"></a>Array.prototype.forEach()</h3><p>forEach()函数本质上是map()函数的非纯版本，它会遍历整个数组，并对每个元素应用回调。 然而这些回调函数不返回值。它是实现for循环的一个更纯粹的方式。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">语法：arr.forEach(callback[,initialValue]);</span><br></pre></td></tr></table></figure></p>\n<p>参数：</p>\n<ul>\n<li>callback()：对数组中每一个元素所应用的。参数有：<ul>\n<li>currentValue：数组当前正在处理的元素</li>\n<li>index：数组中当前元素的序数</li>\n<li>array：当前正在处理的数组</li>\n</ul>\n</li>\n<li>thisArg：可选。回调函数中作为this的值</li>\n</ul>\n<p>例子：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> nodes = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> elem = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">  elem.textContent = x;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> elem;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 对每一个元素的值输出日志</span></span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x)</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 把节点追加到DOM上</span></span><br><span class=\"line\">nodes.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(x)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Array-prototype-concat\"><a href=\"#Array-prototype-concat\" class=\"headerlink\" title=\"Array.prototype.concat()\"></a>Array.prototype.concat()</h3><p>如果不用for或while处理数组，你会经常需要把数组拼接起来。另一个Javascript内建函数concat就是专门干这事儿的。 concat函数会返回一个新数组但不改变旧数组。它可以把你传入的所有参数拼接到一起。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>].concat([<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>]) <span class=\"comment\">// 拼接两个数组</span></span><br><span class=\"line\"><span class=\"comment\">// Output: [1, 2, 3, 'a','b','c']</span></span><br></pre></td></tr></table></figure></p>\n<p>它返回两个数组拼接成的数组，同时原来的那些数组没有被改变。这就意味着concat函数可以链式调用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = [<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> x = arr1.concat(arr2, arr3);</span><br><span class=\"line\"><span class=\"keyword\">var</span> y = arr1.concat(arr2).concat(arr3));</span><br><span class=\"line\"><span class=\"keyword\">var</span> z = arr1.concat(arr2.concat(arr3)));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(y);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(z);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-reverse\"><a href=\"#Array-prototype-reverse\" class=\"headerlink\" title=\"Array.prototype.reverse()\"></a>Array.prototype.reverse()</h3><p>这个Javascript内建函数是用于数组变形的。reverse函数用于将一个数组反转，也就是第个一元素会跑到最后， 而最后一个元素变成了第一个元素。</p>\n<p>然而，这个函数并不会返回一个新的数组，而是把原来的数组替换掉了。我们可以做个更好的。下面是一个纯的反转数组函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> invert = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, i, a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a[a.length - (i + <span class=\"number\">1</span>)];</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> q = invert([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(q);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Array-prototype-sort\"><a href=\"#Array-prototype-sort\" class=\"headerlink\" title=\"Array.prototype.sort()\"></a>Array.prototype.sort()</h3><p>与map()、filter()和reduce()函数相似，排序函数sort()需要传入一个回调函数来定义数组如何排序。 但是，跟reverse()一样，它也会把原来的数组替换。这可不太好。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">200</span>, <span class=\"number\">12</span>, <span class=\"number\">56</span>, <span class=\"number\">7</span>, <span class=\"number\">344</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;<span class=\"keyword\">return</span> a–b&#125;) );</span><br><span class=\"line\"><span class=\"comment\">// arr现在是: [7, 12, 56, 200, 344];</span></span><br></pre></td></tr></table></figure>\n<p>我们可以写一个纯函数的sort()，但是排序算法的源代码很麻烦。对于特别大的数组，应当根据特定的数据结构来选用适合的算法， 比如快速排序、合并排序、冒泡排序等等</p>\n<h3 id=\"Array-prototype-every-amp-amp-Array-prototype-some\"><a href=\"#Array-prototype-every-amp-amp-Array-prototype-some\" class=\"headerlink\" title=\"Array.prototype.every() &amp;&amp; Array.prototype.some()\"></a>Array.prototype.every() &amp;&amp; Array.prototype.some()</h3><p>Array.prototype.every() 和 Array.prototype.some() 都是纯的高阶函数，它们是Array对象的方法， 通过回调函数根据数组各元素返回的布尔值（或相当于布尔的值）来进行测试。如果数组中所有的元素通过回调函数计算都返回True， every()函数就返回true；如果数组中有一个元素返回True，some()函数就返回True。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isNumber</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> !<span class=\"built_in\">isNaN</span>(<span class=\"built_in\">parseFloat</span>(n)) &amp;&amp; <span class=\"built_in\">isFinite</span>(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>].every(isNumber)); <span class=\"comment\">// Return: true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'a'</span>].every(isNumber)); <span class=\"comment\">// Return: false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'a'</span>].some(isNumber)); <span class=\"comment\">// Return: true</span></span><br></pre></td></tr></table></figure>"},{"title":"Redux快速上手","date":"2016-05-23T08:02:18.000Z","_content":"> 文章转载自[Redux快速上手](http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/Redux%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html)，仅供学习和参考\n\n在实际的项目中，面对复杂业务逻辑的挑战，如何清晰高效的管理应用内的数据流动成为了关键。\n\nFlux思想已经在提出后得到逐步推广，并广泛应用到实际项目中。facebook的flux实现，开源社区的reflux、redux等类库开始涌现并得到了广大开发者的认同和使用。\n\nRedux以其简单易用、文档齐全易懂等优点在开源社区得到开发者的一直好评，所以接下来让我们一起走进Redux。\n\n# 1. 基本介绍\nReact已经帮我们在视图层解决了禁止异步和直接操作DOM等问题，让页面的高效渲染和组件话开发成为了可能。美中不足的是，React依旧把处理state中数据的问题留给了你，那么，Redux的出现就是为了帮你解决这个问题\n\n## 1.1 Fulx & Redux\n最初，facebook官网提出了Flux思想管理数据流，同时也给了自己的实现方案flux来管理React应用。\n![Flux](/images/react/flux.jpg)\n1. 在view中触发action中的方法后\n2. action发送dispatch\n3. store接收新的数据进行合并，然后触发view中绑定在store上的方法\n4. 最后通过修改局部state来改变view的展示\n\n![Redux](/images/react/redux.jpg)\n1. view直接触发dispatch\n2. dispatch将action发送到reducer中后，根节点上会更新props，改变全局view\n3. redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中\n\n>相对于Flux而言，Redux的实现更简单，思路更清晰，写的代码也相对更少；只维护单一的 store.\n\n## 1.2 对Redux的介绍\n - Redux是State容器，提供可预测化的状态管理\n - 它可以让你构建一致化的应用，运行于不同的环境(客户端、服务器、原生应用)，并且易于测试\n - 还提供了redux-devtools让开发者享受超爽的开发体验\n - 体小精悍(只有2kb)且没有任何依赖\n - 拥有丰富的生态圈：教程、开发者工具、路由、组件、中间件、工具集...\n\n# 2. 快速上手\n示例代码快速体验\n```javascript\n  //这是一个reducer，形式为(state,action) => state 的纯函数。描述了action如何把state转变成下一个state。\n  //state的形式取决于你，可以是基本类型、数组、对象甚至是Immutable.js生成的数据结构。\n  //唯一的要点是当state变化时需要返回全新的对象，而不是修改传入的参数。\n  function counter(state=0,action){\n    switch (action.type){\n      case 'INCREMENT':\n        return state + 1;\n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n  //创建Redux store来存放应用的状态。\n  //API是{subscribe,dispatch,getState}\n  let store = createStore(counter);\n  //一个单纯渲染页面内容的函数\n  const PureRender = () => {\n    document.body.innerText = store.getState();\n  }\n  //可以手动订阅更新，也可以事件绑定到视图层\n  store.subscribe(PureRender);\n  //执行渲染函数\n  PureRender();\n  //改变内部state唯一方法是dispatch一个action。action可以被序列化，用日记记录和存储下来，后期还可以以回放的方式执行。\n  document.addEventListener('click',function(e){\n    //store dispatch 调度分发一个action(fire)\n    store.dispatch({type:\"DECREMENT\"})\n  })\n```\n\n# 3. 理解Redux的核心概念\n## 3.1 Action & Action Creator\n在Redux中，改变state只能通过action,它是store数据的唯一来源。一般来说你会通过store.dispatch()将action传到store。并且每个action都必须是javascript的简单对象，例如：\n```\n  {\n    type:\"ADD_TODO\"，\n    text:\"Learn Redux\"\n  }\n```\n\nRedux要求action是可以被序列化的，这使得应用程序的状态保存、回放、Undo之类的功能可以被实现。因此，action中不能包含诸如函数调用这样的不可序列化的字段。\naction的格式是有建议规范的，可以包含以下字段：\n```\n  {\n    type:\"ADD_TODO\",\n    payload:{\n      text:\"Do something\"\n    },\n    `meta:{}`\n  }\n```\n\n如果 action 用来表示出错的情况，则可能为：\n```\n  {\n    type: 'ADD_TODO',\n    payload: new Error(),\n    error: true\n  }\n```\ntype 是必须要有的属性，其他都是可选的。完整建议请参考 Flux Standard Action(FSA) 定义。已经有不少第三方模块是基于 FSA 的约定来开发了。\n\n**Action Creator**\n事实上，创建 action 对象很少用这种每次直接声明对象的方式，更多地是通过一个创建函数。这个函数被称为Action Creator，例如：\n```\n  function addTodo(text) {\n    return {\n      type: ADD_TODO,\n      text\n    };\n  }\n```\n\nAction Creator 看起来很简单，但是如果结合上 Middleware 就可以变得非常灵活，后面会专门讲 Middleware 。\n\n## 3.2 Reducer\n我们先来看一下javascript中Array.prototype.reduce的用法：\n```javascript\n  const initState = '';\n  const actions = ['a','b','c'];\n  //传入当前的state和action，返回新的state\n  const newState = actions.reduce((curState,action) => curState + action);\n  console.log(newState);\n```\n\n对应的理解，Redux中的reducer是一个纯函数，传入state和action，返回一个新的state tree,简单而纯粹的完成某一件具体的事情，没有依赖，**简单而纯粹是它的标签**\n```javascript\n  const counter = (state=0, action) => {\n    switch(action.type){\n      case 'INCREMENT':\n        return state + 1;\n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n```\n\n## 3.3 Store\nStore就是用来维持应用所有的state树的一个对象。改变store内state的唯一途径是对它dispatch一个action。\n\nStore是一个具有以下四个方法的对象：\n - getState()\n - dispatch(action)\n - subscribe(listener)\n - replaceReducer(nextReducer)\n\n### 3.3.1 getState()\n返回应用当前的state树。它与store的最后一个reducer返回值相同。\n返回值：应用当前的state树。\n\n### 3.3.2 dispatch(action)\ndispatch分发action。**这是出发state变化的唯一途径。**\n会使用当前getState()的结果和传入的action以同步方式的调用store的reduce函数。返回值会被作为下一个state。从现在开始，这就成为了getState()的返回值，同时变化监听器(change listener)会被触发。\n\n>在Redux里，只会在根reducer返回新state结束后才会调用事件监听器，因此，你可以在事件监听器里再做dispatch。唯一使你不能在reducer中途diapatch的原因是要确保reducer没有副作用。如果action处理会产生副作用，正确的做法是使用异步action创建函数\n\n示例:\n```javascript\n  import {createStore} from 'redux';\n  //reducer\n  const todos = (state = [''],action) => {\n    switch (action.type){\n      case 'ADD_TODO':\n        return Object.assign([],state,[action.text]);\n      default:\n        return state;\n    }\n  }\n  let store = createStore(todos,[ 'Use Redux'])\n  //action Creator\n  function addTodo(text){\n    return {\n      type: 'ADD_TODO',\n      text\n    }\n  }\n  //dispatch\n  store.dispatch(addTodo('Read the docs'));\n  store.dispatch(addTodo('Read about the middleware'));\n```\n\n### 3.3.3 subscribe(listener)\n添加一个变化监听器。每当dispatch action的时候就会执行，state树中的一部分可能已经变化。这是一个底层API。多数情况下，你不会直接使用它，会使用一些React(或其他库)的绑定。\n\n示例：\n```javascript\n  import {createStore} from 'redux';\n  //reducer\n  const todos = (state = [''],action) => {\n    switch (action.type) {\n      case 'ADD_TODO':\n        return Object.assign([].state,[action.text]);\n      default:\n        return state;\n    }\n  }\n  let store = createStore(todos,[ 'Use Redux'])\n  //action Creator\n  function addTodo(text){\n    return{\n      type:'ADD_TODO',\n      text\n    }\n  }\n  const handleChange = () => {\n    console.log(store.getState());\n  }\n  let unsubscribe = store.subscribe(handleChange)\n  handleChange()\n  //dispatch\n  store.dispatch(addTodo('Read the docs'));\n  store.dispatch(addTodo('Read about the middleware'));\n```\n\n# 4. Redux的顶层API介绍\n## 4.1 createStore\n调用方式：createStore(reducer,[initialState])\n\n创建一个Redux store来以存放应用中所有的state，应用中应有且仅有一个store。这个API返回一个store,这个store中保存了应用所有state的对象。改变state的唯一方法是dispatch action。你也可以subscrube监听state的变化，然后更新UI。我们来看一个示例。\n**我们可以试着模拟createStore,深入了解其原理**\n```javascript\n  //reducer纯函数，具体的action执行逻辑\n  const counter = (state = 0,action) =>{\n    switch (action.type){\n      case 'INCREMENT':\n        return state + 1;        \n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n  //模拟createStore,了解其原理\n  const createStore = (reducer) => {\n    let state;\n    let listeners = [];\n    const getState = () => state;\n    const dispatch = (action) => {\n      state = reducer(state,action);\n      listeners.forEach(listener => listener());\n    }\n    const subscribe = (listener) => {\n      listeners.push(listener);\n      return () => {\n        listeners = listeners.filter(item => item !== listener);\n      }\n    }\n<<<<<<< HEAD\n    dispatch({});\n    return {getState,dispatch,subscribe};\n  }\n  const store = createStore(counter);\n  //view 对应到react里面的component\n  const PureRender = () => {\n    document.body.innerText = store.getState();\n=======\n    dispatch();\n    return { getState, dispatch, subscribe };\n    const store = createStore(counter);\n    // view 对应到React里面的component\n    const PureRender = () => {\n      document.body.innerText = store.getState();\n    }\n    // store subscribe 订阅或是监听view（on）\n    store.subscribe(PureRender);\n    PureRender();\n    document.addEventListener('click', function( e ){\n      // store dispatch 调度分发一个 action（fire）\n      store.dispatch({ type: 'DECREMENT'});\n    })\n  }\n```\n\n## 4.2 combineReducers\n调用方式：combineReducers(reducers)\n\n随着应用变得复杂，需要对 reducer 函数进行拆分，拆分后的每一块独立负责管理 state 的一部分。把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。\n\n示例如下\n\n代码清单：reducer/todos.js\n```javascript\n  export default function todos(state = [], action) {\n    switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([action.text])\n    default:\n      return state\n    }\n>>>>>>> b872c55882669de3f10e29ad039674d345d37f2e\n  }\n  //store subscribe 订阅或是监听view(on)\n  store.subscribe(PureRender);\n  PureRender();\n  document.addEventListener('click',function(e){\n    //store dispatch 调度分发一个action(fire)\n    store.dispatch({type:'DECREMENT'})；\n  })\n```\n\n<<<<<<< HEAD\n## 4.2 combineReducers\n调用方式：combineReducers(reducers)\n\n随着应用变得复杂，需要对reducer函数进行拆分，拆分后的每一块独立负责管理state的一部分。把一个由多个不同reducer函数作为value的object，合并成一个最终的reducer函数，然后就可以对这个reducer调用createStore.\n\n示例如下：\n代码清单：reducer/todos.js\n```javascript\n  export default function todos(state = [],action){\n    switch(action.type){\n      case 'ADD_TODO':\n        return state.concat([action.text])\n      default:\n        return state\n    }\n  }\n```\n\n代码清单：reducer/counter.js\n```javascript\n  export default function counter(state = [],action){\n    switch(action.type){\n      case 'INCREMENT':\n        return state + 1\n      case 'DECREMENT':\n        return state - 1\n      default:\n        return state\n      }\n    }\n  }\n```\n\n代码清单：reducer/index.js\n```javascript\n  import { combineReducers } from 'redux'\n  import todos from './todos'\n  import counter from './counter'\n\n  export default combineReducers({\n    todos,\n    counter\n  })\n```\n\n代码清单：App.js\n```javascript\n  import {createStore} from 'redux'\n  import reducer from './reducer/index.js'\n  let store = createStore(reducer)\n  console.log('当前的state: ',store.getState())\n  store.dispatch({\n    type:'ADD_TODO',\n    text:'Use Redux'\n  })\n  store.dispatch({\n    type:'INCREMENT'\n  })\n  console.log('改变后的state: ',store.getState());\n```\n\n## 4.3 applyMiddleware\n调用方式: applyMiddleware(...middlewares)\n\n使用包含自定义功能的middleware来扩展Redux是一种推荐的方式。Middleware可以让你包装store的dispatch方法来达到你想要的目的。同时，middleware还拥有“可组合”这一关键特性。多个middleware可以被组合到一起使用，形成middleware链。其中，每个middleware都不需要关心链中它前后的middleware的任何信息。\n\n## 4.4 bindActionCreators\n调用方式：bindActionCreators(actionCreators,dispatch)\n\n唯一使用bindActionCreators的场景是当你需要把action creator往下传到一个组件上，却不想让这个组件察觉到Redux的存在，而且不希望把Redux store或dispatch传给它。\n\n## 4.5 compose\n调用方法：compose(...functions)\n\ncompose用来实现从右到左组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来些深度嵌套的函数，仅此而已。\n\n# 5. 使用React-redux连接react和redux\n## 5.1 没有react-redux的写法\n封装一个组件，将组件和Redux做基本的组合\n```javascript\n  import { createStore } from 'redux';\n  import React, {Component} from 'react';\n  import ReactDOM from 'react-dom';\n  //reducer 纯函数，具体的action执行逻辑\n  const counter = (state = 0,action) => {\n    switch (action.type){\n      case 'INCREMENT':\n        return state + 1;\n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n  const store = createStore(counter);\n  //Counter组件\n  class Counter extends Component{\n=======\n代码清单：reducer/counter.js\n```javascript\n  export default function counter(state = 0, action) {\n    switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n    }\n  }\n```\n\n代码清单：reducers/index.js\n```javascript\n  import { combineReducers } from 'redux'\n  import todos from './todos'\n  import counter from './counter'\n  export default combineReducers({\n    todos,\n    counter\n  })\n```\n\n代码清单：App.js\n```javascript\n  import { createStore } from 'redux'\n  import reducer from './reducer/index.js'\n\n  let store = createStore(reducer)\n  console.log('当前的 state :', store.getState())\n\n  store.dispatch({\n    type: 'ADD_TODO',\n    text: 'Use Redux'\n  })\n  store.dispatch({\n    type: 'INCREMENT'\n  })\n  console.log('改变后的 state :', store.getState())\n```\n\n## 4.3 applyMiddleware\n调用方式：applyMiddleware(...middlewares)\n\n使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息\n\n## 4.4 bindActionCreators\n调用方式：bindActionCreators(actionCreators, dispatch)\n\n惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。\n\n## 4.5 compose\n调用方式：compose(...functions)\n\ncompose 用来实现从右到左来组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来写深度嵌套的函数，仅此而已。\n\n# 5 使用React-redux连接react和redux\n## 5.1 没有React-redux的写法\n封装一个组件，将组件和Redux做基本的组合\n```javascript\n  import { createStore } from 'redux';\n  import React, { Component } from 'react';\n  import ReactDOM from 'react-dom';\n\n  // reducer 纯函数，具体的action执行逻辑\n  const counter = (state = 0, action) => {\n    switch (action.type) {\n        case 'INCREMENT':\n          return state + 1;\n        case 'DECREMENT':\n          return state - 1;\n        default:\n          return state;\n    }\n  }\n\n  const store = createStore(counter);\n\n  // Counter 组件\n  class Counter extends Component {\n>>>>>>> b872c55882669de3f10e29ad039674d345d37f2e\n    render(){\n      return (\n        <div>\n          <h1>{this.props.value}</h1>\n          <button onClick={this.props.onIncrement}>点击加1</button>\n          <button onClick={this.props.onDecrement}>点击减1</button>\n        </div>\n      )\n    }\n  }\n<<<<<<< HEAD\n  const PureRender = () => {\n    ReactDOM.render(\n      <Counter\n        value={store.getState()}\n        onIncrement={ () => store.dispatch({type: \"INCREMENT\"}) }\n        onDecrement={ () => store.dispatch({type: \"DECREMENT\"}) }\n      />, document.getElementById('app')\n    )\n  }\n  // store subscribe 订阅或是监听view（on）\n  store.subscribe(PureRender)\n  PureRender()\n```\n\n## 5.2 React-redux提供的contect和Provider\n<Provider store>使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在'<Provider>'中才能使用connect()方法。\n=======\n\n  const PureRender = () => {\n    ReactDOM.render(\n        <Counter\n          value={store.getState()}\n          onIncrement={ () => store.dispatch({type: \"INCREMENT\"}) }\n          onDecrement={ () => store.dispatch({type: \"DECREMENT\"}) }\n        />, document.getElementById('app')\n    );\n  }\n\n  // store subscribe 订阅或是监听view（on）\n  store.subscribe(PureRender)\n  PureRender()\n```\n\n## 5.2 React-redux提供的connect和Provider\n<Provider store>使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在<Provider>中才能使用connect()方法。\n```javascript\n  ReactDOM.render(\n    {/*  使组件层级中的 connect() 方法都能够获得 Redux store */}\n    <Provider store={store}>\n      {/* 这里传入的组件MyRootComponent是组件层级的根组件 */}\n      <MyRootComponent />\n    </Provider>\n  )\n```\n\nconnect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options]) connect方法是来连接React组件与Redux store,连接操作不会改变原来的组件类，反而返回一个新的已与Redux store连接的组件类。\n\n使用React-redux的一个简单完整示例\n```javascript\n  import React, { Component, PropTypes} from 'react';\n  import ReactDOM from 'react-dom';\n  import { createStore } from 'redux';\n  import { Provider, connect} from 'react-redux';\n  //这是一个展示型组件counter\n  class Counter extends Component {\n    render(){\n      const { value, onIncrementClick} = this.props;\n      return (\n        <div>\n          <span>{value}</span>\n          <button onClick={onIncrementClick}>点我加一</button>\n        </div>\n      )\n    }\n  }\n  Counter.propTypes = {\n    value: PropTypes.number.isRequired,\n    onIncrementClick: PropTypes.func.isRequired\n  }\n  //Action\n  const increaseAction = {type: 'increase'}\n  //Reducer\n  function counter(state={count:0},action){\n    let count = state.count;\n    switch(action.type){\n      case 'increase':\n        return {count:count + 1}\n      default:\n        return count\n    }\n  }\n  //store\n  let store = createStore(counter);\n  //Map Redux state to component props\n  function mapStateToProps(state){\n    console.log(state);\n    //这里拿到的state就是store里面给的state\n    return {\n      value: state.count\n    }\n  }\n\n  //Map Redux actions to component props\n  function mapDispatchToProps(dispatch){\n    //dispatch\n    return {\n      onIncrementClick: () => dispatch(increaseAction);\n    }\n  }\n\n  class App extends Component{\n    render(){\n      //store里的state经过connect连接后给了根组件的props\n      console.log(this.prps);\n      return (\n        <div>\n          <h1>react-redux</h1>\n          <Counter {...this.props} />\n        </div>\n      )\n    }\n  }\n  //Connected Component\n  let RootApp = connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(App)\n  ReactDOM.render(\n    <Provider store={store}>\n      <RootApp />\n    </Provider>,\n    document.getElementById('app')\n  )\n```\n实际应用中，connect这个部分会比较复杂。\n\n# 6. 一步步开发一个TODO应用\n## 6.1 入口文件\nindex.js\n```javascript\n  import React from 'react';\n  import {render} from 'react-dom';\n  import {createStore} from 'redux';\n  import {Provider} from 'react-redux';\n  import App from './containers/App';\n  import todoApp from './reducers';\n\n  let store = createStore(todoApp);\n\n  let rootElement = document.getElementById('app');\n  render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    rootElement\n  )\n```\n\n## 6.2 Action创建函数和常量\naction.js\n```javascript\n  //action类型\n  export const ADD_TODO = 'ADD_TODO';\n  export const COMPLETE_TODO = 'COMPLETE_TODO';\n  export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER';\n  //其他常量\n  export const VisibilityFilter = {\n    SHOW_ALL: 'SHOW_ALL',\n    SHOW_COMPLETED: 'SHOW_COMPLETED',\n    SHOW_ACTIVE: 'SHOW_ACTIVE'\n  }\n  //action创建函数\n  export function addTodo(text){\n    return {type: ADD_TODO,text}\n  }\n  export function completeTodo(index){\n    return {type: COMPLETE_TODO,index}\n  }\n  export function setVisibilityFilter(filter){\n    return {type: SET_VISIBILITY_FILTER,filter}\n  }\n```\n\n## 6.3 Reducers\nreducers.js\n```javascript\n  import {combineReducers} from 'redux';\n  import {ADD_TODO, COMPLETE_TODO, SET_VISIBILITY_FILTER, VisibilityFilter} from './actions';\n  const {SHOW_ALL} = VisibilityFilter;\n\n  function visibilityFilter(state = SHOW_ALL, action){\n    switch(action.type){\n      case SET_VISIBILITY_FILTER:\n        return action.filter\n      default:\n        return state\n    }\n  }\n\n  function todos(state=[],action){\n    switch(action.type){\n      case ADD_TODO:\n        return [\n          ...state,\n          {\n            text:action.text,\n            completed: false\n          }\n        ]\n      case COMPLETE_TODO:\n        return [\n          ...state.slice(0,action.index),\n          Object.assign({},state[action.index],{\n            completed:true\n          }),\n          ...state.slice(action.index + 1)\n        ]\n      default:\n        return state\n    }\n  }\n\n  const todoApp = combineReducers({\n    visibilityFilter,\n    todos\n  })\n\n  export default todoApp\n```\n\n## 6.4 容器组件\ncontainers/App.js\n```javascript\n  import React, {Component, PropTypes} from 'react';\n  import {connect} from 'react-redux';\n  import {addTodo, completeTodo, setVisibilityFilter, VisibilityFilter} from '../actions';\n  import AddTodo from '../components/AddTodo';\n  import TodoList from '../components/TodoList';\n  import Footer from '../components/Footer';\n\n  class App extends Component {\n    render(){\n      //Injected by connect() call\n      const {dispatch, visibleTodos, visibilityFilter } = this.props;\n      return (\n        <div>\n          <AddTodo onAddClick={text =>\n            dispatch(addTodo(text))\n          } />\n          <TodoList\n            todos={visibleTodos}\n            onAddClick={index =>\n              dispatch(completeTodo(index))\n          } />\n          <Footer\n            filter={visibilityFilter}\n            onFilterChange={nextFilter =>\n              dispatch(setVisibilityFilter(nextFilter))\n          } />\n        </div>\n      )\n    }\n  }\n\n  App.propTypes = {\n    visibleTodos: PropTypes.arrayOf(PropTypes.shape({\n      text: PropTypes.string.isRequired,\n      completed: PropTypes.bool.isRequired\n    }).isRequired).isRequired,\n    visibilityFilter: PropTypes.oneOf({\n      'SHOW_ALL',\n      'SHOW_COMPLETED',\n      'SHOW_ACTIVE'\n    }).isRequired\n  }\n\n  function selectTodos(todo,filter){\n    switch(filter){\n      case visibilityFilters.SHOW_ALL:\n        return todos\n      case VisibilityFilters.SHOW_COMPLETED:\n        return todos.filter(todo => todo.completed)\n      case VisibilityFilters.SHOW_ACTIVE:\n        return todos.filter(todo => !todo.completed)\n    }\n  }\n\n  function select(state){\n    return {\n      visibleTodos: selectTodos(state.todos,state.visibilityFilter),\n      visibilityFilter: state.visibilityFilter\n    }\n  }\n  // 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；\n  export default connect(select)(App)\n```\n\n## 6.5 展示组件\ncomponents/AddTodo.js\n```javascript\n  import React, {Component, PropTypes} from 'react';\n\n  export default class AddTodo extends Component {\n    render() {\n      return (\n        <div>\n          <input type='text' ref='input' />\n          <button onClick={(e) => this.handleClick(e)}>\n            Add\n          </button>\n        </div>\n      )\n    }\n\n    handleClick(e) {\n      const node = this.refs.input\n      const text = node.value.trim()\n      this.props.onAddClick(text)\n      node.value = ''\n    }\n  }\n\n  AddTodo.propTypes = {\n    onAddClick: PropTypes.func.isRequired\n  }\n```\n\ncomponents/Footer.js\n```javascript\n  import React, { Component, PropTypes } from 'react'\n\n  export default class Footer extends Component {\n  renderFilter(filter, name) {\n    if (filter === this.props.filter) {\n      return name\n    }\n\n    return (\n      <a href='#' onClick={e => {\n        e.preventDefault()\n        this.props.onFilterChange(filter)\n      }}>\n        {name}\n      </a>\n    )\n  }\n\n  render() {\n    return (\n      <p>\n        Show:\n        {' '}\n        {this.renderFilter('SHOW_ALL', 'All')}\n        {', '}\n        {this.renderFilter('SHOW_COMPLETED', 'Completed')}\n        {', '}\n        {this.renderFilter('SHOW_ACTIVE', 'Active')}\n        .\n      </p>\n    )\n  }\n}\n\n  Footer.propTypes = {\n    onFilterChange: PropTypes.func.isRequired,\n    filter: PropTypes.oneOf([\n      'SHOW_ALL',\n      'SHOW_COMPLETED',\n      'SHOW_ACTIVE'\n    ]).isRequired\n  }\n```\n\ncomponents/Todo.js\n```javascript\n  import React, { Component, PropTypes } from 'react'\n\n  export default class Todo extends Component {\n    render() {\n      return (\n        <li\n          onClick={this.props.onClick}\n          style={{\n            textDecoration: this.props.completed ? 'line-through' : 'none',\n            cursor: this.props.completed ? 'default' : 'pointer'\n          }}>\n          {this.props.text}\n        </li>\n      )\n    }\n  }\n\n  Todo.propTypes = {\n    onClick: PropTypes.func.isRequired,\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired\n  }\n```\n\ncomponents/TodoList.js\n```javascript\n  import React, { Component, PropTypes } from 'react'\n  import Todo from './Todo'\n\n  export default class TodoList extends Component {\n    render() {\n      return (\n        <ul>\n          {this.props.todos.map((todo, index) =>\n            <Todo {...todo}\n                  key={index}\n                  onClick={() => this.props.onTodoClick(index)} />\n          )}\n        </ul>\n      )\n    }\n  }\n\n  TodoList.propTypes = {\n    onTodoClick: PropTypes.func.isRequired,\n    todos: PropTypes.arrayOf(PropTypes.shape({\n      text: PropTypes.string.isRequired,\n      completed: PropTypes.bool.isRequired\n    }).isRequired).isRequired\n  }\n```\n>>>>>>> b872c55882669de3f10e29ad039674d345d37f2e\n","source":"_posts/Redux快速上手.md","raw":"---\ntitle: Redux快速上手\ndate: 2016-05-23 16:02:18\ntags:\n  - react\n  - Redux\ncategories: 转载笔记\n---\n> 文章转载自[Redux快速上手](http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/Redux%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html)，仅供学习和参考\n\n在实际的项目中，面对复杂业务逻辑的挑战，如何清晰高效的管理应用内的数据流动成为了关键。\n\nFlux思想已经在提出后得到逐步推广，并广泛应用到实际项目中。facebook的flux实现，开源社区的reflux、redux等类库开始涌现并得到了广大开发者的认同和使用。\n\nRedux以其简单易用、文档齐全易懂等优点在开源社区得到开发者的一直好评，所以接下来让我们一起走进Redux。\n\n# 1. 基本介绍\nReact已经帮我们在视图层解决了禁止异步和直接操作DOM等问题，让页面的高效渲染和组件话开发成为了可能。美中不足的是，React依旧把处理state中数据的问题留给了你，那么，Redux的出现就是为了帮你解决这个问题\n\n## 1.1 Fulx & Redux\n最初，facebook官网提出了Flux思想管理数据流，同时也给了自己的实现方案flux来管理React应用。\n![Flux](/images/react/flux.jpg)\n1. 在view中触发action中的方法后\n2. action发送dispatch\n3. store接收新的数据进行合并，然后触发view中绑定在store上的方法\n4. 最后通过修改局部state来改变view的展示\n\n![Redux](/images/react/redux.jpg)\n1. view直接触发dispatch\n2. dispatch将action发送到reducer中后，根节点上会更新props，改变全局view\n3. redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中\n\n>相对于Flux而言，Redux的实现更简单，思路更清晰，写的代码也相对更少；只维护单一的 store.\n\n## 1.2 对Redux的介绍\n - Redux是State容器，提供可预测化的状态管理\n - 它可以让你构建一致化的应用，运行于不同的环境(客户端、服务器、原生应用)，并且易于测试\n - 还提供了redux-devtools让开发者享受超爽的开发体验\n - 体小精悍(只有2kb)且没有任何依赖\n - 拥有丰富的生态圈：教程、开发者工具、路由、组件、中间件、工具集...\n\n# 2. 快速上手\n示例代码快速体验\n```javascript\n  //这是一个reducer，形式为(state,action) => state 的纯函数。描述了action如何把state转变成下一个state。\n  //state的形式取决于你，可以是基本类型、数组、对象甚至是Immutable.js生成的数据结构。\n  //唯一的要点是当state变化时需要返回全新的对象，而不是修改传入的参数。\n  function counter(state=0,action){\n    switch (action.type){\n      case 'INCREMENT':\n        return state + 1;\n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n  //创建Redux store来存放应用的状态。\n  //API是{subscribe,dispatch,getState}\n  let store = createStore(counter);\n  //一个单纯渲染页面内容的函数\n  const PureRender = () => {\n    document.body.innerText = store.getState();\n  }\n  //可以手动订阅更新，也可以事件绑定到视图层\n  store.subscribe(PureRender);\n  //执行渲染函数\n  PureRender();\n  //改变内部state唯一方法是dispatch一个action。action可以被序列化，用日记记录和存储下来，后期还可以以回放的方式执行。\n  document.addEventListener('click',function(e){\n    //store dispatch 调度分发一个action(fire)\n    store.dispatch({type:\"DECREMENT\"})\n  })\n```\n\n# 3. 理解Redux的核心概念\n## 3.1 Action & Action Creator\n在Redux中，改变state只能通过action,它是store数据的唯一来源。一般来说你会通过store.dispatch()将action传到store。并且每个action都必须是javascript的简单对象，例如：\n```\n  {\n    type:\"ADD_TODO\"，\n    text:\"Learn Redux\"\n  }\n```\n\nRedux要求action是可以被序列化的，这使得应用程序的状态保存、回放、Undo之类的功能可以被实现。因此，action中不能包含诸如函数调用这样的不可序列化的字段。\naction的格式是有建议规范的，可以包含以下字段：\n```\n  {\n    type:\"ADD_TODO\",\n    payload:{\n      text:\"Do something\"\n    },\n    `meta:{}`\n  }\n```\n\n如果 action 用来表示出错的情况，则可能为：\n```\n  {\n    type: 'ADD_TODO',\n    payload: new Error(),\n    error: true\n  }\n```\ntype 是必须要有的属性，其他都是可选的。完整建议请参考 Flux Standard Action(FSA) 定义。已经有不少第三方模块是基于 FSA 的约定来开发了。\n\n**Action Creator**\n事实上，创建 action 对象很少用这种每次直接声明对象的方式，更多地是通过一个创建函数。这个函数被称为Action Creator，例如：\n```\n  function addTodo(text) {\n    return {\n      type: ADD_TODO,\n      text\n    };\n  }\n```\n\nAction Creator 看起来很简单，但是如果结合上 Middleware 就可以变得非常灵活，后面会专门讲 Middleware 。\n\n## 3.2 Reducer\n我们先来看一下javascript中Array.prototype.reduce的用法：\n```javascript\n  const initState = '';\n  const actions = ['a','b','c'];\n  //传入当前的state和action，返回新的state\n  const newState = actions.reduce((curState,action) => curState + action);\n  console.log(newState);\n```\n\n对应的理解，Redux中的reducer是一个纯函数，传入state和action，返回一个新的state tree,简单而纯粹的完成某一件具体的事情，没有依赖，**简单而纯粹是它的标签**\n```javascript\n  const counter = (state=0, action) => {\n    switch(action.type){\n      case 'INCREMENT':\n        return state + 1;\n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n```\n\n## 3.3 Store\nStore就是用来维持应用所有的state树的一个对象。改变store内state的唯一途径是对它dispatch一个action。\n\nStore是一个具有以下四个方法的对象：\n - getState()\n - dispatch(action)\n - subscribe(listener)\n - replaceReducer(nextReducer)\n\n### 3.3.1 getState()\n返回应用当前的state树。它与store的最后一个reducer返回值相同。\n返回值：应用当前的state树。\n\n### 3.3.2 dispatch(action)\ndispatch分发action。**这是出发state变化的唯一途径。**\n会使用当前getState()的结果和传入的action以同步方式的调用store的reduce函数。返回值会被作为下一个state。从现在开始，这就成为了getState()的返回值，同时变化监听器(change listener)会被触发。\n\n>在Redux里，只会在根reducer返回新state结束后才会调用事件监听器，因此，你可以在事件监听器里再做dispatch。唯一使你不能在reducer中途diapatch的原因是要确保reducer没有副作用。如果action处理会产生副作用，正确的做法是使用异步action创建函数\n\n示例:\n```javascript\n  import {createStore} from 'redux';\n  //reducer\n  const todos = (state = [''],action) => {\n    switch (action.type){\n      case 'ADD_TODO':\n        return Object.assign([],state,[action.text]);\n      default:\n        return state;\n    }\n  }\n  let store = createStore(todos,[ 'Use Redux'])\n  //action Creator\n  function addTodo(text){\n    return {\n      type: 'ADD_TODO',\n      text\n    }\n  }\n  //dispatch\n  store.dispatch(addTodo('Read the docs'));\n  store.dispatch(addTodo('Read about the middleware'));\n```\n\n### 3.3.3 subscribe(listener)\n添加一个变化监听器。每当dispatch action的时候就会执行，state树中的一部分可能已经变化。这是一个底层API。多数情况下，你不会直接使用它，会使用一些React(或其他库)的绑定。\n\n示例：\n```javascript\n  import {createStore} from 'redux';\n  //reducer\n  const todos = (state = [''],action) => {\n    switch (action.type) {\n      case 'ADD_TODO':\n        return Object.assign([].state,[action.text]);\n      default:\n        return state;\n    }\n  }\n  let store = createStore(todos,[ 'Use Redux'])\n  //action Creator\n  function addTodo(text){\n    return{\n      type:'ADD_TODO',\n      text\n    }\n  }\n  const handleChange = () => {\n    console.log(store.getState());\n  }\n  let unsubscribe = store.subscribe(handleChange)\n  handleChange()\n  //dispatch\n  store.dispatch(addTodo('Read the docs'));\n  store.dispatch(addTodo('Read about the middleware'));\n```\n\n# 4. Redux的顶层API介绍\n## 4.1 createStore\n调用方式：createStore(reducer,[initialState])\n\n创建一个Redux store来以存放应用中所有的state，应用中应有且仅有一个store。这个API返回一个store,这个store中保存了应用所有state的对象。改变state的唯一方法是dispatch action。你也可以subscrube监听state的变化，然后更新UI。我们来看一个示例。\n**我们可以试着模拟createStore,深入了解其原理**\n```javascript\n  //reducer纯函数，具体的action执行逻辑\n  const counter = (state = 0,action) =>{\n    switch (action.type){\n      case 'INCREMENT':\n        return state + 1;        \n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n  //模拟createStore,了解其原理\n  const createStore = (reducer) => {\n    let state;\n    let listeners = [];\n    const getState = () => state;\n    const dispatch = (action) => {\n      state = reducer(state,action);\n      listeners.forEach(listener => listener());\n    }\n    const subscribe = (listener) => {\n      listeners.push(listener);\n      return () => {\n        listeners = listeners.filter(item => item !== listener);\n      }\n    }\n<<<<<<< HEAD\n    dispatch({});\n    return {getState,dispatch,subscribe};\n  }\n  const store = createStore(counter);\n  //view 对应到react里面的component\n  const PureRender = () => {\n    document.body.innerText = store.getState();\n=======\n    dispatch();\n    return { getState, dispatch, subscribe };\n    const store = createStore(counter);\n    // view 对应到React里面的component\n    const PureRender = () => {\n      document.body.innerText = store.getState();\n    }\n    // store subscribe 订阅或是监听view（on）\n    store.subscribe(PureRender);\n    PureRender();\n    document.addEventListener('click', function( e ){\n      // store dispatch 调度分发一个 action（fire）\n      store.dispatch({ type: 'DECREMENT'});\n    })\n  }\n```\n\n## 4.2 combineReducers\n调用方式：combineReducers(reducers)\n\n随着应用变得复杂，需要对 reducer 函数进行拆分，拆分后的每一块独立负责管理 state 的一部分。把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。\n\n示例如下\n\n代码清单：reducer/todos.js\n```javascript\n  export default function todos(state = [], action) {\n    switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([action.text])\n    default:\n      return state\n    }\n>>>>>>> b872c55882669de3f10e29ad039674d345d37f2e\n  }\n  //store subscribe 订阅或是监听view(on)\n  store.subscribe(PureRender);\n  PureRender();\n  document.addEventListener('click',function(e){\n    //store dispatch 调度分发一个action(fire)\n    store.dispatch({type:'DECREMENT'})；\n  })\n```\n\n<<<<<<< HEAD\n## 4.2 combineReducers\n调用方式：combineReducers(reducers)\n\n随着应用变得复杂，需要对reducer函数进行拆分，拆分后的每一块独立负责管理state的一部分。把一个由多个不同reducer函数作为value的object，合并成一个最终的reducer函数，然后就可以对这个reducer调用createStore.\n\n示例如下：\n代码清单：reducer/todos.js\n```javascript\n  export default function todos(state = [],action){\n    switch(action.type){\n      case 'ADD_TODO':\n        return state.concat([action.text])\n      default:\n        return state\n    }\n  }\n```\n\n代码清单：reducer/counter.js\n```javascript\n  export default function counter(state = [],action){\n    switch(action.type){\n      case 'INCREMENT':\n        return state + 1\n      case 'DECREMENT':\n        return state - 1\n      default:\n        return state\n      }\n    }\n  }\n```\n\n代码清单：reducer/index.js\n```javascript\n  import { combineReducers } from 'redux'\n  import todos from './todos'\n  import counter from './counter'\n\n  export default combineReducers({\n    todos,\n    counter\n  })\n```\n\n代码清单：App.js\n```javascript\n  import {createStore} from 'redux'\n  import reducer from './reducer/index.js'\n  let store = createStore(reducer)\n  console.log('当前的state: ',store.getState())\n  store.dispatch({\n    type:'ADD_TODO',\n    text:'Use Redux'\n  })\n  store.dispatch({\n    type:'INCREMENT'\n  })\n  console.log('改变后的state: ',store.getState());\n```\n\n## 4.3 applyMiddleware\n调用方式: applyMiddleware(...middlewares)\n\n使用包含自定义功能的middleware来扩展Redux是一种推荐的方式。Middleware可以让你包装store的dispatch方法来达到你想要的目的。同时，middleware还拥有“可组合”这一关键特性。多个middleware可以被组合到一起使用，形成middleware链。其中，每个middleware都不需要关心链中它前后的middleware的任何信息。\n\n## 4.4 bindActionCreators\n调用方式：bindActionCreators(actionCreators,dispatch)\n\n唯一使用bindActionCreators的场景是当你需要把action creator往下传到一个组件上，却不想让这个组件察觉到Redux的存在，而且不希望把Redux store或dispatch传给它。\n\n## 4.5 compose\n调用方法：compose(...functions)\n\ncompose用来实现从右到左组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来些深度嵌套的函数，仅此而已。\n\n# 5. 使用React-redux连接react和redux\n## 5.1 没有react-redux的写法\n封装一个组件，将组件和Redux做基本的组合\n```javascript\n  import { createStore } from 'redux';\n  import React, {Component} from 'react';\n  import ReactDOM from 'react-dom';\n  //reducer 纯函数，具体的action执行逻辑\n  const counter = (state = 0,action) => {\n    switch (action.type){\n      case 'INCREMENT':\n        return state + 1;\n      case 'DECREMENT':\n        return state - 1;\n      default:\n        return state;\n    }\n  }\n  const store = createStore(counter);\n  //Counter组件\n  class Counter extends Component{\n=======\n代码清单：reducer/counter.js\n```javascript\n  export default function counter(state = 0, action) {\n    switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n    }\n  }\n```\n\n代码清单：reducers/index.js\n```javascript\n  import { combineReducers } from 'redux'\n  import todos from './todos'\n  import counter from './counter'\n  export default combineReducers({\n    todos,\n    counter\n  })\n```\n\n代码清单：App.js\n```javascript\n  import { createStore } from 'redux'\n  import reducer from './reducer/index.js'\n\n  let store = createStore(reducer)\n  console.log('当前的 state :', store.getState())\n\n  store.dispatch({\n    type: 'ADD_TODO',\n    text: 'Use Redux'\n  })\n  store.dispatch({\n    type: 'INCREMENT'\n  })\n  console.log('改变后的 state :', store.getState())\n```\n\n## 4.3 applyMiddleware\n调用方式：applyMiddleware(...middlewares)\n\n使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息\n\n## 4.4 bindActionCreators\n调用方式：bindActionCreators(actionCreators, dispatch)\n\n惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。\n\n## 4.5 compose\n调用方式：compose(...functions)\n\ncompose 用来实现从右到左来组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来写深度嵌套的函数，仅此而已。\n\n# 5 使用React-redux连接react和redux\n## 5.1 没有React-redux的写法\n封装一个组件，将组件和Redux做基本的组合\n```javascript\n  import { createStore } from 'redux';\n  import React, { Component } from 'react';\n  import ReactDOM from 'react-dom';\n\n  // reducer 纯函数，具体的action执行逻辑\n  const counter = (state = 0, action) => {\n    switch (action.type) {\n        case 'INCREMENT':\n          return state + 1;\n        case 'DECREMENT':\n          return state - 1;\n        default:\n          return state;\n    }\n  }\n\n  const store = createStore(counter);\n\n  // Counter 组件\n  class Counter extends Component {\n>>>>>>> b872c55882669de3f10e29ad039674d345d37f2e\n    render(){\n      return (\n        <div>\n          <h1>{this.props.value}</h1>\n          <button onClick={this.props.onIncrement}>点击加1</button>\n          <button onClick={this.props.onDecrement}>点击减1</button>\n        </div>\n      )\n    }\n  }\n<<<<<<< HEAD\n  const PureRender = () => {\n    ReactDOM.render(\n      <Counter\n        value={store.getState()}\n        onIncrement={ () => store.dispatch({type: \"INCREMENT\"}) }\n        onDecrement={ () => store.dispatch({type: \"DECREMENT\"}) }\n      />, document.getElementById('app')\n    )\n  }\n  // store subscribe 订阅或是监听view（on）\n  store.subscribe(PureRender)\n  PureRender()\n```\n\n## 5.2 React-redux提供的contect和Provider\n<Provider store>使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在'<Provider>'中才能使用connect()方法。\n=======\n\n  const PureRender = () => {\n    ReactDOM.render(\n        <Counter\n          value={store.getState()}\n          onIncrement={ () => store.dispatch({type: \"INCREMENT\"}) }\n          onDecrement={ () => store.dispatch({type: \"DECREMENT\"}) }\n        />, document.getElementById('app')\n    );\n  }\n\n  // store subscribe 订阅或是监听view（on）\n  store.subscribe(PureRender)\n  PureRender()\n```\n\n## 5.2 React-redux提供的connect和Provider\n<Provider store>使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在<Provider>中才能使用connect()方法。\n```javascript\n  ReactDOM.render(\n    {/*  使组件层级中的 connect() 方法都能够获得 Redux store */}\n    <Provider store={store}>\n      {/* 这里传入的组件MyRootComponent是组件层级的根组件 */}\n      <MyRootComponent />\n    </Provider>\n  )\n```\n\nconnect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options]) connect方法是来连接React组件与Redux store,连接操作不会改变原来的组件类，反而返回一个新的已与Redux store连接的组件类。\n\n使用React-redux的一个简单完整示例\n```javascript\n  import React, { Component, PropTypes} from 'react';\n  import ReactDOM from 'react-dom';\n  import { createStore } from 'redux';\n  import { Provider, connect} from 'react-redux';\n  //这是一个展示型组件counter\n  class Counter extends Component {\n    render(){\n      const { value, onIncrementClick} = this.props;\n      return (\n        <div>\n          <span>{value}</span>\n          <button onClick={onIncrementClick}>点我加一</button>\n        </div>\n      )\n    }\n  }\n  Counter.propTypes = {\n    value: PropTypes.number.isRequired,\n    onIncrementClick: PropTypes.func.isRequired\n  }\n  //Action\n  const increaseAction = {type: 'increase'}\n  //Reducer\n  function counter(state={count:0},action){\n    let count = state.count;\n    switch(action.type){\n      case 'increase':\n        return {count:count + 1}\n      default:\n        return count\n    }\n  }\n  //store\n  let store = createStore(counter);\n  //Map Redux state to component props\n  function mapStateToProps(state){\n    console.log(state);\n    //这里拿到的state就是store里面给的state\n    return {\n      value: state.count\n    }\n  }\n\n  //Map Redux actions to component props\n  function mapDispatchToProps(dispatch){\n    //dispatch\n    return {\n      onIncrementClick: () => dispatch(increaseAction);\n    }\n  }\n\n  class App extends Component{\n    render(){\n      //store里的state经过connect连接后给了根组件的props\n      console.log(this.prps);\n      return (\n        <div>\n          <h1>react-redux</h1>\n          <Counter {...this.props} />\n        </div>\n      )\n    }\n  }\n  //Connected Component\n  let RootApp = connect(\n    mapStateToProps,\n    mapDispatchToProps\n  )(App)\n  ReactDOM.render(\n    <Provider store={store}>\n      <RootApp />\n    </Provider>,\n    document.getElementById('app')\n  )\n```\n实际应用中，connect这个部分会比较复杂。\n\n# 6. 一步步开发一个TODO应用\n## 6.1 入口文件\nindex.js\n```javascript\n  import React from 'react';\n  import {render} from 'react-dom';\n  import {createStore} from 'redux';\n  import {Provider} from 'react-redux';\n  import App from './containers/App';\n  import todoApp from './reducers';\n\n  let store = createStore(todoApp);\n\n  let rootElement = document.getElementById('app');\n  render(\n    <Provider store={store}>\n      <App />\n    </Provider>,\n    rootElement\n  )\n```\n\n## 6.2 Action创建函数和常量\naction.js\n```javascript\n  //action类型\n  export const ADD_TODO = 'ADD_TODO';\n  export const COMPLETE_TODO = 'COMPLETE_TODO';\n  export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER';\n  //其他常量\n  export const VisibilityFilter = {\n    SHOW_ALL: 'SHOW_ALL',\n    SHOW_COMPLETED: 'SHOW_COMPLETED',\n    SHOW_ACTIVE: 'SHOW_ACTIVE'\n  }\n  //action创建函数\n  export function addTodo(text){\n    return {type: ADD_TODO,text}\n  }\n  export function completeTodo(index){\n    return {type: COMPLETE_TODO,index}\n  }\n  export function setVisibilityFilter(filter){\n    return {type: SET_VISIBILITY_FILTER,filter}\n  }\n```\n\n## 6.3 Reducers\nreducers.js\n```javascript\n  import {combineReducers} from 'redux';\n  import {ADD_TODO, COMPLETE_TODO, SET_VISIBILITY_FILTER, VisibilityFilter} from './actions';\n  const {SHOW_ALL} = VisibilityFilter;\n\n  function visibilityFilter(state = SHOW_ALL, action){\n    switch(action.type){\n      case SET_VISIBILITY_FILTER:\n        return action.filter\n      default:\n        return state\n    }\n  }\n\n  function todos(state=[],action){\n    switch(action.type){\n      case ADD_TODO:\n        return [\n          ...state,\n          {\n            text:action.text,\n            completed: false\n          }\n        ]\n      case COMPLETE_TODO:\n        return [\n          ...state.slice(0,action.index),\n          Object.assign({},state[action.index],{\n            completed:true\n          }),\n          ...state.slice(action.index + 1)\n        ]\n      default:\n        return state\n    }\n  }\n\n  const todoApp = combineReducers({\n    visibilityFilter,\n    todos\n  })\n\n  export default todoApp\n```\n\n## 6.4 容器组件\ncontainers/App.js\n```javascript\n  import React, {Component, PropTypes} from 'react';\n  import {connect} from 'react-redux';\n  import {addTodo, completeTodo, setVisibilityFilter, VisibilityFilter} from '../actions';\n  import AddTodo from '../components/AddTodo';\n  import TodoList from '../components/TodoList';\n  import Footer from '../components/Footer';\n\n  class App extends Component {\n    render(){\n      //Injected by connect() call\n      const {dispatch, visibleTodos, visibilityFilter } = this.props;\n      return (\n        <div>\n          <AddTodo onAddClick={text =>\n            dispatch(addTodo(text))\n          } />\n          <TodoList\n            todos={visibleTodos}\n            onAddClick={index =>\n              dispatch(completeTodo(index))\n          } />\n          <Footer\n            filter={visibilityFilter}\n            onFilterChange={nextFilter =>\n              dispatch(setVisibilityFilter(nextFilter))\n          } />\n        </div>\n      )\n    }\n  }\n\n  App.propTypes = {\n    visibleTodos: PropTypes.arrayOf(PropTypes.shape({\n      text: PropTypes.string.isRequired,\n      completed: PropTypes.bool.isRequired\n    }).isRequired).isRequired,\n    visibilityFilter: PropTypes.oneOf({\n      'SHOW_ALL',\n      'SHOW_COMPLETED',\n      'SHOW_ACTIVE'\n    }).isRequired\n  }\n\n  function selectTodos(todo,filter){\n    switch(filter){\n      case visibilityFilters.SHOW_ALL:\n        return todos\n      case VisibilityFilters.SHOW_COMPLETED:\n        return todos.filter(todo => todo.completed)\n      case VisibilityFilters.SHOW_ACTIVE:\n        return todos.filter(todo => !todo.completed)\n    }\n  }\n\n  function select(state){\n    return {\n      visibleTodos: selectTodos(state.todos,state.visibilityFilter),\n      visibilityFilter: state.visibilityFilter\n    }\n  }\n  // 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；\n  export default connect(select)(App)\n```\n\n## 6.5 展示组件\ncomponents/AddTodo.js\n```javascript\n  import React, {Component, PropTypes} from 'react';\n\n  export default class AddTodo extends Component {\n    render() {\n      return (\n        <div>\n          <input type='text' ref='input' />\n          <button onClick={(e) => this.handleClick(e)}>\n            Add\n          </button>\n        </div>\n      )\n    }\n\n    handleClick(e) {\n      const node = this.refs.input\n      const text = node.value.trim()\n      this.props.onAddClick(text)\n      node.value = ''\n    }\n  }\n\n  AddTodo.propTypes = {\n    onAddClick: PropTypes.func.isRequired\n  }\n```\n\ncomponents/Footer.js\n```javascript\n  import React, { Component, PropTypes } from 'react'\n\n  export default class Footer extends Component {\n  renderFilter(filter, name) {\n    if (filter === this.props.filter) {\n      return name\n    }\n\n    return (\n      <a href='#' onClick={e => {\n        e.preventDefault()\n        this.props.onFilterChange(filter)\n      }}>\n        {name}\n      </a>\n    )\n  }\n\n  render() {\n    return (\n      <p>\n        Show:\n        {' '}\n        {this.renderFilter('SHOW_ALL', 'All')}\n        {', '}\n        {this.renderFilter('SHOW_COMPLETED', 'Completed')}\n        {', '}\n        {this.renderFilter('SHOW_ACTIVE', 'Active')}\n        .\n      </p>\n    )\n  }\n}\n\n  Footer.propTypes = {\n    onFilterChange: PropTypes.func.isRequired,\n    filter: PropTypes.oneOf([\n      'SHOW_ALL',\n      'SHOW_COMPLETED',\n      'SHOW_ACTIVE'\n    ]).isRequired\n  }\n```\n\ncomponents/Todo.js\n```javascript\n  import React, { Component, PropTypes } from 'react'\n\n  export default class Todo extends Component {\n    render() {\n      return (\n        <li\n          onClick={this.props.onClick}\n          style={{\n            textDecoration: this.props.completed ? 'line-through' : 'none',\n            cursor: this.props.completed ? 'default' : 'pointer'\n          }}>\n          {this.props.text}\n        </li>\n      )\n    }\n  }\n\n  Todo.propTypes = {\n    onClick: PropTypes.func.isRequired,\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired\n  }\n```\n\ncomponents/TodoList.js\n```javascript\n  import React, { Component, PropTypes } from 'react'\n  import Todo from './Todo'\n\n  export default class TodoList extends Component {\n    render() {\n      return (\n        <ul>\n          {this.props.todos.map((todo, index) =>\n            <Todo {...todo}\n                  key={index}\n                  onClick={() => this.props.onTodoClick(index)} />\n          )}\n        </ul>\n      )\n    }\n  }\n\n  TodoList.propTypes = {\n    onTodoClick: PropTypes.func.isRequired,\n    todos: PropTypes.arrayOf(PropTypes.shape({\n      text: PropTypes.string.isRequired,\n      completed: PropTypes.bool.isRequired\n    }).isRequired).isRequired\n  }\n```\n>>>>>>> b872c55882669de3f10e29ad039674d345d37f2e\n","slug":"Redux快速上手","published":1,"updated":"2016-05-27T01:28:16.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enb001gb0dl6qugibkq","content":"<blockquote>\n<p>文章转载自<a href=\"http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/Redux%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\" target=\"_blank\" rel=\"external\">Redux快速上手</a>，仅供学习和参考</p>\n</blockquote>\n<p>在实际的项目中，面对复杂业务逻辑的挑战，如何清晰高效的管理应用内的数据流动成为了关键。</p>\n<p>Flux思想已经在提出后得到逐步推广，并广泛应用到实际项目中。facebook的flux实现，开源社区的reflux、redux等类库开始涌现并得到了广大开发者的认同和使用。</p>\n<p>Redux以其简单易用、文档齐全易懂等优点在开源社区得到开发者的一直好评，所以接下来让我们一起走进Redux。</p>\n<h1 id=\"1-基本介绍\"><a href=\"#1-基本介绍\" class=\"headerlink\" title=\"1. 基本介绍\"></a>1. 基本介绍</h1><p>React已经帮我们在视图层解决了禁止异步和直接操作DOM等问题，让页面的高效渲染和组件话开发成为了可能。美中不足的是，React依旧把处理state中数据的问题留给了你，那么，Redux的出现就是为了帮你解决这个问题</p>\n<h2 id=\"1-1-Fulx-amp-Redux\"><a href=\"#1-1-Fulx-amp-Redux\" class=\"headerlink\" title=\"1.1 Fulx &amp; Redux\"></a>1.1 Fulx &amp; Redux</h2><p>最初，facebook官网提出了Flux思想管理数据流，同时也给了自己的实现方案flux来管理React应用。<br><img src=\"/images/react/flux.jpg\" alt=\"Flux\"></p>\n<ol>\n<li>在view中触发action中的方法后</li>\n<li>action发送dispatch</li>\n<li>store接收新的数据进行合并，然后触发view中绑定在store上的方法</li>\n<li>最后通过修改局部state来改变view的展示</li>\n</ol>\n<p><img src=\"/images/react/redux.jpg\" alt=\"Redux\"></p>\n<ol>\n<li>view直接触发dispatch</li>\n<li>dispatch将action发送到reducer中后，根节点上会更新props，改变全局view</li>\n<li>redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中</li>\n</ol>\n<blockquote>\n<p>相对于Flux而言，Redux的实现更简单，思路更清晰，写的代码也相对更少；只维护单一的 store.</p>\n</blockquote>\n<h2 id=\"1-2-对Redux的介绍\"><a href=\"#1-2-对Redux的介绍\" class=\"headerlink\" title=\"1.2 对Redux的介绍\"></a>1.2 对Redux的介绍</h2><ul>\n<li>Redux是State容器，提供可预测化的状态管理</li>\n<li>它可以让你构建一致化的应用，运行于不同的环境(客户端、服务器、原生应用)，并且易于测试</li>\n<li>还提供了redux-devtools让开发者享受超爽的开发体验</li>\n<li>体小精悍(只有2kb)且没有任何依赖</li>\n<li>拥有丰富的生态圈：教程、开发者工具、路由、组件、中间件、工具集…</li>\n</ul>\n<h1 id=\"2-快速上手\"><a href=\"#2-快速上手\" class=\"headerlink\" title=\"2. 快速上手\"></a>2. 快速上手</h1><p>示例代码快速体验<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个reducer，形式为(state,action) =&gt; state 的纯函数。描述了action如何把state转变成下一个state。</span></span><br><span class=\"line\"><span class=\"comment\">//state的形式取决于你，可以是基本类型、数组、对象甚至是Immutable.js生成的数据结构。</span></span><br><span class=\"line\"><span class=\"comment\">//唯一的要点是当state变化时需要返回全新的对象，而不是修改传入的参数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state=0,action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//创建Redux store来存放应用的状态。</span></span><br><span class=\"line\"><span class=\"comment\">//API是&#123;subscribe,dispatch,getState&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(counter);</span><br><span class=\"line\"><span class=\"comment\">//一个单纯渲染页面内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PureRender = () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.innerText = store.getState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以手动订阅更新，也可以事件绑定到视图层</span></span><br><span class=\"line\">store.subscribe(PureRender);</span><br><span class=\"line\"><span class=\"comment\">//执行渲染函数</span></span><br><span class=\"line\">PureRender();</span><br><span class=\"line\"><span class=\"comment\">//改变内部state唯一方法是dispatch一个action。action可以被序列化，用日记记录和存储下来，后期还可以以回放的方式执行。</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//store dispatch 调度分发一个action(fire)</span></span><br><span class=\"line\">  store.dispatch(&#123;type:<span class=\"string\">\"DECREMENT\"</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-理解Redux的核心概念\"><a href=\"#3-理解Redux的核心概念\" class=\"headerlink\" title=\"3. 理解Redux的核心概念\"></a>3. 理解Redux的核心概念</h1><h2 id=\"3-1-Action-amp-Action-Creator\"><a href=\"#3-1-Action-amp-Action-Creator\" class=\"headerlink\" title=\"3.1 Action &amp; Action Creator\"></a>3.1 Action &amp; Action Creator</h2><p>在Redux中，改变state只能通过action,它是store数据的唯一来源。一般来说你会通过store.dispatch()将action传到store。并且每个action都必须是javascript的简单对象，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type:&quot;ADD_TODO&quot;，</span><br><span class=\"line\">  text:&quot;Learn Redux&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Redux要求action是可以被序列化的，这使得应用程序的状态保存、回放、Undo之类的功能可以被实现。因此，action中不能包含诸如函数调用这样的不可序列化的字段。<br>action的格式是有建议规范的，可以包含以下字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type:&quot;ADD_TODO&quot;,</span><br><span class=\"line\">  payload:&#123;</span><br><span class=\"line\">    text:&quot;Do something&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  `meta:&#123;&#125;`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 action 用来表示出错的情况，则可能为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: new Error(),</span><br><span class=\"line\">  error: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>type 是必须要有的属性，其他都是可选的。完整建议请参考 Flux Standard Action(FSA) 定义。已经有不少第三方模块是基于 FSA 的约定来开发了。</p>\n<p><strong>Action Creator</strong><br>事实上，创建 action 对象很少用这种每次直接声明对象的方式，更多地是通过一个创建函数。这个函数被称为Action Creator，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addTodo(text) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Action Creator 看起来很简单，但是如果结合上 Middleware 就可以变得非常灵活，后面会专门讲 Middleware 。</p>\n<h2 id=\"3-2-Reducer\"><a href=\"#3-2-Reducer\" class=\"headerlink\" title=\"3.2 Reducer\"></a>3.2 Reducer</h2><p>我们先来看一下javascript中Array.prototype.reduce的用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initState = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"comment\">//传入当前的state和action，返回新的state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newState = actions.reduce((curState,action) =&gt; curState + action);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newState);</span><br></pre></td></tr></table></figure></p>\n<p>对应的理解，Redux中的reducer是一个纯函数，传入state和action，返回一个新的state tree,简单而纯粹的完成某一件具体的事情，没有依赖，<strong>简单而纯粹是它的标签</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counter = (state=<span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-3-Store\"><a href=\"#3-3-Store\" class=\"headerlink\" title=\"3.3 Store\"></a>3.3 Store</h2><p>Store就是用来维持应用所有的state树的一个对象。改变store内state的唯一途径是对它dispatch一个action。</p>\n<p>Store是一个具有以下四个方法的对象：</p>\n<ul>\n<li>getState()</li>\n<li>dispatch(action)</li>\n<li>subscribe(listener)</li>\n<li>replaceReducer(nextReducer)</li>\n</ul>\n<h3 id=\"3-3-1-getState\"><a href=\"#3-3-1-getState\" class=\"headerlink\" title=\"3.3.1 getState()\"></a>3.3.1 getState()</h3><p>返回应用当前的state树。它与store的最后一个reducer返回值相同。<br>返回值：应用当前的state树。</p>\n<h3 id=\"3-3-2-dispatch-action\"><a href=\"#3-3-2-dispatch-action\" class=\"headerlink\" title=\"3.3.2 dispatch(action)\"></a>3.3.2 dispatch(action)</h3><p>dispatch分发action。<strong>这是出发state变化的唯一途径。</strong><br>会使用当前getState()的结果和传入的action以同步方式的调用store的reduce函数。返回值会被作为下一个state。从现在开始，这就成为了getState()的返回值，同时变化监听器(change listener)会被触发。</p>\n<blockquote>\n<p>在Redux里，只会在根reducer返回新state结束后才会调用事件监听器，因此，你可以在事件监听器里再做dispatch。唯一使你不能在reducer中途diapatch的原因是要确保reducer没有副作用。如果action处理会产生副作用，正确的做法是使用异步action创建函数</p>\n</blockquote>\n<p>示例:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">//reducer</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = (state = [<span class=\"string\">''</span>],action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign([],state,[action.text]);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todos,[ <span class=\"string\">'Use Redux'</span>])</span><br><span class=\"line\"><span class=\"comment\">//action Creator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//dispatch</span></span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read the docs'</span>));</span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read about the middleware'</span>));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-3-subscribe-listener\"><a href=\"#3-3-3-subscribe-listener\" class=\"headerlink\" title=\"3.3.3 subscribe(listener)\"></a>3.3.3 subscribe(listener)</h3><p>添加一个变化监听器。每当dispatch action的时候就会执行，state树中的一部分可能已经变化。这是一个底层API。多数情况下，你不会直接使用它，会使用一些React(或其他库)的绑定。</p>\n<p>示例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">//reducer</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = (state = [<span class=\"string\">''</span>],action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign([].state,[action.text]);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todos,[ <span class=\"string\">'Use Redux'</span>])</span><br><span class=\"line\"><span class=\"comment\">//action Creator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">    type:<span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handleChange = () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store.getState());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> unsubscribe = store.subscribe(handleChange)</span><br><span class=\"line\">handleChange()</span><br><span class=\"line\"><span class=\"comment\">//dispatch</span></span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read the docs'</span>));</span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read about the middleware'</span>));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-Redux的顶层API介绍\"><a href=\"#4-Redux的顶层API介绍\" class=\"headerlink\" title=\"4. Redux的顶层API介绍\"></a>4. Redux的顶层API介绍</h1><h2 id=\"4-1-createStore\"><a href=\"#4-1-createStore\" class=\"headerlink\" title=\"4.1 createStore\"></a>4.1 createStore</h2><p>调用方式：createStore(reducer,[initialState])</p>\n<p>创建一个Redux store来以存放应用中所有的state，应用中应有且仅有一个store。这个API返回一个store,这个store中保存了应用所有state的对象。改变state的唯一方法是dispatch action。你也可以subscrube监听state的变化，然后更新UI。我们来看一个示例。<br><strong>我们可以试着模拟createStore,深入了解其原理</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//reducer纯函数，具体的action执行逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = (state = <span class=\"number\">0</span>,action) =&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;        </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//模拟createStore,了解其原理</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> createStore = (reducer) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = [];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> getState = () =&gt; state;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dispatch = (action) =&gt; &#123;</span><br><span class=\"line\">      state = reducer(state,action);</span><br><span class=\"line\">      listeners.forEach(listener =&gt; listener());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> subscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">      listeners.push(listener);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> () =&gt; &#123;</span><br><span class=\"line\">        listeners = listeners.filter(item =&gt; item !== listener);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">    dispatch(&#123;&#125;);</span><br><span class=\"line\">    return &#123;getState,dispatch,subscribe&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const store = createStore(counter);</span><br><span class=\"line\">  //view 对应到react里面的component</span><br><span class=\"line\">  const PureRender = () =&gt; &#123;</span><br><span class=\"line\">    document.body.innerText = store.getState();</span><br><span class=\"line\">=======</span><br><span class=\"line\">    dispatch();</span><br><span class=\"line\">    return &#123; getState, dispatch, subscribe &#125;;</span><br><span class=\"line\">    const store = createStore(counter);</span><br><span class=\"line\">    // view 对应到React里面的component</span><br><span class=\"line\">    const PureRender = () =&gt; &#123;</span><br><span class=\"line\">      document.body.innerText = store.getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // store subscribe 订阅或是监听view（on）</span><br><span class=\"line\">    store.subscribe(PureRender);</span><br><span class=\"line\">    PureRender();</span><br><span class=\"line\">    document.addEventListener('click', function( e )&#123;</span><br><span class=\"line\">      // store dispatch 调度分发一个 action（fire）</span><br><span class=\"line\">      store.dispatch(&#123; type: 'DECREMENT'&#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-2-combineReducers\"><a href=\"#4-2-combineReducers\" class=\"headerlink\" title=\"4.2 combineReducers\"></a>4.2 combineReducers</h2><p>调用方式：combineReducers(reducers)</p>\n<p>随着应用变得复杂，需要对 reducer 函数进行拆分，拆分后的每一块独立负责管理 state 的一部分。把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。</p>\n<p>示例如下</p>\n<p>代码清单：reducer/todos.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state = [], action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.concat([action.text])</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; b872c55882669de3f10e29ad039674d345d37f2e</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//store subscribe 订阅或是监听view(on)</span></span><br><span class=\"line\">  store.subscribe(PureRender);</span><br><span class=\"line\">  PureRender();</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//store dispatch 调度分发一个action(fire)</span></span><br><span class=\"line\">    store.dispatch(&#123;type:<span class=\"string\">'DECREMENT'</span>&#125;)；</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>\n<h2 id=\"4-2-combineReducers-1\"><a href=\"#4-2-combineReducers-1\" class=\"headerlink\" title=\"4.2 combineReducers\"></a>4.2 combineReducers</h2><p>调用方式：combineReducers(reducers)</p>\n<p>随着应用变得复杂，需要对reducer函数进行拆分，拆分后的每一块独立负责管理state的一部分。把一个由多个不同reducer函数作为value的object，合并成一个最终的reducer函数，然后就可以对这个reducer调用createStore.</p>\n<p>示例如下：<br>代码清单：reducer/todos.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state = [],action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.concat([action.text])</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：reducer/counter.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state = [],action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：reducer/index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  counter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：App.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducer/index.js'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'当前的state: '</span>,store.getState())</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type:<span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">  text:<span class=\"string\">'Use Redux'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type:<span class=\"string\">'INCREMENT'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'改变后的state: '</span>,store.getState());</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-applyMiddleware\"><a href=\"#4-3-applyMiddleware\" class=\"headerlink\" title=\"4.3 applyMiddleware\"></a>4.3 applyMiddleware</h2><p>调用方式: applyMiddleware(…middlewares)</p>\n<p>使用包含自定义功能的middleware来扩展Redux是一种推荐的方式。Middleware可以让你包装store的dispatch方法来达到你想要的目的。同时，middleware还拥有“可组合”这一关键特性。多个middleware可以被组合到一起使用，形成middleware链。其中，每个middleware都不需要关心链中它前后的middleware的任何信息。</p>\n<h2 id=\"4-4-bindActionCreators\"><a href=\"#4-4-bindActionCreators\" class=\"headerlink\" title=\"4.4 bindActionCreators\"></a>4.4 bindActionCreators</h2><p>调用方式：bindActionCreators(actionCreators,dispatch)</p>\n<p>唯一使用bindActionCreators的场景是当你需要把action creator往下传到一个组件上，却不想让这个组件察觉到Redux的存在，而且不希望把Redux store或dispatch传给它。</p>\n<h2 id=\"4-5-compose\"><a href=\"#4-5-compose\" class=\"headerlink\" title=\"4.5 compose\"></a>4.5 compose</h2><p>调用方法：compose(…functions)</p>\n<p>compose用来实现从右到左组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来些深度嵌套的函数，仅此而已。</p>\n<h1 id=\"5-使用React-redux连接react和redux\"><a href=\"#5-使用React-redux连接react和redux\" class=\"headerlink\" title=\"5. 使用React-redux连接react和redux\"></a>5. 使用React-redux连接react和redux</h1><h2 id=\"5-1-没有react-redux的写法\"><a href=\"#5-1-没有react-redux的写法\" class=\"headerlink\" title=\"5.1 没有react-redux的写法\"></a>5.1 没有react-redux的写法</h2><p>封装一个组件，将组件和Redux做基本的组合<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\">  <span class=\"comment\">//reducer 纯函数，具体的action执行逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = (state = <span class=\"number\">0</span>,action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\">  <span class=\"comment\">//Counter组件</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">=======</span><br><span class=\"line\">代码清单：reducer/counter.js</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`javascript</span><br><span class=\"line\">  export default function counter(state = 0, action) &#123;</span><br><span class=\"line\">    switch (action.type) &#123;</span><br><span class=\"line\">    case 'INCREMENT':</span><br><span class=\"line\">      return state + 1</span><br><span class=\"line\">    case 'DECREMENT':</span><br><span class=\"line\">      return state - 1</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      return state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>代码清单：reducers/index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  counter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：App.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducer/index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'当前的 state :'</span>, store.getState())</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">  text: <span class=\"string\">'Use Redux'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'INCREMENT'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'改变后的 state :'</span>, store.getState())</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-applyMiddleware-1\"><a href=\"#4-3-applyMiddleware-1\" class=\"headerlink\" title=\"4.3 applyMiddleware\"></a>4.3 applyMiddleware</h2><p>调用方式：applyMiddleware(…middlewares)</p>\n<p>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息</p>\n<h2 id=\"4-4-bindActionCreators-1\"><a href=\"#4-4-bindActionCreators-1\" class=\"headerlink\" title=\"4.4 bindActionCreators\"></a>4.4 bindActionCreators</h2><p>调用方式：bindActionCreators(actionCreators, dispatch)</p>\n<p>惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。</p>\n<h2 id=\"4-5-compose-1\"><a href=\"#4-5-compose-1\" class=\"headerlink\" title=\"4.5 compose\"></a>4.5 compose</h2><p>调用方式：compose(…functions)</p>\n<p>compose 用来实现从右到左来组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来写深度嵌套的函数，仅此而已。</p>\n<h1 id=\"5-使用React-redux连接react和redux-1\"><a href=\"#5-使用React-redux连接react和redux-1\" class=\"headerlink\" title=\"5 使用React-redux连接react和redux\"></a>5 使用React-redux连接react和redux</h1><h2 id=\"5-1-没有React-redux的写法\"><a href=\"#5-1-没有React-redux的写法\" class=\"headerlink\" title=\"5.1 没有React-redux的写法\"></a>5.1 没有React-redux的写法</h2><p>封装一个组件，将组件和Redux做基本的组合<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// reducer 纯函数，具体的action执行逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = (state = <span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Counter 组件</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; b872c55882669de3f10e29ad039674d345d37f2e</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;h1&gt;&#123;this.props.value&#125;&lt;/h1&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;点击加1&lt;/button&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;this.props.onDecrement&#125;&gt;点击减1&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">  const PureRender = () =&gt; &#123;</span><br><span class=\"line\">    ReactDOM.render(</span><br><span class=\"line\">      &lt;Counter</span><br><span class=\"line\">        value=&#123;store.getState()&#125;</span><br><span class=\"line\">        onIncrement=&#123; () =&gt; store.dispatch(&#123;type: \"INCREMENT\"&#125;) &#125;</span><br><span class=\"line\">        onDecrement=&#123; () =&gt; store.dispatch(&#123;type: \"DECREMENT\"&#125;) &#125;</span><br><span class=\"line\">      /&gt;, document.getElementById('app')</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // store subscribe 订阅或是监听view（on）</span><br><span class=\"line\">  store.subscribe(PureRender)</span><br><span class=\"line\">  PureRender()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-2-React-redux提供的contect和Provider\"><a href=\"#5-2-React-redux提供的contect和Provider\" class=\"headerlink\" title=\"5.2 React-redux提供的contect和Provider\"></a>5.2 React-redux提供的contect和Provider</h2><h1 id=\"使组件层级中的connect-方法都能够获得Redux-store-正常情况下，你的根组件应该嵌套在’‘中才能使用connect-方法。\"><a href=\"#使组件层级中的connect-方法都能够获得Redux-store-正常情况下，你的根组件应该嵌套在’‘中才能使用connect-方法。\" class=\"headerlink\" title=\"使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在’‘中才能使用connect()方法。\"></a><provider store=\"\">使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在’<provider>‘中才能使用connect()方法。</provider></provider></h1><p>  const PureRender = () =&gt; {<br>    ReactDOM.render(<br>        <counter value=\"{store.getState()}\" onincrement=\"{\" ()=\"\"> store.dispatch({type: “INCREMENT”}) }<br>          onDecrement={ () =&gt; store.dispatch({type: “DECREMENT”}) }<br>        /&gt;, document.getElementById(‘app’)<br>    );<br>  }</counter></p>\n<p>  // store subscribe 订阅或是监听view（on）<br>  store.subscribe(PureRender)<br>  PureRender()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 5.2 React-redux提供的connect和Provider</span><br><span class=\"line\">&lt;Provider store&gt;使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在&lt;Provider&gt;中才能使用connect()方法。</span><br><span class=\"line\">```javascript</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &#123;/*  使组件层级中的 connect() 方法都能够获得 Redux store */&#125;</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &#123;/* 这里传入的组件MyRootComponent是组件层级的根组件 */&#125;</span><br><span class=\"line\">      &lt;MyRootComponent /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure></p>\n<p>connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options]) connect方法是来连接React组件与Redux store,连接操作不会改变原来的组件类，反而返回一个新的已与Redux store连接的组件类。</p>\n<p>使用React-redux的一个简单完整示例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider, connect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">//这是一个展示型组件counter</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrementClick&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;value&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrementClick&#125;&gt;点我加一&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Counter.propTypes = &#123;</span><br><span class=\"line\">  value: PropTypes.number.isRequired,</span><br><span class=\"line\">  onIncrementClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Action</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> increaseAction = &#123;type: <span class=\"string\">'increase'</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">//Reducer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state=&#123;count:0&#125;,action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = state.count;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'increase'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;count:count + <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//store</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(counter);</span><br><span class=\"line\"><span class=\"comment\">//Map Redux state to component props</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(state);</span><br><span class=\"line\">  <span class=\"comment\">//这里拿到的state就是store里面给的state</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    value: state.count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Map Redux actions to component props</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    onIncrementClick: () =&gt; dispatch(increaseAction);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//store里的state经过connect连接后给了根组件的props</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.prps);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;react-redux&lt;/h1&gt;</span><br><span class=\"line\">        &lt;Counter &#123;...this.props&#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//Connected Component</span><br><span class=\"line\">let RootApp = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(App)</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;RootApp /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  document.getElementById('app')</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>实际应用中，connect这个部分会比较复杂。</p>\n<h1 id=\"6-一步步开发一个TODO应用\"><a href=\"#6-一步步开发一个TODO应用\" class=\"headerlink\" title=\"6. 一步步开发一个TODO应用\"></a>6. 一步步开发一个TODO应用</h1><h2 id=\"6-1-入口文件\"><a href=\"#6-1-入口文件\" class=\"headerlink\" title=\"6.1 入口文件\"></a>6.1 入口文件</h2><p>index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Provider&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./containers/App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoApp <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todoApp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> rootElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>);</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  rootElement</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-2-Action创建函数和常量\"><a href=\"#6-2-Action创建函数和常量\" class=\"headerlink\" title=\"6.2 Action创建函数和常量\"></a>6.2 Action创建函数和常量</h2><p>action.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//action类型</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO = <span class=\"string\">'ADD_TODO'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> COMPLETE_TODO = <span class=\"string\">'COMPLETE_TODO'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SET_VISIBILITY_FILTER = <span class=\"string\">'SET_VISIBILITY_FILTER'</span>;</span><br><span class=\"line\"><span class=\"comment\">//其他常量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> VisibilityFilter = &#123;</span><br><span class=\"line\">  SHOW_ALL: <span class=\"string\">'SHOW_ALL'</span>,</span><br><span class=\"line\">  SHOW_COMPLETED: <span class=\"string\">'SHOW_COMPLETED'</span>,</span><br><span class=\"line\">  SHOW_ACTIVE: <span class=\"string\">'SHOW_ACTIVE'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//action创建函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;type: ADD_TODO,text&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">completeTodo</span>(<span class=\"params\">index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;type: COMPLETE_TODO,index&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVisibilityFilter</span>(<span class=\"params\">filter</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;type: SET_VISIBILITY_FILTER,filter&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-3-Reducers\"><a href=\"#6-3-Reducers\" class=\"headerlink\" title=\"6.3 Reducers\"></a>6.3 Reducers</h2><p>reducers.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;combineReducers&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ADD_TODO, COMPLETE_TODO, SET_VISIBILITY_FILTER, VisibilityFilter&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;SHOW_ALL&#125; = VisibilityFilter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">visibilityFilter</span>(<span class=\"params\">state = SHOW_ALL, action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.filter</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state=[],action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          text:action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COMPLETE_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state.slice(<span class=\"number\">0</span>,action.index),</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.assign(&#123;&#125;,state[action.index],&#123;</span><br><span class=\"line\">          completed:<span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        ...state.slice(action.index + <span class=\"number\">1</span>)</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  visibilityFilter,</span><br><span class=\"line\">  todos</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-4-容器组件\"><a href=\"#6-4-容器组件\" class=\"headerlink\" title=\"6.4 容器组件\"></a>6.4 容器组件</h2><p>containers/App.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component, PropTypes&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;connect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;addTodo, completeTodo, setVisibilityFilter, VisibilityFilter&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> AddTodo <span class=\"keyword\">from</span> <span class=\"string\">'../components/AddTodo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">'../components/TodoList'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Footer <span class=\"keyword\">from</span> <span class=\"string\">'../components/Footer'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Injected by connect() call</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;dispatch, visibleTodos, visibilityFilter &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;AddTodo onAddClick=&#123;text =&gt;</span><br><span class=\"line\">          dispatch(addTodo(text))</span><br><span class=\"line\">        &#125; /&gt;</span><br><span class=\"line\">        &lt;TodoList</span><br><span class=\"line\">          todos=&#123;visibleTodos&#125;</span><br><span class=\"line\">          onAddClick=&#123;index =&gt;</span><br><span class=\"line\">            dispatch(completeTodo(index))</span><br><span class=\"line\">        &#125; /&gt;</span><br><span class=\"line\">        &lt;Footer</span><br><span class=\"line\">          filter=&#123;visibilityFilter&#125;</span><br><span class=\"line\">          onFilterChange=&#123;nextFilter =&gt;</span><br><span class=\"line\">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class=\"line\">        &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.propTypes = &#123;</span><br><span class=\"line\">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class=\"line\">    text: PropTypes.string.isRequired,</span><br><span class=\"line\">    completed: PropTypes.bool.isRequired</span><br><span class=\"line\">  &#125;).isRequired).isRequired,</span><br><span class=\"line\">  visibilityFilter: PropTypes.oneOf(&#123;</span><br><span class=\"line\">    'SHOW_ALL',</span><br><span class=\"line\">    'SHOW_COMPLETED',</span><br><span class=\"line\">    'SHOW_ACTIVE'</span><br><span class=\"line\">  &#125;).isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function selectTodos(todo,filter)&#123;</span><br><span class=\"line\">  switch(filter)&#123;</span><br><span class=\"line\">    case visibilityFilters.SHOW_ALL:</span><br><span class=\"line\">      return todos</span><br><span class=\"line\">    case VisibilityFilters.SHOW_COMPLETED:</span><br><span class=\"line\">      return todos.filter(todo =&gt; todo.completed)</span><br><span class=\"line\">    case VisibilityFilters.SHOW_ACTIVE:</span><br><span class=\"line\">      return todos.filter(todo =&gt; !todo.completed)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function select(state)&#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visibleTodos: selectTodos(state.todos,state.visibilityFilter),</span><br><span class=\"line\">    visibilityFilter: state.visibilityFilter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；</span><br><span class=\"line\">export default connect(select)(App)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-5-展示组件\"><a href=\"#6-5-展示组件\" class=\"headerlink\" title=\"6.5 展示组件\"></a>6.5 展示组件</h2><p>components/AddTodo.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component, PropTypes&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddTodo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type='text' ref='input' /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class=\"line\">          Add</span><br><span class=\"line\">        &lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick(e) &#123;</span><br><span class=\"line\">    const node = this.refs.input</span><br><span class=\"line\">    const text = node.value.trim()</span><br><span class=\"line\">    this.props.onAddClick(text)</span><br><span class=\"line\">    node.value = ''</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AddTodo.propTypes = &#123;</span><br><span class=\"line\">  onAddClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>components/Footer.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Footer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  renderFilter(filter, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filter === <span class=\"keyword\">this</span>.props.filter) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;a href='#' onClick=&#123;e =&gt; &#123;</span><br><span class=\"line\">        e.preventDefault()</span><br><span class=\"line\">        this.props.onFilterChange(filter)</span><br><span class=\"line\">      &#125;&#125;&gt;</span><br><span class=\"line\">        &#123;name&#125;</span><br><span class=\"line\">      &lt;/a&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Show:</span><br><span class=\"line\">        &#123;' '&#125;</span><br><span class=\"line\">        &#123;this.renderFilter('SHOW_ALL', 'All')&#125;</span><br><span class=\"line\">        &#123;', '&#125;</span><br><span class=\"line\">        &#123;this.renderFilter('SHOW_COMPLETED', 'Completed')&#125;</span><br><span class=\"line\">        &#123;', '&#125;</span><br><span class=\"line\">        &#123;this.renderFilter('SHOW_ACTIVE', 'Active')&#125;</span><br><span class=\"line\">        .</span><br><span class=\"line\">      &lt;/p&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Footer.propTypes = &#123;</span><br><span class=\"line\">    onFilterChange: PropTypes.func.isRequired,</span><br><span class=\"line\">    filter: PropTypes.oneOf([</span><br><span class=\"line\">      <span class=\"string\">'SHOW_ALL'</span>,</span><br><span class=\"line\">      <span class=\"string\">'SHOW_COMPLETED'</span>,</span><br><span class=\"line\">      <span class=\"string\">'SHOW_ACTIVE'</span></span><br><span class=\"line\">    ]).isRequired</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>components/Todo.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;li</span><br><span class=\"line\">        onClick=&#123;this.props.onClick&#125;</span><br><span class=\"line\">        style=&#123;&#123;</span><br><span class=\"line\">          textDecoration: this.props.completed ? 'line-through' : 'none',</span><br><span class=\"line\">          cursor: this.props.completed ? 'default' : 'pointer'</span><br><span class=\"line\">        &#125;&#125;&gt;</span><br><span class=\"line\">        &#123;this.props.text&#125;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Todo.propTypes = &#123;</span><br><span class=\"line\">  onClick: PropTypes.func.isRequired,</span><br><span class=\"line\">  text: PropTypes.string.isRequired,</span><br><span class=\"line\">  completed: PropTypes.bool.isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>components/TodoList.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Todo <span class=\"keyword\">from</span> <span class=\"string\">'./Todo'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TodoList</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul&gt;</span><br><span class=\"line\">        &#123;this.props.todos.map((todo, index) =&gt;</span><br><span class=\"line\">          &lt;Todo &#123;...todo&#125;</span><br><span class=\"line\">                key=&#123;index&#125;</span><br><span class=\"line\">                onClick=&#123;() =&gt; this.props.onTodoClick(index)&#125; /&gt;</span><br><span class=\"line\">        )&#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TodoList.propTypes = &#123;</span><br><span class=\"line\">  onTodoClick: PropTypes.func.isRequired,</span><br><span class=\"line\">  todos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class=\"line\">    text: PropTypes.string.isRequired,</span><br><span class=\"line\">    completed: PropTypes.bool.isRequired</span><br><span class=\"line\">  &#125;).isRequired).isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>b872c55882669de3f10e29ad039674d345d37f2e</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n","excerpt":"","more":"<blockquote>\n<p>文章转载自<a href=\"http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/Redux%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B.html\">Redux快速上手</a>，仅供学习和参考</p>\n</blockquote>\n<p>在实际的项目中，面对复杂业务逻辑的挑战，如何清晰高效的管理应用内的数据流动成为了关键。</p>\n<p>Flux思想已经在提出后得到逐步推广，并广泛应用到实际项目中。facebook的flux实现，开源社区的reflux、redux等类库开始涌现并得到了广大开发者的认同和使用。</p>\n<p>Redux以其简单易用、文档齐全易懂等优点在开源社区得到开发者的一直好评，所以接下来让我们一起走进Redux。</p>\n<h1 id=\"1-基本介绍\"><a href=\"#1-基本介绍\" class=\"headerlink\" title=\"1. 基本介绍\"></a>1. 基本介绍</h1><p>React已经帮我们在视图层解决了禁止异步和直接操作DOM等问题，让页面的高效渲染和组件话开发成为了可能。美中不足的是，React依旧把处理state中数据的问题留给了你，那么，Redux的出现就是为了帮你解决这个问题</p>\n<h2 id=\"1-1-Fulx-amp-Redux\"><a href=\"#1-1-Fulx-amp-Redux\" class=\"headerlink\" title=\"1.1 Fulx &amp; Redux\"></a>1.1 Fulx &amp; Redux</h2><p>最初，facebook官网提出了Flux思想管理数据流，同时也给了自己的实现方案flux来管理React应用。<br><img src=\"/images/react/flux.jpg\" alt=\"Flux\"></p>\n<ol>\n<li>在view中触发action中的方法后</li>\n<li>action发送dispatch</li>\n<li>store接收新的数据进行合并，然后触发view中绑定在store上的方法</li>\n<li>最后通过修改局部state来改变view的展示</li>\n</ol>\n<p><img src=\"/images/react/redux.jpg\" alt=\"Redux\"></p>\n<ol>\n<li>view直接触发dispatch</li>\n<li>dispatch将action发送到reducer中后，根节点上会更新props，改变全局view</li>\n<li>redux将view和store的绑定从手动编码中提取出来，放在了统一规范放在了自己的体系中</li>\n</ol>\n<blockquote>\n<p>相对于Flux而言，Redux的实现更简单，思路更清晰，写的代码也相对更少；只维护单一的 store.</p>\n</blockquote>\n<h2 id=\"1-2-对Redux的介绍\"><a href=\"#1-2-对Redux的介绍\" class=\"headerlink\" title=\"1.2 对Redux的介绍\"></a>1.2 对Redux的介绍</h2><ul>\n<li>Redux是State容器，提供可预测化的状态管理</li>\n<li>它可以让你构建一致化的应用，运行于不同的环境(客户端、服务器、原生应用)，并且易于测试</li>\n<li>还提供了redux-devtools让开发者享受超爽的开发体验</li>\n<li>体小精悍(只有2kb)且没有任何依赖</li>\n<li>拥有丰富的生态圈：教程、开发者工具、路由、组件、中间件、工具集…</li>\n</ul>\n<h1 id=\"2-快速上手\"><a href=\"#2-快速上手\" class=\"headerlink\" title=\"2. 快速上手\"></a>2. 快速上手</h1><p>示例代码快速体验<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个reducer，形式为(state,action) =&gt; state 的纯函数。描述了action如何把state转变成下一个state。</span></span><br><span class=\"line\"><span class=\"comment\">//state的形式取决于你，可以是基本类型、数组、对象甚至是Immutable.js生成的数据结构。</span></span><br><span class=\"line\"><span class=\"comment\">//唯一的要点是当state变化时需要返回全新的对象，而不是修改传入的参数。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state=0,action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//创建Redux store来存放应用的状态。</span></span><br><span class=\"line\"><span class=\"comment\">//API是&#123;subscribe,dispatch,getState&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(counter);</span><br><span class=\"line\"><span class=\"comment\">//一个单纯渲染页面内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> PureRender = () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.innerText = store.getState();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//可以手动订阅更新，也可以事件绑定到视图层</span></span><br><span class=\"line\">store.subscribe(PureRender);</span><br><span class=\"line\"><span class=\"comment\">//执行渲染函数</span></span><br><span class=\"line\">PureRender();</span><br><span class=\"line\"><span class=\"comment\">//改变内部state唯一方法是dispatch一个action。action可以被序列化，用日记记录和存储下来，后期还可以以回放的方式执行。</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//store dispatch 调度分发一个action(fire)</span></span><br><span class=\"line\">  store.dispatch(&#123;type:<span class=\"string\">\"DECREMENT\"</span>&#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"3-理解Redux的核心概念\"><a href=\"#3-理解Redux的核心概念\" class=\"headerlink\" title=\"3. 理解Redux的核心概念\"></a>3. 理解Redux的核心概念</h1><h2 id=\"3-1-Action-amp-Action-Creator\"><a href=\"#3-1-Action-amp-Action-Creator\" class=\"headerlink\" title=\"3.1 Action &amp; Action Creator\"></a>3.1 Action &amp; Action Creator</h2><p>在Redux中，改变state只能通过action,它是store数据的唯一来源。一般来说你会通过store.dispatch()将action传到store。并且每个action都必须是javascript的简单对象，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type:&quot;ADD_TODO&quot;，</span><br><span class=\"line\">  text:&quot;Learn Redux&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Redux要求action是可以被序列化的，这使得应用程序的状态保存、回放、Undo之类的功能可以被实现。因此，action中不能包含诸如函数调用这样的不可序列化的字段。<br>action的格式是有建议规范的，可以包含以下字段：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type:&quot;ADD_TODO&quot;,</span><br><span class=\"line\">  payload:&#123;</span><br><span class=\"line\">    text:&quot;Do something&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  `meta:&#123;&#125;`</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 action 用来表示出错的情况，则可能为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  type: &apos;ADD_TODO&apos;,</span><br><span class=\"line\">  payload: new Error(),</span><br><span class=\"line\">  error: true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>type 是必须要有的属性，其他都是可选的。完整建议请参考 Flux Standard Action(FSA) 定义。已经有不少第三方模块是基于 FSA 的约定来开发了。</p>\n<p><strong>Action Creator</strong><br>事实上，创建 action 对象很少用这种每次直接声明对象的方式，更多地是通过一个创建函数。这个函数被称为Action Creator，例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function addTodo(text) &#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Action Creator 看起来很简单，但是如果结合上 Middleware 就可以变得非常灵活，后面会专门讲 Middleware 。</p>\n<h2 id=\"3-2-Reducer\"><a href=\"#3-2-Reducer\" class=\"headerlink\" title=\"3.2 Reducer\"></a>3.2 Reducer</h2><p>我们先来看一下javascript中Array.prototype.reduce的用法：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> initState = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> actions = [<span class=\"string\">'a'</span>,<span class=\"string\">'b'</span>,<span class=\"string\">'c'</span>];</span><br><span class=\"line\"><span class=\"comment\">//传入当前的state和action，返回新的state</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newState = actions.reduce((curState,action) =&gt; curState + action);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(newState);</span><br></pre></td></tr></table></figure></p>\n<p>对应的理解，Redux中的reducer是一个纯函数，传入state和action，返回一个新的state tree,简单而纯粹的完成某一件具体的事情，没有依赖，<strong>简单而纯粹是它的标签</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> counter = (state=<span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"3-3-Store\"><a href=\"#3-3-Store\" class=\"headerlink\" title=\"3.3 Store\"></a>3.3 Store</h2><p>Store就是用来维持应用所有的state树的一个对象。改变store内state的唯一途径是对它dispatch一个action。</p>\n<p>Store是一个具有以下四个方法的对象：</p>\n<ul>\n<li>getState()</li>\n<li>dispatch(action)</li>\n<li>subscribe(listener)</li>\n<li>replaceReducer(nextReducer)</li>\n</ul>\n<h3 id=\"3-3-1-getState\"><a href=\"#3-3-1-getState\" class=\"headerlink\" title=\"3.3.1 getState()\"></a>3.3.1 getState()</h3><p>返回应用当前的state树。它与store的最后一个reducer返回值相同。<br>返回值：应用当前的state树。</p>\n<h3 id=\"3-3-2-dispatch-action\"><a href=\"#3-3-2-dispatch-action\" class=\"headerlink\" title=\"3.3.2 dispatch(action)\"></a>3.3.2 dispatch(action)</h3><p>dispatch分发action。<strong>这是出发state变化的唯一途径。</strong><br>会使用当前getState()的结果和传入的action以同步方式的调用store的reduce函数。返回值会被作为下一个state。从现在开始，这就成为了getState()的返回值，同时变化监听器(change listener)会被触发。</p>\n<blockquote>\n<p>在Redux里，只会在根reducer返回新state结束后才会调用事件监听器，因此，你可以在事件监听器里再做dispatch。唯一使你不能在reducer中途diapatch的原因是要确保reducer没有副作用。如果action处理会产生副作用，正确的做法是使用异步action创建函数</p>\n</blockquote>\n<p>示例:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">//reducer</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = (state = [<span class=\"string\">''</span>],action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign([],state,[action.text]);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todos,[ <span class=\"string\">'Use Redux'</span>])</span><br><span class=\"line\"><span class=\"comment\">//action Creator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//dispatch</span></span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read the docs'</span>));</span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read about the middleware'</span>));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"3-3-3-subscribe-listener\"><a href=\"#3-3-3-subscribe-listener\" class=\"headerlink\" title=\"3.3.3 subscribe(listener)\"></a>3.3.3 subscribe(listener)</h3><p>添加一个变化监听器。每当dispatch action的时候就会执行，state树中的一部分可能已经变化。这是一个底层API。多数情况下，你不会直接使用它，会使用一些React(或其他库)的绑定。</p>\n<p>示例：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">//reducer</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = (state = [<span class=\"string\">''</span>],action) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign([].state,[action.text]);</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todos,[ <span class=\"string\">'Use Redux'</span>])</span><br><span class=\"line\"><span class=\"comment\">//action Creator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span>&#123;</span><br><span class=\"line\">    type:<span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> handleChange = () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(store.getState());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> unsubscribe = store.subscribe(handleChange)</span><br><span class=\"line\">handleChange()</span><br><span class=\"line\"><span class=\"comment\">//dispatch</span></span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read the docs'</span>));</span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Read about the middleware'</span>));</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"4-Redux的顶层API介绍\"><a href=\"#4-Redux的顶层API介绍\" class=\"headerlink\" title=\"4. Redux的顶层API介绍\"></a>4. Redux的顶层API介绍</h1><h2 id=\"4-1-createStore\"><a href=\"#4-1-createStore\" class=\"headerlink\" title=\"4.1 createStore\"></a>4.1 createStore</h2><p>调用方式：createStore(reducer,[initialState])</p>\n<p>创建一个Redux store来以存放应用中所有的state，应用中应有且仅有一个store。这个API返回一个store,这个store中保存了应用所有state的对象。改变state的唯一方法是dispatch action。你也可以subscrube监听state的变化，然后更新UI。我们来看一个示例。<br><strong>我们可以试着模拟createStore,深入了解其原理</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\">//reducer纯函数，具体的action执行逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = (state = <span class=\"number\">0</span>,action) =&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;        </span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//模拟createStore,了解其原理</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> createStore = (reducer) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> state;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> listeners = [];</span><br><span class=\"line\">    <span class=\"keyword\">const</span> getState = () =&gt; state;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> dispatch = (action) =&gt; &#123;</span><br><span class=\"line\">      state = reducer(state,action);</span><br><span class=\"line\">      listeners.forEach(listener =&gt; listener());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> subscribe = (listener) =&gt; &#123;</span><br><span class=\"line\">      listeners.push(listener);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> () =&gt; &#123;</span><br><span class=\"line\">        listeners = listeners.filter(item =&gt; item !== listener);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">    dispatch(&#123;&#125;);</span><br><span class=\"line\">    return &#123;getState,dispatch,subscribe&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  const store = createStore(counter);</span><br><span class=\"line\">  //view 对应到react里面的component</span><br><span class=\"line\">  const PureRender = () =&gt; &#123;</span><br><span class=\"line\">    document.body.innerText = store.getState();</span><br><span class=\"line\">=======</span><br><span class=\"line\">    dispatch();</span><br><span class=\"line\">    return &#123; getState, dispatch, subscribe &#125;;</span><br><span class=\"line\">    const store = createStore(counter);</span><br><span class=\"line\">    // view 对应到React里面的component</span><br><span class=\"line\">    const PureRender = () =&gt; &#123;</span><br><span class=\"line\">      document.body.innerText = store.getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // store subscribe 订阅或是监听view（on）</span><br><span class=\"line\">    store.subscribe(PureRender);</span><br><span class=\"line\">    PureRender();</span><br><span class=\"line\">    document.addEventListener('click', function( e )&#123;</span><br><span class=\"line\">      // store dispatch 调度分发一个 action（fire）</span><br><span class=\"line\">      store.dispatch(&#123; type: 'DECREMENT'&#125;);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-2-combineReducers\"><a href=\"#4-2-combineReducers\" class=\"headerlink\" title=\"4.2 combineReducers\"></a>4.2 combineReducers</h2><p>调用方式：combineReducers(reducers)</p>\n<p>随着应用变得复杂，需要对 reducer 函数进行拆分，拆分后的每一块独立负责管理 state 的一部分。把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore。</p>\n<p>示例如下</p>\n<p>代码清单：reducer/todos.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state = [], action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.concat([action.text])</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; b872c55882669de3f10e29ad039674d345d37f2e</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//store subscribe 订阅或是监听view(on)</span></span><br><span class=\"line\">  store.subscribe(PureRender);</span><br><span class=\"line\">  PureRender();</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'click'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//store dispatch 调度分发一个action(fire)</span></span><br><span class=\"line\">    store.dispatch(&#123;type:<span class=\"string\">'DECREMENT'</span>&#125;)；</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>\n<h2 id=\"4-2-combineReducers-1\"><a href=\"#4-2-combineReducers-1\" class=\"headerlink\" title=\"4.2 combineReducers\"></a>4.2 combineReducers</h2><p>调用方式：combineReducers(reducers)</p>\n<p>随着应用变得复杂，需要对reducer函数进行拆分，拆分后的每一块独立负责管理state的一部分。把一个由多个不同reducer函数作为value的object，合并成一个最终的reducer函数，然后就可以对这个reducer调用createStore.</p>\n<p>示例如下：<br>代码清单：reducer/todos.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state = [],action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.concat([action.text])</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：reducer/counter.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state = [],action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state - <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：reducer/index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  counter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：App.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducer/index.js'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'当前的state: '</span>,store.getState())</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type:<span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">  text:<span class=\"string\">'Use Redux'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type:<span class=\"string\">'INCREMENT'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'改变后的state: '</span>,store.getState());</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-applyMiddleware\"><a href=\"#4-3-applyMiddleware\" class=\"headerlink\" title=\"4.3 applyMiddleware\"></a>4.3 applyMiddleware</h2><p>调用方式: applyMiddleware(…middlewares)</p>\n<p>使用包含自定义功能的middleware来扩展Redux是一种推荐的方式。Middleware可以让你包装store的dispatch方法来达到你想要的目的。同时，middleware还拥有“可组合”这一关键特性。多个middleware可以被组合到一起使用，形成middleware链。其中，每个middleware都不需要关心链中它前后的middleware的任何信息。</p>\n<h2 id=\"4-4-bindActionCreators\"><a href=\"#4-4-bindActionCreators\" class=\"headerlink\" title=\"4.4 bindActionCreators\"></a>4.4 bindActionCreators</h2><p>调用方式：bindActionCreators(actionCreators,dispatch)</p>\n<p>唯一使用bindActionCreators的场景是当你需要把action creator往下传到一个组件上，却不想让这个组件察觉到Redux的存在，而且不希望把Redux store或dispatch传给它。</p>\n<h2 id=\"4-5-compose\"><a href=\"#4-5-compose\" class=\"headerlink\" title=\"4.5 compose\"></a>4.5 compose</h2><p>调用方法：compose(…functions)</p>\n<p>compose用来实现从右到左组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来些深度嵌套的函数，仅此而已。</p>\n<h1 id=\"5-使用React-redux连接react和redux\"><a href=\"#5-使用React-redux连接react和redux\" class=\"headerlink\" title=\"5. 使用React-redux连接react和redux\"></a>5. 使用React-redux连接react和redux</h1><h2 id=\"5-1-没有react-redux的写法\"><a href=\"#5-1-没有react-redux的写法\" class=\"headerlink\" title=\"5.1 没有react-redux的写法\"></a>5.1 没有react-redux的写法</h2><p>封装一个组件，将组件和Redux做基本的组合<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> React, &#123;Component&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\">  <span class=\"comment\">//reducer 纯函数，具体的action执行逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = (state = <span class=\"number\">0</span>,action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\">  <span class=\"comment\">//Counter组件</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">=======</span><br><span class=\"line\">代码清单：reducer/counter.js</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`javascript</span><br><span class=\"line\">  export default function counter(state = 0, action) &#123;</span><br><span class=\"line\">    switch (action.type) &#123;</span><br><span class=\"line\">    case 'INCREMENT':</span><br><span class=\"line\">      return state + 1</span><br><span class=\"line\">    case 'DECREMENT':</span><br><span class=\"line\">      return state - 1</span><br><span class=\"line\">    default:</span><br><span class=\"line\">      return state</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>代码清单：reducers/index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todos <span class=\"keyword\">from</span> <span class=\"string\">'./todos'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> counter <span class=\"keyword\">from</span> <span class=\"string\">'./counter'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> combineReducers(&#123;</span><br><span class=\"line\">  todos,</span><br><span class=\"line\">  counter</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>代码清单：App.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducer/index.js'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(reducer)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'当前的 state :'</span>, store.getState())</span><br><span class=\"line\"></span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'ADD_TODO'</span>,</span><br><span class=\"line\">  text: <span class=\"string\">'Use Redux'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'INCREMENT'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'改变后的 state :'</span>, store.getState())</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"4-3-applyMiddleware-1\"><a href=\"#4-3-applyMiddleware-1\" class=\"headerlink\" title=\"4.3 applyMiddleware\"></a>4.3 applyMiddleware</h2><p>调用方式：applyMiddleware(…middlewares)</p>\n<p>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息</p>\n<h2 id=\"4-4-bindActionCreators-1\"><a href=\"#4-4-bindActionCreators-1\" class=\"headerlink\" title=\"4.4 bindActionCreators\"></a>4.4 bindActionCreators</h2><p>调用方式：bindActionCreators(actionCreators, dispatch)</p>\n<p>惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。</p>\n<h2 id=\"4-5-compose-1\"><a href=\"#4-5-compose-1\" class=\"headerlink\" title=\"4.5 compose\"></a>4.5 compose</h2><p>调用方式：compose(…functions)</p>\n<p>compose 用来实现从右到左来组合传入的多个函数，它做的只是让你不使用深度右括号的情况下来写深度嵌套的函数，仅此而已。</p>\n<h1 id=\"5-使用React-redux连接react和redux-1\"><a href=\"#5-使用React-redux连接react和redux-1\" class=\"headerlink\" title=\"5 使用React-redux连接react和redux\"></a>5 使用React-redux连接react和redux</h1><h2 id=\"5-1-没有React-redux的写法\"><a href=\"#5-1-没有React-redux的写法\" class=\"headerlink\" title=\"5.1 没有React-redux的写法\"></a>5.1 没有React-redux的写法</h2><p>封装一个组件，将组件和Redux做基本的组合<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> React, &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// reducer 纯函数，具体的action执行逻辑</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> counter = (state = <span class=\"number\">0</span>, action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'INCREMENT'</span>:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'DECREMENT'</span>:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> store = createStore(counter);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Counter 组件</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; b872c55882669de3f10e29ad039674d345d37f2e</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;h1&gt;&#123;this.props.value&#125;&lt;/h1&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;this.props.onIncrement&#125;&gt;点击加1&lt;/button&gt;</span><br><span class=\"line\">          &lt;button onClick=&#123;this.props.onDecrement&#125;&gt;点击减1&lt;/button&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">  const PureRender = () =&gt; &#123;</span><br><span class=\"line\">    ReactDOM.render(</span><br><span class=\"line\">      &lt;Counter</span><br><span class=\"line\">        value=&#123;store.getState()&#125;</span><br><span class=\"line\">        onIncrement=&#123; () =&gt; store.dispatch(&#123;type: \"INCREMENT\"&#125;) &#125;</span><br><span class=\"line\">        onDecrement=&#123; () =&gt; store.dispatch(&#123;type: \"DECREMENT\"&#125;) &#125;</span><br><span class=\"line\">      /&gt;, document.getElementById('app')</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // store subscribe 订阅或是监听view（on）</span><br><span class=\"line\">  store.subscribe(PureRender)</span><br><span class=\"line\">  PureRender()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"5-2-React-redux提供的contect和Provider\"><a href=\"#5-2-React-redux提供的contect和Provider\" class=\"headerlink\" title=\"5.2 React-redux提供的contect和Provider\"></a>5.2 React-redux提供的contect和Provider</h2><h1 id=\"使组件层级中的connect-方法都能够获得Redux-store-正常情况下，你的根组件应该嵌套在’‘中才能使用connect-方法。\"><a href=\"#使组件层级中的connect-方法都能够获得Redux-store-正常情况下，你的根组件应该嵌套在’‘中才能使用connect-方法。\" class=\"headerlink\" title=\"使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在’‘中才能使用connect()方法。\"></a><Provider store>使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在’<Provider>‘中才能使用connect()方法。</h1><p>  const PureRender = () =&gt; {<br>    ReactDOM.render(<br>        <Counter\n          value={store.getState()}\n          onIncrement={ () => store.dispatch({type: “INCREMENT”}) }<br>          onDecrement={ () =&gt; store.dispatch({type: “DECREMENT”}) }<br>        /&gt;, document.getElementById(‘app’)<br>    );<br>  }</p>\n<p>  // store subscribe 订阅或是监听view（on）<br>  store.subscribe(PureRender)<br>  PureRender()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">## 5.2 React-redux提供的connect和Provider</span><br><span class=\"line\">&lt;Provider store&gt;使组件层级中的connect()方法都能够获得Redux store.正常情况下，你的根组件应该嵌套在&lt;Provider&gt;中才能使用connect()方法。</span><br><span class=\"line\">```javascript</span><br><span class=\"line\">  ReactDOM.render(</span><br><span class=\"line\">    &#123;/*  使组件层级中的 connect() 方法都能够获得 Redux store */&#125;</span><br><span class=\"line\">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">      &#123;/* 这里传入的组件MyRootComponent是组件层级的根组件 */&#125;</span><br><span class=\"line\">      &lt;MyRootComponent /&gt;</span><br><span class=\"line\">    &lt;/Provider&gt;</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure></p>\n<p>connect([mapStateToProps],[mapDispatchToProps],[mergeProps],[options]) connect方法是来连接React组件与Redux store,连接操作不会改变原来的组件类，反而返回一个新的已与Redux store连接的组件类。</p>\n<p>使用React-redux的一个简单完整示例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> ReactDOM <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider, connect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"comment\">//这是一个展示型组件counter</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123; value, onIncrementClick&#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;span&gt;&#123;value&#125;&lt;/span&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;onIncrementClick&#125;&gt;点我加一&lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Counter.propTypes = &#123;</span><br><span class=\"line\">  value: PropTypes.number.isRequired,</span><br><span class=\"line\">  onIncrementClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Action</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> increaseAction = &#123;type: <span class=\"string\">'increase'</span>&#125;</span><br><span class=\"line\"><span class=\"comment\">//Reducer</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">counter</span>(<span class=\"params\">state=&#123;count:0&#125;,action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> count = state.count;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'increase'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;count:count + <span class=\"number\">1</span>&#125;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//store</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(counter);</span><br><span class=\"line\"><span class=\"comment\">//Map Redux state to component props</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapStateToProps</span>(<span class=\"params\">state</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(state);</span><br><span class=\"line\">  <span class=\"comment\">//这里拿到的state就是store里面给的state</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    value: state.count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Map Redux actions to component props</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mapDispatchToProps</span>(<span class=\"params\">dispatch</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    onIncrementClick: () =&gt; dispatch(increaseAction);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//store里的state经过connect连接后给了根组件的props</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.prps);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;h1&gt;react-redux&lt;/h1&gt;</span><br><span class=\"line\">        &lt;Counter &#123;...this.props&#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//Connected Component</span><br><span class=\"line\">let RootApp = connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(App)</span><br><span class=\"line\">ReactDOM.render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;RootApp /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  document.getElementById('app')</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>实际应用中，connect这个部分会比较复杂。</p>\n<h1 id=\"6-一步步开发一个TODO应用\"><a href=\"#6-一步步开发一个TODO应用\" class=\"headerlink\" title=\"6. 一步步开发一个TODO应用\"></a>6. 一步步开发一个TODO应用</h1><h2 id=\"6-1-入口文件\"><a href=\"#6-1-入口文件\" class=\"headerlink\" title=\"6.1 入口文件\"></a>6.1 入口文件</h2><p>index.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;render&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;createStore&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Provider&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./containers/App'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> todoApp <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todoApp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> rootElement = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'app'</span>);</span><br><span class=\"line\">render(</span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;/Provider&gt;,</span><br><span class=\"line\">  rootElement</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-2-Action创建函数和常量\"><a href=\"#6-2-Action创建函数和常量\" class=\"headerlink\" title=\"6.2 Action创建函数和常量\"></a>6.2 Action创建函数和常量</h2><p>action.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//action类型</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> ADD_TODO = <span class=\"string\">'ADD_TODO'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> COMPLETE_TODO = <span class=\"string\">'COMPLETE_TODO'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SET_VISIBILITY_FILTER = <span class=\"string\">'SET_VISIBILITY_FILTER'</span>;</span><br><span class=\"line\"><span class=\"comment\">//其他常量</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> VisibilityFilter = &#123;</span><br><span class=\"line\">  SHOW_ALL: <span class=\"string\">'SHOW_ALL'</span>,</span><br><span class=\"line\">  SHOW_COMPLETED: <span class=\"string\">'SHOW_COMPLETED'</span>,</span><br><span class=\"line\">  SHOW_ACTIVE: <span class=\"string\">'SHOW_ACTIVE'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//action创建函数</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;type: ADD_TODO,text&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">completeTodo</span>(<span class=\"params\">index</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;type: COMPLETE_TODO,index&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setVisibilityFilter</span>(<span class=\"params\">filter</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;type: SET_VISIBILITY_FILTER,filter&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-3-Reducers\"><a href=\"#6-3-Reducers\" class=\"headerlink\" title=\"6.3 Reducers\"></a>6.3 Reducers</h2><p>reducers.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;combineReducers&#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;ADD_TODO, COMPLETE_TODO, SET_VISIBILITY_FILTER, VisibilityFilter&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123;SHOW_ALL&#125; = VisibilityFilter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">visibilityFilter</span>(<span class=\"params\">state = SHOW_ALL, action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action.filter</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todos</span>(<span class=\"params\">state=[],action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          text:action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">case</span> COMPLETE_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state.slice(<span class=\"number\">0</span>,action.index),</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.assign(&#123;&#125;,state[action.index],&#123;</span><br><span class=\"line\">          completed:<span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        ...state.slice(action.index + <span class=\"number\">1</span>)</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  visibilityFilter,</span><br><span class=\"line\">  todos</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> todoApp</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-4-容器组件\"><a href=\"#6-4-容器组件\" class=\"headerlink\" title=\"6.4 容器组件\"></a>6.4 容器组件</h2><p>containers/App.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component, PropTypes&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;connect&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;addTodo, completeTodo, setVisibilityFilter, VisibilityFilter&#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> AddTodo <span class=\"keyword\">from</span> <span class=\"string\">'../components/AddTodo'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">'../components/TodoList'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Footer <span class=\"keyword\">from</span> <span class=\"string\">'../components/Footer'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">App</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render()&#123;</span><br><span class=\"line\">    <span class=\"comment\">//Injected by connect() call</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;dispatch, visibleTodos, visibilityFilter &#125; = <span class=\"keyword\">this</span>.props;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;AddTodo onAddClick=&#123;text =&gt;</span><br><span class=\"line\">          dispatch(addTodo(text))</span><br><span class=\"line\">        &#125; /&gt;</span><br><span class=\"line\">        &lt;TodoList</span><br><span class=\"line\">          todos=&#123;visibleTodos&#125;</span><br><span class=\"line\">          onAddClick=&#123;index =&gt;</span><br><span class=\"line\">            dispatch(completeTodo(index))</span><br><span class=\"line\">        &#125; /&gt;</span><br><span class=\"line\">        &lt;Footer</span><br><span class=\"line\">          filter=&#123;visibilityFilter&#125;</span><br><span class=\"line\">          onFilterChange=&#123;nextFilter =&gt;</span><br><span class=\"line\">            dispatch(setVisibilityFilter(nextFilter))</span><br><span class=\"line\">        &#125; /&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">App.propTypes = &#123;</span><br><span class=\"line\">  visibleTodos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class=\"line\">    text: PropTypes.string.isRequired,</span><br><span class=\"line\">    completed: PropTypes.bool.isRequired</span><br><span class=\"line\">  &#125;).isRequired).isRequired,</span><br><span class=\"line\">  visibilityFilter: PropTypes.oneOf(&#123;</span><br><span class=\"line\">    'SHOW_ALL',</span><br><span class=\"line\">    'SHOW_COMPLETED',</span><br><span class=\"line\">    'SHOW_ACTIVE'</span><br><span class=\"line\">  &#125;).isRequired</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function selectTodos(todo,filter)&#123;</span><br><span class=\"line\">  switch(filter)&#123;</span><br><span class=\"line\">    case visibilityFilters.SHOW_ALL:</span><br><span class=\"line\">      return todos</span><br><span class=\"line\">    case VisibilityFilters.SHOW_COMPLETED:</span><br><span class=\"line\">      return todos.filter(todo =&gt; todo.completed)</span><br><span class=\"line\">    case VisibilityFilters.SHOW_ACTIVE:</span><br><span class=\"line\">      return todos.filter(todo =&gt; !todo.completed)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function select(state)&#123;</span><br><span class=\"line\">  return &#123;</span><br><span class=\"line\">    visibleTodos: selectTodos(state.todos,state.visibilityFilter),</span><br><span class=\"line\">    visibilityFilter: state.visibilityFilter</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 包装 component ，注入 dispatch 和 state 到其默认的 connect(select)(App) 中；</span><br><span class=\"line\">export default connect(select)(App)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"6-5-展示组件\"><a href=\"#6-5-展示组件\" class=\"headerlink\" title=\"6.5 展示组件\"></a>6.5 展示组件</h2><p>components/AddTodo.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123;Component, PropTypes&#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AddTodo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;input type='text' ref='input' /&gt;</span><br><span class=\"line\">        &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class=\"line\">          Add</span><br><span class=\"line\">        &lt;/button&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  handleClick(e) &#123;</span><br><span class=\"line\">    const node = this.refs.input</span><br><span class=\"line\">    const text = node.value.trim()</span><br><span class=\"line\">    this.props.onAddClick(text)</span><br><span class=\"line\">    node.value = ''</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">AddTodo.propTypes = &#123;</span><br><span class=\"line\">  onAddClick: PropTypes.func.isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>components/Footer.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Footer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  renderFilter(filter, name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filter === <span class=\"keyword\">this</span>.props.filter) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;a href='#' onClick=&#123;e =&gt; &#123;</span><br><span class=\"line\">        e.preventDefault()</span><br><span class=\"line\">        this.props.onFilterChange(filter)</span><br><span class=\"line\">      &#125;&#125;&gt;</span><br><span class=\"line\">        &#123;name&#125;</span><br><span class=\"line\">      &lt;/a&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;p&gt;</span><br><span class=\"line\">        Show:</span><br><span class=\"line\">        &#123;' '&#125;</span><br><span class=\"line\">        &#123;this.renderFilter('SHOW_ALL', 'All')&#125;</span><br><span class=\"line\">        &#123;', '&#125;</span><br><span class=\"line\">        &#123;this.renderFilter('SHOW_COMPLETED', 'Completed')&#125;</span><br><span class=\"line\">        &#123;', '&#125;</span><br><span class=\"line\">        &#123;this.renderFilter('SHOW_ACTIVE', 'Active')&#125;</span><br><span class=\"line\">        .</span><br><span class=\"line\">      &lt;/p&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  Footer.propTypes = &#123;</span><br><span class=\"line\">    onFilterChange: PropTypes.func.isRequired,</span><br><span class=\"line\">    filter: PropTypes.oneOf([</span><br><span class=\"line\">      <span class=\"string\">'SHOW_ALL'</span>,</span><br><span class=\"line\">      <span class=\"string\">'SHOW_COMPLETED'</span>,</span><br><span class=\"line\">      <span class=\"string\">'SHOW_ACTIVE'</span></span><br><span class=\"line\">    ]).isRequired</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>components/Todo.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Todo</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;li</span><br><span class=\"line\">        onClick=&#123;this.props.onClick&#125;</span><br><span class=\"line\">        style=&#123;&#123;</span><br><span class=\"line\">          textDecoration: this.props.completed ? 'line-through' : 'none',</span><br><span class=\"line\">          cursor: this.props.completed ? 'default' : 'pointer'</span><br><span class=\"line\">        &#125;&#125;&gt;</span><br><span class=\"line\">        &#123;this.props.text&#125;</span><br><span class=\"line\">      &lt;/li&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Todo.propTypes = &#123;</span><br><span class=\"line\">  onClick: PropTypes.func.isRequired,</span><br><span class=\"line\">  text: PropTypes.string.isRequired,</span><br><span class=\"line\">  completed: PropTypes.bool.isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>components/TodoList.js<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React, &#123; Component, PropTypes &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Todo <span class=\"keyword\">from</span> <span class=\"string\">'./Todo'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TodoList</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      &lt;ul&gt;</span><br><span class=\"line\">        &#123;this.props.todos.map((todo, index) =&gt;</span><br><span class=\"line\">          &lt;Todo &#123;...todo&#125;</span><br><span class=\"line\">                key=&#123;index&#125;</span><br><span class=\"line\">                onClick=&#123;() =&gt; this.props.onTodoClick(index)&#125; /&gt;</span><br><span class=\"line\">        )&#125;</span><br><span class=\"line\">      &lt;/ul&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">TodoList.propTypes = &#123;</span><br><span class=\"line\">  onTodoClick: PropTypes.func.isRequired,</span><br><span class=\"line\">  todos: PropTypes.arrayOf(PropTypes.shape(&#123;</span><br><span class=\"line\">    text: PropTypes.string.isRequired,</span><br><span class=\"line\">    completed: PropTypes.bool.isRequired</span><br><span class=\"line\">  &#125;).isRequired).isRequired</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>b872c55882669de3f10e29ad039674d345d37f2e</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n"},{"title":"初识ServiceWorker","date":"2016-07-26T15:50:01.000Z","_content":"> The best preparation for tomorrow is doing your best today.\n\n`Service worker本质上作为一个代理坐落于web应用和浏览器与网络(可用时)之间。他们旨在(包括其他事情)建立高效的离线体验，拦截网络请求，并且会根据当前的网络是否可用、服务器的内容是否有所更新来采取合适的策略。他们还允许通知推送和后台同步API.`\n\n## Service worker的概念和用法\nserviced worker是一个被注册在一个源和路径下的事件驱动的worker。它允许javascript文件控制与其相关的页面或者网站，拦截或者修改导航和资源请求，并且运用十分细化的方式来缓解资源。这让你可以完全控制自己的网页APP无论是在什么情况下(最明显的情况就是当前网络不可用时)。\n\nservice worker运行在一个worker的环境中：因此，他不会用dom的访问权，并且是在主线程之外的另一个线程中运行来加速你的APP，所以它不会造成阻塞。它的设计是完全异步的，因此，同步的XHR请求和localStorage都不能应用在service worker中。\n\n为了安全起见，service workers只通过HTTPS运行。在被篡改的网络连接中被第三者攻击可就不好了。\n\n`注意：Service Workers之所以优于以前如AppCache的同类尝试，是因为他不会对你想要做的事情做一些假设并且在那些假设不完全准确的时候失去作用。你可以更细致地去控制每一件事情。`\n\n`注意：service workers大量使用了promise，因此通常他们会等待响应后才继续下一步。在此之后，他们会返回一个成功或者失败的响应。promises架构十分适合这种场景。`\n\n## 注册\n使用`ServiceWorkerContainer.register()`方法来进行service worker的第一次注册。一旦注册成功，你的service worker就会被下载到客户端并且试着安装/激活，用于整个域内用户可以访问的urls，或者在你规定的子集内。\n\n## 下载、安装和激活\n此时，你的service worker会遵守以下的生命周期。\n 1. 下载\n 2. 安装\n 3. 激活\n\n当用户首次访问被service worker控制的网站/页面时，service worker会立刻被下载。\n\n之后它会至少每24小时被下载一次。它**可能**被更频繁得下载，但它肯定会每24小时被下载一次，以免不良脚本长时间生效。\n\n当下载的文件被发现是新的，就会尝试进行安装--无论是与现存的service worker不同(字节方式的对比)，或者是第一次有service worker到达这个页面/网站。\n\n如果这是第一次service worker可以被使用，页面首先会尝试安装，安装成功后它会被激活。\n\n如果有现存的可用的service worker，新版本会被安装在后台，但是并不会被激活--此时我们称这个worker处在等待状态。知道再也没有已加载的页面使用旧的service worker的时候，它才会被激活。一旦没有了依赖旧service worker得已加载页面，新的service worker就会被激活(成为活动的worker)。\n\n你可以监听InstallEvent,有一个标准动作是让你的service worker在触发时为使用做好准备，例如利用内置的storage API来创建缓存，并且放置你离线的时候期望你APP运行的内容。\n\n同样的，会有一个activate事件。这个事件触发的时候，是一个很好的时间点去清理旧缓存和其他与旧service worker相关的东西.\n\nservice worker可以通过FetchEvent事件去响应请求。通过使用FecthEvent.respondWith方法，你可以任意修改对于这些请求的响应。\n\n你的service worker可以用FetchEvent事件响应请求。你可以使用FetchEvent.respondWith任意修改对这些请求的响应。\n\n`注意：因为oninstall/onactivate可能需要一些时间去完成，service worker标准提供了一个waitUtil方法，当oninstall或者onactivate时被调用，接受一个promise.在这个promise被成功地resolve前，这个service worker的functional events并不会被触发。`\n\n## 其他使用场景\nService workers也可以被用来做这些事情：\n - 后台数据同步\n - 响应其他源的资源请求\n - 集中获取不易计算的数据的更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据了\n - 为了开发目的，在客户端进行coffeeScript、less、CJS/AMD模块等的编译和依赖管理\n - 为监控后台服务提供钩子\n - 针对特定URL的个性化模板\n - 增强性能，比如预取用户将来可能会需要的资源，比如一个相册中的几张新图片\n\n在将来，service workers能够用来做更多使web平台接近原生应用的事。有趣的是，其他一些标准也能并且即将使用service worker作为环境，比如：\n - 后台同步：启动一个service worker即使没有用户访问特定站点，这样就可以更新缓存。\n - 对推送消息作出响应：启动一个service worker来向用户发送一条消息告诉他们有新的可用内容\n - 对时间或日期作出响应\n","source":"_posts/初识ServiceWorker.md","raw":"---\ntitle: 初识ServiceWorker\ndate: 2016-07-26 23:50:01\ntags:\n- javascript\n- service worker\ncategories: 笔记\n---\n> The best preparation for tomorrow is doing your best today.\n\n`Service worker本质上作为一个代理坐落于web应用和浏览器与网络(可用时)之间。他们旨在(包括其他事情)建立高效的离线体验，拦截网络请求，并且会根据当前的网络是否可用、服务器的内容是否有所更新来采取合适的策略。他们还允许通知推送和后台同步API.`\n\n## Service worker的概念和用法\nserviced worker是一个被注册在一个源和路径下的事件驱动的worker。它允许javascript文件控制与其相关的页面或者网站，拦截或者修改导航和资源请求，并且运用十分细化的方式来缓解资源。这让你可以完全控制自己的网页APP无论是在什么情况下(最明显的情况就是当前网络不可用时)。\n\nservice worker运行在一个worker的环境中：因此，他不会用dom的访问权，并且是在主线程之外的另一个线程中运行来加速你的APP，所以它不会造成阻塞。它的设计是完全异步的，因此，同步的XHR请求和localStorage都不能应用在service worker中。\n\n为了安全起见，service workers只通过HTTPS运行。在被篡改的网络连接中被第三者攻击可就不好了。\n\n`注意：Service Workers之所以优于以前如AppCache的同类尝试，是因为他不会对你想要做的事情做一些假设并且在那些假设不完全准确的时候失去作用。你可以更细致地去控制每一件事情。`\n\n`注意：service workers大量使用了promise，因此通常他们会等待响应后才继续下一步。在此之后，他们会返回一个成功或者失败的响应。promises架构十分适合这种场景。`\n\n## 注册\n使用`ServiceWorkerContainer.register()`方法来进行service worker的第一次注册。一旦注册成功，你的service worker就会被下载到客户端并且试着安装/激活，用于整个域内用户可以访问的urls，或者在你规定的子集内。\n\n## 下载、安装和激活\n此时，你的service worker会遵守以下的生命周期。\n 1. 下载\n 2. 安装\n 3. 激活\n\n当用户首次访问被service worker控制的网站/页面时，service worker会立刻被下载。\n\n之后它会至少每24小时被下载一次。它**可能**被更频繁得下载，但它肯定会每24小时被下载一次，以免不良脚本长时间生效。\n\n当下载的文件被发现是新的，就会尝试进行安装--无论是与现存的service worker不同(字节方式的对比)，或者是第一次有service worker到达这个页面/网站。\n\n如果这是第一次service worker可以被使用，页面首先会尝试安装，安装成功后它会被激活。\n\n如果有现存的可用的service worker，新版本会被安装在后台，但是并不会被激活--此时我们称这个worker处在等待状态。知道再也没有已加载的页面使用旧的service worker的时候，它才会被激活。一旦没有了依赖旧service worker得已加载页面，新的service worker就会被激活(成为活动的worker)。\n\n你可以监听InstallEvent,有一个标准动作是让你的service worker在触发时为使用做好准备，例如利用内置的storage API来创建缓存，并且放置你离线的时候期望你APP运行的内容。\n\n同样的，会有一个activate事件。这个事件触发的时候，是一个很好的时间点去清理旧缓存和其他与旧service worker相关的东西.\n\nservice worker可以通过FetchEvent事件去响应请求。通过使用FecthEvent.respondWith方法，你可以任意修改对于这些请求的响应。\n\n你的service worker可以用FetchEvent事件响应请求。你可以使用FetchEvent.respondWith任意修改对这些请求的响应。\n\n`注意：因为oninstall/onactivate可能需要一些时间去完成，service worker标准提供了一个waitUtil方法，当oninstall或者onactivate时被调用，接受一个promise.在这个promise被成功地resolve前，这个service worker的functional events并不会被触发。`\n\n## 其他使用场景\nService workers也可以被用来做这些事情：\n - 后台数据同步\n - 响应其他源的资源请求\n - 集中获取不易计算的数据的更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据了\n - 为了开发目的，在客户端进行coffeeScript、less、CJS/AMD模块等的编译和依赖管理\n - 为监控后台服务提供钩子\n - 针对特定URL的个性化模板\n - 增强性能，比如预取用户将来可能会需要的资源，比如一个相册中的几张新图片\n\n在将来，service workers能够用来做更多使web平台接近原生应用的事。有趣的是，其他一些标准也能并且即将使用service worker作为环境，比如：\n - 后台同步：启动一个service worker即使没有用户访问特定站点，这样就可以更新缓存。\n - 对推送消息作出响应：启动一个service worker来向用户发送一条消息告诉他们有新的可用内容\n - 对时间或日期作出响应\n","slug":"初识ServiceWorker","published":1,"updated":"2016-07-27T01:41:10.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0end001kb0dlrno8814u","content":"<blockquote>\n<p>The best preparation for tomorrow is doing your best today.</p>\n</blockquote>\n<p><code>Service worker本质上作为一个代理坐落于web应用和浏览器与网络(可用时)之间。他们旨在(包括其他事情)建立高效的离线体验，拦截网络请求，并且会根据当前的网络是否可用、服务器的内容是否有所更新来采取合适的策略。他们还允许通知推送和后台同步API.</code></p>\n<h2 id=\"Service-worker的概念和用法\"><a href=\"#Service-worker的概念和用法\" class=\"headerlink\" title=\"Service worker的概念和用法\"></a>Service worker的概念和用法</h2><p>serviced worker是一个被注册在一个源和路径下的事件驱动的worker。它允许javascript文件控制与其相关的页面或者网站，拦截或者修改导航和资源请求，并且运用十分细化的方式来缓解资源。这让你可以完全控制自己的网页APP无论是在什么情况下(最明显的情况就是当前网络不可用时)。</p>\n<p>service worker运行在一个worker的环境中：因此，他不会用dom的访问权，并且是在主线程之外的另一个线程中运行来加速你的APP，所以它不会造成阻塞。它的设计是完全异步的，因此，同步的XHR请求和localStorage都不能应用在service worker中。</p>\n<p>为了安全起见，service workers只通过HTTPS运行。在被篡改的网络连接中被第三者攻击可就不好了。</p>\n<p><code>注意：Service Workers之所以优于以前如AppCache的同类尝试，是因为他不会对你想要做的事情做一些假设并且在那些假设不完全准确的时候失去作用。你可以更细致地去控制每一件事情。</code></p>\n<p><code>注意：service workers大量使用了promise，因此通常他们会等待响应后才继续下一步。在此之后，他们会返回一个成功或者失败的响应。promises架构十分适合这种场景。</code></p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><p>使用<code>ServiceWorkerContainer.register()</code>方法来进行service worker的第一次注册。一旦注册成功，你的service worker就会被下载到客户端并且试着安装/激活，用于整个域内用户可以访问的urls，或者在你规定的子集内。</p>\n<h2 id=\"下载、安装和激活\"><a href=\"#下载、安装和激活\" class=\"headerlink\" title=\"下载、安装和激活\"></a>下载、安装和激活</h2><p>此时，你的service worker会遵守以下的生命周期。</p>\n<ol>\n<li>下载</li>\n<li>安装</li>\n<li>激活</li>\n</ol>\n<p>当用户首次访问被service worker控制的网站/页面时，service worker会立刻被下载。</p>\n<p>之后它会至少每24小时被下载一次。它<strong>可能</strong>被更频繁得下载，但它肯定会每24小时被下载一次，以免不良脚本长时间生效。</p>\n<p>当下载的文件被发现是新的，就会尝试进行安装–无论是与现存的service worker不同(字节方式的对比)，或者是第一次有service worker到达这个页面/网站。</p>\n<p>如果这是第一次service worker可以被使用，页面首先会尝试安装，安装成功后它会被激活。</p>\n<p>如果有现存的可用的service worker，新版本会被安装在后台，但是并不会被激活–此时我们称这个worker处在等待状态。知道再也没有已加载的页面使用旧的service worker的时候，它才会被激活。一旦没有了依赖旧service worker得已加载页面，新的service worker就会被激活(成为活动的worker)。</p>\n<p>你可以监听InstallEvent,有一个标准动作是让你的service worker在触发时为使用做好准备，例如利用内置的storage API来创建缓存，并且放置你离线的时候期望你APP运行的内容。</p>\n<p>同样的，会有一个activate事件。这个事件触发的时候，是一个很好的时间点去清理旧缓存和其他与旧service worker相关的东西.</p>\n<p>service worker可以通过FetchEvent事件去响应请求。通过使用FecthEvent.respondWith方法，你可以任意修改对于这些请求的响应。</p>\n<p>你的service worker可以用FetchEvent事件响应请求。你可以使用FetchEvent.respondWith任意修改对这些请求的响应。</p>\n<p><code>注意：因为oninstall/onactivate可能需要一些时间去完成，service worker标准提供了一个waitUtil方法，当oninstall或者onactivate时被调用，接受一个promise.在这个promise被成功地resolve前，这个service worker的functional events并不会被触发。</code></p>\n<h2 id=\"其他使用场景\"><a href=\"#其他使用场景\" class=\"headerlink\" title=\"其他使用场景\"></a>其他使用场景</h2><p>Service workers也可以被用来做这些事情：</p>\n<ul>\n<li>后台数据同步</li>\n<li>响应其他源的资源请求</li>\n<li>集中获取不易计算的数据的更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据了</li>\n<li>为了开发目的，在客户端进行coffeeScript、less、CJS/AMD模块等的编译和依赖管理</li>\n<li>为监控后台服务提供钩子</li>\n<li>针对特定URL的个性化模板</li>\n<li>增强性能，比如预取用户将来可能会需要的资源，比如一个相册中的几张新图片</li>\n</ul>\n<p>在将来，service workers能够用来做更多使web平台接近原生应用的事。有趣的是，其他一些标准也能并且即将使用service worker作为环境，比如：</p>\n<ul>\n<li>后台同步：启动一个service worker即使没有用户访问特定站点，这样就可以更新缓存。</li>\n<li>对推送消息作出响应：启动一个service worker来向用户发送一条消息告诉他们有新的可用内容</li>\n<li>对时间或日期作出响应</li>\n</ul>\n","excerpt":"","more":"<blockquote>\n<p>The best preparation for tomorrow is doing your best today.</p>\n</blockquote>\n<p><code>Service worker本质上作为一个代理坐落于web应用和浏览器与网络(可用时)之间。他们旨在(包括其他事情)建立高效的离线体验，拦截网络请求，并且会根据当前的网络是否可用、服务器的内容是否有所更新来采取合适的策略。他们还允许通知推送和后台同步API.</code></p>\n<h2 id=\"Service-worker的概念和用法\"><a href=\"#Service-worker的概念和用法\" class=\"headerlink\" title=\"Service worker的概念和用法\"></a>Service worker的概念和用法</h2><p>serviced worker是一个被注册在一个源和路径下的事件驱动的worker。它允许javascript文件控制与其相关的页面或者网站，拦截或者修改导航和资源请求，并且运用十分细化的方式来缓解资源。这让你可以完全控制自己的网页APP无论是在什么情况下(最明显的情况就是当前网络不可用时)。</p>\n<p>service worker运行在一个worker的环境中：因此，他不会用dom的访问权，并且是在主线程之外的另一个线程中运行来加速你的APP，所以它不会造成阻塞。它的设计是完全异步的，因此，同步的XHR请求和localStorage都不能应用在service worker中。</p>\n<p>为了安全起见，service workers只通过HTTPS运行。在被篡改的网络连接中被第三者攻击可就不好了。</p>\n<p><code>注意：Service Workers之所以优于以前如AppCache的同类尝试，是因为他不会对你想要做的事情做一些假设并且在那些假设不完全准确的时候失去作用。你可以更细致地去控制每一件事情。</code></p>\n<p><code>注意：service workers大量使用了promise，因此通常他们会等待响应后才继续下一步。在此之后，他们会返回一个成功或者失败的响应。promises架构十分适合这种场景。</code></p>\n<h2 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h2><p>使用<code>ServiceWorkerContainer.register()</code>方法来进行service worker的第一次注册。一旦注册成功，你的service worker就会被下载到客户端并且试着安装/激活，用于整个域内用户可以访问的urls，或者在你规定的子集内。</p>\n<h2 id=\"下载、安装和激活\"><a href=\"#下载、安装和激活\" class=\"headerlink\" title=\"下载、安装和激活\"></a>下载、安装和激活</h2><p>此时，你的service worker会遵守以下的生命周期。</p>\n<ol>\n<li>下载</li>\n<li>安装</li>\n<li>激活</li>\n</ol>\n<p>当用户首次访问被service worker控制的网站/页面时，service worker会立刻被下载。</p>\n<p>之后它会至少每24小时被下载一次。它<strong>可能</strong>被更频繁得下载，但它肯定会每24小时被下载一次，以免不良脚本长时间生效。</p>\n<p>当下载的文件被发现是新的，就会尝试进行安装–无论是与现存的service worker不同(字节方式的对比)，或者是第一次有service worker到达这个页面/网站。</p>\n<p>如果这是第一次service worker可以被使用，页面首先会尝试安装，安装成功后它会被激活。</p>\n<p>如果有现存的可用的service worker，新版本会被安装在后台，但是并不会被激活–此时我们称这个worker处在等待状态。知道再也没有已加载的页面使用旧的service worker的时候，它才会被激活。一旦没有了依赖旧service worker得已加载页面，新的service worker就会被激活(成为活动的worker)。</p>\n<p>你可以监听InstallEvent,有一个标准动作是让你的service worker在触发时为使用做好准备，例如利用内置的storage API来创建缓存，并且放置你离线的时候期望你APP运行的内容。</p>\n<p>同样的，会有一个activate事件。这个事件触发的时候，是一个很好的时间点去清理旧缓存和其他与旧service worker相关的东西.</p>\n<p>service worker可以通过FetchEvent事件去响应请求。通过使用FecthEvent.respondWith方法，你可以任意修改对于这些请求的响应。</p>\n<p>你的service worker可以用FetchEvent事件响应请求。你可以使用FetchEvent.respondWith任意修改对这些请求的响应。</p>\n<p><code>注意：因为oninstall/onactivate可能需要一些时间去完成，service worker标准提供了一个waitUtil方法，当oninstall或者onactivate时被调用，接受一个promise.在这个promise被成功地resolve前，这个service worker的functional events并不会被触发。</code></p>\n<h2 id=\"其他使用场景\"><a href=\"#其他使用场景\" class=\"headerlink\" title=\"其他使用场景\"></a>其他使用场景</h2><p>Service workers也可以被用来做这些事情：</p>\n<ul>\n<li>后台数据同步</li>\n<li>响应其他源的资源请求</li>\n<li>集中获取不易计算的数据的更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据了</li>\n<li>为了开发目的，在客户端进行coffeeScript、less、CJS/AMD模块等的编译和依赖管理</li>\n<li>为监控后台服务提供钩子</li>\n<li>针对特定URL的个性化模板</li>\n<li>增强性能，比如预取用户将来可能会需要的资源，比如一个相册中的几张新图片</li>\n</ul>\n<p>在将来，service workers能够用来做更多使web平台接近原生应用的事。有趣的是，其他一些标准也能并且即将使用service worker作为环境，比如：</p>\n<ul>\n<li>后台同步：启动一个service worker即使没有用户访问特定站点，这样就可以更新缓存。</li>\n<li>对推送消息作出响应：启动一个service worker来向用户发送一条消息告诉他们有新的可用内容</li>\n<li>对时间或日期作出响应</li>\n</ul>\n"},{"title":"初始Promise","date":"2016-07-28T03:21:39.000Z","_content":"> Don't let yesterday take up too much of today.\n\n## 概述\nPromise对象用于异步(asynchronous)计算。一个promise对象代表着一个还未完成，但预期将来会完成的操作。\n\n**语法**\n```javascript\n  new Promise(executor);\n  new Promise(function(resolve,reject){ ... });\n```\n\n**参数**\nexecutor,带有resolve、reject两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景。一旦我们的操作完成即可调用这些函数。\n\n## 描述\nPromise对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的promise对象来替代原返回值。\n\nPromise对象有以下几种状态：\n - pedding: 初始状态，既不是fulfilled也不是rejected.\n - fulfilled: 成功的操作\n - rejected: 失败的操作\n\npending状态的promise对象即可转换为带着一个成功值的fulfilled状态，也可变为带着一个失败信息的rejected状态。当状态发生转化时，promise.then绑定的方法(函数句柄)就会被调用。(当绑定方法时，如果promise对象已经处在fulfilled或rejected状态，那么相应的方法将会被立刻调用，所以在异步操作的完成情况和它的绑定方法之间不存在竞争条件)。\n\n因为Promise.prototype.then和Promise.prototype.catch方法返回promises对象，所以他们它们可以被链式调用--一种被称为composition的操作。\n\n![Promise](/images/promise/promises.png)\n\n`注意：如果一个promise对象处在fulfilled或rejected状态而不是pedding状态，那么它也可以被称为settled转态。你可能也会听到一个术语resolved，它表示promise对象处于settled状态，或者promise对象被锁定在了调用链中。`\n\n## 属性\nPromise.length\n长度属性，其值为1(构造器参数的数目)\nPromise.prototype\n表示Promise构造器的原型\n\n## 方法\nPromise.all(iterable)\n返回一个promise对象，当iterable参数里的所有的promise都被完成后，该promise也会被完成。\nPromise.race(iterable)\n当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\nPromise.reject(reason)\n调用Promise的rejected句柄，并返回这个Promise对象\nPromise.resolve(value)\n用成功值value完成一个Promise对象。如果该value为可继续的(thenable，即带有then方法)，返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足(fullfil)返回的Promise对象。\n\n## Promise原型\n**原型**\nPromise.prototype.constructor\n返回创建了实例原型的函数。默认为Promise函数。\n\n**方法**\nPromise.prototype.catch(onRejected)\n添加一个否定(rejection)回调到当前promise，返回一个新的promise。如果这个回调被调用，新promise将以它的返回值来resolve，否则如果当前promise进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果。\n\nPromise.prototype.then(onFulfilled.onRejected)\n添加肯定和否定回调到当前promise，返回一个新的promise，将以回调的返回值来resolve.\n\n## 示例\n**创建Promise**\n这个小例子展示了Promise的机制。每当`<button>`被按下时，testPromise()函数就会被执行。该函数会创建一个用window.setTimeout在1秒到3秒(随机)后用‘result’字符串完成的promise。\n这里通过p1.then方法满足回调，简单的输出了promise的满足过程，这些输出显示了该方法的同步部分是如何和promise的异步完成解耦的。\n```javascript\n  <div id=\"log\"></div>\n  <script>\n    'use strict'\n    var promiseCount = 0;\n    function testPromise(){\n      var thisPromiseCount = ++promiseCount;\n      var log = document.getElementById('log');\n      log.insertAdjacentHTML('beforeend',thisPromiseCount + ') 开始(同步代码开始)<br/>');\n\n      //我们创建一个新的promise:然后用'result'字符串完成这个promise(3秒后)\n      var p1 = new Promise(function(resolve,reject){\n        //完成函数带着完成(resolve)或拒绝(reject) promise的能力被执行\n        log.insertAdjacentHTML('beforeend',thisPromiseCount + ') Promise开始(异步代码开始)<br/>');\n\n        //这只是个创建异步完成的示例\n        window.setTimeout(function(){\n          //我们满足(fullfil)了这个promise！\n          resolve(thisPromiseCount)\n        },Math.random() *2000 + 1000);\n      });\n\n      //定义当promise被满足时应做什么\n      p1.then(function(val){\n        //输出一段信息和一个值\n        log.insertAdjacentHTML('beforeend',val + ') Promise被满足了(异步代码结束)<br/>');\n      });\n\n      log.insertAdjacentHTML('beforeend',thisPromiseCount + ') 建立了Promise(同步代码结束)<br/><br/>');\n    }\n    testPromise();\n    testPromise();\n    testPromise();\n  </script>\n```\n这个例子在按钮被按下后执行。你需要一个支持Promise的浏览器。你能通过短时间内按多次按钮看到不同的promise一个接一个的被满足。\n\n## Example using new XMLHttpRequest()\n**创建一个promise**\n这个例子展示了如何用promise报告一个XMLHttpRequest的成功或失败。\n```javascript\n  'use strict'\n  function $http(url){\n    var core = {\n      ajax: function(method,url,args){\n        var promise = new Promise(function(resolve,reject){\n          var client = new XMLHttpRequest();\n          var uri = url;\n\n          if(args && (method === 'POST' || method === 'PUT')){\n            uri += '?';\n            var argcount = 0;\n            for(var key in args){\n              if(args.hasOwnProperty(key)){\n                if(argcount++){\n                  uri += '&';\n                }\n                uri += encodeURIcomponent(key) + '=' + encodeURIcomponent(args[key]);\n              }\n            }\n          }\n\n          client.open(method, uri);\n          client.send();\n\n          client.onload = function(){\n            if(this.status >= 200 && this.status <300){\n              resolve(this.response);\n            }else{\n              reject(this.statusText);\n            }\n          };\n          client.onerror = function(){\n            reject(this.statusText);\n          }\n        });\n\n        return promise;\n      }\n    };\n\n    //Adapter patten\n    return {\n      'get': function(args){\n        return core.ajax('GET',url,args);\n      },\n      'post': function(args){\n        return core.ajax('POST',url,args);\n      },\n      'delete': function(args){\n        return core.ajax('DELETE',url,args);\n      }\n    }\n  }\n  //End A\n\n  var mdnAPI = 'https://developer.mozilla.org/en-US/search.json';\n  var payload = {\n    'topic': 'js',\n    'q': 'Promise'\n  };\n\n  var callback = {\n    success: function(data){\n      console.log(1,'success',JSON.parse(data));\n    },\n    error: function(data){\n      console.log(2,'error',JSON.parse(data));\n    }\n  }\n  //End B\n\n  //Executes the method call\n  $http(mdnAPI)\n    .get(payload)\n    .then(callback.success)\n    .catch(callback.error);\n\n  $http(mdnAPI)\n    .get(payload)\n    .then(callback.success,callback.error);\n\n  $http(mdnAPI)\n    .get(payload)\n    .then(callback.success)\n    .then(undefined, callback.error);\n```\n","source":"_posts/初始Promise.md","raw":"---\ntitle: 初始Promise\ndate: 2016-07-28 11:21:39\ntags:\n- javascript\n- promise\ncategories: 笔记\n---\n> Don't let yesterday take up too much of today.\n\n## 概述\nPromise对象用于异步(asynchronous)计算。一个promise对象代表着一个还未完成，但预期将来会完成的操作。\n\n**语法**\n```javascript\n  new Promise(executor);\n  new Promise(function(resolve,reject){ ... });\n```\n\n**参数**\nexecutor,带有resolve、reject两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景。一旦我们的操作完成即可调用这些函数。\n\n## 描述\nPromise对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的promise对象来替代原返回值。\n\nPromise对象有以下几种状态：\n - pedding: 初始状态，既不是fulfilled也不是rejected.\n - fulfilled: 成功的操作\n - rejected: 失败的操作\n\npending状态的promise对象即可转换为带着一个成功值的fulfilled状态，也可变为带着一个失败信息的rejected状态。当状态发生转化时，promise.then绑定的方法(函数句柄)就会被调用。(当绑定方法时，如果promise对象已经处在fulfilled或rejected状态，那么相应的方法将会被立刻调用，所以在异步操作的完成情况和它的绑定方法之间不存在竞争条件)。\n\n因为Promise.prototype.then和Promise.prototype.catch方法返回promises对象，所以他们它们可以被链式调用--一种被称为composition的操作。\n\n![Promise](/images/promise/promises.png)\n\n`注意：如果一个promise对象处在fulfilled或rejected状态而不是pedding状态，那么它也可以被称为settled转态。你可能也会听到一个术语resolved，它表示promise对象处于settled状态，或者promise对象被锁定在了调用链中。`\n\n## 属性\nPromise.length\n长度属性，其值为1(构造器参数的数目)\nPromise.prototype\n表示Promise构造器的原型\n\n## 方法\nPromise.all(iterable)\n返回一个promise对象，当iterable参数里的所有的promise都被完成后，该promise也会被完成。\nPromise.race(iterable)\n当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\nPromise.reject(reason)\n调用Promise的rejected句柄，并返回这个Promise对象\nPromise.resolve(value)\n用成功值value完成一个Promise对象。如果该value为可继续的(thenable，即带有then方法)，返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足(fullfil)返回的Promise对象。\n\n## Promise原型\n**原型**\nPromise.prototype.constructor\n返回创建了实例原型的函数。默认为Promise函数。\n\n**方法**\nPromise.prototype.catch(onRejected)\n添加一个否定(rejection)回调到当前promise，返回一个新的promise。如果这个回调被调用，新promise将以它的返回值来resolve，否则如果当前promise进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果。\n\nPromise.prototype.then(onFulfilled.onRejected)\n添加肯定和否定回调到当前promise，返回一个新的promise，将以回调的返回值来resolve.\n\n## 示例\n**创建Promise**\n这个小例子展示了Promise的机制。每当`<button>`被按下时，testPromise()函数就会被执行。该函数会创建一个用window.setTimeout在1秒到3秒(随机)后用‘result’字符串完成的promise。\n这里通过p1.then方法满足回调，简单的输出了promise的满足过程，这些输出显示了该方法的同步部分是如何和promise的异步完成解耦的。\n```javascript\n  <div id=\"log\"></div>\n  <script>\n    'use strict'\n    var promiseCount = 0;\n    function testPromise(){\n      var thisPromiseCount = ++promiseCount;\n      var log = document.getElementById('log');\n      log.insertAdjacentHTML('beforeend',thisPromiseCount + ') 开始(同步代码开始)<br/>');\n\n      //我们创建一个新的promise:然后用'result'字符串完成这个promise(3秒后)\n      var p1 = new Promise(function(resolve,reject){\n        //完成函数带着完成(resolve)或拒绝(reject) promise的能力被执行\n        log.insertAdjacentHTML('beforeend',thisPromiseCount + ') Promise开始(异步代码开始)<br/>');\n\n        //这只是个创建异步完成的示例\n        window.setTimeout(function(){\n          //我们满足(fullfil)了这个promise！\n          resolve(thisPromiseCount)\n        },Math.random() *2000 + 1000);\n      });\n\n      //定义当promise被满足时应做什么\n      p1.then(function(val){\n        //输出一段信息和一个值\n        log.insertAdjacentHTML('beforeend',val + ') Promise被满足了(异步代码结束)<br/>');\n      });\n\n      log.insertAdjacentHTML('beforeend',thisPromiseCount + ') 建立了Promise(同步代码结束)<br/><br/>');\n    }\n    testPromise();\n    testPromise();\n    testPromise();\n  </script>\n```\n这个例子在按钮被按下后执行。你需要一个支持Promise的浏览器。你能通过短时间内按多次按钮看到不同的promise一个接一个的被满足。\n\n## Example using new XMLHttpRequest()\n**创建一个promise**\n这个例子展示了如何用promise报告一个XMLHttpRequest的成功或失败。\n```javascript\n  'use strict'\n  function $http(url){\n    var core = {\n      ajax: function(method,url,args){\n        var promise = new Promise(function(resolve,reject){\n          var client = new XMLHttpRequest();\n          var uri = url;\n\n          if(args && (method === 'POST' || method === 'PUT')){\n            uri += '?';\n            var argcount = 0;\n            for(var key in args){\n              if(args.hasOwnProperty(key)){\n                if(argcount++){\n                  uri += '&';\n                }\n                uri += encodeURIcomponent(key) + '=' + encodeURIcomponent(args[key]);\n              }\n            }\n          }\n\n          client.open(method, uri);\n          client.send();\n\n          client.onload = function(){\n            if(this.status >= 200 && this.status <300){\n              resolve(this.response);\n            }else{\n              reject(this.statusText);\n            }\n          };\n          client.onerror = function(){\n            reject(this.statusText);\n          }\n        });\n\n        return promise;\n      }\n    };\n\n    //Adapter patten\n    return {\n      'get': function(args){\n        return core.ajax('GET',url,args);\n      },\n      'post': function(args){\n        return core.ajax('POST',url,args);\n      },\n      'delete': function(args){\n        return core.ajax('DELETE',url,args);\n      }\n    }\n  }\n  //End A\n\n  var mdnAPI = 'https://developer.mozilla.org/en-US/search.json';\n  var payload = {\n    'topic': 'js',\n    'q': 'Promise'\n  };\n\n  var callback = {\n    success: function(data){\n      console.log(1,'success',JSON.parse(data));\n    },\n    error: function(data){\n      console.log(2,'error',JSON.parse(data));\n    }\n  }\n  //End B\n\n  //Executes the method call\n  $http(mdnAPI)\n    .get(payload)\n    .then(callback.success)\n    .catch(callback.error);\n\n  $http(mdnAPI)\n    .get(payload)\n    .then(callback.success,callback.error);\n\n  $http(mdnAPI)\n    .get(payload)\n    .then(callback.success)\n    .then(undefined, callback.error);\n```\n","slug":"初始Promise","published":1,"updated":"2016-08-01T02:11:38.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0ene001nb0dl6hskbg1v","content":"<blockquote>\n<p>Don’t let yesterday take up too much of today.</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Promise对象用于异步(asynchronous)计算。一个promise对象代表着一个还未完成，但预期将来会完成的操作。</p>\n<p><strong>语法</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(executor);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong><br>executor,带有resolve、reject两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景。一旦我们的操作完成即可调用这些函数。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>Promise对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的promise对象来替代原返回值。</p>\n<p>Promise对象有以下几种状态：</p>\n<ul>\n<li>pedding: 初始状态，既不是fulfilled也不是rejected.</li>\n<li>fulfilled: 成功的操作</li>\n<li>rejected: 失败的操作</li>\n</ul>\n<p>pending状态的promise对象即可转换为带着一个成功值的fulfilled状态，也可变为带着一个失败信息的rejected状态。当状态发生转化时，promise.then绑定的方法(函数句柄)就会被调用。(当绑定方法时，如果promise对象已经处在fulfilled或rejected状态，那么相应的方法将会被立刻调用，所以在异步操作的完成情况和它的绑定方法之间不存在竞争条件)。</p>\n<p>因为Promise.prototype.then和Promise.prototype.catch方法返回promises对象，所以他们它们可以被链式调用–一种被称为composition的操作。</p>\n<p><img src=\"/images/promise/promises.png\" alt=\"Promise\"></p>\n<p><code>注意：如果一个promise对象处在fulfilled或rejected状态而不是pedding状态，那么它也可以被称为settled转态。你可能也会听到一个术语resolved，它表示promise对象处于settled状态，或者promise对象被锁定在了调用链中。</code></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>Promise.length<br>长度属性，其值为1(构造器参数的数目)<br>Promise.prototype<br>表示Promise构造器的原型</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Promise.all(iterable)<br>返回一个promise对象，当iterable参数里的所有的promise都被完成后，该promise也会被完成。<br>Promise.race(iterable)<br>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。<br>Promise.reject(reason)<br>调用Promise的rejected句柄，并返回这个Promise对象<br>Promise.resolve(value)<br>用成功值value完成一个Promise对象。如果该value为可继续的(thenable，即带有then方法)，返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足(fullfil)返回的Promise对象。</p>\n<h2 id=\"Promise原型\"><a href=\"#Promise原型\" class=\"headerlink\" title=\"Promise原型\"></a>Promise原型</h2><p><strong>原型</strong><br>Promise.prototype.constructor<br>返回创建了实例原型的函数。默认为Promise函数。</p>\n<p><strong>方法</strong><br>Promise.prototype.catch(onRejected)<br>添加一个否定(rejection)回调到当前promise，返回一个新的promise。如果这个回调被调用，新promise将以它的返回值来resolve，否则如果当前promise进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果。</p>\n<p>Promise.prototype.then(onFulfilled.onRejected)<br>添加肯定和否定回调到当前promise，返回一个新的promise，将以回调的返回值来resolve.</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p><strong>创建Promise</strong><br>这个小例子展示了Promise的机制。每当<code>&lt;button&gt;</code>被按下时，testPromise()函数就会被执行。该函数会创建一个用window.setTimeout在1秒到3秒(随机)后用‘result’字符串完成的promise。<br>这里通过p1.then方法满足回调，简单的输出了promise的满足过程，这些输出显示了该方法的同步部分是如何和promise的异步完成解耦的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"log\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"string\">'use strict'</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> promiseCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testPromise</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thisPromiseCount = ++promiseCount;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> log = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'log'</span>);</span><br><span class=\"line\">    log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,thisPromiseCount + <span class=\"string\">') 开始(同步代码开始)&lt;br/&gt;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//我们创建一个新的promise:然后用'result'字符串完成这个promise(3秒后)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//完成函数带着完成(resolve)或拒绝(reject) promise的能力被执行</span></span><br><span class=\"line\">      log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,thisPromiseCount + <span class=\"string\">') Promise开始(异步代码开始)&lt;br/&gt;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//这只是个创建异步完成的示例</span></span><br><span class=\"line\">      <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//我们满足(fullfil)了这个promise！</span></span><br><span class=\"line\">        resolve(thisPromiseCount)</span><br><span class=\"line\">      &#125;,<span class=\"built_in\">Math</span>.random() *<span class=\"number\">2000</span> + <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义当promise被满足时应做什么</span></span><br><span class=\"line\">    p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//输出一段信息和一个值</span></span><br><span class=\"line\">      log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,val + <span class=\"string\">') Promise被满足了(异步代码结束)&lt;br/&gt;'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,thisPromiseCount + <span class=\"string\">') 建立了Promise(同步代码结束)&lt;br/&gt;&lt;br/&gt;'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  testPromise();</span><br><span class=\"line\">  testPromise();</span><br><span class=\"line\">  testPromise();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个例子在按钮被按下后执行。你需要一个支持Promise的浏览器。你能通过短时间内按多次按钮看到不同的promise一个接一个的被满足。</p>\n<h2 id=\"Example-using-new-XMLHttpRequest\"><a href=\"#Example-using-new-XMLHttpRequest\" class=\"headerlink\" title=\"Example using new XMLHttpRequest()\"></a>Example using new XMLHttpRequest()</h2><p><strong>创建一个promise</strong><br>这个例子展示了如何用promise报告一个XMLHttpRequest的成功或失败。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">$http</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> core = &#123;</span><br><span class=\"line\">    ajax: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method,url,args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> uri = url;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args &amp;&amp; (method === <span class=\"string\">'POST'</span> || method === <span class=\"string\">'PUT'</span>))&#123;</span><br><span class=\"line\">          uri += <span class=\"string\">'?'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> argcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> args)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(args.hasOwnProperty(key))&#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(argcount++)&#123;</span><br><span class=\"line\">                uri += <span class=\"string\">'&amp;'</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              uri += encodeURIcomponent(key) + <span class=\"string\">'='</span> + encodeURIcomponent(args[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client.open(method, uri);</span><br><span class=\"line\">        client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">        client.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status &gt;= <span class=\"number\">200</span> &amp;&amp; <span class=\"keyword\">this</span>.status &lt;<span class=\"number\">300</span>)&#123;</span><br><span class=\"line\">            resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            reject(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        client.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          reject(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Adapter patten</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">'get'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> core.ajax(<span class=\"string\">'GET'</span>,url,args);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'post'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> core.ajax(<span class=\"string\">'POST'</span>,url,args);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'delete'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> core.ajax(<span class=\"string\">'DELETE'</span>,url,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//End A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mdnAPI = <span class=\"string\">'https://developer.mozilla.org/en-US/search.json'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> payload = &#123;</span><br><span class=\"line\">  <span class=\"string\">'topic'</span>: <span class=\"string\">'js'</span>,</span><br><span class=\"line\">  <span class=\"string\">'q'</span>: <span class=\"string\">'Promise'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> callback = &#123;</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>,<span class=\"string\">'success'</span>,<span class=\"built_in\">JSON</span>.parse(data));</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>,<span class=\"string\">'error'</span>,<span class=\"built_in\">JSON</span>.parse(data));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//End B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Executes the method call</span></span><br><span class=\"line\">$http(mdnAPI)</span><br><span class=\"line\">  .get(payload)</span><br><span class=\"line\">  .then(callback.success)</span><br><span class=\"line\">  .catch(callback.error);</span><br><span class=\"line\"></span><br><span class=\"line\">$http(mdnAPI)</span><br><span class=\"line\">  .get(payload)</span><br><span class=\"line\">  .then(callback.success,callback.error);</span><br><span class=\"line\"></span><br><span class=\"line\">$http(mdnAPI)</span><br><span class=\"line\">  .get(payload)</span><br><span class=\"line\">  .then(callback.success)</span><br><span class=\"line\">  .then(<span class=\"literal\">undefined</span>, callback.error);</span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>Don’t let yesterday take up too much of today.</p>\n</blockquote>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>Promise对象用于异步(asynchronous)计算。一个promise对象代表着一个还未完成，但预期将来会完成的操作。</p>\n<p><strong>语法</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(executor);</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure></p>\n<p><strong>参数</strong><br>executor,带有resolve、reject两个参数的函数对象。第一个参数用在处理执行成功的场景，第二个参数则用在处理执行失败的场景。一旦我们的操作完成即可调用这些函数。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>Promise对象是一个返回值的代理，这个返回值在promise对象创建时未必已知。它允许你为异步操作的成功或失败指定处理方法。这使得异步方法可以像同步方法那样返回值：异步方法会返回一个包含了原返回值的promise对象来替代原返回值。</p>\n<p>Promise对象有以下几种状态：</p>\n<ul>\n<li>pedding: 初始状态，既不是fulfilled也不是rejected.</li>\n<li>fulfilled: 成功的操作</li>\n<li>rejected: 失败的操作</li>\n</ul>\n<p>pending状态的promise对象即可转换为带着一个成功值的fulfilled状态，也可变为带着一个失败信息的rejected状态。当状态发生转化时，promise.then绑定的方法(函数句柄)就会被调用。(当绑定方法时，如果promise对象已经处在fulfilled或rejected状态，那么相应的方法将会被立刻调用，所以在异步操作的完成情况和它的绑定方法之间不存在竞争条件)。</p>\n<p>因为Promise.prototype.then和Promise.prototype.catch方法返回promises对象，所以他们它们可以被链式调用–一种被称为composition的操作。</p>\n<p><img src=\"/images/promise/promises.png\" alt=\"Promise\"></p>\n<p><code>注意：如果一个promise对象处在fulfilled或rejected状态而不是pedding状态，那么它也可以被称为settled转态。你可能也会听到一个术语resolved，它表示promise对象处于settled状态，或者promise对象被锁定在了调用链中。</code></p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><p>Promise.length<br>长度属性，其值为1(构造器参数的数目)<br>Promise.prototype<br>表示Promise构造器的原型</p>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>Promise.all(iterable)<br>返回一个promise对象，当iterable参数里的所有的promise都被完成后，该promise也会被完成。<br>Promise.race(iterable)<br>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。<br>Promise.reject(reason)<br>调用Promise的rejected句柄，并返回这个Promise对象<br>Promise.resolve(value)<br>用成功值value完成一个Promise对象。如果该value为可继续的(thenable，即带有then方法)，返回的Promise对象会“跟随”这个value，采用这个value的最终状态；否则的话返回值会用这个value满足(fullfil)返回的Promise对象。</p>\n<h2 id=\"Promise原型\"><a href=\"#Promise原型\" class=\"headerlink\" title=\"Promise原型\"></a>Promise原型</h2><p><strong>原型</strong><br>Promise.prototype.constructor<br>返回创建了实例原型的函数。默认为Promise函数。</p>\n<p><strong>方法</strong><br>Promise.prototype.catch(onRejected)<br>添加一个否定(rejection)回调到当前promise，返回一个新的promise。如果这个回调被调用，新promise将以它的返回值来resolve，否则如果当前promise进入fulfilled状态，则以当前promise的肯定结果作为新promise的肯定结果。</p>\n<p>Promise.prototype.then(onFulfilled.onRejected)<br>添加肯定和否定回调到当前promise，返回一个新的promise，将以回调的返回值来resolve.</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p><strong>创建Promise</strong><br>这个小例子展示了Promise的机制。每当<code>&lt;button&gt;</code>被按下时，testPromise()函数就会被执行。该函数会创建一个用window.setTimeout在1秒到3秒(随机)后用‘result’字符串完成的promise。<br>这里通过p1.then方法满足回调，简单的输出了promise的满足过程，这些输出显示了该方法的同步部分是如何和promise的异步完成解耦的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=<span class=\"string\">\"log\"</span>&gt;&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">  <span class=\"string\">'use strict'</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> promiseCount = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testPromise</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> thisPromiseCount = ++promiseCount;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> log = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'log'</span>);</span><br><span class=\"line\">    log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,thisPromiseCount + <span class=\"string\">') 开始(同步代码开始)&lt;br/&gt;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//我们创建一个新的promise:然后用'result'字符串完成这个promise(3秒后)</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//完成函数带着完成(resolve)或拒绝(reject) promise的能力被执行</span></span><br><span class=\"line\">      log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,thisPromiseCount + <span class=\"string\">') Promise开始(异步代码开始)&lt;br/&gt;'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">//这只是个创建异步完成的示例</span></span><br><span class=\"line\">      <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//我们满足(fullfil)了这个promise！</span></span><br><span class=\"line\">        resolve(thisPromiseCount)</span><br><span class=\"line\">      &#125;,<span class=\"built_in\">Math</span>.random() *<span class=\"number\">2000</span> + <span class=\"number\">1000</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//定义当promise被满足时应做什么</span></span><br><span class=\"line\">    p1.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">val</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//输出一段信息和一个值</span></span><br><span class=\"line\">      log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,val + <span class=\"string\">') Promise被满足了(异步代码结束)&lt;br/&gt;'</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    log.insertAdjacentHTML(<span class=\"string\">'beforeend'</span>,thisPromiseCount + <span class=\"string\">') 建立了Promise(同步代码结束)&lt;br/&gt;&lt;br/&gt;'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  testPromise();</span><br><span class=\"line\">  testPromise();</span><br><span class=\"line\">  testPromise();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>\n<p>这个例子在按钮被按下后执行。你需要一个支持Promise的浏览器。你能通过短时间内按多次按钮看到不同的promise一个接一个的被满足。</p>\n<h2 id=\"Example-using-new-XMLHttpRequest\"><a href=\"#Example-using-new-XMLHttpRequest\" class=\"headerlink\" title=\"Example using new XMLHttpRequest()\"></a>Example using new XMLHttpRequest()</h2><p><strong>创建一个promise</strong><br>这个例子展示了如何用promise报告一个XMLHttpRequest的成功或失败。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">$http</span>(<span class=\"params\">url</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> core = &#123;</span><br><span class=\"line\">    ajax: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">method,url,args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve,reject</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> client = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">        <span class=\"keyword\">var</span> uri = url;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(args &amp;&amp; (method === <span class=\"string\">'POST'</span> || method === <span class=\"string\">'PUT'</span>))&#123;</span><br><span class=\"line\">          uri += <span class=\"string\">'?'</span>;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> argcount = <span class=\"number\">0</span>;</span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> args)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(args.hasOwnProperty(key))&#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span>(argcount++)&#123;</span><br><span class=\"line\">                uri += <span class=\"string\">'&amp;'</span>;</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">              uri += encodeURIcomponent(key) + <span class=\"string\">'='</span> + encodeURIcomponent(args[key]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        client.open(method, uri);</span><br><span class=\"line\">        client.send();</span><br><span class=\"line\"></span><br><span class=\"line\">        client.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.status &gt;= <span class=\"number\">200</span> &amp;&amp; <span class=\"keyword\">this</span>.status &lt;<span class=\"number\">300</span>)&#123;</span><br><span class=\"line\">            resolve(<span class=\"keyword\">this</span>.response);</span><br><span class=\"line\">          &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            reject(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        client.onerror = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">          reject(<span class=\"keyword\">this</span>.statusText);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//Adapter patten</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"string\">'get'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> core.ajax(<span class=\"string\">'GET'</span>,url,args);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'post'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> core.ajax(<span class=\"string\">'POST'</span>,url,args);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'delete'</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">args</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> core.ajax(<span class=\"string\">'DELETE'</span>,url,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//End A</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mdnAPI = <span class=\"string\">'https://developer.mozilla.org/en-US/search.json'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> payload = &#123;</span><br><span class=\"line\">  <span class=\"string\">'topic'</span>: <span class=\"string\">'js'</span>,</span><br><span class=\"line\">  <span class=\"string\">'q'</span>: <span class=\"string\">'Promise'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> callback = &#123;</span><br><span class=\"line\">  success: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>,<span class=\"string\">'success'</span>,<span class=\"built_in\">JSON</span>.parse(data));</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>,<span class=\"string\">'error'</span>,<span class=\"built_in\">JSON</span>.parse(data));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//End B</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Executes the method call</span></span><br><span class=\"line\">$http(mdnAPI)</span><br><span class=\"line\">  .get(payload)</span><br><span class=\"line\">  .then(callback.success)</span><br><span class=\"line\">  .catch(callback.error);</span><br><span class=\"line\"></span><br><span class=\"line\">$http(mdnAPI)</span><br><span class=\"line\">  .get(payload)</span><br><span class=\"line\">  .then(callback.success,callback.error);</span><br><span class=\"line\"></span><br><span class=\"line\">$http(mdnAPI)</span><br><span class=\"line\">  .get(payload)</span><br><span class=\"line\">  .then(callback.success)</span><br><span class=\"line\">  .then(<span class=\"literal\">undefined</span>, callback.error);</span><br></pre></td></tr></table></figure></p>\n"},{"title":"基本函数式的编程","date":"2016-05-22T14:22:35.000Z","_content":"\n# 基本上函数式的编程\n一个没有副作用的程序是什么样？那是一个什么都做不了的程序。\n\n用包含了不可避免的副作用的函数式代码进行编程可以叫做\"基本上函数式编程(Mostly functional programming)\"。最好的实践是：在同一代码基础上运用多种范例并且利用其长处。基本上函数式的编程是如何用纯的、传统的函数式编程建模：将尽可能多的逻辑放在纯函数中，接口用命令式代码。\n\n这也是我们将要写的一个小应用的方式：\n\n在这个例子里，我们有个老板，他让我们为公司写个web应用来追踪员工的状态。在这个虚拟的公司里所有的员工只有一个工作：使用我们的网站。员工在开始工作时会嵌入，离开时会签出。但是这还不够，他还需要在内容有变化是自定更新，这样我们的老板就不用不停刷新页面。\n\n我们将Lazy.js作为我们的函数式库。并且我们也要懒一点：我们不去考虑如何处理用户的登陆注销、Websocket、数据库等等，而是假设已经有一个通用的应用对象已经为我们提供了这些完美的API。\n\n现在，我们先搞定丑陋的部分，让他们别碍事儿。这些部分是连接和创建副作用的。\n\n```javascript\n  function Receptor(name,available){\n    this.name = name;\n    this.available = available; //mutable state\n    this.render = function(){\n      output = '';\n      output += this.available ? this.name + ' is available': this.name + ' is not available';\n      output += '';\n      return output;\n    }\n  }\n  var me = new Receptor;\n  var receptors = app.getReceptors().push(me);\n  app.container.innerHTML = receptors.map(function(r){\n    return r.render();\n  }).join('');\n```\n\n对于显示状态列表这就足够了，不过我们想让它是响应式，这是我们的第一个障碍。\n\nLazy.js库会把这些对象存在一个序列里，而不会立刻计算它们的值，直到调用toArray()方法。这样我们就可以利用其惰性的优点来写出有那么点函数是响应式的程序。\n\n```javascript\n  var lazyReceptors = Lazy(receptors).map(function(r){\n    return r.render();\n  });\n  app.container.innerHTML = lazyReceptors.toArray().join('');\n```\n\n由于Receptor.render()方法返回新的HTML而不是修改现有的HTML,所以只需要把innerHTML参数设置为它的输出。 我们还不得不相信我们的用户管理通用程序还会为我们提供可用的回调方法。\n\n```javascript\n  app.onUserLogin = function(){\n    this.available = true;\n    app.container.innerHTML = lazyReceptors.toArray().join('');\n  };\n  app.onUserLogout = function(){\n    this.available = false;\n    app.container.innerHTML = lazyReceptors.toArray().join('');\n  };\n```\n\n这样，任何用户登录或者注销的时候，lazyReceptors将会被重新计算，打印出状态列表最新的值。\n\n# 处理事件\n如果应用没有在用户登录注销时提供回调怎么办？回调往往比较凌乱，会很快让程序变成意面代码。作为替代，我们可以通过直接观察用户来搞定。如果用户聚集于网页，那么他/她肯定是活跃并可用。我们可以利用javascript的focus和blur事件。\n\n```javascript\n  window.addEventListner('focus',function(event){\n    me.available = true;\n    app.setReceptor(me.name,me.available);\n    container.innerHTML = lazyReceptors.toArray().join('');\n  });\n  window.addEventListner('blur',function(event){\n    me.available = false;\n    app.setReceptor(me.name, me.available);\n    container.innerHTML = lazyReceptors.toArray().join('');\n  })\n```\n\n等等，难道事件不能使响应式的吗？它们可以惰性计算吗？在Lazy.js里是可以的，而且有个好用的方法。\n\n```javascript\n  var focusedReceptors = Lazy.events(window,\"focus\").each(function(e){\n    me.available = true;\n    app.setReceptor(me.name,me.available);\n    container.innerHTML = lazyReceptors.toArray().join('');\n  });\n  var blurredReceptors = Lazy.events(window,\"blur\").each(function(e){\n    me.available = false;\n    app.setReceptor(me.name,me.available);\n    container.innerHTML = lazyReceptors.toArray().join('')''\n  });\n```\n\n通过使用Lazy.js库处理事件，我们可以为事件创建一个无限序列。每次事件触发的时候， Lazy.each()函数会再遍历一次。\n\n到目前为止我们的老板还算喜欢这个应用，不过她指出，如果一个员工在一天离开前没有关闭网页而注销， 那么应用仍会说这个员工是可用状态。\n\n为了查明一个员工在网站上是否是活跃的，我们可以监视键盘和鼠标事件，我们认为30分钟没有操作就是不可用状态。\n\n```javascript\n  var timeout = null;\n  var inputs = Lazy.events(window,'mousemove').each(function(e){\n    me.available = true;\n    container.innerHTML = lazyReceptors.toArray().join('');\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      me.available = false;\n      container.innerHTML = lazyReceptors.toArray().join('');\n    }, 1800000);\n  })\n```\n\nLazy.js库让我们把事件作为可以映射的无限流非常容易。这之所以可能是因为它用了函数组合来控制执行顺序。\n\n# 函数式响应式编程\n我们再来建立另一种类型的应用，他的工作方式差不多，都是用函数式编程来响应状态变化。但是这回应用不会依赖于事件监听。\n\n来想来想象一下，你在一个新闻媒体公司工作，你的老板让你建立一个web应用来跟踪竞选日的政府竞选结果。 数据会根据地方选区的结果持续流动，所以显示在页面上的结果是具有响应式特征的。然而我们还需跟踪每一个区域的结果， 所以会有多个对象需要追踪。\n\n我们与其建立一个巨大的面向对象的层次结构来为接口建模，不如把它描述为声明式的不可变数据。 我们可以把它转换为纯函数或者半纯函数，半纯函数在必须保持的状态要更新时才产生副作用（理想状况下不会很多）。\n\n我们将使用Bacon.js库，它可以快速开发函数式响应式编程(FRP)的应用。这个应用只在选举日使用， 我们的老板认为它花费的时间应该与之成比例。通过函数式编程和像Bacon.js这样的库，我们将仅需要一半的时间。\n\n不过首先我们需要一些对象来描述选区，比如州、省、区等等。\n\n```javascript\n  function Region(name,percent,partials){\n    //可变属性\n    this.name = name;\n    this.percent = percent;\n    this.partials = partials;\n    //返回一段HTML\n    this.render = function(){\n      var lis = this.partials.map(function(p){\n        return '' + p.name + ': ' + p.votes + '';\n      });\n      var output = '' + this.name + '';\n      output += '' + this.name + '';\n      output += '' + lis.join('') + '';\n    output += 'Percent reported: ' + this.percent;\n    return output;\n      }\n    }\n    function getRegions(data) {\n      return JSON.parse(data).map(function(obj) {\n        return new Region(obj.name, obj.percent, obj.parties);\n      });\n    }\n    var url = 'http://api.server.com/election-data?format=json';\n    var data = jQuery.ajax(url);\n    var regions = getRegions(data);\n    app.container.innerHTML = regions.map(function(r) {\n      return r.render();\n    }).join('');\n```\n\n上面的代码可以满足对静态选举结果列表的展示，然而我们需要一种动态更新选区的方式。是时候来点Bacon和FRP了\n\n## 响应式编程\nbacon有个函数，Bacon.fromPoll()，用于创建事件流，它让事件成为在一定时间间隔被调用的函数。 还有stream.subscribe()函数让我们可以订阅（subsribe）一个针对这个流的处理函数。由于它是惰性的， 如果没有订阅者（subscriber）流实际上就不去做任何事情。\n\n```javascript\n  var eventStream = Bacon.fromPoll(10000, function() {\n  return Bacon.Next;\n  });\n  var subscriber = eventStream.subscribe(function() {\n  var url = 'http://api.server.com/election-data?format=json';\n  var data = jQuery.ajax(url);\n  var newRegions = getRegions(data);\n  container.innerHTML = newRegions.map(function(r) {\n    return r.render();\n  }).join('');\n  });\n```\n\n大体上就是把它放到一个每10秒运行一次的循环中，我们的工作完成了。但是这个方法将会不断的ping网络， 并且非常低效。这还不是很函数式。让我们继续深入挖掘一下Bacon.js库。\n\nBeacon里有EventStreams和Properties参数。Properties可以想作是\"魔术\"变量，它随着事件的响应不断变化。 实际上这不是魔术，因为他们依赖于事件流。属性的不断变化与事件流相关。\n\nBacon.js里还有一个戏法。Bacon.fromPromise()函数是一种利用promise把事件搞成流的方式。 jQuery从1.5.0版本开始实现了promise接口，所以我们所要做的仅仅是写一个AJAX查询函数， 在异步调用完成时触发事件。每当promise被处理时，他就调用EventStream的订阅者（subscribers）。\n\n```javascript\nvar url = 'http://api.server.com/election-data?format=json';\nvar eventStream = Bacon.fromPromise(jQuery.ajax(url));\nvar subscriber = eventStream.onValue(function(data) {\nnewRegions = getRegions(data);\ncontainer.innerHTML = newRegions.map(function(r) {\n  return r.render();\n}).join('');\n}\n```\n\npromise可以想成是一个初始值；通过Bacon.js，我们可以对初始值惰性地等待。\n\n## 把它们搁到一块\n现在我们学完了响应式的内容，最后我们可以用些代码来玩一玩它。\n\n我们可以通过对纯函数的链式调用改变订阅者来做些事情，比如求和或者过滤不想要的结果， 我们只需通过我们所创建的对按钮的onclick()处理函数来完成这些。\n\n```javascript\n// 在函数外创建事件流\nvar eventStream = Bacon.onPromise(jQuery.ajax(url));\nvar subscribe = null;\nvar url = 'http://api.server.com/election-data?format=json';\n// 未被改变的订阅者\n$('button#showAll').click(function() {\nvar subscriber = eventStream.onValue(function(data) {\n  var newRegions = getRegions(data).map(function(r) {\n    return new Region(r.name, r.percent, r.parties);\n  });\n  container.innerHTML = newRegions.map(function(r) {\n    return r.render();\n  }).join('');\n});\n});\n// 显示全部选举情况的按钮\n$('button#showTotal').click(function() {\nvar subscriber = eventStream.onValue(function(data) {\n  var emptyRegion = new Region('empty', 0, [{\n    name: 'Republican',\n    votes: 0\n  }, {\n    name: 'Democrat',\n    votes: 0\n  }]);\n  var totalRegions = getRegions(data).reduce(function(r1, r2) {\n    newParties = r1.parties.map(function(x, i) {\n      return {\n        name: r1.parties[i].name,\n        votes: r1.parties[i].votes + r2.parties[i].votes\n      };\n    });\n    newRegion = new Region('Total', (r1.percent + r2.percent) / 2,\n      newParties);\n    return newRegion;\n  }, emptyRegion);\n  container.innerHTML = totalRegions.render();\n});\n});\n// 只显示报告大于50%的选区\n$('button#showMostlyReported').click(function() {\nvar subscriber = eventStream.onValue(function(data) {\n  var newRegions = getRegions(data).map(function(r) {\n    if (r.percent > 50) return r;\n    else return null;\n  }).filter(function(r) {\n    return r != null;\n  });\n  container.innerHTML = newRegions.map(function(r) {\n    return r.render();\n  }).join('');\n});\n});\n```\n\n它的美丽之处在于：当用户点击按钮时，事件流并没有变化，但是订阅者变化了，这就使所有的工作很平顺。\n","source":"_posts/基本函数式的编程.md","raw":"---\ntitle: 基本函数式的编程\ndate: 2016-05-22T22:22:35.000Z\ntags:\n  - javascript\n  - 函数式编程\ncategories: 转载笔记\n---\n\n# 基本上函数式的编程\n一个没有副作用的程序是什么样？那是一个什么都做不了的程序。\n\n用包含了不可避免的副作用的函数式代码进行编程可以叫做\"基本上函数式编程(Mostly functional programming)\"。最好的实践是：在同一代码基础上运用多种范例并且利用其长处。基本上函数式的编程是如何用纯的、传统的函数式编程建模：将尽可能多的逻辑放在纯函数中，接口用命令式代码。\n\n这也是我们将要写的一个小应用的方式：\n\n在这个例子里，我们有个老板，他让我们为公司写个web应用来追踪员工的状态。在这个虚拟的公司里所有的员工只有一个工作：使用我们的网站。员工在开始工作时会嵌入，离开时会签出。但是这还不够，他还需要在内容有变化是自定更新，这样我们的老板就不用不停刷新页面。\n\n我们将Lazy.js作为我们的函数式库。并且我们也要懒一点：我们不去考虑如何处理用户的登陆注销、Websocket、数据库等等，而是假设已经有一个通用的应用对象已经为我们提供了这些完美的API。\n\n现在，我们先搞定丑陋的部分，让他们别碍事儿。这些部分是连接和创建副作用的。\n\n```javascript\n  function Receptor(name,available){\n    this.name = name;\n    this.available = available; //mutable state\n    this.render = function(){\n      output = '';\n      output += this.available ? this.name + ' is available': this.name + ' is not available';\n      output += '';\n      return output;\n    }\n  }\n  var me = new Receptor;\n  var receptors = app.getReceptors().push(me);\n  app.container.innerHTML = receptors.map(function(r){\n    return r.render();\n  }).join('');\n```\n\n对于显示状态列表这就足够了，不过我们想让它是响应式，这是我们的第一个障碍。\n\nLazy.js库会把这些对象存在一个序列里，而不会立刻计算它们的值，直到调用toArray()方法。这样我们就可以利用其惰性的优点来写出有那么点函数是响应式的程序。\n\n```javascript\n  var lazyReceptors = Lazy(receptors).map(function(r){\n    return r.render();\n  });\n  app.container.innerHTML = lazyReceptors.toArray().join('');\n```\n\n由于Receptor.render()方法返回新的HTML而不是修改现有的HTML,所以只需要把innerHTML参数设置为它的输出。 我们还不得不相信我们的用户管理通用程序还会为我们提供可用的回调方法。\n\n```javascript\n  app.onUserLogin = function(){\n    this.available = true;\n    app.container.innerHTML = lazyReceptors.toArray().join('');\n  };\n  app.onUserLogout = function(){\n    this.available = false;\n    app.container.innerHTML = lazyReceptors.toArray().join('');\n  };\n```\n\n这样，任何用户登录或者注销的时候，lazyReceptors将会被重新计算，打印出状态列表最新的值。\n\n# 处理事件\n如果应用没有在用户登录注销时提供回调怎么办？回调往往比较凌乱，会很快让程序变成意面代码。作为替代，我们可以通过直接观察用户来搞定。如果用户聚集于网页，那么他/她肯定是活跃并可用。我们可以利用javascript的focus和blur事件。\n\n```javascript\n  window.addEventListner('focus',function(event){\n    me.available = true;\n    app.setReceptor(me.name,me.available);\n    container.innerHTML = lazyReceptors.toArray().join('');\n  });\n  window.addEventListner('blur',function(event){\n    me.available = false;\n    app.setReceptor(me.name, me.available);\n    container.innerHTML = lazyReceptors.toArray().join('');\n  })\n```\n\n等等，难道事件不能使响应式的吗？它们可以惰性计算吗？在Lazy.js里是可以的，而且有个好用的方法。\n\n```javascript\n  var focusedReceptors = Lazy.events(window,\"focus\").each(function(e){\n    me.available = true;\n    app.setReceptor(me.name,me.available);\n    container.innerHTML = lazyReceptors.toArray().join('');\n  });\n  var blurredReceptors = Lazy.events(window,\"blur\").each(function(e){\n    me.available = false;\n    app.setReceptor(me.name,me.available);\n    container.innerHTML = lazyReceptors.toArray().join('')''\n  });\n```\n\n通过使用Lazy.js库处理事件，我们可以为事件创建一个无限序列。每次事件触发的时候， Lazy.each()函数会再遍历一次。\n\n到目前为止我们的老板还算喜欢这个应用，不过她指出，如果一个员工在一天离开前没有关闭网页而注销， 那么应用仍会说这个员工是可用状态。\n\n为了查明一个员工在网站上是否是活跃的，我们可以监视键盘和鼠标事件，我们认为30分钟没有操作就是不可用状态。\n\n```javascript\n  var timeout = null;\n  var inputs = Lazy.events(window,'mousemove').each(function(e){\n    me.available = true;\n    container.innerHTML = lazyReceptors.toArray().join('');\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      me.available = false;\n      container.innerHTML = lazyReceptors.toArray().join('');\n    }, 1800000);\n  })\n```\n\nLazy.js库让我们把事件作为可以映射的无限流非常容易。这之所以可能是因为它用了函数组合来控制执行顺序。\n\n# 函数式响应式编程\n我们再来建立另一种类型的应用，他的工作方式差不多，都是用函数式编程来响应状态变化。但是这回应用不会依赖于事件监听。\n\n来想来想象一下，你在一个新闻媒体公司工作，你的老板让你建立一个web应用来跟踪竞选日的政府竞选结果。 数据会根据地方选区的结果持续流动，所以显示在页面上的结果是具有响应式特征的。然而我们还需跟踪每一个区域的结果， 所以会有多个对象需要追踪。\n\n我们与其建立一个巨大的面向对象的层次结构来为接口建模，不如把它描述为声明式的不可变数据。 我们可以把它转换为纯函数或者半纯函数，半纯函数在必须保持的状态要更新时才产生副作用（理想状况下不会很多）。\n\n我们将使用Bacon.js库，它可以快速开发函数式响应式编程(FRP)的应用。这个应用只在选举日使用， 我们的老板认为它花费的时间应该与之成比例。通过函数式编程和像Bacon.js这样的库，我们将仅需要一半的时间。\n\n不过首先我们需要一些对象来描述选区，比如州、省、区等等。\n\n```javascript\n  function Region(name,percent,partials){\n    //可变属性\n    this.name = name;\n    this.percent = percent;\n    this.partials = partials;\n    //返回一段HTML\n    this.render = function(){\n      var lis = this.partials.map(function(p){\n        return '' + p.name + ': ' + p.votes + '';\n      });\n      var output = '' + this.name + '';\n      output += '' + this.name + '';\n      output += '' + lis.join('') + '';\n    output += 'Percent reported: ' + this.percent;\n    return output;\n      }\n    }\n    function getRegions(data) {\n      return JSON.parse(data).map(function(obj) {\n        return new Region(obj.name, obj.percent, obj.parties);\n      });\n    }\n    var url = 'http://api.server.com/election-data?format=json';\n    var data = jQuery.ajax(url);\n    var regions = getRegions(data);\n    app.container.innerHTML = regions.map(function(r) {\n      return r.render();\n    }).join('');\n```\n\n上面的代码可以满足对静态选举结果列表的展示，然而我们需要一种动态更新选区的方式。是时候来点Bacon和FRP了\n\n## 响应式编程\nbacon有个函数，Bacon.fromPoll()，用于创建事件流，它让事件成为在一定时间间隔被调用的函数。 还有stream.subscribe()函数让我们可以订阅（subsribe）一个针对这个流的处理函数。由于它是惰性的， 如果没有订阅者（subscriber）流实际上就不去做任何事情。\n\n```javascript\n  var eventStream = Bacon.fromPoll(10000, function() {\n  return Bacon.Next;\n  });\n  var subscriber = eventStream.subscribe(function() {\n  var url = 'http://api.server.com/election-data?format=json';\n  var data = jQuery.ajax(url);\n  var newRegions = getRegions(data);\n  container.innerHTML = newRegions.map(function(r) {\n    return r.render();\n  }).join('');\n  });\n```\n\n大体上就是把它放到一个每10秒运行一次的循环中，我们的工作完成了。但是这个方法将会不断的ping网络， 并且非常低效。这还不是很函数式。让我们继续深入挖掘一下Bacon.js库。\n\nBeacon里有EventStreams和Properties参数。Properties可以想作是\"魔术\"变量，它随着事件的响应不断变化。 实际上这不是魔术，因为他们依赖于事件流。属性的不断变化与事件流相关。\n\nBacon.js里还有一个戏法。Bacon.fromPromise()函数是一种利用promise把事件搞成流的方式。 jQuery从1.5.0版本开始实现了promise接口，所以我们所要做的仅仅是写一个AJAX查询函数， 在异步调用完成时触发事件。每当promise被处理时，他就调用EventStream的订阅者（subscribers）。\n\n```javascript\nvar url = 'http://api.server.com/election-data?format=json';\nvar eventStream = Bacon.fromPromise(jQuery.ajax(url));\nvar subscriber = eventStream.onValue(function(data) {\nnewRegions = getRegions(data);\ncontainer.innerHTML = newRegions.map(function(r) {\n  return r.render();\n}).join('');\n}\n```\n\npromise可以想成是一个初始值；通过Bacon.js，我们可以对初始值惰性地等待。\n\n## 把它们搁到一块\n现在我们学完了响应式的内容，最后我们可以用些代码来玩一玩它。\n\n我们可以通过对纯函数的链式调用改变订阅者来做些事情，比如求和或者过滤不想要的结果， 我们只需通过我们所创建的对按钮的onclick()处理函数来完成这些。\n\n```javascript\n// 在函数外创建事件流\nvar eventStream = Bacon.onPromise(jQuery.ajax(url));\nvar subscribe = null;\nvar url = 'http://api.server.com/election-data?format=json';\n// 未被改变的订阅者\n$('button#showAll').click(function() {\nvar subscriber = eventStream.onValue(function(data) {\n  var newRegions = getRegions(data).map(function(r) {\n    return new Region(r.name, r.percent, r.parties);\n  });\n  container.innerHTML = newRegions.map(function(r) {\n    return r.render();\n  }).join('');\n});\n});\n// 显示全部选举情况的按钮\n$('button#showTotal').click(function() {\nvar subscriber = eventStream.onValue(function(data) {\n  var emptyRegion = new Region('empty', 0, [{\n    name: 'Republican',\n    votes: 0\n  }, {\n    name: 'Democrat',\n    votes: 0\n  }]);\n  var totalRegions = getRegions(data).reduce(function(r1, r2) {\n    newParties = r1.parties.map(function(x, i) {\n      return {\n        name: r1.parties[i].name,\n        votes: r1.parties[i].votes + r2.parties[i].votes\n      };\n    });\n    newRegion = new Region('Total', (r1.percent + r2.percent) / 2,\n      newParties);\n    return newRegion;\n  }, emptyRegion);\n  container.innerHTML = totalRegions.render();\n});\n});\n// 只显示报告大于50%的选区\n$('button#showMostlyReported').click(function() {\nvar subscriber = eventStream.onValue(function(data) {\n  var newRegions = getRegions(data).map(function(r) {\n    if (r.percent > 50) return r;\n    else return null;\n  }).filter(function(r) {\n    return r != null;\n  });\n  container.innerHTML = newRegions.map(function(r) {\n    return r.render();\n  }).join('');\n});\n});\n```\n\n它的美丽之处在于：当用户点击按钮时，事件流并没有变化，但是订阅者变化了，这就使所有的工作很平顺。\n","slug":"基本函数式的编程","published":1,"updated":"2016-05-23T01:26:51.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enf001rb0dlbx38v3mk","content":"<h1 id=\"基本上函数式的编程\"><a href=\"#基本上函数式的编程\" class=\"headerlink\" title=\"基本上函数式的编程\"></a>基本上函数式的编程</h1><p>一个没有副作用的程序是什么样？那是一个什么都做不了的程序。</p>\n<p>用包含了不可避免的副作用的函数式代码进行编程可以叫做”基本上函数式编程(Mostly functional programming)”。最好的实践是：在同一代码基础上运用多种范例并且利用其长处。基本上函数式的编程是如何用纯的、传统的函数式编程建模：将尽可能多的逻辑放在纯函数中，接口用命令式代码。</p>\n<p>这也是我们将要写的一个小应用的方式：</p>\n<p>在这个例子里，我们有个老板，他让我们为公司写个web应用来追踪员工的状态。在这个虚拟的公司里所有的员工只有一个工作：使用我们的网站。员工在开始工作时会嵌入，离开时会签出。但是这还不够，他还需要在内容有变化是自定更新，这样我们的老板就不用不停刷新页面。</p>\n<p>我们将Lazy.js作为我们的函数式库。并且我们也要懒一点：我们不去考虑如何处理用户的登陆注销、Websocket、数据库等等，而是假设已经有一个通用的应用对象已经为我们提供了这些完美的API。</p>\n<p>现在，我们先搞定丑陋的部分，让他们别碍事儿。这些部分是连接和创建副作用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Receptor</span>(<span class=\"params\">name,available</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.available = available; <span class=\"comment\">//mutable state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.render = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    output = <span class=\"string\">''</span>;</span><br><span class=\"line\">    output += <span class=\"keyword\">this</span>.available ? <span class=\"keyword\">this</span>.name + <span class=\"string\">' is available'</span>: <span class=\"keyword\">this</span>.name + <span class=\"string\">' is not available'</span>;</span><br><span class=\"line\">    output += <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"keyword\">new</span> Receptor;</span><br><span class=\"line\"><span class=\"keyword\">var</span> receptors = app.getReceptors().push(me);</span><br><span class=\"line\">app.container.innerHTML = receptors.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;).join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>对于显示状态列表这就足够了，不过我们想让它是响应式，这是我们的第一个障碍。</p>\n<p>Lazy.js库会把这些对象存在一个序列里，而不会立刻计算它们的值，直到调用toArray()方法。这样我们就可以利用其惰性的优点来写出有那么点函数是响应式的程序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lazyReceptors = Lazy(receptors).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>由于Receptor.render()方法返回新的HTML而不是修改现有的HTML,所以只需要把innerHTML参数设置为它的输出。 我们还不得不相信我们的用户管理通用程序还会为我们提供可用的回调方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.onUserLogin = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  app.container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">app.onUserLogout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  app.container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样，任何用户登录或者注销的时候，lazyReceptors将会被重新计算，打印出状态列表最新的值。</p>\n<h1 id=\"处理事件\"><a href=\"#处理事件\" class=\"headerlink\" title=\"处理事件\"></a>处理事件</h1><p>如果应用没有在用户登录注销时提供回调怎么办？回调往往比较凌乱，会很快让程序变成意面代码。作为替代，我们可以通过直接观察用户来搞定。如果用户聚集于网页，那么他/她肯定是活跃并可用。我们可以利用javascript的focus和blur事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListner(<span class=\"string\">'focus'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  app.setReceptor(me.name,me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListner(<span class=\"string\">'blur'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  app.setReceptor(me.name, me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>等等，难道事件不能使响应式的吗？它们可以惰性计算吗？在Lazy.js里是可以的，而且有个好用的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> focusedReceptors = Lazy.events(<span class=\"built_in\">window</span>,<span class=\"string\">\"focus\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  app.setReceptor(me.name,me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blurredReceptors = Lazy.events(<span class=\"built_in\">window</span>,<span class=\"string\">\"blur\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  app.setReceptor(me.name,me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>)<span class=\"string\">''</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过使用Lazy.js库处理事件，我们可以为事件创建一个无限序列。每次事件触发的时候， Lazy.each()函数会再遍历一次。</p>\n<p>到目前为止我们的老板还算喜欢这个应用，不过她指出，如果一个员工在一天离开前没有关闭网页而注销， 那么应用仍会说这个员工是可用状态。</p>\n<p>为了查明一个员工在网站上是否是活跃的，我们可以监视键盘和鼠标事件，我们认为30分钟没有操作就是不可用状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inputs = Lazy.events(<span class=\"built_in\">window</span>,<span class=\"string\">'mousemove'</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  clearTimeout(timeout);</span><br><span class=\"line\">  timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    me.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1800000</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Lazy.js库让我们把事件作为可以映射的无限流非常容易。这之所以可能是因为它用了函数组合来控制执行顺序。</p>\n<h1 id=\"函数式响应式编程\"><a href=\"#函数式响应式编程\" class=\"headerlink\" title=\"函数式响应式编程\"></a>函数式响应式编程</h1><p>我们再来建立另一种类型的应用，他的工作方式差不多，都是用函数式编程来响应状态变化。但是这回应用不会依赖于事件监听。</p>\n<p>来想来想象一下，你在一个新闻媒体公司工作，你的老板让你建立一个web应用来跟踪竞选日的政府竞选结果。 数据会根据地方选区的结果持续流动，所以显示在页面上的结果是具有响应式特征的。然而我们还需跟踪每一个区域的结果， 所以会有多个对象需要追踪。</p>\n<p>我们与其建立一个巨大的面向对象的层次结构来为接口建模，不如把它描述为声明式的不可变数据。 我们可以把它转换为纯函数或者半纯函数，半纯函数在必须保持的状态要更新时才产生副作用（理想状况下不会很多）。</p>\n<p>我们将使用Bacon.js库，它可以快速开发函数式响应式编程(FRP)的应用。这个应用只在选举日使用， 我们的老板认为它花费的时间应该与之成比例。通过函数式编程和像Bacon.js这样的库，我们将仅需要一半的时间。</p>\n<p>不过首先我们需要一些对象来描述选区，比如州、省、区等等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Region</span>(<span class=\"params\">name,percent,partials</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//可变属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.percent = percent;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.partials = partials;</span><br><span class=\"line\">  <span class=\"comment\">//返回一段HTML</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.render = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lis = <span class=\"keyword\">this</span>.partials.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">''</span> + p.name + <span class=\"string\">': '</span> + p.votes + <span class=\"string\">''</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> output = <span class=\"string\">''</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">''</span>;</span><br><span class=\"line\">    output += <span class=\"string\">''</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">''</span>;</span><br><span class=\"line\">    output += <span class=\"string\">''</span> + lis.join(<span class=\"string\">''</span>) + <span class=\"string\">''</span>;</span><br><span class=\"line\">  output += <span class=\"string\">'Percent reported: '</span> + <span class=\"keyword\">this</span>.percent;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRegions</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(data).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Region(obj.name, obj.percent, obj.parties);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = jQuery.ajax(url);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> regions = getRegions(data);</span><br><span class=\"line\">  app.container.innerHTML = regions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以满足对静态选举结果列表的展示，然而我们需要一种动态更新选区的方式。是时候来点Bacon和FRP了</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><p>bacon有个函数，Bacon.fromPoll()，用于创建事件流，它让事件成为在一定时间间隔被调用的函数。 还有stream.subscribe()函数让我们可以订阅（subsribe）一个针对这个流的处理函数。由于它是惰性的， 如果没有订阅者（subscriber）流实际上就不去做任何事情。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eventStream = Bacon.fromPoll(<span class=\"number\">10000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Bacon.Next;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.subscribe(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = jQuery.ajax(url);</span><br><span class=\"line\"><span class=\"keyword\">var</span> newRegions = getRegions(data);</span><br><span class=\"line\">container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>大体上就是把它放到一个每10秒运行一次的循环中，我们的工作完成了。但是这个方法将会不断的ping网络， 并且非常低效。这还不是很函数式。让我们继续深入挖掘一下Bacon.js库。</p>\n<p>Beacon里有EventStreams和Properties参数。Properties可以想作是”魔术”变量，它随着事件的响应不断变化。 实际上这不是魔术，因为他们依赖于事件流。属性的不断变化与事件流相关。</p>\n<p>Bacon.js里还有一个戏法。Bacon.fromPromise()函数是一种利用promise把事件搞成流的方式。 jQuery从1.5.0版本开始实现了promise接口，所以我们所要做的仅仅是写一个AJAX查询函数， 在异步调用完成时触发事件。每当promise被处理时，他就调用EventStream的订阅者（subscribers）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> eventStream = Bacon.fromPromise(jQuery.ajax(url));</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">newRegions = getRegions(data);</span><br><span class=\"line\">container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promise可以想成是一个初始值；通过Bacon.js，我们可以对初始值惰性地等待。</p>\n<h2 id=\"把它们搁到一块\"><a href=\"#把它们搁到一块\" class=\"headerlink\" title=\"把它们搁到一块\"></a>把它们搁到一块</h2><p>现在我们学完了响应式的内容，最后我们可以用些代码来玩一玩它。</p>\n<p>我们可以通过对纯函数的链式调用改变订阅者来做些事情，比如求和或者过滤不想要的结果， 我们只需通过我们所创建的对按钮的onclick()处理函数来完成这些。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在函数外创建事件流</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> eventStream = Bacon.onPromise(jQuery.ajax(url));</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscribe = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 未被改变的订阅者</span></span><br><span class=\"line\">$(<span class=\"string\">'button#showAll'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newRegions = getRegions(data).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Region(r.name, r.percent, r.parties);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 显示全部选举情况的按钮</span></span><br><span class=\"line\">$(<span class=\"string\">'button#showTotal'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> emptyRegion = <span class=\"keyword\">new</span> Region(<span class=\"string\">'empty'</span>, <span class=\"number\">0</span>, [&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Republican'</span>,</span><br><span class=\"line\">    votes: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Democrat'</span>,</span><br><span class=\"line\">    votes: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;]);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> totalRegions = getRegions(data).reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r1, r2</span>) </span>&#123;</span><br><span class=\"line\">    newParties = r1.parties.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, i</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name: r1.parties[i].name,</span><br><span class=\"line\">        votes: r1.parties[i].votes + r2.parties[i].votes</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    newRegion = <span class=\"keyword\">new</span> Region(<span class=\"string\">'Total'</span>, (r1.percent + r2.percent) / <span class=\"number\">2</span>,</span><br><span class=\"line\">      newParties);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newRegion;</span><br><span class=\"line\">  &#125;, emptyRegion);</span><br><span class=\"line\">  container.innerHTML = totalRegions.render();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 只显示报告大于50%的选区</span></span><br><span class=\"line\">$(<span class=\"string\">'button#showMostlyReported'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newRegions = getRegions(data).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.percent &gt; <span class=\"number\">50</span>) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r != <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>它的美丽之处在于：当用户点击按钮时，事件流并没有变化，但是订阅者变化了，这就使所有的工作很平顺。</p>\n","excerpt":"","more":"<h1 id=\"基本上函数式的编程\"><a href=\"#基本上函数式的编程\" class=\"headerlink\" title=\"基本上函数式的编程\"></a>基本上函数式的编程</h1><p>一个没有副作用的程序是什么样？那是一个什么都做不了的程序。</p>\n<p>用包含了不可避免的副作用的函数式代码进行编程可以叫做”基本上函数式编程(Mostly functional programming)”。最好的实践是：在同一代码基础上运用多种范例并且利用其长处。基本上函数式的编程是如何用纯的、传统的函数式编程建模：将尽可能多的逻辑放在纯函数中，接口用命令式代码。</p>\n<p>这也是我们将要写的一个小应用的方式：</p>\n<p>在这个例子里，我们有个老板，他让我们为公司写个web应用来追踪员工的状态。在这个虚拟的公司里所有的员工只有一个工作：使用我们的网站。员工在开始工作时会嵌入，离开时会签出。但是这还不够，他还需要在内容有变化是自定更新，这样我们的老板就不用不停刷新页面。</p>\n<p>我们将Lazy.js作为我们的函数式库。并且我们也要懒一点：我们不去考虑如何处理用户的登陆注销、Websocket、数据库等等，而是假设已经有一个通用的应用对象已经为我们提供了这些完美的API。</p>\n<p>现在，我们先搞定丑陋的部分，让他们别碍事儿。这些部分是连接和创建副作用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Receptor</span>(<span class=\"params\">name,available</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.available = available; <span class=\"comment\">//mutable state</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.render = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    output = <span class=\"string\">''</span>;</span><br><span class=\"line\">    output += <span class=\"keyword\">this</span>.available ? <span class=\"keyword\">this</span>.name + <span class=\"string\">' is available'</span>: <span class=\"keyword\">this</span>.name + <span class=\"string\">' is not available'</span>;</span><br><span class=\"line\">    output += <span class=\"string\">''</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = <span class=\"keyword\">new</span> Receptor;</span><br><span class=\"line\"><span class=\"keyword\">var</span> receptors = app.getReceptors().push(me);</span><br><span class=\"line\">app.container.innerHTML = receptors.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;).join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>对于显示状态列表这就足够了，不过我们想让它是响应式，这是我们的第一个障碍。</p>\n<p>Lazy.js库会把这些对象存在一个序列里，而不会立刻计算它们的值，直到调用toArray()方法。这样我们就可以利用其惰性的优点来写出有那么点函数是响应式的程序。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lazyReceptors = Lazy(receptors).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">app.container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>由于Receptor.render()方法返回新的HTML而不是修改现有的HTML,所以只需要把innerHTML参数设置为它的输出。 我们还不得不相信我们的用户管理通用程序还会为我们提供可用的回调方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.onUserLogin = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  app.container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">app.onUserLogout = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  app.container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样，任何用户登录或者注销的时候，lazyReceptors将会被重新计算，打印出状态列表最新的值。</p>\n<h1 id=\"处理事件\"><a href=\"#处理事件\" class=\"headerlink\" title=\"处理事件\"></a>处理事件</h1><p>如果应用没有在用户登录注销时提供回调怎么办？回调往往比较凌乱，会很快让程序变成意面代码。作为替代，我们可以通过直接观察用户来搞定。如果用户聚集于网页，那么他/她肯定是活跃并可用。我们可以利用javascript的focus和blur事件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.addEventListner(<span class=\"string\">'focus'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  app.setReceptor(me.name,me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListner(<span class=\"string\">'blur'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  app.setReceptor(me.name, me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>等等，难道事件不能使响应式的吗？它们可以惰性计算吗？在Lazy.js里是可以的，而且有个好用的方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> focusedReceptors = Lazy.events(<span class=\"built_in\">window</span>,<span class=\"string\">\"focus\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  app.setReceptor(me.name,me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> blurredReceptors = Lazy.events(<span class=\"built_in\">window</span>,<span class=\"string\">\"blur\"</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  app.setReceptor(me.name,me.available);</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>)<span class=\"string\">''</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>通过使用Lazy.js库处理事件，我们可以为事件创建一个无限序列。每次事件触发的时候， Lazy.each()函数会再遍历一次。</p>\n<p>到目前为止我们的老板还算喜欢这个应用，不过她指出，如果一个员工在一天离开前没有关闭网页而注销， 那么应用仍会说这个员工是可用状态。</p>\n<p>为了查明一个员工在网站上是否是活跃的，我们可以监视键盘和鼠标事件，我们认为30分钟没有操作就是不可用状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> inputs = Lazy.events(<span class=\"built_in\">window</span>,<span class=\"string\">'mousemove'</span>).each(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  me.available = <span class=\"literal\">true</span>;</span><br><span class=\"line\">  container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  clearTimeout(timeout);</span><br><span class=\"line\">  timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    me.available = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    container.innerHTML = lazyReceptors.toArray().join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;, <span class=\"number\">1800000</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Lazy.js库让我们把事件作为可以映射的无限流非常容易。这之所以可能是因为它用了函数组合来控制执行顺序。</p>\n<h1 id=\"函数式响应式编程\"><a href=\"#函数式响应式编程\" class=\"headerlink\" title=\"函数式响应式编程\"></a>函数式响应式编程</h1><p>我们再来建立另一种类型的应用，他的工作方式差不多，都是用函数式编程来响应状态变化。但是这回应用不会依赖于事件监听。</p>\n<p>来想来想象一下，你在一个新闻媒体公司工作，你的老板让你建立一个web应用来跟踪竞选日的政府竞选结果。 数据会根据地方选区的结果持续流动，所以显示在页面上的结果是具有响应式特征的。然而我们还需跟踪每一个区域的结果， 所以会有多个对象需要追踪。</p>\n<p>我们与其建立一个巨大的面向对象的层次结构来为接口建模，不如把它描述为声明式的不可变数据。 我们可以把它转换为纯函数或者半纯函数，半纯函数在必须保持的状态要更新时才产生副作用（理想状况下不会很多）。</p>\n<p>我们将使用Bacon.js库，它可以快速开发函数式响应式编程(FRP)的应用。这个应用只在选举日使用， 我们的老板认为它花费的时间应该与之成比例。通过函数式编程和像Bacon.js这样的库，我们将仅需要一半的时间。</p>\n<p>不过首先我们需要一些对象来描述选区，比如州、省、区等等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Region</span>(<span class=\"params\">name,percent,partials</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//可变属性</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.percent = percent;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.partials = partials;</span><br><span class=\"line\">  <span class=\"comment\">//返回一段HTML</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.render = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> lis = <span class=\"keyword\">this</span>.partials.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">p</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">''</span> + p.name + <span class=\"string\">': '</span> + p.votes + <span class=\"string\">''</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> output = <span class=\"string\">''</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">''</span>;</span><br><span class=\"line\">    output += <span class=\"string\">''</span> + <span class=\"keyword\">this</span>.name + <span class=\"string\">''</span>;</span><br><span class=\"line\">    output += <span class=\"string\">''</span> + lis.join(<span class=\"string\">''</span>) + <span class=\"string\">''</span>;</span><br><span class=\"line\">  output += <span class=\"string\">'Percent reported: '</span> + <span class=\"keyword\">this</span>.percent;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> output;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getRegions</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(data).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Region(obj.name, obj.percent, obj.parties);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = jQuery.ajax(url);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> regions = getRegions(data);</span><br><span class=\"line\">  app.container.innerHTML = regions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br></pre></td></tr></table></figure>\n<p>上面的代码可以满足对静态选举结果列表的展示，然而我们需要一种动态更新选区的方式。是时候来点Bacon和FRP了</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><p>bacon有个函数，Bacon.fromPoll()，用于创建事件流，它让事件成为在一定时间间隔被调用的函数。 还有stream.subscribe()函数让我们可以订阅（subsribe）一个针对这个流的处理函数。由于它是惰性的， 如果没有订阅者（subscriber）流实际上就不去做任何事情。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> eventStream = Bacon.fromPoll(<span class=\"number\">10000</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> Bacon.Next;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.subscribe(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> data = jQuery.ajax(url);</span><br><span class=\"line\"><span class=\"keyword\">var</span> newRegions = getRegions(data);</span><br><span class=\"line\">container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>大体上就是把它放到一个每10秒运行一次的循环中，我们的工作完成了。但是这个方法将会不断的ping网络， 并且非常低效。这还不是很函数式。让我们继续深入挖掘一下Bacon.js库。</p>\n<p>Beacon里有EventStreams和Properties参数。Properties可以想作是”魔术”变量，它随着事件的响应不断变化。 实际上这不是魔术，因为他们依赖于事件流。属性的不断变化与事件流相关。</p>\n<p>Bacon.js里还有一个戏法。Bacon.fromPromise()函数是一种利用promise把事件搞成流的方式。 jQuery从1.5.0版本开始实现了promise接口，所以我们所要做的仅仅是写一个AJAX查询函数， 在异步调用完成时触发事件。每当promise被处理时，他就调用EventStream的订阅者（subscribers）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> eventStream = Bacon.fromPromise(jQuery.ajax(url));</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">newRegions = getRegions(data);</span><br><span class=\"line\">container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">&#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>promise可以想成是一个初始值；通过Bacon.js，我们可以对初始值惰性地等待。</p>\n<h2 id=\"把它们搁到一块\"><a href=\"#把它们搁到一块\" class=\"headerlink\" title=\"把它们搁到一块\"></a>把它们搁到一块</h2><p>现在我们学完了响应式的内容，最后我们可以用些代码来玩一玩它。</p>\n<p>我们可以通过对纯函数的链式调用改变订阅者来做些事情，比如求和或者过滤不想要的结果， 我们只需通过我们所创建的对按钮的onclick()处理函数来完成这些。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在函数外创建事件流</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> eventStream = Bacon.onPromise(jQuery.ajax(url));</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscribe = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.server.com/election-data?format=json'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 未被改变的订阅者</span></span><br><span class=\"line\">$(<span class=\"string\">'button#showAll'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newRegions = getRegions(data).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Region(r.name, r.percent, r.parties);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 显示全部选举情况的按钮</span></span><br><span class=\"line\">$(<span class=\"string\">'button#showTotal'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> emptyRegion = <span class=\"keyword\">new</span> Region(<span class=\"string\">'empty'</span>, <span class=\"number\">0</span>, [&#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Republican'</span>,</span><br><span class=\"line\">    votes: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;, &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Democrat'</span>,</span><br><span class=\"line\">    votes: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;]);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> totalRegions = getRegions(data).reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r1, r2</span>) </span>&#123;</span><br><span class=\"line\">    newParties = r1.parties.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, i</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        name: r1.parties[i].name,</span><br><span class=\"line\">        votes: r1.parties[i].votes + r2.parties[i].votes</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    newRegion = <span class=\"keyword\">new</span> Region(<span class=\"string\">'Total'</span>, (r1.percent + r2.percent) / <span class=\"number\">2</span>,</span><br><span class=\"line\">      newParties);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> newRegion;</span><br><span class=\"line\">  &#125;, emptyRegion);</span><br><span class=\"line\">  container.innerHTML = totalRegions.render();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 只显示报告大于50%的选区</span></span><br><span class=\"line\">$(<span class=\"string\">'button#showMostlyReported'</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> subscriber = eventStream.onValue(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newRegions = getRegions(data).map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (r.percent &gt; <span class=\"number\">50</span>) <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;).filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r != <span class=\"literal\">null</span>;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  container.innerHTML = newRegions.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">r</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> r.render();</span><br><span class=\"line\">  &#125;).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>它的美丽之处在于：当用户点击按钮时，事件流并没有变化，但是订阅者变化了，这就使所有的工作很平顺。</p>\n"},{"title":"函数组合-JS函数式编程","date":"2016-05-21T16:46:16.000Z","_content":"\n> Experience is the mother of wisdom.\n\n# 函数组合\n> 在函数式编程中，我们希望一些都是函数，尤其希望是一元函数，如果可能的话。如果可以把多有的函数转换为一元函数，将发生神奇的事情。\n\n 一元函数是只接受单个输入的函数。函数如果有多个输入就是多元的，不过我们一般把接受两个输入的叫二元函数，把接受三个输入的叫三元函数。有的函数接受的输入的数量并不确定，我们称它为可变的\n\n> 操作函数及其可接受数量的输入可以极富表达力。在这一节，我们将探索如何把小的函数组合成新的函数：小的单元逻辑组合成的整个程序比这些函数本身之和还要大。\n\n## 组合\n组合函数使我们能够从简单的、通用的函数建立复杂的函数。通过把函数作为其它函数的构建单元，我们可以建立真正模块化的应用，使其具有很棒的可读性和维护性。\n\n在我们定义compose()这个补充函数之前，我们先通过下面的例子看看她是怎么工作的：\n\n```javascript\n  var roundedSqrt = Math.round.compose(Math.sqrt);\n  console.log(roundedSqrt(5)); //Returns:2\n  var squaredDate = roundedSqrt.compose(Date.parse)\n  console.log(squaredDate(\"January 1, 2014\")); //Returns: 1178370\n```\n\n在函数里，函数f和g的组合定义为f(g(x)).在javascript里，可以写成这样：\n\n```javascript\n  var compose = function(f,g){\n    return function(x){\n      return f(g(x));\n    }\n  }\n```\n\n```\n  compose = (f,g) -> (x) -> f g x\n```\n\n不过如果就写成这样的话，我们就失去了对this的跟踪。解决方法是使用call()和apply()。与柯里化相比，compose()这个补充函数相当简单：\n\n```javascript\n  Function.prototype.compose = function(prevFunc){\n    var nextFunc = this;\n    return function(){\n      return nextFunc.call(this,prevFunc.apply(this,arguments));\n    }\n  }\n```\n\n为了展示他怎么用，来建个完整的例子，如下：\n\n```javascript\n  function function1(a){ return a + '1'}\n  function function2(b){ return b + '1'}\n  function function3(c){ return c + '1'}\n  var composition = function3.compose(function2).compose(function1);\n  console.log(composition('count'));\n```\n\n你是否注意到function1函数最先被应用？这很重要，函数是从右往左应用的。\n\n```\n  原文是“Did you notice that the function3 parameter was applied first?”。 意思应该是function3参数最先被应用，这个应该是作者弄错了，显然是funtion1最先被应用， 返回了“count 1”，而且这样顺序也是从右往左的。\n```\n\n## 序列--反向组合\n由于很多人喜欢从左往右读东西，让函数也从左往右可以更通顺些。我们把这叫做序列而不是组合。为了让顺序相反，我们需要交换nextFunc和prevFunc参数。\n\n```javascript\n  Function.prototype.sequence = function(prevFunc){\n    var nextFunc = this;\n    return function(){\n      return prevFunc.call(this,nextFunc.apply(this,arguments));\n    }\n  }\n```\n\n现在可以用更加自然的顺序调用这些函数\n\n```javascript\n  var sequences = function1.sequence(function2).sequence(function3);\n  console.log(sequences('count')); //returns 'count 1 2 3'\n```\n\n## 组合 vs. 链\n下面是五种实现floorSqrt()函数组合的方式。它们看起来差不多，但是需要仔细观察。\n\n```javascript\n  function floorSqrt1(num){\n    var sqrtNum = Math.sqrt(num);\n    var floorSqrt = Math.floor(sqrtNum);\n    var stringNum = String(floorSqrt);\n    return stringNum;\n  }\n  function floorSqrt2(num){\n    return String(Math.floor(Math.sqrt(num)));\n  }\n  function floorSqrt3(num){\n    return [num].map(Math.sqrt).map(Math.floor).toString();\n  }\n  var floorSqrt4 = String.compose(Math.floor).compose(Math.sqrt);\n  var floorSqrt5 = Math.sqrt.sequence(Math.floor).sequence(String);\n  //所有的函数都可以这样调用\n  floorSqrt <N>(17); //Return:4\n```\n\n这里有些关键的区别需要仔细看：\n- 第一种方法很明显冗长且低效。\n- 第二种方法是个不错的一行代码，但是这种方式只要有几个函数应用就会变得可读性很差。\n- 我们说代码越少越好其实没说到点上。代码在有效指令越简洁的时候可维护性越好。如果你减少屏幕上的字符数量却没有改变有效指令的实现，这只能得到相反的效果 -- 代码难以理解，并且真的更难维护了。比如，当我们使用嵌套在一起的三目运算符时，我们就把许多指令放到了一行里面。这种方式减少了屏幕上的代码总量，但是这并没有减少代码实际的具体步骤。所以其效果就是模糊不清难以理解。让代码易于维护的那种简洁是有效减少具体指令（比如使用更简单的算法靠更少和/或更简单的步骤完成同样的结果），或者只是简单地把代码替换为消息，比如调用一个具有良好文档的API的库。\n- 第三种方式是一个数组函数的链，尤其是map函数。他工作很好，但并非数学正确的。\n- 第四个使我们compose()函数的实际应用。所有的方法被强制为一元的，鼓励使用更好、更简单、更小函数的纯函数只做一件事情，并且做的很好。\n- 最后一种实现使用compose()函数相反的顺序，同样有效。\n\n## 使用组合来编程\n组合最重要的一个方面是，除了应用的第一个函数以外，他们使用纯函数、只接受一个参数的一元函数效果最好。 执行的第一个函数的输出传递给第二个函数。也就是函数必须接受前一个函数所传给它的东西。类型签名对其有重要作用。\n\n```\n  类型签名用于明确地声明函数接受的输入类型是什么以及输出类型是什么。它首先被Haskell使用，实际上Haskell在函数定义时使用它们是为了编译器使用它们。但是，在javascript里，我们只能把个性签名放在代码注释里。它们看起来是这样：foo::arg1 -> argN -> output\n  例如：\n  // getStringLength :: String -> Int\n  function getStringLength(s){return s.length};\n  // concatDates :: Date -> Date -> [Date]\n  function concatDates(d1,d2){return [d1, d2]};\n  // pureFunc :: (int -> Bool) -> [int] -> [int]\n  pureFunc(func, arr){return arr.filter(func)}\n```\n\n为了能真正尝到组合的甜头，所有应用都需要一个由一元纯函数组成的强大的集合。它们是更大的函数的结构单元，这些大的函数使应用非常模块化、可靠、易维护 来看个例子。首先，我们需要许多结构单元函数。它们中的一些需要依赖于其他函数：\n\n```javascript\n  //stringToArray :: String -> [Char]\n  function stringToArray(s){\n    return s.split('');\n  }\n  //arrayToString:: [Char] -> String\n  function a.join('');\n  //nextChar :: Char -> Char\n  function nextChar(c){\n    return String.fromCharCode(c.charCodeAt(0) + 1);\n  }\n  //previousChar :: Char -> Char\n  function previousChar(c){\n    return String.fromCharCode(c.charCodeAt(0) - 1);\n  }\n  //higherColorHex :: Char -> Char\n  function higherColorHex(c){\n    return c >= 'f' ? 'f' : c == '9' ? 'a' : nextChar(c)\n  }\n  // lowerColorHex :: Char -> Char\n  function lowerColorHex(c) {\n    return c <= '0' ? '0' :\n      c == 'a' ? '9' :\n      previousChar(c);\n  }\n  // raiseColorHexes :: String -> String\n  function raiseColorHexes(arr) {\n    return arr.map(higherColorHex);\n  }\n  // lowerColorHexes :: String -> String\n  function lowerColorHexes(arr) {\n    return arr.map(lowerColorHex);\n  }\n```\n\n现在来把它们组合在一起\n\n```javascript\n  var lighterColor = arrayToString\n  .compose(raiseColorHexes)\n  .compose(stringToArray)\n  var darkerColor = arrayToString\n  .compose(lowerColorHexes)\n  .compose(stringToArray)\n  console.log(lighterColor('af0189')); // Returns: 'bf129a'\n  console.log(darkerColor('af0189')); // Returns: '9e0078'\n```\n\n我们甚至可以混合使用compse()和curry()。实际上，它们一起工作得很好。我们来借助组合的例子来打造珂理化的例子。 首先我们需要一些前面的辅助函数。\n\n```javascript\n  //compose2hex :: Ints -> String\n  function componentToHex(c){\n    var hex = c.toString(16);\n    return hex.length == 1 ? '0'+hex : hex;\n  }\n  //nums2hex :: Ints* -> String\n  function nums2hex(){\n    return Array.prototype.map.call(arguments,componentToHex).join('');\n  }\n```\n\n首先我们需要建立柯里化和部分应用的函数，然后把它们组合成其它组合函数。\n\n```javascript\nvar lighterColors = lighterColor\n  .compose(nums2hex.curry());\nvar darkerRed = darkerColor\n  .compose(nums2hex.partialApply(255));\nvar lighterRgb2hex = lighterColor\n  .compose(nums2hex.partialApply());\nconsole.log(lighterColors(123, 0, 22)); // Returns: 8cff11 [原书代码错误，实际返回是8c]\nconsole.log(darkerRed(123, 0)); // Returns: ee6a00\nconsole.log(lighterRgb2hex(123,200,100)); // Returns: 8cd975\n```\n\n我们完成了！这些函数易读且直观。我们被迫从只做一件事的小函数开始，然后就能够把函数放在一起形成更多功能。\n\n我们来看最后一个例子。先有个函数根据一个可变的值来减淡RBG值，然后我们用组合根据它创建一个新函数。\n\n```javascript\n// lighterColorNumSteps :: string -> num -> string\nfunction lighterColorNumSteps(color, n) {\nfor (var i = 0; i < n; i++) {\n  color = lighterColor(color);\n}\nreturn color;\n}\n// 现在我们可以这样建立函数:\nvar lighterRedNumSteps =\nlighterColorNumSteps.curry().compose(reds)(0, 0);\n// 然后这样使用:\nconsole.log(lighterRedNumSteps(5)); // Return: 'ff5555'\nconsole.log(lighterRedNumSteps(2)); // Return: 'ff2222'\n```\n\n用同样的方式，我们可以轻松地创建更多的函数来建立更淡或更深的蓝色、绿色、灰色、紫色等等你所想要的。 这是建立API的一个极好的方式。\n\n我们仅仅接触了函数组合能做的事情的一个表面。组合所做的是让控制脱离Javascript。一般Javascript是从左到右求值， 但是现在解释器会说\"OK，有人来管它了，我来处理别的东西。\"现在compose()函数控制了求值顺序！\n\n这就是Lazy.js和Bacon.js等是如何能够实现惰性求值和无限序列这些东西的。下面我们会看看这些库怎么用。\n","source":"_posts/函数组合-JS函数式编程.md","raw":"---\ntitle: 函数组合-JS函数式编程\ndate: 2016-05-22T00:46:16.000Z\ntags:\n  - javascript\n  - 函数式编程\ncategories: 转载笔记\n---\n\n> Experience is the mother of wisdom.\n\n# 函数组合\n> 在函数式编程中，我们希望一些都是函数，尤其希望是一元函数，如果可能的话。如果可以把多有的函数转换为一元函数，将发生神奇的事情。\n\n 一元函数是只接受单个输入的函数。函数如果有多个输入就是多元的，不过我们一般把接受两个输入的叫二元函数，把接受三个输入的叫三元函数。有的函数接受的输入的数量并不确定，我们称它为可变的\n\n> 操作函数及其可接受数量的输入可以极富表达力。在这一节，我们将探索如何把小的函数组合成新的函数：小的单元逻辑组合成的整个程序比这些函数本身之和还要大。\n\n## 组合\n组合函数使我们能够从简单的、通用的函数建立复杂的函数。通过把函数作为其它函数的构建单元，我们可以建立真正模块化的应用，使其具有很棒的可读性和维护性。\n\n在我们定义compose()这个补充函数之前，我们先通过下面的例子看看她是怎么工作的：\n\n```javascript\n  var roundedSqrt = Math.round.compose(Math.sqrt);\n  console.log(roundedSqrt(5)); //Returns:2\n  var squaredDate = roundedSqrt.compose(Date.parse)\n  console.log(squaredDate(\"January 1, 2014\")); //Returns: 1178370\n```\n\n在函数里，函数f和g的组合定义为f(g(x)).在javascript里，可以写成这样：\n\n```javascript\n  var compose = function(f,g){\n    return function(x){\n      return f(g(x));\n    }\n  }\n```\n\n```\n  compose = (f,g) -> (x) -> f g x\n```\n\n不过如果就写成这样的话，我们就失去了对this的跟踪。解决方法是使用call()和apply()。与柯里化相比，compose()这个补充函数相当简单：\n\n```javascript\n  Function.prototype.compose = function(prevFunc){\n    var nextFunc = this;\n    return function(){\n      return nextFunc.call(this,prevFunc.apply(this,arguments));\n    }\n  }\n```\n\n为了展示他怎么用，来建个完整的例子，如下：\n\n```javascript\n  function function1(a){ return a + '1'}\n  function function2(b){ return b + '1'}\n  function function3(c){ return c + '1'}\n  var composition = function3.compose(function2).compose(function1);\n  console.log(composition('count'));\n```\n\n你是否注意到function1函数最先被应用？这很重要，函数是从右往左应用的。\n\n```\n  原文是“Did you notice that the function3 parameter was applied first?”。 意思应该是function3参数最先被应用，这个应该是作者弄错了，显然是funtion1最先被应用， 返回了“count 1”，而且这样顺序也是从右往左的。\n```\n\n## 序列--反向组合\n由于很多人喜欢从左往右读东西，让函数也从左往右可以更通顺些。我们把这叫做序列而不是组合。为了让顺序相反，我们需要交换nextFunc和prevFunc参数。\n\n```javascript\n  Function.prototype.sequence = function(prevFunc){\n    var nextFunc = this;\n    return function(){\n      return prevFunc.call(this,nextFunc.apply(this,arguments));\n    }\n  }\n```\n\n现在可以用更加自然的顺序调用这些函数\n\n```javascript\n  var sequences = function1.sequence(function2).sequence(function3);\n  console.log(sequences('count')); //returns 'count 1 2 3'\n```\n\n## 组合 vs. 链\n下面是五种实现floorSqrt()函数组合的方式。它们看起来差不多，但是需要仔细观察。\n\n```javascript\n  function floorSqrt1(num){\n    var sqrtNum = Math.sqrt(num);\n    var floorSqrt = Math.floor(sqrtNum);\n    var stringNum = String(floorSqrt);\n    return stringNum;\n  }\n  function floorSqrt2(num){\n    return String(Math.floor(Math.sqrt(num)));\n  }\n  function floorSqrt3(num){\n    return [num].map(Math.sqrt).map(Math.floor).toString();\n  }\n  var floorSqrt4 = String.compose(Math.floor).compose(Math.sqrt);\n  var floorSqrt5 = Math.sqrt.sequence(Math.floor).sequence(String);\n  //所有的函数都可以这样调用\n  floorSqrt <N>(17); //Return:4\n```\n\n这里有些关键的区别需要仔细看：\n- 第一种方法很明显冗长且低效。\n- 第二种方法是个不错的一行代码，但是这种方式只要有几个函数应用就会变得可读性很差。\n- 我们说代码越少越好其实没说到点上。代码在有效指令越简洁的时候可维护性越好。如果你减少屏幕上的字符数量却没有改变有效指令的实现，这只能得到相反的效果 -- 代码难以理解，并且真的更难维护了。比如，当我们使用嵌套在一起的三目运算符时，我们就把许多指令放到了一行里面。这种方式减少了屏幕上的代码总量，但是这并没有减少代码实际的具体步骤。所以其效果就是模糊不清难以理解。让代码易于维护的那种简洁是有效减少具体指令（比如使用更简单的算法靠更少和/或更简单的步骤完成同样的结果），或者只是简单地把代码替换为消息，比如调用一个具有良好文档的API的库。\n- 第三种方式是一个数组函数的链，尤其是map函数。他工作很好，但并非数学正确的。\n- 第四个使我们compose()函数的实际应用。所有的方法被强制为一元的，鼓励使用更好、更简单、更小函数的纯函数只做一件事情，并且做的很好。\n- 最后一种实现使用compose()函数相反的顺序，同样有效。\n\n## 使用组合来编程\n组合最重要的一个方面是，除了应用的第一个函数以外，他们使用纯函数、只接受一个参数的一元函数效果最好。 执行的第一个函数的输出传递给第二个函数。也就是函数必须接受前一个函数所传给它的东西。类型签名对其有重要作用。\n\n```\n  类型签名用于明确地声明函数接受的输入类型是什么以及输出类型是什么。它首先被Haskell使用，实际上Haskell在函数定义时使用它们是为了编译器使用它们。但是，在javascript里，我们只能把个性签名放在代码注释里。它们看起来是这样：foo::arg1 -> argN -> output\n  例如：\n  // getStringLength :: String -> Int\n  function getStringLength(s){return s.length};\n  // concatDates :: Date -> Date -> [Date]\n  function concatDates(d1,d2){return [d1, d2]};\n  // pureFunc :: (int -> Bool) -> [int] -> [int]\n  pureFunc(func, arr){return arr.filter(func)}\n```\n\n为了能真正尝到组合的甜头，所有应用都需要一个由一元纯函数组成的强大的集合。它们是更大的函数的结构单元，这些大的函数使应用非常模块化、可靠、易维护 来看个例子。首先，我们需要许多结构单元函数。它们中的一些需要依赖于其他函数：\n\n```javascript\n  //stringToArray :: String -> [Char]\n  function stringToArray(s){\n    return s.split('');\n  }\n  //arrayToString:: [Char] -> String\n  function a.join('');\n  //nextChar :: Char -> Char\n  function nextChar(c){\n    return String.fromCharCode(c.charCodeAt(0) + 1);\n  }\n  //previousChar :: Char -> Char\n  function previousChar(c){\n    return String.fromCharCode(c.charCodeAt(0) - 1);\n  }\n  //higherColorHex :: Char -> Char\n  function higherColorHex(c){\n    return c >= 'f' ? 'f' : c == '9' ? 'a' : nextChar(c)\n  }\n  // lowerColorHex :: Char -> Char\n  function lowerColorHex(c) {\n    return c <= '0' ? '0' :\n      c == 'a' ? '9' :\n      previousChar(c);\n  }\n  // raiseColorHexes :: String -> String\n  function raiseColorHexes(arr) {\n    return arr.map(higherColorHex);\n  }\n  // lowerColorHexes :: String -> String\n  function lowerColorHexes(arr) {\n    return arr.map(lowerColorHex);\n  }\n```\n\n现在来把它们组合在一起\n\n```javascript\n  var lighterColor = arrayToString\n  .compose(raiseColorHexes)\n  .compose(stringToArray)\n  var darkerColor = arrayToString\n  .compose(lowerColorHexes)\n  .compose(stringToArray)\n  console.log(lighterColor('af0189')); // Returns: 'bf129a'\n  console.log(darkerColor('af0189')); // Returns: '9e0078'\n```\n\n我们甚至可以混合使用compse()和curry()。实际上，它们一起工作得很好。我们来借助组合的例子来打造珂理化的例子。 首先我们需要一些前面的辅助函数。\n\n```javascript\n  //compose2hex :: Ints -> String\n  function componentToHex(c){\n    var hex = c.toString(16);\n    return hex.length == 1 ? '0'+hex : hex;\n  }\n  //nums2hex :: Ints* -> String\n  function nums2hex(){\n    return Array.prototype.map.call(arguments,componentToHex).join('');\n  }\n```\n\n首先我们需要建立柯里化和部分应用的函数，然后把它们组合成其它组合函数。\n\n```javascript\nvar lighterColors = lighterColor\n  .compose(nums2hex.curry());\nvar darkerRed = darkerColor\n  .compose(nums2hex.partialApply(255));\nvar lighterRgb2hex = lighterColor\n  .compose(nums2hex.partialApply());\nconsole.log(lighterColors(123, 0, 22)); // Returns: 8cff11 [原书代码错误，实际返回是8c]\nconsole.log(darkerRed(123, 0)); // Returns: ee6a00\nconsole.log(lighterRgb2hex(123,200,100)); // Returns: 8cd975\n```\n\n我们完成了！这些函数易读且直观。我们被迫从只做一件事的小函数开始，然后就能够把函数放在一起形成更多功能。\n\n我们来看最后一个例子。先有个函数根据一个可变的值来减淡RBG值，然后我们用组合根据它创建一个新函数。\n\n```javascript\n// lighterColorNumSteps :: string -> num -> string\nfunction lighterColorNumSteps(color, n) {\nfor (var i = 0; i < n; i++) {\n  color = lighterColor(color);\n}\nreturn color;\n}\n// 现在我们可以这样建立函数:\nvar lighterRedNumSteps =\nlighterColorNumSteps.curry().compose(reds)(0, 0);\n// 然后这样使用:\nconsole.log(lighterRedNumSteps(5)); // Return: 'ff5555'\nconsole.log(lighterRedNumSteps(2)); // Return: 'ff2222'\n```\n\n用同样的方式，我们可以轻松地创建更多的函数来建立更淡或更深的蓝色、绿色、灰色、紫色等等你所想要的。 这是建立API的一个极好的方式。\n\n我们仅仅接触了函数组合能做的事情的一个表面。组合所做的是让控制脱离Javascript。一般Javascript是从左到右求值， 但是现在解释器会说\"OK，有人来管它了，我来处理别的东西。\"现在compose()函数控制了求值顺序！\n\n这就是Lazy.js和Bacon.js等是如何能够实现惰性求值和无限序列这些东西的。下面我们会看看这些库怎么用。\n","slug":"函数组合-JS函数式编程","published":1,"updated":"2016-05-23T01:26:51.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enj001ub0dl3uk3dzek","content":"<blockquote>\n<p>Experience is the mother of wisdom.</p>\n</blockquote>\n<h1 id=\"函数组合\"><a href=\"#函数组合\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h1><blockquote>\n<p>在函数式编程中，我们希望一些都是函数，尤其希望是一元函数，如果可能的话。如果可以把多有的函数转换为一元函数，将发生神奇的事情。</p>\n</blockquote>\n<p> 一元函数是只接受单个输入的函数。函数如果有多个输入就是多元的，不过我们一般把接受两个输入的叫二元函数，把接受三个输入的叫三元函数。有的函数接受的输入的数量并不确定，我们称它为可变的</p>\n<blockquote>\n<p>操作函数及其可接受数量的输入可以极富表达力。在这一节，我们将探索如何把小的函数组合成新的函数：小的单元逻辑组合成的整个程序比这些函数本身之和还要大。</p>\n</blockquote>\n<h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><p>组合函数使我们能够从简单的、通用的函数建立复杂的函数。通过把函数作为其它函数的构建单元，我们可以建立真正模块化的应用，使其具有很棒的可读性和维护性。</p>\n<p>在我们定义compose()这个补充函数之前，我们先通过下面的例子看看她是怎么工作的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> roundedSqrt = <span class=\"built_in\">Math</span>.round.compose(<span class=\"built_in\">Math</span>.sqrt);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(roundedSqrt(<span class=\"number\">5</span>)); <span class=\"comment\">//Returns:2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> squaredDate = roundedSqrt.compose(<span class=\"built_in\">Date</span>.parse)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(squaredDate(<span class=\"string\">\"January 1, 2014\"</span>)); <span class=\"comment\">//Returns: 1178370</span></span><br></pre></td></tr></table></figure>\n<p>在函数里，函数f和g的组合定义为f(g(x)).在javascript里，可以写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose = (f,g) -&gt; (x) -&gt; f g x</span><br></pre></td></tr></table></figure>\n<p>不过如果就写成这样的话，我们就失去了对this的跟踪。解决方法是使用call()和apply()。与柯里化相比，compose()这个补充函数相当简单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevFunc</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nextFunc = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextFunc.call(<span class=\"keyword\">this</span>,prevFunc.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了展示他怎么用，来建个完整的例子，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function1</span>(<span class=\"params\">a</span>)</span>&#123; <span class=\"keyword\">return</span> a + <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function2</span>(<span class=\"params\">b</span>)</span>&#123; <span class=\"keyword\">return</span> b + <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function3</span>(<span class=\"params\">c</span>)</span>&#123; <span class=\"keyword\">return</span> c + <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> composition = function3.compose(function2).compose(function1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(composition(<span class=\"string\">'count'</span>));</span><br></pre></td></tr></table></figure>\n<p>你是否注意到function1函数最先被应用？这很重要，函数是从右往左应用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原文是“Did you notice that the function3 parameter was applied first?”。 意思应该是function3参数最先被应用，这个应该是作者弄错了，显然是funtion1最先被应用， 返回了“count 1”，而且这样顺序也是从右往左的。</span><br></pre></td></tr></table></figure>\n<h2 id=\"序列–反向组合\"><a href=\"#序列–反向组合\" class=\"headerlink\" title=\"序列–反向组合\"></a>序列–反向组合</h2><p>由于很多人喜欢从左往右读东西，让函数也从左往右可以更通顺些。我们把这叫做序列而不是组合。为了让顺序相反，我们需要交换nextFunc和prevFunc参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.sequence = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevFunc</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nextFunc = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prevFunc.call(<span class=\"keyword\">this</span>,nextFunc.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在可以用更加自然的顺序调用这些函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sequences = function1.sequence(function2).sequence(function3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sequences(<span class=\"string\">'count'</span>)); <span class=\"comment\">//returns 'count 1 2 3'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"组合-vs-链\"><a href=\"#组合-vs-链\" class=\"headerlink\" title=\"组合 vs. 链\"></a>组合 vs. 链</h2><p>下面是五种实现floorSqrt()函数组合的方式。它们看起来差不多，但是需要仔细观察。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">floorSqrt1</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sqrtNum = <span class=\"built_in\">Math</span>.sqrt(num);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> floorSqrt = <span class=\"built_in\">Math</span>.floor(sqrtNum);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stringNum = <span class=\"built_in\">String</span>(floorSqrt);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stringNum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">floorSqrt2</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>(<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.sqrt(num)));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">floorSqrt3</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [num].map(<span class=\"built_in\">Math</span>.sqrt).map(<span class=\"built_in\">Math</span>.floor).toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> floorSqrt4 = <span class=\"built_in\">String</span>.compose(<span class=\"built_in\">Math</span>.floor).compose(<span class=\"built_in\">Math</span>.sqrt);</span><br><span class=\"line\"><span class=\"keyword\">var</span> floorSqrt5 = <span class=\"built_in\">Math</span>.sqrt.sequence(<span class=\"built_in\">Math</span>.floor).sequence(<span class=\"built_in\">String</span>);</span><br><span class=\"line\"><span class=\"comment\">//所有的函数都可以这样调用</span></span><br><span class=\"line\">floorSqrt &lt;N&gt;(<span class=\"number\">17</span>); <span class=\"comment\">//Return:4</span></span><br></pre></td></tr></table></figure>\n<p>这里有些关键的区别需要仔细看：</p>\n<ul>\n<li>第一种方法很明显冗长且低效。</li>\n<li>第二种方法是个不错的一行代码，但是这种方式只要有几个函数应用就会变得可读性很差。</li>\n<li>我们说代码越少越好其实没说到点上。代码在有效指令越简洁的时候可维护性越好。如果你减少屏幕上的字符数量却没有改变有效指令的实现，这只能得到相反的效果 – 代码难以理解，并且真的更难维护了。比如，当我们使用嵌套在一起的三目运算符时，我们就把许多指令放到了一行里面。这种方式减少了屏幕上的代码总量，但是这并没有减少代码实际的具体步骤。所以其效果就是模糊不清难以理解。让代码易于维护的那种简洁是有效减少具体指令（比如使用更简单的算法靠更少和/或更简单的步骤完成同样的结果），或者只是简单地把代码替换为消息，比如调用一个具有良好文档的API的库。</li>\n<li>第三种方式是一个数组函数的链，尤其是map函数。他工作很好，但并非数学正确的。</li>\n<li>第四个使我们compose()函数的实际应用。所有的方法被强制为一元的，鼓励使用更好、更简单、更小函数的纯函数只做一件事情，并且做的很好。</li>\n<li>最后一种实现使用compose()函数相反的顺序，同样有效。</li>\n</ul>\n<h2 id=\"使用组合来编程\"><a href=\"#使用组合来编程\" class=\"headerlink\" title=\"使用组合来编程\"></a>使用组合来编程</h2><p>组合最重要的一个方面是，除了应用的第一个函数以外，他们使用纯函数、只接受一个参数的一元函数效果最好。 执行的第一个函数的输出传递给第二个函数。也就是函数必须接受前一个函数所传给它的东西。类型签名对其有重要作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型签名用于明确地声明函数接受的输入类型是什么以及输出类型是什么。它首先被Haskell使用，实际上Haskell在函数定义时使用它们是为了编译器使用它们。但是，在javascript里，我们只能把个性签名放在代码注释里。它们看起来是这样：foo::arg1 -&gt; argN -&gt; output</span><br><span class=\"line\">例如：</span><br><span class=\"line\">// getStringLength :: String -&gt; Int</span><br><span class=\"line\">function getStringLength(s)&#123;return s.length&#125;;</span><br><span class=\"line\">// concatDates :: Date -&gt; Date -&gt; [Date]</span><br><span class=\"line\">function concatDates(d1,d2)&#123;return [d1, d2]&#125;;</span><br><span class=\"line\">// pureFunc :: (int -&gt; Bool) -&gt; [int] -&gt; [int]</span><br><span class=\"line\">pureFunc(func, arr)&#123;return arr.filter(func)&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能真正尝到组合的甜头，所有应用都需要一个由一元纯函数组成的强大的集合。它们是更大的函数的结构单元，这些大的函数使应用非常模块化、可靠、易维护 来看个例子。首先，我们需要许多结构单元函数。它们中的一些需要依赖于其他函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//stringToArray :: String -&gt; [Char]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringToArray</span>(<span class=\"params\">s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.split(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//arrayToString:: [Char] -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>.<span class=\"title\">join</span>(<span class=\"params\">''</span>);</span><br><span class=\"line\">//<span class=\"title\">nextChar</span> :: <span class=\"title\">Char</span> -&gt; <span class=\"title\">Char</span></span><br><span class=\"line\"><span class=\"title\">function</span> <span class=\"title\">nextChar</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(c.charCodeAt(<span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//previousChar :: Char -&gt; Char</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">previousChar</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(c.charCodeAt(<span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//higherColorHex :: Char -&gt; Char</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">higherColorHex</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c &gt;= <span class=\"string\">'f'</span> ? <span class=\"string\">'f'</span> : c == <span class=\"string\">'9'</span> ? <span class=\"string\">'a'</span> : nextChar(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lowerColorHex :: Char -&gt; Char</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lowerColorHex</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c &lt;= <span class=\"string\">'0'</span> ? <span class=\"string\">'0'</span> :</span><br><span class=\"line\">    c == <span class=\"string\">'a'</span> ? <span class=\"string\">'9'</span> :</span><br><span class=\"line\">    previousChar(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// raiseColorHexes :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">raiseColorHexes</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(higherColorHex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lowerColorHexes :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lowerColorHexes</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(lowerColorHex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在来把它们组合在一起</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lighterColor = arrayToString</span><br><span class=\"line\">.compose(raiseColorHexes)</span><br><span class=\"line\">.compose(stringToArray)</span><br><span class=\"line\"><span class=\"keyword\">var</span> darkerColor = arrayToString</span><br><span class=\"line\">.compose(lowerColorHexes)</span><br><span class=\"line\">.compose(stringToArray)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterColor(<span class=\"string\">'af0189'</span>)); <span class=\"comment\">// Returns: 'bf129a'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(darkerColor(<span class=\"string\">'af0189'</span>)); <span class=\"comment\">// Returns: '9e0078'</span></span><br></pre></td></tr></table></figure>\n<p>我们甚至可以混合使用compse()和curry()。实际上，它们一起工作得很好。我们来借助组合的例子来打造珂理化的例子。 首先我们需要一些前面的辅助函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//compose2hex :: Ints -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">componentToHex</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hex = c.toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hex.length == <span class=\"number\">1</span> ? <span class=\"string\">'0'</span>+hex : hex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//nums2hex :: Ints* -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nums2hex</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">arguments</span>,componentToHex).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们需要建立柯里化和部分应用的函数，然后把它们组合成其它组合函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lighterColors = lighterColor</span><br><span class=\"line\">  .compose(nums2hex.curry());</span><br><span class=\"line\"><span class=\"keyword\">var</span> darkerRed = darkerColor</span><br><span class=\"line\">  .compose(nums2hex.partialApply(<span class=\"number\">255</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> lighterRgb2hex = lighterColor</span><br><span class=\"line\">  .compose(nums2hex.partialApply());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterColors(<span class=\"number\">123</span>, <span class=\"number\">0</span>, <span class=\"number\">22</span>)); <span class=\"comment\">// Returns: 8cff11 [原书代码错误，实际返回是8c]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(darkerRed(<span class=\"number\">123</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// Returns: ee6a00</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterRgb2hex(<span class=\"number\">123</span>,<span class=\"number\">200</span>,<span class=\"number\">100</span>)); <span class=\"comment\">// Returns: 8cd975</span></span><br></pre></td></tr></table></figure>\n<p>我们完成了！这些函数易读且直观。我们被迫从只做一件事的小函数开始，然后就能够把函数放在一起形成更多功能。</p>\n<p>我们来看最后一个例子。先有个函数根据一个可变的值来减淡RBG值，然后我们用组合根据它创建一个新函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lighterColorNumSteps :: string -&gt; num -&gt; string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lighterColorNumSteps</span>(<span class=\"params\">color, n</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">  color = lighterColor(color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 现在我们可以这样建立函数:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lighterRedNumSteps =</span><br><span class=\"line\">lighterColorNumSteps.curry().compose(reds)(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 然后这样使用:</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterRedNumSteps(<span class=\"number\">5</span>)); <span class=\"comment\">// Return: 'ff5555'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterRedNumSteps(<span class=\"number\">2</span>)); <span class=\"comment\">// Return: 'ff2222'</span></span><br></pre></td></tr></table></figure>\n<p>用同样的方式，我们可以轻松地创建更多的函数来建立更淡或更深的蓝色、绿色、灰色、紫色等等你所想要的。 这是建立API的一个极好的方式。</p>\n<p>我们仅仅接触了函数组合能做的事情的一个表面。组合所做的是让控制脱离Javascript。一般Javascript是从左到右求值， 但是现在解释器会说”OK，有人来管它了，我来处理别的东西。”现在compose()函数控制了求值顺序！</p>\n<p>这就是Lazy.js和Bacon.js等是如何能够实现惰性求值和无限序列这些东西的。下面我们会看看这些库怎么用。</p>\n","excerpt":"","more":"<blockquote>\n<p>Experience is the mother of wisdom.</p>\n</blockquote>\n<h1 id=\"函数组合\"><a href=\"#函数组合\" class=\"headerlink\" title=\"函数组合\"></a>函数组合</h1><blockquote>\n<p>在函数式编程中，我们希望一些都是函数，尤其希望是一元函数，如果可能的话。如果可以把多有的函数转换为一元函数，将发生神奇的事情。</p>\n</blockquote>\n<p> 一元函数是只接受单个输入的函数。函数如果有多个输入就是多元的，不过我们一般把接受两个输入的叫二元函数，把接受三个输入的叫三元函数。有的函数接受的输入的数量并不确定，我们称它为可变的</p>\n<blockquote>\n<p>操作函数及其可接受数量的输入可以极富表达力。在这一节，我们将探索如何把小的函数组合成新的函数：小的单元逻辑组合成的整个程序比这些函数本身之和还要大。</p>\n</blockquote>\n<h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><p>组合函数使我们能够从简单的、通用的函数建立复杂的函数。通过把函数作为其它函数的构建单元，我们可以建立真正模块化的应用，使其具有很棒的可读性和维护性。</p>\n<p>在我们定义compose()这个补充函数之前，我们先通过下面的例子看看她是怎么工作的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> roundedSqrt = <span class=\"built_in\">Math</span>.round.compose(<span class=\"built_in\">Math</span>.sqrt);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(roundedSqrt(<span class=\"number\">5</span>)); <span class=\"comment\">//Returns:2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> squaredDate = roundedSqrt.compose(<span class=\"built_in\">Date</span>.parse)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(squaredDate(<span class=\"string\">\"January 1, 2014\"</span>)); <span class=\"comment\">//Returns: 1178370</span></span><br></pre></td></tr></table></figure>\n<p>在函数里，函数f和g的组合定义为f(g(x)).在javascript里，可以写成这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compose = (f,g) -&gt; (x) -&gt; f g x</span><br></pre></td></tr></table></figure>\n<p>不过如果就写成这样的话，我们就失去了对this的跟踪。解决方法是使用call()和apply()。与柯里化相比，compose()这个补充函数相当简单：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevFunc</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nextFunc = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> nextFunc.call(<span class=\"keyword\">this</span>,prevFunc.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>为了展示他怎么用，来建个完整的例子，如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function1</span>(<span class=\"params\">a</span>)</span>&#123; <span class=\"keyword\">return</span> a + <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function2</span>(<span class=\"params\">b</span>)</span>&#123; <span class=\"keyword\">return</span> b + <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">function3</span>(<span class=\"params\">c</span>)</span>&#123; <span class=\"keyword\">return</span> c + <span class=\"string\">'1'</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> composition = function3.compose(function2).compose(function1);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(composition(<span class=\"string\">'count'</span>));</span><br></pre></td></tr></table></figure>\n<p>你是否注意到function1函数最先被应用？这很重要，函数是从右往左应用的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">原文是“Did you notice that the function3 parameter was applied first?”。 意思应该是function3参数最先被应用，这个应该是作者弄错了，显然是funtion1最先被应用， 返回了“count 1”，而且这样顺序也是从右往左的。</span><br></pre></td></tr></table></figure>\n<h2 id=\"序列–反向组合\"><a href=\"#序列–反向组合\" class=\"headerlink\" title=\"序列–反向组合\"></a>序列–反向组合</h2><p>由于很多人喜欢从左往右读东西，让函数也从左往右可以更通顺些。我们把这叫做序列而不是组合。为了让顺序相反，我们需要交换nextFunc和prevFunc参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.sequence = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prevFunc</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> nextFunc = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> prevFunc.call(<span class=\"keyword\">this</span>,nextFunc.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在可以用更加自然的顺序调用这些函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sequences = function1.sequence(function2).sequence(function3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sequences(<span class=\"string\">'count'</span>)); <span class=\"comment\">//returns 'count 1 2 3'</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"组合-vs-链\"><a href=\"#组合-vs-链\" class=\"headerlink\" title=\"组合 vs. 链\"></a>组合 vs. 链</h2><p>下面是五种实现floorSqrt()函数组合的方式。它们看起来差不多，但是需要仔细观察。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">floorSqrt1</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sqrtNum = <span class=\"built_in\">Math</span>.sqrt(num);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> floorSqrt = <span class=\"built_in\">Math</span>.floor(sqrtNum);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> stringNum = <span class=\"built_in\">String</span>(floorSqrt);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stringNum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">floorSqrt2</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>(<span class=\"built_in\">Math</span>.floor(<span class=\"built_in\">Math</span>.sqrt(num)));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">floorSqrt3</span>(<span class=\"params\">num</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> [num].map(<span class=\"built_in\">Math</span>.sqrt).map(<span class=\"built_in\">Math</span>.floor).toString();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> floorSqrt4 = <span class=\"built_in\">String</span>.compose(<span class=\"built_in\">Math</span>.floor).compose(<span class=\"built_in\">Math</span>.sqrt);</span><br><span class=\"line\"><span class=\"keyword\">var</span> floorSqrt5 = <span class=\"built_in\">Math</span>.sqrt.sequence(<span class=\"built_in\">Math</span>.floor).sequence(<span class=\"built_in\">String</span>);</span><br><span class=\"line\"><span class=\"comment\">//所有的函数都可以这样调用</span></span><br><span class=\"line\">floorSqrt &lt;N&gt;(<span class=\"number\">17</span>); <span class=\"comment\">//Return:4</span></span><br></pre></td></tr></table></figure>\n<p>这里有些关键的区别需要仔细看：</p>\n<ul>\n<li>第一种方法很明显冗长且低效。</li>\n<li>第二种方法是个不错的一行代码，但是这种方式只要有几个函数应用就会变得可读性很差。</li>\n<li>我们说代码越少越好其实没说到点上。代码在有效指令越简洁的时候可维护性越好。如果你减少屏幕上的字符数量却没有改变有效指令的实现，这只能得到相反的效果 – 代码难以理解，并且真的更难维护了。比如，当我们使用嵌套在一起的三目运算符时，我们就把许多指令放到了一行里面。这种方式减少了屏幕上的代码总量，但是这并没有减少代码实际的具体步骤。所以其效果就是模糊不清难以理解。让代码易于维护的那种简洁是有效减少具体指令（比如使用更简单的算法靠更少和/或更简单的步骤完成同样的结果），或者只是简单地把代码替换为消息，比如调用一个具有良好文档的API的库。</li>\n<li>第三种方式是一个数组函数的链，尤其是map函数。他工作很好，但并非数学正确的。</li>\n<li>第四个使我们compose()函数的实际应用。所有的方法被强制为一元的，鼓励使用更好、更简单、更小函数的纯函数只做一件事情，并且做的很好。</li>\n<li>最后一种实现使用compose()函数相反的顺序，同样有效。</li>\n</ul>\n<h2 id=\"使用组合来编程\"><a href=\"#使用组合来编程\" class=\"headerlink\" title=\"使用组合来编程\"></a>使用组合来编程</h2><p>组合最重要的一个方面是，除了应用的第一个函数以外，他们使用纯函数、只接受一个参数的一元函数效果最好。 执行的第一个函数的输出传递给第二个函数。也就是函数必须接受前一个函数所传给它的东西。类型签名对其有重要作用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类型签名用于明确地声明函数接受的输入类型是什么以及输出类型是什么。它首先被Haskell使用，实际上Haskell在函数定义时使用它们是为了编译器使用它们。但是，在javascript里，我们只能把个性签名放在代码注释里。它们看起来是这样：foo::arg1 -&gt; argN -&gt; output</span><br><span class=\"line\">例如：</span><br><span class=\"line\">// getStringLength :: String -&gt; Int</span><br><span class=\"line\">function getStringLength(s)&#123;return s.length&#125;;</span><br><span class=\"line\">// concatDates :: Date -&gt; Date -&gt; [Date]</span><br><span class=\"line\">function concatDates(d1,d2)&#123;return [d1, d2]&#125;;</span><br><span class=\"line\">// pureFunc :: (int -&gt; Bool) -&gt; [int] -&gt; [int]</span><br><span class=\"line\">pureFunc(func, arr)&#123;return arr.filter(func)&#125;</span><br></pre></td></tr></table></figure>\n<p>为了能真正尝到组合的甜头，所有应用都需要一个由一元纯函数组成的强大的集合。它们是更大的函数的结构单元，这些大的函数使应用非常模块化、可靠、易维护 来看个例子。首先，我们需要许多结构单元函数。它们中的一些需要依赖于其他函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//stringToArray :: String -&gt; [Char]</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">stringToArray</span>(<span class=\"params\">s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> s.split(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//arrayToString:: [Char] -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>.<span class=\"title\">join</span>(<span class=\"params\">''</span>);</span><br><span class=\"line\">//<span class=\"title\">nextChar</span> :: <span class=\"title\">Char</span> -&gt; <span class=\"title\">Char</span></span><br><span class=\"line\"><span class=\"title\">function</span> <span class=\"title\">nextChar</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(c.charCodeAt(<span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//previousChar :: Char -&gt; Char</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">previousChar</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">String</span>.fromCharCode(c.charCodeAt(<span class=\"number\">0</span>) - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//higherColorHex :: Char -&gt; Char</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">higherColorHex</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c &gt;= <span class=\"string\">'f'</span> ? <span class=\"string\">'f'</span> : c == <span class=\"string\">'9'</span> ? <span class=\"string\">'a'</span> : nextChar(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lowerColorHex :: Char -&gt; Char</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lowerColorHex</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c &lt;= <span class=\"string\">'0'</span> ? <span class=\"string\">'0'</span> :</span><br><span class=\"line\">    c == <span class=\"string\">'a'</span> ? <span class=\"string\">'9'</span> :</span><br><span class=\"line\">    previousChar(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// raiseColorHexes :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">raiseColorHexes</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(higherColorHex);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// lowerColorHexes :: String -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lowerColorHexes</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.map(lowerColorHex);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在来把它们组合在一起</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lighterColor = arrayToString</span><br><span class=\"line\">.compose(raiseColorHexes)</span><br><span class=\"line\">.compose(stringToArray)</span><br><span class=\"line\"><span class=\"keyword\">var</span> darkerColor = arrayToString</span><br><span class=\"line\">.compose(lowerColorHexes)</span><br><span class=\"line\">.compose(stringToArray)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterColor(<span class=\"string\">'af0189'</span>)); <span class=\"comment\">// Returns: 'bf129a'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(darkerColor(<span class=\"string\">'af0189'</span>)); <span class=\"comment\">// Returns: '9e0078'</span></span><br></pre></td></tr></table></figure>\n<p>我们甚至可以混合使用compse()和curry()。实际上，它们一起工作得很好。我们来借助组合的例子来打造珂理化的例子。 首先我们需要一些前面的辅助函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//compose2hex :: Ints -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">componentToHex</span>(<span class=\"params\">c</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> hex = c.toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> hex.length == <span class=\"number\">1</span> ? <span class=\"string\">'0'</span>+hex : hex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//nums2hex :: Ints* -&gt; String</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nums2hex</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">arguments</span>,componentToHex).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先我们需要建立柯里化和部分应用的函数，然后把它们组合成其它组合函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> lighterColors = lighterColor</span><br><span class=\"line\">  .compose(nums2hex.curry());</span><br><span class=\"line\"><span class=\"keyword\">var</span> darkerRed = darkerColor</span><br><span class=\"line\">  .compose(nums2hex.partialApply(<span class=\"number\">255</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> lighterRgb2hex = lighterColor</span><br><span class=\"line\">  .compose(nums2hex.partialApply());</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterColors(<span class=\"number\">123</span>, <span class=\"number\">0</span>, <span class=\"number\">22</span>)); <span class=\"comment\">// Returns: 8cff11 [原书代码错误，实际返回是8c]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(darkerRed(<span class=\"number\">123</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// Returns: ee6a00</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterRgb2hex(<span class=\"number\">123</span>,<span class=\"number\">200</span>,<span class=\"number\">100</span>)); <span class=\"comment\">// Returns: 8cd975</span></span><br></pre></td></tr></table></figure>\n<p>我们完成了！这些函数易读且直观。我们被迫从只做一件事的小函数开始，然后就能够把函数放在一起形成更多功能。</p>\n<p>我们来看最后一个例子。先有个函数根据一个可变的值来减淡RBG值，然后我们用组合根据它创建一个新函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// lighterColorNumSteps :: string -&gt; num -&gt; string</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">lighterColorNumSteps</span>(<span class=\"params\">color, n</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">  color = lighterColor(color);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 现在我们可以这样建立函数:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> lighterRedNumSteps =</span><br><span class=\"line\">lighterColorNumSteps.curry().compose(reds)(<span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"comment\">// 然后这样使用:</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterRedNumSteps(<span class=\"number\">5</span>)); <span class=\"comment\">// Return: 'ff5555'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(lighterRedNumSteps(<span class=\"number\">2</span>)); <span class=\"comment\">// Return: 'ff2222'</span></span><br></pre></td></tr></table></figure>\n<p>用同样的方式，我们可以轻松地创建更多的函数来建立更淡或更深的蓝色、绿色、灰色、紫色等等你所想要的。 这是建立API的一个极好的方式。</p>\n<p>我们仅仅接触了函数组合能做的事情的一个表面。组合所做的是让控制脱离Javascript。一般Javascript是从左到右求值， 但是现在解释器会说”OK，有人来管它了，我来处理别的东西。”现在compose()函数控制了求值顺序！</p>\n<p>这就是Lazy.js和Bacon.js等是如何能够实现惰性求值和无限序列这些东西的。下面我们会看看这些库怎么用。</p>\n"},{"title":"模块系统","date":"2016-03-17T16:17:04.000Z","_content":"## 系统模块的演进\n模块系统主要解决模块的定义、依赖和导出，现已经存在的模块系统有如下几种。\n  \n### `<script>`标签\n```javascript\n    <script src=\"module1.js\"></script>\n    <script src=\"module2.js\"></script>\n    <script src=\"module3.js\"></script>\n```\n这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的接口调用都是一个作用域，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如YUI库。  \n\n这种原始的加载方式暴露了一些显而易见的弊端：  \n1. 全局 作用于下容易造成变量冲突  \n2. 文件只能按照`<script>`的书写顺序进行加载\n3. 开发人员必须主观解决模块和代码库的依赖关系\n4. 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪\n\n### CommonJS\n服务器端的Node.js遵循[CommonJS规范](http://wiki.commonjs.org/wiki/CommonJS)，该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口。\n```javascript\n    require(\"module\");  \n    require(\"../file.js\");  \n    exports.doSth = function(){};\n    module.exports = someThing;\n```\n优点：\n1. 服务器端模块便于重用\n2. NPM中已经有将近20万个可以使用的模块包\n3. 简单并容易使用\n\n缺点：\n1. 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的\n2. 不能非阻塞的并行加载多个模块\n\n实现：\n1. 服务器端的Node.js\n2. Browserify，浏览器端的CommonJS实现，可以使用NPM的模块，但是编译打包后的文件体积可能很大\n3. modules-webmake，类似Browserify，还不如Browserify灵活\n4. wreq，Browserify的前身\n\n### AMD\n[Asynchronous Module Definition](https://github.com/amdjs/amdjs-api) 规范其实只有一个主要的接口define(id?,dependencies?,factory)，它要在声明模块的时候指定所有的依赖dependences，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置。\n```javascript\n    define(\"module\",[\"dep1\".\"dep2\"],function(d1,d2){\n        return someThing;\n    });\n    require([\"module\",\"../files\"],function(module,file){\n        doSomething();\n    })\n```\n优点：\n1. 适合在浏览器环境中异步加载模块\n2. 可以并行加载多个模块\n\n缺点：\n1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅\n2. 不符合通用的模块化思维方式，是一种妥协的实现\n\n实现：\n- [RequireJS](http://requirejs.org/)\n- [curl](https://github.com/cujojs/curl)\n\n### CMD\n[Common Module Definition](https://github.com/cmdjs/specification/blob/master/draft/module.md)规范和AMD很相似，尽量保持简单，并与ComminJS和Node.js的Modules规范保持了很大的兼容性。  \n```javascript\n    define(function(require,exports,module){\n        var $ = require(\"jquery\");\n        exports.doSomething = ...\n        module.exports = ...\n    })\n```\n优点：\n1. 依赖就近，延迟执行\n2. 可以很容易在Nod.js中执行\n\n缺点：\n1. 依赖SPM打包，模块的加载逻辑偏重\n\n实现：\n- [Sea.js](http://seajs.org/)\n- [coolie](https://github.com/cloudcome/coolie)\n\n### UMD\n[Universal Module Definition](https://github.com/umdjs/umd) 规范类似于兼容 CommonJS 和 AMD的语法糖，是模块定义的跨平台解决方案。\n\n### ES6模块\nEcmaScript6 标准增加了JavaScript语言层面的模块体系定义。[ES6模块](http://es6.ruanyifeng.com/#docs/module)的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD都只能在运行时确认这些东西。\n```javascript\n    import \"jquery\";\n    export function doStuff(){}\n    module \"localModule\" {}\n```\n优点：\n1. 容易进行静态分析\n2. 面向未来的EcmaScript标准\n\n缺点：\n1. 原生浏览器端还没有实现该标准\n2. 全新的命令字，新版的Node.js才支持\n\n实现：\n- [Babel](https://babeljs.io/)\n\n### 期望的模块系统\n可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅是Javascript模块化，还有CSS、图片、字体等资源也需要模块化。\n\n## 前端模块加载\n前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。  \n模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。  \n***分块传输***，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。  \n要实现模块的按需加载，就需要一个对整个代码库的模块进行静态分析、编译打包的过程。\n\n## 所有资源都是模块\n在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。\n\n如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：\n```javascript\n    require(\"./style.css\");\n    require(\"./style.less\");\n    require(\"./template.jade\");\n    require(\"./image.png\");\n```\n\n## 静态分析\n在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的记载其来处理。比如一个用LESS写的样式模块，可以先用LESS加载器将它转成一个CSS模块，再通过CSS模块把他插入到页面的<script>标签中执行。Webpack就是这样的需求中应运而生。\n同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。","source":"_posts/模块系统.md","raw":"---\ntitle: 模块系统\ndate: 2016-03-18 00:17:04\ntags:\n- webpack\n- 模块系统\ncategories: 教程\n---\n## 系统模块的演进\n模块系统主要解决模块的定义、依赖和导出，现已经存在的模块系统有如下几种。\n  \n### `<script>`标签\n```javascript\n    <script src=\"module1.js\"></script>\n    <script src=\"module2.js\"></script>\n    <script src=\"module3.js\"></script>\n```\n这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的接口调用都是一个作用域，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如YUI库。  \n\n这种原始的加载方式暴露了一些显而易见的弊端：  \n1. 全局 作用于下容易造成变量冲突  \n2. 文件只能按照`<script>`的书写顺序进行加载\n3. 开发人员必须主观解决模块和代码库的依赖关系\n4. 在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪\n\n### CommonJS\n服务器端的Node.js遵循[CommonJS规范](http://wiki.commonjs.org/wiki/CommonJS)，该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口。\n```javascript\n    require(\"module\");  \n    require(\"../file.js\");  \n    exports.doSth = function(){};\n    module.exports = someThing;\n```\n优点：\n1. 服务器端模块便于重用\n2. NPM中已经有将近20万个可以使用的模块包\n3. 简单并容易使用\n\n缺点：\n1. 同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的\n2. 不能非阻塞的并行加载多个模块\n\n实现：\n1. 服务器端的Node.js\n2. Browserify，浏览器端的CommonJS实现，可以使用NPM的模块，但是编译打包后的文件体积可能很大\n3. modules-webmake，类似Browserify，还不如Browserify灵活\n4. wreq，Browserify的前身\n\n### AMD\n[Asynchronous Module Definition](https://github.com/amdjs/amdjs-api) 规范其实只有一个主要的接口define(id?,dependencies?,factory)，它要在声明模块的时候指定所有的依赖dependences，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置。\n```javascript\n    define(\"module\",[\"dep1\".\"dep2\"],function(d1,d2){\n        return someThing;\n    });\n    require([\"module\",\"../files\"],function(module,file){\n        doSomething();\n    })\n```\n优点：\n1. 适合在浏览器环境中异步加载模块\n2. 可以并行加载多个模块\n\n缺点：\n1. 提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅\n2. 不符合通用的模块化思维方式，是一种妥协的实现\n\n实现：\n- [RequireJS](http://requirejs.org/)\n- [curl](https://github.com/cujojs/curl)\n\n### CMD\n[Common Module Definition](https://github.com/cmdjs/specification/blob/master/draft/module.md)规范和AMD很相似，尽量保持简单，并与ComminJS和Node.js的Modules规范保持了很大的兼容性。  \n```javascript\n    define(function(require,exports,module){\n        var $ = require(\"jquery\");\n        exports.doSomething = ...\n        module.exports = ...\n    })\n```\n优点：\n1. 依赖就近，延迟执行\n2. 可以很容易在Nod.js中执行\n\n缺点：\n1. 依赖SPM打包，模块的加载逻辑偏重\n\n实现：\n- [Sea.js](http://seajs.org/)\n- [coolie](https://github.com/cloudcome/coolie)\n\n### UMD\n[Universal Module Definition](https://github.com/umdjs/umd) 规范类似于兼容 CommonJS 和 AMD的语法糖，是模块定义的跨平台解决方案。\n\n### ES6模块\nEcmaScript6 标准增加了JavaScript语言层面的模块体系定义。[ES6模块](http://es6.ruanyifeng.com/#docs/module)的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD都只能在运行时确认这些东西。\n```javascript\n    import \"jquery\";\n    export function doStuff(){}\n    module \"localModule\" {}\n```\n优点：\n1. 容易进行静态分析\n2. 面向未来的EcmaScript标准\n\n缺点：\n1. 原生浏览器端还没有实现该标准\n2. 全新的命令字，新版的Node.js才支持\n\n实现：\n- [Babel](https://babeljs.io/)\n\n### 期望的模块系统\n可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅是Javascript模块化，还有CSS、图片、字体等资源也需要模块化。\n\n## 前端模块加载\n前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。  \n模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。  \n***分块传输***，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。  \n要实现模块的按需加载，就需要一个对整个代码库的模块进行静态分析、编译打包的过程。\n\n## 所有资源都是模块\n在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。\n\n如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：\n```javascript\n    require(\"./style.css\");\n    require(\"./style.less\");\n    require(\"./template.jade\");\n    require(\"./image.png\");\n```\n\n## 静态分析\n在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的记载其来处理。比如一个用LESS写的样式模块，可以先用LESS加载器将它转成一个CSS模块，再通过CSS模块把他插入到页面的<script>标签中执行。Webpack就是这样的需求中应运而生。\n同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。","slug":"模块系统","published":1,"updated":"2016-05-16T02:11:32.479Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enm001xb0dlrblyifif","content":"<h2 id=\"系统模块的演进\"><a href=\"#系统模块的演进\" class=\"headerlink\" title=\"系统模块的演进\"></a>系统模块的演进</h2><p>模块系统主要解决模块的定义、依赖和导出，现已经存在的模块系统有如下几种。</p>\n<h3 id=\"lt-script-gt-标签\"><a href=\"#lt-script-gt-标签\" class=\"headerlink\" title=\"&lt;script&gt;标签\"></a><code>&lt;script&gt;</code>标签</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"module1.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"module2.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"module3.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的接口调用都是一个作用域，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如YUI库。  </p>\n<p>这种原始的加载方式暴露了一些显而易见的弊端：  </p>\n<ol>\n<li>全局 作用于下容易造成变量冲突  </li>\n<li>文件只能按照<code>&lt;script&gt;</code>的书写顺序进行加载</li>\n<li>开发人员必须主观解决模块和代码库的依赖关系</li>\n<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>\n</ol>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p>服务器端的Node.js遵循<a href=\"http://wiki.commonjs.org/wiki/CommonJS\" target=\"_blank\" rel=\"external\">CommonJS规范</a>，该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"module\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"../file.js\"</span>);  </span><br><span class=\"line\">exports.doSth = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = someThing;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>服务器端模块便于重用</li>\n<li>NPM中已经有将近20万个可以使用的模块包</li>\n<li>简单并容易使用</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li>\n<li>不能非阻塞的并行加载多个模块</li>\n</ol>\n<p>实现：</p>\n<ol>\n<li>服务器端的Node.js</li>\n<li>Browserify，浏览器端的CommonJS实现，可以使用NPM的模块，但是编译打包后的文件体积可能很大</li>\n<li>modules-webmake，类似Browserify，还不如Browserify灵活</li>\n<li>wreq，Browserify的前身</li>\n</ol>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p><a href=\"https://github.com/amdjs/amdjs-api\" target=\"_blank\" rel=\"external\">Asynchronous Module Definition</a> 规范其实只有一个主要的接口define(id?,dependencies?,factory)，它要在声明模块的时候指定所有的依赖dependences，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">\"module\"</span>,[<span class=\"string\">\"dep1\"</span>.<span class=\"string\">\"dep2\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d1,d2</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> someThing;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"module\"</span>,<span class=\"string\">\"../files\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module,file</span>)</span>&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>适合在浏览器环境中异步加载模块</li>\n<li>可以并行加载多个模块</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>\n<li>不符合通用的模块化思维方式，是一种妥协的实现</li>\n</ol>\n<p>实现：</p>\n<ul>\n<li><a href=\"http://requirejs.org/\" target=\"_blank\" rel=\"external\">RequireJS</a></li>\n<li><a href=\"https://github.com/cujojs/curl\" target=\"_blank\" rel=\"external\">curl</a></li>\n</ul>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\" target=\"_blank\" rel=\"external\">Common Module Definition</a>规范和AMD很相似，尽量保持简单，并与ComminJS和Node.js的Modules规范保持了很大的兼容性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,exports,module</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">\"jquery\"</span>);</span><br><span class=\"line\">    exports.doSomething = ...</span><br><span class=\"line\">    module.exports = ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>依赖就近，延迟执行</li>\n<li>可以很容易在Nod.js中执行</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>依赖SPM打包，模块的加载逻辑偏重</li>\n</ol>\n<p>实现：</p>\n<ul>\n<li><a href=\"http://seajs.org/\" target=\"_blank\" rel=\"external\">Sea.js</a></li>\n<li><a href=\"https://github.com/cloudcome/coolie\" target=\"_blank\" rel=\"external\">coolie</a></li>\n</ul>\n<h3 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h3><p><a href=\"https://github.com/umdjs/umd\" target=\"_blank\" rel=\"external\">Universal Module Definition</a> 规范类似于兼容 CommonJS 和 AMD的语法糖，是模块定义的跨平台解决方案。</p>\n<h3 id=\"ES6模块\"><a href=\"#ES6模块\" class=\"headerlink\" title=\"ES6模块\"></a>ES6模块</h3><p>EcmaScript6 标准增加了JavaScript语言层面的模块体系定义。<a href=\"http://es6.ruanyifeng.com/#docs/module\" target=\"_blank\" rel=\"external\">ES6模块</a>的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD都只能在运行时确认这些东西。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"jquery\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doStuff</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span> <span class=\"string\">\"localModule\"</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>容易进行静态分析</li>\n<li>面向未来的EcmaScript标准</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>原生浏览器端还没有实现该标准</li>\n<li>全新的命令字，新版的Node.js才支持</li>\n</ol>\n<p>实现：</p>\n<ul>\n<li><a href=\"https://babeljs.io/\" target=\"_blank\" rel=\"external\">Babel</a></li>\n</ul>\n<h3 id=\"期望的模块系统\"><a href=\"#期望的模块系统\" class=\"headerlink\" title=\"期望的模块系统\"></a>期望的模块系统</h3><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅是Javascript模块化，还有CSS、图片、字体等资源也需要模块化。</p>\n<h2 id=\"前端模块加载\"><a href=\"#前端模块加载\" class=\"headerlink\" title=\"前端模块加载\"></a>前端模块加载</h2><p>前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。<br>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。<br><strong><em>分块传输</em></strong>，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。<br>要实现模块的按需加载，就需要一个对整个代码库的模块进行静态分析、编译打包的过程。</p>\n<h2 id=\"所有资源都是模块\"><a href=\"#所有资源都是模块\" class=\"headerlink\" title=\"所有资源都是模块\"></a>所有资源都是模块</h2><p>在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。</p>\n<p>如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./style.css\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./style.less\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./template.jade\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./image.png\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"静态分析\"><a href=\"#静态分析\" class=\"headerlink\" title=\"静态分析\"></a>静态分析</h2><p>在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的记载其来处理。比如一个用LESS写的样式模块，可以先用LESS加载器将它转成一个CSS模块，再通过CSS模块把他插入到页面的<script>标签中执行。Webpack就是这样的需求中应运而生。<br>同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。</p>\n</script></p>","excerpt":"","more":"<h2 id=\"系统模块的演进\"><a href=\"#系统模块的演进\" class=\"headerlink\" title=\"系统模块的演进\"></a>系统模块的演进</h2><p>模块系统主要解决模块的定义、依赖和导出，现已经存在的模块系统有如下几种。</p>\n<h3 id=\"lt-script-gt-标签\"><a href=\"#lt-script-gt-标签\" class=\"headerlink\" title=\"&lt;script&gt;标签\"></a><code>&lt;script&gt;</code>标签</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"module1.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"module2.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"module3.js\"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<p>这是最原始的JavaScript文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在window对象中，不同模块的接口调用都是一个作用域，一些复杂的框架，会使用命名空间的概念来组织这些模块的接口，典型的例子如YUI库。  </p>\n<p>这种原始的加载方式暴露了一些显而易见的弊端：  </p>\n<ol>\n<li>全局 作用于下容易造成变量冲突  </li>\n<li>文件只能按照<code>&lt;script&gt;</code>的书写顺序进行加载</li>\n<li>开发人员必须主观解决模块和代码库的依赖关系</li>\n<li>在大型项目中各种资源难以管理，长期积累的问题导致代码库混乱不堪</li>\n</ol>\n<h3 id=\"CommonJS\"><a href=\"#CommonJS\" class=\"headerlink\" title=\"CommonJS\"></a>CommonJS</h3><p>服务器端的Node.js遵循<a href=\"http://wiki.commonjs.org/wiki/CommonJS\">CommonJS规范</a>，该规范的核心思想是允许模块通过require方法来同步加载所要依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"module\"</span>);  </span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"../file.js\"</span>);  </span><br><span class=\"line\">exports.doSth = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = someThing;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>服务器端模块便于重用</li>\n<li>NPM中已经有将近20万个可以使用的模块包</li>\n<li>简单并容易使用</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>同步的模块加载方式不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的</li>\n<li>不能非阻塞的并行加载多个模块</li>\n</ol>\n<p>实现：</p>\n<ol>\n<li>服务器端的Node.js</li>\n<li>Browserify，浏览器端的CommonJS实现，可以使用NPM的模块，但是编译打包后的文件体积可能很大</li>\n<li>modules-webmake，类似Browserify，还不如Browserify灵活</li>\n<li>wreq，Browserify的前身</li>\n</ol>\n<h3 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h3><p><a href=\"https://github.com/amdjs/amdjs-api\">Asynchronous Module Definition</a> 规范其实只有一个主要的接口define(id?,dependencies?,factory)，它要在声明模块的时候指定所有的依赖dependences，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">\"module\"</span>,[<span class=\"string\">\"dep1\"</span>.<span class=\"string\">\"dep2\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d1,d2</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> someThing;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"module\"</span>,<span class=\"string\">\"../files\"</span>],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module,file</span>)</span>&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>适合在浏览器环境中异步加载模块</li>\n<li>可以并行加载多个模块</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>提高了开发成本，代码的阅读和书写比较困难，模块定义方式的语义不顺畅</li>\n<li>不符合通用的模块化思维方式，是一种妥协的实现</li>\n</ol>\n<p>实现：</p>\n<ul>\n<li><a href=\"http://requirejs.org/\">RequireJS</a></li>\n<li><a href=\"https://github.com/cujojs/curl\">curl</a></li>\n</ul>\n<h3 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h3><p><a href=\"https://github.com/cmdjs/specification/blob/master/draft/module.md\">Common Module Definition</a>规范和AMD很相似，尽量保持简单，并与ComminJS和Node.js的Modules规范保持了很大的兼容性。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require,exports,module</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">\"jquery\"</span>);</span><br><span class=\"line\">    exports.doSomething = ...</span><br><span class=\"line\">    module.exports = ...</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>依赖就近，延迟执行</li>\n<li>可以很容易在Nod.js中执行</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>依赖SPM打包，模块的加载逻辑偏重</li>\n</ol>\n<p>实现：</p>\n<ul>\n<li><a href=\"http://seajs.org/\">Sea.js</a></li>\n<li><a href=\"https://github.com/cloudcome/coolie\">coolie</a></li>\n</ul>\n<h3 id=\"UMD\"><a href=\"#UMD\" class=\"headerlink\" title=\"UMD\"></a>UMD</h3><p><a href=\"https://github.com/umdjs/umd\">Universal Module Definition</a> 规范类似于兼容 CommonJS 和 AMD的语法糖，是模块定义的跨平台解决方案。</p>\n<h3 id=\"ES6模块\"><a href=\"#ES6模块\" class=\"headerlink\" title=\"ES6模块\"></a>ES6模块</h3><p>EcmaScript6 标准增加了JavaScript语言层面的模块体系定义。<a href=\"http://es6.ruanyifeng.com/#docs/module\">ES6模块</a>的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD都只能在运行时确认这些东西。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">\"jquery\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doStuff</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span> <span class=\"string\">\"localModule\"</span> &#123;&#125;</span><br></pre></td></tr></table></figure></p>\n<p>优点：</p>\n<ol>\n<li>容易进行静态分析</li>\n<li>面向未来的EcmaScript标准</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>原生浏览器端还没有实现该标准</li>\n<li>全新的命令字，新版的Node.js才支持</li>\n</ol>\n<p>实现：</p>\n<ul>\n<li><a href=\"https://babeljs.io/\">Babel</a></li>\n</ul>\n<h3 id=\"期望的模块系统\"><a href=\"#期望的模块系统\" class=\"headerlink\" title=\"期望的模块系统\"></a>期望的模块系统</h3><p>可以兼容多种模块风格，尽量可以利用已有的代码，不仅仅是Javascript模块化，还有CSS、图片、字体等资源也需要模块化。</p>\n<h2 id=\"前端模块加载\"><a href=\"#前端模块加载\" class=\"headerlink\" title=\"前端模块加载\"></a>前端模块加载</h2><p>前端模块要在客户端中执行，所以他们需要增量加载到浏览器中。<br>模块的加载和传输，我们首先能想到两种极端的方式，一种是每个模块文件都单独请求，另一种是所有模块打包成一个文件然后只请求一次。显而易见，每个模块都发起单独的请求造成了请求次数过多，导致应用启动速度慢；一次请求加载所有模块导致流量浪费、初始化过程慢。这两种方式都不是好的解决方案，它们过于简单粗暴。<br><strong><em>分块传输</em></strong>，按需进行懒加载，在实际用到某些模块的时候再增量更新，才是较为合理的模块加载方案。<br>要实现模块的按需加载，就需要一个对整个代码库的模块进行静态分析、编译打包的过程。</p>\n<h2 id=\"所有资源都是模块\"><a href=\"#所有资源都是模块\" class=\"headerlink\" title=\"所有资源都是模块\"></a>所有资源都是模块</h2><p>在上面的分析过程中，我们提到的模块仅仅是指JavaScript模块文件。然而，在前端开发过程中还涉及到样式、图片、字体、HTML 模板等等众多的资源。这些资源还会以各种方言的形式存在，比如 coffeescript、 less、 sass、众多的模板库、多语言系统（i18n）等等。</p>\n<p>如果他们都可以视作模块，并且都可以通过require的方式来加载，将带来优雅的开发体验，比如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./style.css\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./style.less\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./template.jade\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"./image.png\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"静态分析\"><a href=\"#静态分析\" class=\"headerlink\" title=\"静态分析\"></a>静态分析</h2><p>在编译的时候，要对整个代码进行静态分析，分析出各个模块的类型和它们依赖关系，然后将不同类型的模块提交给适配的记载其来处理。比如一个用LESS写的样式模块，可以先用LESS加载器将它转成一个CSS模块，再通过CSS模块把他插入到页面的<script>标签中执行。Webpack就是这样的需求中应运而生。<br>同时，为了能利用已经存在的各种框架、库和已经写好的文件，我们还需要一个模块加载的兼容策略，来避免重写所有的模块。</p>\n"},{"title":"流程控制与错误处理","date":"2016-05-17T10:36:49.000Z","_content":"> Energy and persistence conquer all things.\n\n在JavaScript中，任何表达式(expression)都可以看作一条语句(statement)，每条语句可以使用分号( ; )来分隔。你可以在每行书写一条语句；也可以在一行书写多条语句。但是我们推荐在书写代码的时候采用第一种方式，以便于后期的代码维护。\n\n## 语句块(Block Statement)\n大多数程序都使用语句块来给语句分组，这样可以使语句的结构清晰明了。我们使用一对花括号（ {} ）来分组语句块，如下所示：\n\n```javascript\n    {\n       statement_1;   statement_2;\n       statement_3;\n       ...\n       statement_n;\n    }\n```\n\n示例\n语句块通常大多数用于流程控制，如 if, for, while等等。\n\n```javascript\n    while (x < 10){\n      x++;\n    }\n```\n这里{ x++; } 就是语句块。\n\n## 条件判断语句(Conditional Statements)\n条件判断语句指的是根据指定的条件所返回的结果（真或假或其它预定义的），来执行特定的语句。JavaScript提供了两种条件判断语句：if...else 和 switch。\n\n### if...else语句\n当一个逻辑条件为真，用if语句执行一个语句。当这个条件为假，使用可选择的else从句来执行这个语句。\n\n在条件表达式中最好不要使用“=”来判断条件是否相等，因为这会产生非预期结果。不要使用下面的代码：\n```javascript\n   if (x = y) {\n     /* do the right thing */\n   } \n```\n\n如果你需要在条件表达式中使用赋值，一个共同的习惯是在赋值语句前后额外的添加一对括号。例如：\n```javascript\n   if ((x = y)) {\n     /* do the right thing */\n   }\n```\n\n下面这些值将被计算出 false:\n - false\n - undefined\n - null\n - 0\n - NaN\n - 空字符串(\"\")\n当传递给条件语句时，所有其他值，包括所有对象会被计算为 true。\n\n**请不要混淆原始的布尔值true和false与布尔对象的值true和false。**例如：\n```javascript\n   var b = new Boolean(false);\n   if(b) //this condition evaluates to true\n   if(b == true) //this condition evaluates to false\n```\n\n例如\n在下面的例子中，如果一个文本对象中的字符串长度是3，函数checkData返回true；否则，函数显示一个alert的弹出框消息并返回false。\n```javascript\n   function checkData() {\n     if (document.form1.threeChar.value.length == 3) {\n       return true;\n     } else {\n       alert(\"Enter exactly three characters. \" +\n         document.form1.threeChar.value + \" is not valid.\");\n       return false;\n     }\n   } \n```\n\n### switch语句(Switch Statement)\n开关语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个case label。如果匹配成功，这个程序执行相关的语句。开关语句如下所示：\n```javascript\n  switch (expression) {\n     case label_1:\n        statements_1\n        [break;]\n     case label_2:\n        statements_2\n        [break;]\n     ...\n     default:\n        statements_def\n        [break;]\n  }  \n```\n\n## 循环语句(Loop Statement)\n循环语句是一系列反复执行直到符合特定条件的命令。JavaScript 支持 for, do while, while这些循环语句，还有Label (label 本身不是一个循环语句，但是经常和这些语句一起使用)。另外，你可以在循环语句中使用break和continue 语句。另一个语句：for...in也反复执行语句，但它是用来操作对象的。\n\n### 标签语句(label Statement)\n标签语句提供一种使你同一程序的另一处找到它的标识。例如，你可以用一个标签来识别一个循环，并用break或continue语句来说明一个程序是否要中断这个循环或是继续执行。如下所示：\n```javascript\n    label:\n        statement\n```\nlabel的值可以是js的任何非保留字符标识符。用label标识的语句可以是任何语句。\n\n例如：\n```javascript\n    markLoop:\n    while(theMark == true){\n        doSomething();\n    }\n```\n\n## 中断语句(break Statement)\n使用中断语句终止循环、开关或与标签语句连接。\n\n - 当你使用没有带标签语句的中断语句（break）时，while,do-while,for或switch封闭的内部语句将立即终止，并转移到后面的语句执行。\n - 当你使用带有标签语句的中断语句(break)时，将终止在特定的标签语句。\n \n 中断语句的语法如下：\n 1.break;\n 2.break label;\n \n 第一种语法形式用于终止在循环体或者switch的封闭内部；第二种语法形式用于在特定的封闭标签语句。\n \n 示例1：\n 下面的例子中，对一个数组里的元素进行循环处理，直到数组元素下标等于theValue的值：\n ```javascript\n    for(var i=0;i<a.length;i++){\n        if(a[i] == theValue){\n            break;\n        }\n    }\n ```\n\n示例2：中断跳到标签语句\n```javascript\n    var x = 0;\n    var z = 0;\n    labelCancelLoops: while(true){\n        console.log(\"Outer loops:\" + x);\n        x += 1;\n        z = 1;\n        while(true){\n            console.log(\"Inner loops: \"+z);\n            z+=1;\n            if(z === 10 && x === 10){\n                break labelCancelLoops;\n            }else if(z === 10){\n                break;\n            }\n        }\n    }\n```\n\n## 连续语句(continue Statement)\n连续语句用于重新开始while,do-while,for语句，或者标签语句(label statement).\n\n - 当你使用没有带标签语句的连续语句(continue Statement)时，将在当前的while,do-while或者for循环体封闭的内部语句中止执行，然后进入下一次循环继续执行。与中断语句(break Statement)相比，连续语句不会把整个循环终止。在while循环里，将跳回条件判断(continue)；\n 在for循环里，则调回累计表达式(increment-expression).\n - 当你使用带有标签语句的连续语句时，用于识别循环体中的标签语句。\n \n 连续语句的语法如下：\n \n 1.continue\n 2.continue label\n\n示例1\n下面的例子实现了一个带有连续语句的while循环，当i的值为3时，该连续语句执行。因此，n的值分别为1、3、7和12。\n```javascript\n  i = 0;\n  n = 0;\n  while (i < 5) {\n     i++;\n     if (i == 3)\n        continue;\n     n += i;\n  }  \n```\n\n示例2\n一个标签语句checkiandj包含了一个标签语句checkj。如果连续语句被触发，程序会中止在当前循环中的checkj然后开始下一轮循环。每次连续语句被触发，checkj会重复直到该条件判断返回false值。当返回false值时，会完成剩下的checkiandj语句，然后checkiandj会重复直到其条件判断返回false值。当返回false值时，程序会继续执行在checkiandj后面的语句。\n\n如果连续语句包含的是checkiandj标签，那么程序会在checkiandj语句的顶层继续执行。\n```javascript\n    checkiandj :\n       while (i < 4) {\n          document.write(i + \"<br/>\");\n          i += 1;\n          checkj :\n             while (j > 4) {\n                document.write(j + \"<br/>\");\n                j -= 1;\n                if ((j % 2) == 0)\n                   continue checkj;\n                document.write(j + \" is odd.<br/>\");\n             }\n          document.write(\"i = \" + i + \"<br/>\");\n          document.write(\"j = \" + j + \"<br/>\");\n       }\n```\n\n## 对象操作语句(Object Manipulation Statements)\nJavaScript用for...in,for each...in和with语句来操作对象。\n\n## 异常处理语句(Exception Handling Statements)\n你可以用throw语句抛出一个异常并且用try...catch语句捕获处理它。\n\n### 异常类型(Exception Types)\nJavaScript可以抛出任意对象。然而，不是所有对象能产生相同的结果。尽管抛出数值或者字母串作为错误信息十分常见，但是通常用下列其中一种异常类型来创建目标更为高效：\n - ECMAScript exceptions\n - DOMException\n - nsIXPCException\n \n### 抛出错误(throw Statement)\n使用throw语句抛出一个异常。当你抛出异常，你规定一个含有值的表达式要被抛出。\n```javascript\n    throw expression\n```\n\n你可以抛出任意表达式而不是特定一种类型的表达式。下面的代码抛出了几个不同类型的表达式：\n - throw \"Error\"; //string type\n - throw 42;\n - throw true;\n - throw {toString:function(){return \"I'm an object!\"}};\n\n```javascript\n    //create an object type UserException\n    function UserException (message){\n        this.message = message;\n        this.name = \"UserException\";\n    }\n    //Make the exception convert to a pretty string when used as a string (e.g. by the error console)\n    UserException.prototype.toString = function(){\n        return this.name + ': \"' + this.message+ '\"';\n    }\n    //create an instance of the object type and throw it\n    throw new UserException(\"Value too high\");\n```\n\n### try...catch语句\ntry...catch语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常抛出。如果我们抛出一个异常，try...catch语句就捕获它。\n\ntry...catch语句有一个包含一条或者多条语句的try代码块，0个或多个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 换句话说，如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。\n\n下面的例子使用了try...catch语句。示例调用了一个函数用于从一个数组中根据传递值来获取一个月份名称。如果该值与月份数值不相符，会抛出一个带有\"InvalidMonthNo\"值的异常，然后在捕捉块语句中设monthName变量为unknown。\n\n```javascript\n   function getMonthName(mo) {\n     mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec)\n     var months = [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];\n     if (months[mo]) {\n       return months[mo];\n     } else {\n       throw \"InvalidMonthNo\"; //throw keyword is used here\n     }\n   }\n   try { // statements to try\n     monthName = getMonthName(myMonth); // function could throw exception\n   }\n   catch (e) {\n     monthName = \"unknown\";\n     logMyErrors(e); // pass exception object to error handler -> your own function\n   }\n```\n\n### 捕捉块(The catch block)\n你可以使用捕捉块来处理所有可能在try代码块中产生的异常。\n\n```javascript\n    catch(catchID){\n        statements\n    }\n\n捕捉块指定了一个标识符 (上述语句中的catchID）来存放抛出语句指定的值；你可以用这个标识符来获取抛出的异常信息。在插入捕捉块时JavaScript创建这个标识符；标识符只存在于捕捉块的存续期间里；当捕捉块执行完成时，标识符不再可用。\n\n举个例子，下面代码抛出了一个异常。当异常出现时跳到捕捉块（the catch block）。\n\n```javascript\n   try {\n      throw \"myException\" // generates an exception\n   }\n   catch (e) {\n   // statements to handle any exceptions\n      logMyErrors(e) // pass exception object to error handler\n   } \n```\n\n### 终结块(The finally Block)\n终结块包含了在try和catch块完成后、下面接着的try...catch语句之前执行的语句。终结块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，终结块里的语句也会执行。\n\n你可以用终结块来令你的脚本在异常发生时优雅地退出；举个例子，你可能需要在绑定的脚本中释放资源。接下来的例子用文件处理语句打开了一个文件（服务端的JavaScript允许你进入文件）。如果在文件打开时一个异常抛出，终结块会在脚本错误之前关闭文件。\n\n```javascript\n   openMyFile();\n   try {\n       writeMyFile(theData); //This may throw a error\n   }catch(e){\n       handleError(e); // If we got a error we handle it\n   }finally {\n       closeMyFile(); // always close the resource\n   } \n```\n\n如果终结块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：\n\n```javascript\n   function f() {\n     try {\n       console.log(0);\n       throw \"bogus\";\n     } catch(e) {\n       console.log(1);\n       return true; // this return statement is suspended\n                    // until finally block has completed\n       console.log(2); // not reachable\n     } finally {\n       console.log(3);\n       return false; // overwrites the previous \"return\"\n       console.log(4); // not reachable\n     }\n     // \"return false\" is executed now  \n     console.log(5); // not reachable\n   }\n   f(); // console 0, 1, 3; returns false \n```\n\n嵌套try...catch语句\n\n你可以嵌套一个或多个try...catch语句。如果一个内部的try...catch语句没有捕捉块（catch block），将会启动匹配外部的try...catch语句的捕捉块（catch block）。\n\n## 错误匹配对象(Utilizing Error objects)\n根据错误类型，你也许可以用'name'和'message'获取更精炼的信息。'name'提供了常规的错误类(e.g., 'DOMException' or 'Error')，而'message'通常提供了一条从错误对象转换成字符串的简明信息。\n\n在抛出你个人所为的异常时，为了充分利用那些属性（比如你的catch块不能分辨是你个人所为的异常还是系统的异常时），你可以使用错误构造函数（the Error constructor）。比如：\n\n```javascript\n   function doSomethingErrorProne () {\n     if (ourCodeMakesAMistake()) {\n       throw (new Error('The message'));\n     } else {\n       doSomethingToGetAJavascriptError();\n     }\n   }\n   ....\n   try {\n     doSomethingErrorProne();\n   }\n   catch (e) {\n     console.log(e.name); // logs 'Error'\n     console.log(e.message); // logs 'The message' or a JavaScript error message)\n   } \n```","source":"_posts/流程控制与错误处理.md","raw":"---\ntitle: 流程控制与错误处理\ndate: 2016-05-17 18:36:49\ntags:\n- javascript\n- 流程控制和错误处理\ncategories: 笔记\n---\n> Energy and persistence conquer all things.\n\n在JavaScript中，任何表达式(expression)都可以看作一条语句(statement)，每条语句可以使用分号( ; )来分隔。你可以在每行书写一条语句；也可以在一行书写多条语句。但是我们推荐在书写代码的时候采用第一种方式，以便于后期的代码维护。\n\n## 语句块(Block Statement)\n大多数程序都使用语句块来给语句分组，这样可以使语句的结构清晰明了。我们使用一对花括号（ {} ）来分组语句块，如下所示：\n\n```javascript\n    {\n       statement_1;   statement_2;\n       statement_3;\n       ...\n       statement_n;\n    }\n```\n\n示例\n语句块通常大多数用于流程控制，如 if, for, while等等。\n\n```javascript\n    while (x < 10){\n      x++;\n    }\n```\n这里{ x++; } 就是语句块。\n\n## 条件判断语句(Conditional Statements)\n条件判断语句指的是根据指定的条件所返回的结果（真或假或其它预定义的），来执行特定的语句。JavaScript提供了两种条件判断语句：if...else 和 switch。\n\n### if...else语句\n当一个逻辑条件为真，用if语句执行一个语句。当这个条件为假，使用可选择的else从句来执行这个语句。\n\n在条件表达式中最好不要使用“=”来判断条件是否相等，因为这会产生非预期结果。不要使用下面的代码：\n```javascript\n   if (x = y) {\n     /* do the right thing */\n   } \n```\n\n如果你需要在条件表达式中使用赋值，一个共同的习惯是在赋值语句前后额外的添加一对括号。例如：\n```javascript\n   if ((x = y)) {\n     /* do the right thing */\n   }\n```\n\n下面这些值将被计算出 false:\n - false\n - undefined\n - null\n - 0\n - NaN\n - 空字符串(\"\")\n当传递给条件语句时，所有其他值，包括所有对象会被计算为 true。\n\n**请不要混淆原始的布尔值true和false与布尔对象的值true和false。**例如：\n```javascript\n   var b = new Boolean(false);\n   if(b) //this condition evaluates to true\n   if(b == true) //this condition evaluates to false\n```\n\n例如\n在下面的例子中，如果一个文本对象中的字符串长度是3，函数checkData返回true；否则，函数显示一个alert的弹出框消息并返回false。\n```javascript\n   function checkData() {\n     if (document.form1.threeChar.value.length == 3) {\n       return true;\n     } else {\n       alert(\"Enter exactly three characters. \" +\n         document.form1.threeChar.value + \" is not valid.\");\n       return false;\n     }\n   } \n```\n\n### switch语句(Switch Statement)\n开关语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个case label。如果匹配成功，这个程序执行相关的语句。开关语句如下所示：\n```javascript\n  switch (expression) {\n     case label_1:\n        statements_1\n        [break;]\n     case label_2:\n        statements_2\n        [break;]\n     ...\n     default:\n        statements_def\n        [break;]\n  }  \n```\n\n## 循环语句(Loop Statement)\n循环语句是一系列反复执行直到符合特定条件的命令。JavaScript 支持 for, do while, while这些循环语句，还有Label (label 本身不是一个循环语句，但是经常和这些语句一起使用)。另外，你可以在循环语句中使用break和continue 语句。另一个语句：for...in也反复执行语句，但它是用来操作对象的。\n\n### 标签语句(label Statement)\n标签语句提供一种使你同一程序的另一处找到它的标识。例如，你可以用一个标签来识别一个循环，并用break或continue语句来说明一个程序是否要中断这个循环或是继续执行。如下所示：\n```javascript\n    label:\n        statement\n```\nlabel的值可以是js的任何非保留字符标识符。用label标识的语句可以是任何语句。\n\n例如：\n```javascript\n    markLoop:\n    while(theMark == true){\n        doSomething();\n    }\n```\n\n## 中断语句(break Statement)\n使用中断语句终止循环、开关或与标签语句连接。\n\n - 当你使用没有带标签语句的中断语句（break）时，while,do-while,for或switch封闭的内部语句将立即终止，并转移到后面的语句执行。\n - 当你使用带有标签语句的中断语句(break)时，将终止在特定的标签语句。\n \n 中断语句的语法如下：\n 1.break;\n 2.break label;\n \n 第一种语法形式用于终止在循环体或者switch的封闭内部；第二种语法形式用于在特定的封闭标签语句。\n \n 示例1：\n 下面的例子中，对一个数组里的元素进行循环处理，直到数组元素下标等于theValue的值：\n ```javascript\n    for(var i=0;i<a.length;i++){\n        if(a[i] == theValue){\n            break;\n        }\n    }\n ```\n\n示例2：中断跳到标签语句\n```javascript\n    var x = 0;\n    var z = 0;\n    labelCancelLoops: while(true){\n        console.log(\"Outer loops:\" + x);\n        x += 1;\n        z = 1;\n        while(true){\n            console.log(\"Inner loops: \"+z);\n            z+=1;\n            if(z === 10 && x === 10){\n                break labelCancelLoops;\n            }else if(z === 10){\n                break;\n            }\n        }\n    }\n```\n\n## 连续语句(continue Statement)\n连续语句用于重新开始while,do-while,for语句，或者标签语句(label statement).\n\n - 当你使用没有带标签语句的连续语句(continue Statement)时，将在当前的while,do-while或者for循环体封闭的内部语句中止执行，然后进入下一次循环继续执行。与中断语句(break Statement)相比，连续语句不会把整个循环终止。在while循环里，将跳回条件判断(continue)；\n 在for循环里，则调回累计表达式(increment-expression).\n - 当你使用带有标签语句的连续语句时，用于识别循环体中的标签语句。\n \n 连续语句的语法如下：\n \n 1.continue\n 2.continue label\n\n示例1\n下面的例子实现了一个带有连续语句的while循环，当i的值为3时，该连续语句执行。因此，n的值分别为1、3、7和12。\n```javascript\n  i = 0;\n  n = 0;\n  while (i < 5) {\n     i++;\n     if (i == 3)\n        continue;\n     n += i;\n  }  \n```\n\n示例2\n一个标签语句checkiandj包含了一个标签语句checkj。如果连续语句被触发，程序会中止在当前循环中的checkj然后开始下一轮循环。每次连续语句被触发，checkj会重复直到该条件判断返回false值。当返回false值时，会完成剩下的checkiandj语句，然后checkiandj会重复直到其条件判断返回false值。当返回false值时，程序会继续执行在checkiandj后面的语句。\n\n如果连续语句包含的是checkiandj标签，那么程序会在checkiandj语句的顶层继续执行。\n```javascript\n    checkiandj :\n       while (i < 4) {\n          document.write(i + \"<br/>\");\n          i += 1;\n          checkj :\n             while (j > 4) {\n                document.write(j + \"<br/>\");\n                j -= 1;\n                if ((j % 2) == 0)\n                   continue checkj;\n                document.write(j + \" is odd.<br/>\");\n             }\n          document.write(\"i = \" + i + \"<br/>\");\n          document.write(\"j = \" + j + \"<br/>\");\n       }\n```\n\n## 对象操作语句(Object Manipulation Statements)\nJavaScript用for...in,for each...in和with语句来操作对象。\n\n## 异常处理语句(Exception Handling Statements)\n你可以用throw语句抛出一个异常并且用try...catch语句捕获处理它。\n\n### 异常类型(Exception Types)\nJavaScript可以抛出任意对象。然而，不是所有对象能产生相同的结果。尽管抛出数值或者字母串作为错误信息十分常见，但是通常用下列其中一种异常类型来创建目标更为高效：\n - ECMAScript exceptions\n - DOMException\n - nsIXPCException\n \n### 抛出错误(throw Statement)\n使用throw语句抛出一个异常。当你抛出异常，你规定一个含有值的表达式要被抛出。\n```javascript\n    throw expression\n```\n\n你可以抛出任意表达式而不是特定一种类型的表达式。下面的代码抛出了几个不同类型的表达式：\n - throw \"Error\"; //string type\n - throw 42;\n - throw true;\n - throw {toString:function(){return \"I'm an object!\"}};\n\n```javascript\n    //create an object type UserException\n    function UserException (message){\n        this.message = message;\n        this.name = \"UserException\";\n    }\n    //Make the exception convert to a pretty string when used as a string (e.g. by the error console)\n    UserException.prototype.toString = function(){\n        return this.name + ': \"' + this.message+ '\"';\n    }\n    //create an instance of the object type and throw it\n    throw new UserException(\"Value too high\");\n```\n\n### try...catch语句\ntry...catch语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常抛出。如果我们抛出一个异常，try...catch语句就捕获它。\n\ntry...catch语句有一个包含一条或者多条语句的try代码块，0个或多个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 换句话说，如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。\n\n下面的例子使用了try...catch语句。示例调用了一个函数用于从一个数组中根据传递值来获取一个月份名称。如果该值与月份数值不相符，会抛出一个带有\"InvalidMonthNo\"值的异常，然后在捕捉块语句中设monthName变量为unknown。\n\n```javascript\n   function getMonthName(mo) {\n     mo = mo - 1; // Adjust month number for array index (1 = Jan, 12 = Dec)\n     var months = [\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"];\n     if (months[mo]) {\n       return months[mo];\n     } else {\n       throw \"InvalidMonthNo\"; //throw keyword is used here\n     }\n   }\n   try { // statements to try\n     monthName = getMonthName(myMonth); // function could throw exception\n   }\n   catch (e) {\n     monthName = \"unknown\";\n     logMyErrors(e); // pass exception object to error handler -> your own function\n   }\n```\n\n### 捕捉块(The catch block)\n你可以使用捕捉块来处理所有可能在try代码块中产生的异常。\n\n```javascript\n    catch(catchID){\n        statements\n    }\n\n捕捉块指定了一个标识符 (上述语句中的catchID）来存放抛出语句指定的值；你可以用这个标识符来获取抛出的异常信息。在插入捕捉块时JavaScript创建这个标识符；标识符只存在于捕捉块的存续期间里；当捕捉块执行完成时，标识符不再可用。\n\n举个例子，下面代码抛出了一个异常。当异常出现时跳到捕捉块（the catch block）。\n\n```javascript\n   try {\n      throw \"myException\" // generates an exception\n   }\n   catch (e) {\n   // statements to handle any exceptions\n      logMyErrors(e) // pass exception object to error handler\n   } \n```\n\n### 终结块(The finally Block)\n终结块包含了在try和catch块完成后、下面接着的try...catch语句之前执行的语句。终结块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，终结块里的语句也会执行。\n\n你可以用终结块来令你的脚本在异常发生时优雅地退出；举个例子，你可能需要在绑定的脚本中释放资源。接下来的例子用文件处理语句打开了一个文件（服务端的JavaScript允许你进入文件）。如果在文件打开时一个异常抛出，终结块会在脚本错误之前关闭文件。\n\n```javascript\n   openMyFile();\n   try {\n       writeMyFile(theData); //This may throw a error\n   }catch(e){\n       handleError(e); // If we got a error we handle it\n   }finally {\n       closeMyFile(); // always close the resource\n   } \n```\n\n如果终结块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：\n\n```javascript\n   function f() {\n     try {\n       console.log(0);\n       throw \"bogus\";\n     } catch(e) {\n       console.log(1);\n       return true; // this return statement is suspended\n                    // until finally block has completed\n       console.log(2); // not reachable\n     } finally {\n       console.log(3);\n       return false; // overwrites the previous \"return\"\n       console.log(4); // not reachable\n     }\n     // \"return false\" is executed now  \n     console.log(5); // not reachable\n   }\n   f(); // console 0, 1, 3; returns false \n```\n\n嵌套try...catch语句\n\n你可以嵌套一个或多个try...catch语句。如果一个内部的try...catch语句没有捕捉块（catch block），将会启动匹配外部的try...catch语句的捕捉块（catch block）。\n\n## 错误匹配对象(Utilizing Error objects)\n根据错误类型，你也许可以用'name'和'message'获取更精炼的信息。'name'提供了常规的错误类(e.g., 'DOMException' or 'Error')，而'message'通常提供了一条从错误对象转换成字符串的简明信息。\n\n在抛出你个人所为的异常时，为了充分利用那些属性（比如你的catch块不能分辨是你个人所为的异常还是系统的异常时），你可以使用错误构造函数（the Error constructor）。比如：\n\n```javascript\n   function doSomethingErrorProne () {\n     if (ourCodeMakesAMistake()) {\n       throw (new Error('The message'));\n     } else {\n       doSomethingToGetAJavascriptError();\n     }\n   }\n   ....\n   try {\n     doSomethingErrorProne();\n   }\n   catch (e) {\n     console.log(e.name); // logs 'Error'\n     console.log(e.message); // logs 'The message' or a JavaScript error message)\n   } \n```","slug":"流程控制与错误处理","published":1,"updated":"2016-05-18T01:10:20.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0eno0021b0dldn36fu31","content":"<blockquote>\n<p>Energy and persistence conquer all things.</p>\n</blockquote>\n<p>在JavaScript中，任何表达式(expression)都可以看作一条语句(statement)，每条语句可以使用分号( ; )来分隔。你可以在每行书写一条语句；也可以在一行书写多条语句。但是我们推荐在书写代码的时候采用第一种方式，以便于后期的代码维护。</p>\n<h2 id=\"语句块-Block-Statement\"><a href=\"#语句块-Block-Statement\" class=\"headerlink\" title=\"语句块(Block Statement)\"></a>语句块(Block Statement)</h2><p>大多数程序都使用语句块来给语句分组，这样可以使语句的结构清晰明了。我们使用一对花括号（ {} ）来分组语句块，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   statement_1;   statement_2;</span><br><span class=\"line\">   statement_3;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   statement_n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例<br>语句块通常大多数用于流程控制，如 if, for, while等等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (x &lt; <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">  x++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里{ x++; } 就是语句块。</p>\n<h2 id=\"条件判断语句-Conditional-Statements\"><a href=\"#条件判断语句-Conditional-Statements\" class=\"headerlink\" title=\"条件判断语句(Conditional Statements)\"></a>条件判断语句(Conditional Statements)</h2><p>条件判断语句指的是根据指定的条件所返回的结果（真或假或其它预定义的），来执行特定的语句。JavaScript提供了两种条件判断语句：if…else 和 switch。</p>\n<h3 id=\"if…else语句\"><a href=\"#if…else语句\" class=\"headerlink\" title=\"if…else语句\"></a>if…else语句</h3><p>当一个逻辑条件为真，用if语句执行一个语句。当这个条件为假，使用可选择的else从句来执行这个语句。</p>\n<p>在条件表达式中最好不要使用“=”来判断条件是否相等，因为这会产生非预期结果。不要使用下面的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x = y) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* do the right thing */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你需要在条件表达式中使用赋值，一个共同的习惯是在赋值语句前后额外的添加一对括号。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((x = y)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* do the right thing */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面这些值将被计算出 false:</p>\n<ul>\n<li>false</li>\n<li>undefined</li>\n<li>null</li>\n<li>0</li>\n<li>NaN</li>\n<li>空字符串(“”)<br>当传递给条件语句时，所有其他值，包括所有对象会被计算为 true。</li>\n</ul>\n<p><strong>请不要混淆原始的布尔值true和false与布尔对象的值true和false。</strong>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(b) <span class=\"comment\">//this condition evaluates to true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(b == <span class=\"literal\">true</span>) <span class=\"comment\">//this condition evaluates to false</span></span><br></pre></td></tr></table></figure></p>\n<p>例如<br>在下面的例子中，如果一个文本对象中的字符串长度是3，函数checkData返回true；否则，函数显示一个alert的弹出框消息并返回false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkData</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.form1.threeChar.value.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"Enter exactly three characters. \"</span> +</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.form1.threeChar.value + <span class=\"string\">\" is not valid.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"switch语句-Switch-Statement\"><a href=\"#switch语句-Switch-Statement\" class=\"headerlink\" title=\"switch语句(Switch Statement)\"></a>switch语句(Switch Statement)</h3><p>开关语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个case label。如果匹配成功，这个程序执行相关的语句。开关语句如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (expression) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> label_1:</span><br><span class=\"line\">      statements_1</span><br><span class=\"line\">      [<span class=\"keyword\">break</span>;]</span><br><span class=\"line\">   <span class=\"keyword\">case</span> label_2:</span><br><span class=\"line\">      statements_2</span><br><span class=\"line\">      [<span class=\"keyword\">break</span>;]</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   default:</span><br><span class=\"line\">      statements_def</span><br><span class=\"line\">      [<span class=\"keyword\">break</span>;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"循环语句-Loop-Statement\"><a href=\"#循环语句-Loop-Statement\" class=\"headerlink\" title=\"循环语句(Loop Statement)\"></a>循环语句(Loop Statement)</h2><p>循环语句是一系列反复执行直到符合特定条件的命令。JavaScript 支持 for, do while, while这些循环语句，还有Label (label 本身不是一个循环语句，但是经常和这些语句一起使用)。另外，你可以在循环语句中使用break和continue 语句。另一个语句：for…in也反复执行语句，但它是用来操作对象的。</p>\n<h3 id=\"标签语句-label-Statement\"><a href=\"#标签语句-label-Statement\" class=\"headerlink\" title=\"标签语句(label Statement)\"></a>标签语句(label Statement)</h3><p>标签语句提供一种使你同一程序的另一处找到它的标识。例如，你可以用一个标签来识别一个循环，并用break或continue语句来说明一个程序是否要中断这个循环或是继续执行。如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label:</span><br><span class=\"line\">    statement</span><br></pre></td></tr></table></figure></p>\n<p>label的值可以是js的任何非保留字符标识符。用label标识的语句可以是任何语句。</p>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLoop:</span><br><span class=\"line\"><span class=\"keyword\">while</span>(theMark == <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"中断语句-break-Statement\"><a href=\"#中断语句-break-Statement\" class=\"headerlink\" title=\"中断语句(break Statement)\"></a>中断语句(break Statement)</h2><p>使用中断语句终止循环、开关或与标签语句连接。</p>\n<ul>\n<li>当你使用没有带标签语句的中断语句（break）时，while,do-while,for或switch封闭的内部语句将立即终止，并转移到后面的语句执行。</li>\n<li><p>当你使用带有标签语句的中断语句(break)时，将终止在特定的标签语句。</p>\n<p>中断语句的语法如下：<br>1.break;<br>2.break label;</p>\n<p>第一种语法形式用于终止在循环体或者switch的封闭内部；第二种语法形式用于在特定的封闭标签语句。</p>\n<p>示例1：<br>下面的例子中，对一个数组里的元素进行循环处理，直到数组元素下标等于theValue的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[i] == theValue)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例2：中断跳到标签语句<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> z = <span class=\"number\">0</span>;</span><br><span class=\"line\">labelCancelLoops: <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Outer loops:\"</span> + x);</span><br><span class=\"line\">    x += <span class=\"number\">1</span>;</span><br><span class=\"line\">    z = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Inner loops: \"</span>+z);</span><br><span class=\"line\">        z+=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(z === <span class=\"number\">10</span> &amp;&amp; x === <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span> labelCancelLoops;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(z === <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"连续语句-continue-Statement\"><a href=\"#连续语句-continue-Statement\" class=\"headerlink\" title=\"连续语句(continue Statement)\"></a>连续语句(continue Statement)</h2><p>连续语句用于重新开始while,do-while,for语句，或者标签语句(label statement).</p>\n<ul>\n<li>当你使用没有带标签语句的连续语句(continue Statement)时，将在当前的while,do-while或者for循环体封闭的内部语句中止执行，然后进入下一次循环继续执行。与中断语句(break Statement)相比，连续语句不会把整个循环终止。在while循环里，将跳回条件判断(continue)；<br>在for循环里，则调回累计表达式(increment-expression).</li>\n<li><p>当你使用带有标签语句的连续语句时，用于识别循环体中的标签语句。</p>\n<p>连续语句的语法如下：</p>\n<p>1.continue<br>2.continue label</p>\n</li>\n</ul>\n<p>示例1<br>下面的例子实现了一个带有连续语句的while循环，当i的值为3时，该连续语句执行。因此，n的值分别为1、3、7和12。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">0</span>;</span><br><span class=\"line\">n = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">   i++;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (i == <span class=\"number\">3</span>)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">   n += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>示例2<br>一个标签语句checkiandj包含了一个标签语句checkj。如果连续语句被触发，程序会中止在当前循环中的checkj然后开始下一轮循环。每次连续语句被触发，checkj会重复直到该条件判断返回false值。当返回false值时，会完成剩下的checkiandj语句，然后checkiandj会重复直到其条件判断返回false值。当返回false值时，程序会继续执行在checkiandj后面的语句。</p>\n<p>如果连续语句包含的是checkiandj标签，那么程序会在checkiandj语句的顶层继续执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkiandj :</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (i &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.write(i + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">      i += <span class=\"number\">1</span>;</span><br><span class=\"line\">      checkj :</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.write(j + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">            j -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((j % <span class=\"number\">2</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">               <span class=\"keyword\">continue</span> checkj;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.write(j + <span class=\"string\">\" is odd.&lt;br/&gt;\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.write(<span class=\"string\">\"i = \"</span> + i + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.write(<span class=\"string\">\"j = \"</span> + j + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"对象操作语句-Object-Manipulation-Statements\"><a href=\"#对象操作语句-Object-Manipulation-Statements\" class=\"headerlink\" title=\"对象操作语句(Object Manipulation Statements)\"></a>对象操作语句(Object Manipulation Statements)</h2><p>JavaScript用for…in,for each…in和with语句来操作对象。</p>\n<h2 id=\"异常处理语句-Exception-Handling-Statements\"><a href=\"#异常处理语句-Exception-Handling-Statements\" class=\"headerlink\" title=\"异常处理语句(Exception Handling Statements)\"></a>异常处理语句(Exception Handling Statements)</h2><p>你可以用throw语句抛出一个异常并且用try…catch语句捕获处理它。</p>\n<h3 id=\"异常类型-Exception-Types\"><a href=\"#异常类型-Exception-Types\" class=\"headerlink\" title=\"异常类型(Exception Types)\"></a>异常类型(Exception Types)</h3><p>JavaScript可以抛出任意对象。然而，不是所有对象能产生相同的结果。尽管抛出数值或者字母串作为错误信息十分常见，但是通常用下列其中一种异常类型来创建目标更为高效：</p>\n<ul>\n<li>ECMAScript exceptions</li>\n<li>DOMException</li>\n<li>nsIXPCException</li>\n</ul>\n<h3 id=\"抛出错误-throw-Statement\"><a href=\"#抛出错误-throw-Statement\" class=\"headerlink\" title=\"抛出错误(throw Statement)\"></a>抛出错误(throw Statement)</h3><p>使用throw语句抛出一个异常。当你抛出异常，你规定一个含有值的表达式要被抛出。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> expression</span><br></pre></td></tr></table></figure></p>\n<p>你可以抛出任意表达式而不是特定一种类型的表达式。下面的代码抛出了几个不同类型的表达式：</p>\n<ul>\n<li>throw “Error”; //string type</li>\n<li>throw 42;</li>\n<li>throw true;</li>\n<li>throw {toString:function(){return “I’m an object!”}};</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//create an object type UserException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserException</span> (<span class=\"params\">message</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserException\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Make the exception convert to a pretty string when used as a string (e.g. by the error console)</span></span><br><span class=\"line\">UserException.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">': \"'</span> + <span class=\"keyword\">this</span>.message+ <span class=\"string\">'\"'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//create an instance of the object type and throw it</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserException(<span class=\"string\">\"Value too high\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"try…catch语句\"><a href=\"#try…catch语句\" class=\"headerlink\" title=\"try…catch语句\"></a>try…catch语句</h3><p>try…catch语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常抛出。如果我们抛出一个异常，try…catch语句就捕获它。</p>\n<p>try…catch语句有一个包含一条或者多条语句的try代码块，0个或多个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 换句话说，如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。</p>\n<p>下面的例子使用了try…catch语句。示例调用了一个函数用于从一个数组中根据传递值来获取一个月份名称。如果该值与月份数值不相符，会抛出一个带有”InvalidMonthNo”值的异常，然后在捕捉块语句中设monthName变量为unknown。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMonthName</span>(<span class=\"params\">mo</span>) </span>&#123;</span><br><span class=\"line\">  mo = mo - <span class=\"number\">1</span>; <span class=\"comment\">// Adjust month number for array index (1 = Jan, 12 = Dec)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> months = [<span class=\"string\">\"Jan\"</span>,<span class=\"string\">\"Feb\"</span>,<span class=\"string\">\"Mar\"</span>,<span class=\"string\">\"Apr\"</span>,<span class=\"string\">\"May\"</span>,<span class=\"string\">\"Jun\"</span>,<span class=\"string\">\"Jul\"</span>,<span class=\"string\">\"Aug\"</span>,<span class=\"string\">\"Sep\"</span>,<span class=\"string\">\"Oct\"</span>,<span class=\"string\">\"Nov\"</span>,<span class=\"string\">\"Dec\"</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (months[mo]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> months[mo];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"InvalidMonthNo\"</span>; <span class=\"comment\">//throw keyword is used here</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123; <span class=\"comment\">// statements to try</span></span><br><span class=\"line\">  monthName = getMonthName(myMonth); <span class=\"comment\">// function could throw exception</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  monthName = <span class=\"string\">\"unknown\"</span>;</span><br><span class=\"line\">  logMyErrors(e); <span class=\"comment\">// pass exception object to error handler -&gt; your own function</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"捕捉块-The-catch-block\"><a href=\"#捕捉块-The-catch-block\" class=\"headerlink\" title=\"捕捉块(The catch block)\"></a>捕捉块(The catch block)</h3><p>你可以使用捕捉块来处理所有可能在try代码块中产生的异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">catch</span>(catchID)&#123;</span><br><span class=\"line\">        statements</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">捕捉块指定了一个标识符 (上述语句中的catchID）来存放抛出语句指定的值；你可以用这个标识符来获取抛出的异常信息。在插入捕捉块时JavaScript创建这个标识符；标识符只存在于捕捉块的存续期间里；当捕捉块执行完成时，标识符不再可用。</span><br><span class=\"line\"></span><br><span class=\"line\">举个例子，下面代码抛出了一个异常。当异常出现时跳到捕捉块（the <span class=\"keyword\">catch</span> block）。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`javascript</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      throw \"myException\" // generates an exception</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (e) &#123;</span><br><span class=\"line\">   // statements to handle any exceptions</span><br><span class=\"line\">      logMyErrors(e) // pass exception object to error handler</span><br><span class=\"line\">   &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"终结块-The-finally-Block\"><a href=\"#终结块-The-finally-Block\" class=\"headerlink\" title=\"终结块(The finally Block)\"></a>终结块(The finally Block)</h3><p>终结块包含了在try和catch块完成后、下面接着的try…catch语句之前执行的语句。终结块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，终结块里的语句也会执行。</p>\n<p>你可以用终结块来令你的脚本在异常发生时优雅地退出；举个例子，你可能需要在绑定的脚本中释放资源。接下来的例子用文件处理语句打开了一个文件（服务端的JavaScript允许你进入文件）。如果在文件打开时一个异常抛出，终结块会在脚本错误之前关闭文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openMyFile();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    writeMyFile(theData); <span class=\"comment\">//This may throw a error</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">    handleError(e); <span class=\"comment\">// If we got a error we handle it</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    closeMyFile(); <span class=\"comment\">// always close the resource</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果终结块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"bogus\"</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// this return statement is suspended</span></span><br><span class=\"line\">                 <span class=\"comment\">// until finally block has completed</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>); <span class=\"comment\">// not reachable</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// overwrites the previous \"return\"</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>); <span class=\"comment\">// not reachable</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// \"return false\" is executed now  </span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>); <span class=\"comment\">// not reachable</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// console 0, 1, 3; returns false</span></span><br></pre></td></tr></table></figure>\n<p>嵌套try…catch语句</p>\n<p>你可以嵌套一个或多个try…catch语句。如果一个内部的try…catch语句没有捕捉块（catch block），将会启动匹配外部的try…catch语句的捕捉块（catch block）。</p>\n<h2 id=\"错误匹配对象-Utilizing-Error-objects\"><a href=\"#错误匹配对象-Utilizing-Error-objects\" class=\"headerlink\" title=\"错误匹配对象(Utilizing Error objects)\"></a>错误匹配对象(Utilizing Error objects)</h2><p>根据错误类型，你也许可以用’name’和’message’获取更精炼的信息。’name’提供了常规的错误类(e.g., ‘DOMException’ or ‘Error’)，而’message’通常提供了一条从错误对象转换成字符串的简明信息。</p>\n<p>在抛出你个人所为的异常时，为了充分利用那些属性（比如你的catch块不能分辨是你个人所为的异常还是系统的异常时），你可以使用错误构造函数（the Error constructor）。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomethingErrorProne</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ourCodeMakesAMistake()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The message'</span>));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    doSomethingToGetAJavascriptError();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  doSomethingErrorProne();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.name); <span class=\"comment\">// logs 'Error'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.message); <span class=\"comment\">// logs 'The message' or a JavaScript error message)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","excerpt":"","more":"<blockquote>\n<p>Energy and persistence conquer all things.</p>\n</blockquote>\n<p>在JavaScript中，任何表达式(expression)都可以看作一条语句(statement)，每条语句可以使用分号( ; )来分隔。你可以在每行书写一条语句；也可以在一行书写多条语句。但是我们推荐在书写代码的时候采用第一种方式，以便于后期的代码维护。</p>\n<h2 id=\"语句块-Block-Statement\"><a href=\"#语句块-Block-Statement\" class=\"headerlink\" title=\"语句块(Block Statement)\"></a>语句块(Block Statement)</h2><p>大多数程序都使用语句块来给语句分组，这样可以使语句的结构清晰明了。我们使用一对花括号（ {} ）来分组语句块，如下所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   statement_1;   statement_2;</span><br><span class=\"line\">   statement_3;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   statement_n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例<br>语句块通常大多数用于流程控制，如 if, for, while等等。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (x &lt; <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">  x++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里{ x++; } 就是语句块。</p>\n<h2 id=\"条件判断语句-Conditional-Statements\"><a href=\"#条件判断语句-Conditional-Statements\" class=\"headerlink\" title=\"条件判断语句(Conditional Statements)\"></a>条件判断语句(Conditional Statements)</h2><p>条件判断语句指的是根据指定的条件所返回的结果（真或假或其它预定义的），来执行特定的语句。JavaScript提供了两种条件判断语句：if…else 和 switch。</p>\n<h3 id=\"if…else语句\"><a href=\"#if…else语句\" class=\"headerlink\" title=\"if…else语句\"></a>if…else语句</h3><p>当一个逻辑条件为真，用if语句执行一个语句。当这个条件为假，使用可选择的else从句来执行这个语句。</p>\n<p>在条件表达式中最好不要使用“=”来判断条件是否相等，因为这会产生非预期结果。不要使用下面的代码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (x = y) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* do the right thing */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你需要在条件表达式中使用赋值，一个共同的习惯是在赋值语句前后额外的添加一对括号。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((x = y)) &#123;</span><br><span class=\"line\">  <span class=\"comment\">/* do the right thing */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面这些值将被计算出 false:</p>\n<ul>\n<li>false</li>\n<li>undefined</li>\n<li>null</li>\n<li>0</li>\n<li>NaN</li>\n<li>空字符串(“”)<br>当传递给条件语句时，所有其他值，包括所有对象会被计算为 true。</li>\n</ul>\n<p><strong>请不要混淆原始的布尔值true和false与布尔对象的值true和false。</strong>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(b) <span class=\"comment\">//this condition evaluates to true</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(b == <span class=\"literal\">true</span>) <span class=\"comment\">//this condition evaluates to false</span></span><br></pre></td></tr></table></figure></p>\n<p>例如<br>在下面的例子中，如果一个文本对象中的字符串长度是3，函数checkData返回true；否则，函数显示一个alert的弹出框消息并返回false。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkData</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.form1.threeChar.value.length == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"Enter exactly three characters. \"</span> +</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.form1.threeChar.value + <span class=\"string\">\" is not valid.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"switch语句-Switch-Statement\"><a href=\"#switch语句-Switch-Statement\" class=\"headerlink\" title=\"switch语句(Switch Statement)\"></a>switch语句(Switch Statement)</h3><p>开关语句允许一个程序求一个表达式的值并且尝试去匹配表达式的值到一个case label。如果匹配成功，这个程序执行相关的语句。开关语句如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span> (expression) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">case</span> label_1:</span><br><span class=\"line\">      statements_1</span><br><span class=\"line\">      [<span class=\"keyword\">break</span>;]</span><br><span class=\"line\">   <span class=\"keyword\">case</span> label_2:</span><br><span class=\"line\">      statements_2</span><br><span class=\"line\">      [<span class=\"keyword\">break</span>;]</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   default:</span><br><span class=\"line\">      statements_def</span><br><span class=\"line\">      [<span class=\"keyword\">break</span>;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"循环语句-Loop-Statement\"><a href=\"#循环语句-Loop-Statement\" class=\"headerlink\" title=\"循环语句(Loop Statement)\"></a>循环语句(Loop Statement)</h2><p>循环语句是一系列反复执行直到符合特定条件的命令。JavaScript 支持 for, do while, while这些循环语句，还有Label (label 本身不是一个循环语句，但是经常和这些语句一起使用)。另外，你可以在循环语句中使用break和continue 语句。另一个语句：for…in也反复执行语句，但它是用来操作对象的。</p>\n<h3 id=\"标签语句-label-Statement\"><a href=\"#标签语句-label-Statement\" class=\"headerlink\" title=\"标签语句(label Statement)\"></a>标签语句(label Statement)</h3><p>标签语句提供一种使你同一程序的另一处找到它的标识。例如，你可以用一个标签来识别一个循环，并用break或continue语句来说明一个程序是否要中断这个循环或是继续执行。如下所示：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">label:</span><br><span class=\"line\">    statement</span><br></pre></td></tr></table></figure></p>\n<p>label的值可以是js的任何非保留字符标识符。用label标识的语句可以是任何语句。</p>\n<p>例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">markLoop:</span><br><span class=\"line\"><span class=\"keyword\">while</span>(theMark == <span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    doSomething();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"中断语句-break-Statement\"><a href=\"#中断语句-break-Statement\" class=\"headerlink\" title=\"中断语句(break Statement)\"></a>中断语句(break Statement)</h2><p>使用中断语句终止循环、开关或与标签语句连接。</p>\n<ul>\n<li>当你使用没有带标签语句的中断语句（break）时，while,do-while,for或switch封闭的内部语句将立即终止，并转移到后面的语句执行。</li>\n<li><p>当你使用带有标签语句的中断语句(break)时，将终止在特定的标签语句。</p>\n<p>中断语句的语法如下：<br>1.break;<br>2.break label;</p>\n<p>第一种语法形式用于终止在循环体或者switch的封闭内部；第二种语法形式用于在特定的封闭标签语句。</p>\n<p>示例1：<br>下面的例子中，对一个数组里的元素进行循环处理，直到数组元素下标等于theValue的值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>;i&lt;a.length;i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(a[i] == theValue)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例2：中断跳到标签语句<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> z = <span class=\"number\">0</span>;</span><br><span class=\"line\">labelCancelLoops: <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Outer loops:\"</span> + x);</span><br><span class=\"line\">    x += <span class=\"number\">1</span>;</span><br><span class=\"line\">    z = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Inner loops: \"</span>+z);</span><br><span class=\"line\">        z+=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(z === <span class=\"number\">10</span> &amp;&amp; x === <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span> labelCancelLoops;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(z === <span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"连续语句-continue-Statement\"><a href=\"#连续语句-continue-Statement\" class=\"headerlink\" title=\"连续语句(continue Statement)\"></a>连续语句(continue Statement)</h2><p>连续语句用于重新开始while,do-while,for语句，或者标签语句(label statement).</p>\n<ul>\n<li>当你使用没有带标签语句的连续语句(continue Statement)时，将在当前的while,do-while或者for循环体封闭的内部语句中止执行，然后进入下一次循环继续执行。与中断语句(break Statement)相比，连续语句不会把整个循环终止。在while循环里，将跳回条件判断(continue)；<br>在for循环里，则调回累计表达式(increment-expression).</li>\n<li><p>当你使用带有标签语句的连续语句时，用于识别循环体中的标签语句。</p>\n<p>连续语句的语法如下：</p>\n<p>1.continue<br>2.continue label</p>\n</li>\n</ul>\n<p>示例1<br>下面的例子实现了一个带有连续语句的while循环，当i的值为3时，该连续语句执行。因此，n的值分别为1、3、7和12。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = <span class=\"number\">0</span>;</span><br><span class=\"line\">n = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (i &lt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">   i++;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (i == <span class=\"number\">3</span>)</span><br><span class=\"line\">      <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">   n += i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>示例2<br>一个标签语句checkiandj包含了一个标签语句checkj。如果连续语句被触发，程序会中止在当前循环中的checkj然后开始下一轮循环。每次连续语句被触发，checkj会重复直到该条件判断返回false值。当返回false值时，会完成剩下的checkiandj语句，然后checkiandj会重复直到其条件判断返回false值。当返回false值时，程序会继续执行在checkiandj后面的语句。</p>\n<p>如果连续语句包含的是checkiandj标签，那么程序会在checkiandj语句的顶层继续执行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">checkiandj :</span><br><span class=\"line\">   <span class=\"keyword\">while</span> (i &lt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.write(i + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">      i += <span class=\"number\">1</span>;</span><br><span class=\"line\">      checkj :</span><br><span class=\"line\">         <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.write(j + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">            j -= <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((j % <span class=\"number\">2</span>) == <span class=\"number\">0</span>)</span><br><span class=\"line\">               <span class=\"keyword\">continue</span> checkj;</span><br><span class=\"line\">            <span class=\"built_in\">document</span>.write(j + <span class=\"string\">\" is odd.&lt;br/&gt;\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.write(<span class=\"string\">\"i = \"</span> + i + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">      <span class=\"built_in\">document</span>.write(<span class=\"string\">\"j = \"</span> + j + <span class=\"string\">\"&lt;br/&gt;\"</span>);</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"对象操作语句-Object-Manipulation-Statements\"><a href=\"#对象操作语句-Object-Manipulation-Statements\" class=\"headerlink\" title=\"对象操作语句(Object Manipulation Statements)\"></a>对象操作语句(Object Manipulation Statements)</h2><p>JavaScript用for…in,for each…in和with语句来操作对象。</p>\n<h2 id=\"异常处理语句-Exception-Handling-Statements\"><a href=\"#异常处理语句-Exception-Handling-Statements\" class=\"headerlink\" title=\"异常处理语句(Exception Handling Statements)\"></a>异常处理语句(Exception Handling Statements)</h2><p>你可以用throw语句抛出一个异常并且用try…catch语句捕获处理它。</p>\n<h3 id=\"异常类型-Exception-Types\"><a href=\"#异常类型-Exception-Types\" class=\"headerlink\" title=\"异常类型(Exception Types)\"></a>异常类型(Exception Types)</h3><p>JavaScript可以抛出任意对象。然而，不是所有对象能产生相同的结果。尽管抛出数值或者字母串作为错误信息十分常见，但是通常用下列其中一种异常类型来创建目标更为高效：</p>\n<ul>\n<li>ECMAScript exceptions</li>\n<li>DOMException</li>\n<li>nsIXPCException</li>\n</ul>\n<h3 id=\"抛出错误-throw-Statement\"><a href=\"#抛出错误-throw-Statement\" class=\"headerlink\" title=\"抛出错误(throw Statement)\"></a>抛出错误(throw Statement)</h3><p>使用throw语句抛出一个异常。当你抛出异常，你规定一个含有值的表达式要被抛出。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">throw</span> expression</span><br></pre></td></tr></table></figure></p>\n<p>你可以抛出任意表达式而不是特定一种类型的表达式。下面的代码抛出了几个不同类型的表达式：</p>\n<ul>\n<li>throw “Error”; //string type</li>\n<li>throw 42;</li>\n<li>throw true;</li>\n<li>throw {toString:function(){return “I’m an object!”}};</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//create an object type UserException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserException</span> (<span class=\"params\">message</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.message = message;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserException\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//Make the exception convert to a pretty string when used as a string (e.g. by the error console)</span></span><br><span class=\"line\">UserException.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">': \"'</span> + <span class=\"keyword\">this</span>.message+ <span class=\"string\">'\"'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//create an instance of the object type and throw it</span></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserException(<span class=\"string\">\"Value too high\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"try…catch语句\"><a href=\"#try…catch语句\" class=\"headerlink\" title=\"try…catch语句\"></a>try…catch语句</h3><p>try…catch语句标记一块待尝试的语句，并规定一个以上的响应应该有一个异常抛出。如果我们抛出一个异常，try…catch语句就捕获它。</p>\n<p>try…catch语句有一个包含一条或者多条语句的try代码块，0个或多个的catch代码块，catch代码块中的语句会在try代码块中抛出异常时执行。 换句话说，如果你在try代码块中的代码如果没有执行成功，那么你希望将执行流程转入catch代码块。如果try代码块中的语句（或者try 代码块中调用的方法）一旦抛出了异常，那么执行流程会立即进入catch 代码块。如果try代码块没有抛出异常，catch代码块就会被跳过。finally 代码块总会紧跟在try和catch代码块之后执行，但会在try和catch代码块之后的其他代码之前执行。</p>\n<p>下面的例子使用了try…catch语句。示例调用了一个函数用于从一个数组中根据传递值来获取一个月份名称。如果该值与月份数值不相符，会抛出一个带有”InvalidMonthNo”值的异常，然后在捕捉块语句中设monthName变量为unknown。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMonthName</span>(<span class=\"params\">mo</span>) </span>&#123;</span><br><span class=\"line\">  mo = mo - <span class=\"number\">1</span>; <span class=\"comment\">// Adjust month number for array index (1 = Jan, 12 = Dec)</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> months = [<span class=\"string\">\"Jan\"</span>,<span class=\"string\">\"Feb\"</span>,<span class=\"string\">\"Mar\"</span>,<span class=\"string\">\"Apr\"</span>,<span class=\"string\">\"May\"</span>,<span class=\"string\">\"Jun\"</span>,<span class=\"string\">\"Jul\"</span>,<span class=\"string\">\"Aug\"</span>,<span class=\"string\">\"Sep\"</span>,<span class=\"string\">\"Oct\"</span>,<span class=\"string\">\"Nov\"</span>,<span class=\"string\">\"Dec\"</span>];</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (months[mo]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> months[mo];</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"InvalidMonthNo\"</span>; <span class=\"comment\">//throw keyword is used here</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123; <span class=\"comment\">// statements to try</span></span><br><span class=\"line\">  monthName = getMonthName(myMonth); <span class=\"comment\">// function could throw exception</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  monthName = <span class=\"string\">\"unknown\"</span>;</span><br><span class=\"line\">  logMyErrors(e); <span class=\"comment\">// pass exception object to error handler -&gt; your own function</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"捕捉块-The-catch-block\"><a href=\"#捕捉块-The-catch-block\" class=\"headerlink\" title=\"捕捉块(The catch block)\"></a>捕捉块(The catch block)</h3><p>你可以使用捕捉块来处理所有可能在try代码块中产生的异常。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">catch</span>(catchID)&#123;</span><br><span class=\"line\">        statements</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">捕捉块指定了一个标识符 (上述语句中的catchID）来存放抛出语句指定的值；你可以用这个标识符来获取抛出的异常信息。在插入捕捉块时JavaScript创建这个标识符；标识符只存在于捕捉块的存续期间里；当捕捉块执行完成时，标识符不再可用。</span><br><span class=\"line\"></span><br><span class=\"line\">举个例子，下面代码抛出了一个异常。当异常出现时跳到捕捉块（the <span class=\"keyword\">catch</span> block）。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`javascript</span><br><span class=\"line\">   try &#123;</span><br><span class=\"line\">      throw \"myException\" // generates an exception</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   catch (e) &#123;</span><br><span class=\"line\">   // statements to handle any exceptions</span><br><span class=\"line\">      logMyErrors(e) // pass exception object to error handler</span><br><span class=\"line\">   &#125;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"终结块-The-finally-Block\"><a href=\"#终结块-The-finally-Block\" class=\"headerlink\" title=\"终结块(The finally Block)\"></a>终结块(The finally Block)</h3><p>终结块包含了在try和catch块完成后、下面接着的try…catch语句之前执行的语句。终结块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，终结块里的语句也会执行。</p>\n<p>你可以用终结块来令你的脚本在异常发生时优雅地退出；举个例子，你可能需要在绑定的脚本中释放资源。接下来的例子用文件处理语句打开了一个文件（服务端的JavaScript允许你进入文件）。如果在文件打开时一个异常抛出，终结块会在脚本错误之前关闭文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">openMyFile();</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    writeMyFile(theData); <span class=\"comment\">//This may throw a error</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">    handleError(e); <span class=\"comment\">// If we got a error we handle it</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    closeMyFile(); <span class=\"comment\">// always close the resource</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果终结块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"bogus\"</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// this return statement is suspended</span></span><br><span class=\"line\">                 <span class=\"comment\">// until finally block has completed</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>); <span class=\"comment\">// not reachable</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// overwrites the previous \"return\"</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>); <span class=\"comment\">// not reachable</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// \"return false\" is executed now  </span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>); <span class=\"comment\">// not reachable</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f(); <span class=\"comment\">// console 0, 1, 3; returns false</span></span><br></pre></td></tr></table></figure>\n<p>嵌套try…catch语句</p>\n<p>你可以嵌套一个或多个try…catch语句。如果一个内部的try…catch语句没有捕捉块（catch block），将会启动匹配外部的try…catch语句的捕捉块（catch block）。</p>\n<h2 id=\"错误匹配对象-Utilizing-Error-objects\"><a href=\"#错误匹配对象-Utilizing-Error-objects\" class=\"headerlink\" title=\"错误匹配对象(Utilizing Error objects)\"></a>错误匹配对象(Utilizing Error objects)</h2><p>根据错误类型，你也许可以用’name’和’message’获取更精炼的信息。’name’提供了常规的错误类(e.g., ‘DOMException’ or ‘Error’)，而’message’通常提供了一条从错误对象转换成字符串的简明信息。</p>\n<p>在抛出你个人所为的异常时，为了充分利用那些属性（比如你的catch块不能分辨是你个人所为的异常还是系统的异常时），你可以使用错误构造函数（the Error constructor）。比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doSomethingErrorProne</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ourCodeMakesAMistake()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> (<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'The message'</span>));</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    doSomethingToGetAJavascriptError();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">....</span><br><span class=\"line\">try &#123;</span><br><span class=\"line\">  doSomethingErrorProne();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.name); <span class=\"comment\">// logs 'Error'</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(e.message); <span class=\"comment\">// logs 'The message' or a JavaScript error message)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"数组中插入元素","date":"2016-06-20T07:01:12.000Z","_content":"# 在数组中插入元素\n在数组中插入一个元素是我们日常都需要操作的事。当然你可以通过`push`来在一个数组的尾部插入一个元素，或者用`unshift`在数组的开头插入一个元素，或者用`splice`在元素的中间。这些都是被广泛使用的方法，但是这并不意味着我们没有更加高效的方法。比如：\n\n## 在数组的尾部新增一个元素\n在数组的尾部新增一个元素最简单的方法是`push()`，但是还是有其他的方法。\n```javascript\n  var arr = [1,2,3,4,5];\n  var arr2 = [];\n\n  arr.push(6);\n  arr[arr.length] = 6;\n  arr2 = arr.concat([6]);\n```\n上面的方法都能够修改原始的数组。\n### 那我们看看在移动设备上性能比较：  \n\n**Android(v4.2.2)**\n1. arr.push(6);以及arr[arr.length] = 6; 性能是相同的，都是3 319 694 ops/sec\n2. arr2 = arr.concat([6]); 相比较上面的两个方法在性能上慢50.61%\n**Chrome Mobile(v33.0.0)**\n1. arr[arr.length] = 6; //6 125 975 ops/sec\n2. arr.push(6); //慢66.74%\n3. arr2 = arr.concat([6]); //慢87.63%\n**Safari Mobile**\n1. arr[arr.length] = 6; //7 452 898 ops/sec\n2. arr.push(6); //慢40.19%\n3. arr2 = arr.concat([6]); //慢49.78%\n```javascript\n  //最终的比较结果\n  arr[arr.length] = 6; //平均为5 632 856 ops/sec\n  arr.push(6); //慢33.64%\n  arr2 = arr.concat([6]); //慢62.67%\n```\n### 我们再看看在桌面设备上的性能比较  \n\n**Chrome(v48.0.2564)**\n1. arr[arr.length] = 6; //21 602 722 ops/sec\n2. arr.push(6); //慢61.94%\n3. arr2 = arr.concat([6]); //慢87.45%\n**Firefox(v44)**\n1. arr[arr.length] = 6; //56 032 805 ops/sec\n2. arr.push(6); //慢0.52%\n3. arr2 = arr.concat([6]); //慢87.36%\n**IE(v11)**\n1. arr[arr.length] = 6; //67 197 046 ops/sec\n2. arr.push(6); //慢39.61%\n3. arr2 = arr.concat([6]); //慢93.41%\n**Opera(v35.0.2066.68)**\n1. arr[arr.length] = 6; //30 775 071 ops/sec\n2. arr.push(6); //慢71.60%\n3. arr2 = arr.concat([6]); //慢83.70%\n**Safari(v9.0.3)**\n1. arr[arr.length] = 6; //42 670 978 ops/sec\n2. arr.push(6); //慢0.80%\n3. arr2 = arr.concat([6]); //慢76.07%\n```javascript\n //最终的比较结果\n arr[arr.length] = 6; //平均为42 345 449 ops/sec\n arr.push(6); //慢34.66%\n arr2 = arr.concat([6]); //慢85.79%\n```\n\n## 在数组的开头新增一个元素\n现在我们尝试在数组的开头新增一个元素：\n```javascript\n  var arr = [1,2,3,4,5];\n\n  arr.unshift(0);\n  [0].concat(arr);\n```\n### 我们看看在移动设备上的性能比较  \n\n**Android(v4.2.2)**\n1. [0].concat(arr); //1 808 717 ops/sec\n2. arr.unshift(0); //慢97.85%\n**Chrome Mobile(v33.0.0)**\n1. [0].concat(arr); //1 269 498 ops/sec\n2. arr.unshift(0); //慢99.86%\n**Safari Mobile(v9)**\n1. arr.unshift(0); //3 250 184 ops/sec\n2. [0].concat(arr); //慢33.67%\n ```javascript\n  //最终的比较结果\n  [0].concat(arr); //平均为4 972 622 ops/sec\n  arr.unshift(0); //慢64.70%\n ```\n\n### 我们看看在桌面设备上的性能比较  \n\n**Chrome(v48.0.2564)**\n1. [0].concat(arr); //2 656 685 ops/sec\n2. arr.unshift(0); //慢96.77%\n**Firefox(v44)**\n1. [0].concat(arr); //8 039 759 ops/sec\n2. arr.unshift(0); //慢99.72%\n**IE(v11)**\n1. [0].concat(arr); //3 604 226 ops/sec\n2. arr.unshift(0); //慢98.31%\n**Opera(v35.0.2066.68)**\n1. [0].concat(arr); //4 102 128 ops/sec\n2. arr.unshift(0); //慢97.44%\n**Safari(v9.0.3)**\n1. arr.unshift(0); //12 356 477 ops/sec\n2. [0].concat(arr); //慢15.17%\n```javascript\n//最终的比较结果\n[0].concat(arr); //平均为6 032 573 ops/sec\narr.unshift(0); //慢78.65%\n```\n\n## 在数组的中间新增一个元素\n在数组中间新增一个元素的最简单的方法是`splice`，并且用它是最高效的方法。\n```javascript\n  var items = ['one','two','three','four'];\n  items.splice(item.length/2, 0, 'hello');\n```\n我尝试在各个不同类型的浏览器和移动设备中进行了测试，结果是类似的。我希望这些tips能够对你有所帮助并且鼓励你也尝试自己做这些尝试。\n","source":"_posts/数组中插入元素.md","raw":"---\ntitle: 数组中插入元素\ndate: 2016-06-20 15:01:12\ntags:\n  - javascript\n  - tips\ncategories: 翻译\n---\n# 在数组中插入元素\n在数组中插入一个元素是我们日常都需要操作的事。当然你可以通过`push`来在一个数组的尾部插入一个元素，或者用`unshift`在数组的开头插入一个元素，或者用`splice`在元素的中间。这些都是被广泛使用的方法，但是这并不意味着我们没有更加高效的方法。比如：\n\n## 在数组的尾部新增一个元素\n在数组的尾部新增一个元素最简单的方法是`push()`，但是还是有其他的方法。\n```javascript\n  var arr = [1,2,3,4,5];\n  var arr2 = [];\n\n  arr.push(6);\n  arr[arr.length] = 6;\n  arr2 = arr.concat([6]);\n```\n上面的方法都能够修改原始的数组。\n### 那我们看看在移动设备上性能比较：  \n\n**Android(v4.2.2)**\n1. arr.push(6);以及arr[arr.length] = 6; 性能是相同的，都是3 319 694 ops/sec\n2. arr2 = arr.concat([6]); 相比较上面的两个方法在性能上慢50.61%\n**Chrome Mobile(v33.0.0)**\n1. arr[arr.length] = 6; //6 125 975 ops/sec\n2. arr.push(6); //慢66.74%\n3. arr2 = arr.concat([6]); //慢87.63%\n**Safari Mobile**\n1. arr[arr.length] = 6; //7 452 898 ops/sec\n2. arr.push(6); //慢40.19%\n3. arr2 = arr.concat([6]); //慢49.78%\n```javascript\n  //最终的比较结果\n  arr[arr.length] = 6; //平均为5 632 856 ops/sec\n  arr.push(6); //慢33.64%\n  arr2 = arr.concat([6]); //慢62.67%\n```\n### 我们再看看在桌面设备上的性能比较  \n\n**Chrome(v48.0.2564)**\n1. arr[arr.length] = 6; //21 602 722 ops/sec\n2. arr.push(6); //慢61.94%\n3. arr2 = arr.concat([6]); //慢87.45%\n**Firefox(v44)**\n1. arr[arr.length] = 6; //56 032 805 ops/sec\n2. arr.push(6); //慢0.52%\n3. arr2 = arr.concat([6]); //慢87.36%\n**IE(v11)**\n1. arr[arr.length] = 6; //67 197 046 ops/sec\n2. arr.push(6); //慢39.61%\n3. arr2 = arr.concat([6]); //慢93.41%\n**Opera(v35.0.2066.68)**\n1. arr[arr.length] = 6; //30 775 071 ops/sec\n2. arr.push(6); //慢71.60%\n3. arr2 = arr.concat([6]); //慢83.70%\n**Safari(v9.0.3)**\n1. arr[arr.length] = 6; //42 670 978 ops/sec\n2. arr.push(6); //慢0.80%\n3. arr2 = arr.concat([6]); //慢76.07%\n```javascript\n //最终的比较结果\n arr[arr.length] = 6; //平均为42 345 449 ops/sec\n arr.push(6); //慢34.66%\n arr2 = arr.concat([6]); //慢85.79%\n```\n\n## 在数组的开头新增一个元素\n现在我们尝试在数组的开头新增一个元素：\n```javascript\n  var arr = [1,2,3,4,5];\n\n  arr.unshift(0);\n  [0].concat(arr);\n```\n### 我们看看在移动设备上的性能比较  \n\n**Android(v4.2.2)**\n1. [0].concat(arr); //1 808 717 ops/sec\n2. arr.unshift(0); //慢97.85%\n**Chrome Mobile(v33.0.0)**\n1. [0].concat(arr); //1 269 498 ops/sec\n2. arr.unshift(0); //慢99.86%\n**Safari Mobile(v9)**\n1. arr.unshift(0); //3 250 184 ops/sec\n2. [0].concat(arr); //慢33.67%\n ```javascript\n  //最终的比较结果\n  [0].concat(arr); //平均为4 972 622 ops/sec\n  arr.unshift(0); //慢64.70%\n ```\n\n### 我们看看在桌面设备上的性能比较  \n\n**Chrome(v48.0.2564)**\n1. [0].concat(arr); //2 656 685 ops/sec\n2. arr.unshift(0); //慢96.77%\n**Firefox(v44)**\n1. [0].concat(arr); //8 039 759 ops/sec\n2. arr.unshift(0); //慢99.72%\n**IE(v11)**\n1. [0].concat(arr); //3 604 226 ops/sec\n2. arr.unshift(0); //慢98.31%\n**Opera(v35.0.2066.68)**\n1. [0].concat(arr); //4 102 128 ops/sec\n2. arr.unshift(0); //慢97.44%\n**Safari(v9.0.3)**\n1. arr.unshift(0); //12 356 477 ops/sec\n2. [0].concat(arr); //慢15.17%\n```javascript\n//最终的比较结果\n[0].concat(arr); //平均为6 032 573 ops/sec\narr.unshift(0); //慢78.65%\n```\n\n## 在数组的中间新增一个元素\n在数组中间新增一个元素的最简单的方法是`splice`，并且用它是最高效的方法。\n```javascript\n  var items = ['one','two','three','four'];\n  items.splice(item.length/2, 0, 'hello');\n```\n我尝试在各个不同类型的浏览器和移动设备中进行了测试，结果是类似的。我希望这些tips能够对你有所帮助并且鼓励你也尝试自己做这些尝试。\n","slug":"数组中插入元素","published":1,"updated":"2016-06-20T08:10:48.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enq0024b0dl3yz1g4t5","content":"<h1 id=\"在数组中插入元素\"><a href=\"#在数组中插入元素\" class=\"headerlink\" title=\"在数组中插入元素\"></a>在数组中插入元素</h1><p>在数组中插入一个元素是我们日常都需要操作的事。当然你可以通过<code>push</code>来在一个数组的尾部插入一个元素，或者用<code>unshift</code>在数组的开头插入一个元素，或者用<code>splice</code>在元素的中间。这些都是被广泛使用的方法，但是这并不意味着我们没有更加高效的方法。比如：</p>\n<h2 id=\"在数组的尾部新增一个元素\"><a href=\"#在数组的尾部新增一个元素\" class=\"headerlink\" title=\"在数组的尾部新增一个元素\"></a>在数组的尾部新增一个元素</h2><p>在数组的尾部新增一个元素最简单的方法是<code>push()</code>，但是还是有其他的方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.push(<span class=\"number\">6</span>);</span><br><span class=\"line\">arr[arr.length] = <span class=\"number\">6</span>;</span><br><span class=\"line\">arr2 = arr.concat([<span class=\"number\">6</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法都能够修改原始的数组。</p>\n<h3 id=\"那我们看看在移动设备上性能比较：\"><a href=\"#那我们看看在移动设备上性能比较：\" class=\"headerlink\" title=\"那我们看看在移动设备上性能比较：\"></a>那我们看看在移动设备上性能比较：</h3><p><strong>Android(v4.2.2)</strong></p>\n<ol>\n<li>arr.push(6);以及arr[arr.length] = 6; 性能是相同的，都是3 319 694 ops/sec</li>\n<li>arr2 = arr.concat([6]); 相比较上面的两个方法在性能上慢50.61%<br><strong>Chrome Mobile(v33.0.0)</strong></li>\n<li>arr[arr.length] = 6; //6 125 975 ops/sec</li>\n<li>arr.push(6); //慢66.74%</li>\n<li>arr2 = arr.concat([6]); //慢87.63%<br><strong>Safari Mobile</strong></li>\n<li>arr[arr.length] = 6; //7 452 898 ops/sec</li>\n<li>arr.push(6); //慢40.19%</li>\n<li>arr2 = arr.concat([6]); //慢49.78%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">arr[arr.length] = <span class=\"number\">6</span>; <span class=\"comment\">//平均为5 632 856 ops/sec</span></span><br><span class=\"line\">arr.push(<span class=\"number\">6</span>); <span class=\"comment\">//慢33.64%</span></span><br><span class=\"line\">arr2 = arr.concat([<span class=\"number\">6</span>]); <span class=\"comment\">//慢62.67%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"我们再看看在桌面设备上的性能比较\"><a href=\"#我们再看看在桌面设备上的性能比较\" class=\"headerlink\" title=\"我们再看看在桌面设备上的性能比较\"></a>我们再看看在桌面设备上的性能比较</h3><p><strong>Chrome(v48.0.2564)</strong></p>\n<ol>\n<li>arr[arr.length] = 6; //21 602 722 ops/sec</li>\n<li>arr.push(6); //慢61.94%</li>\n<li>arr2 = arr.concat([6]); //慢87.45%<br><strong>Firefox(v44)</strong></li>\n<li>arr[arr.length] = 6; //56 032 805 ops/sec</li>\n<li>arr.push(6); //慢0.52%</li>\n<li>arr2 = arr.concat([6]); //慢87.36%<br><strong>IE(v11)</strong></li>\n<li>arr[arr.length] = 6; //67 197 046 ops/sec</li>\n<li>arr.push(6); //慢39.61%</li>\n<li>arr2 = arr.concat([6]); //慢93.41%<br><strong>Opera(v35.0.2066.68)</strong></li>\n<li>arr[arr.length] = 6; //30 775 071 ops/sec</li>\n<li>arr.push(6); //慢71.60%</li>\n<li>arr2 = arr.concat([6]); //慢83.70%<br><strong>Safari(v9.0.3)</strong></li>\n<li>arr[arr.length] = 6; //42 670 978 ops/sec</li>\n<li>arr.push(6); //慢0.80%</li>\n<li>arr2 = arr.concat([6]); //慢76.07%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">arr[arr.length] = <span class=\"number\">6</span>; <span class=\"comment\">//平均为42 345 449 ops/sec</span></span><br><span class=\"line\">arr.push(<span class=\"number\">6</span>); <span class=\"comment\">//慢34.66%</span></span><br><span class=\"line\">arr2 = arr.concat([<span class=\"number\">6</span>]); <span class=\"comment\">//慢85.79%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在数组的开头新增一个元素\"><a href=\"#在数组的开头新增一个元素\" class=\"headerlink\" title=\"在数组的开头新增一个元素\"></a>在数组的开头新增一个元素</h2><p>现在我们尝试在数组的开头新增一个元素：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.unshift(<span class=\"number\">0</span>);</span><br><span class=\"line\">[<span class=\"number\">0</span>].concat(arr);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"我们看看在移动设备上的性能比较\"><a href=\"#我们看看在移动设备上的性能比较\" class=\"headerlink\" title=\"我们看看在移动设备上的性能比较\"></a>我们看看在移动设备上的性能比较</h3><p><strong>Android(v4.2.2)</strong></p>\n<ol>\n<li>[0].concat(arr); //1 808 717 ops/sec</li>\n<li>arr.unshift(0); //慢97.85%<br><strong>Chrome Mobile(v33.0.0)</strong></li>\n<li>[0].concat(arr); //1 269 498 ops/sec</li>\n<li>arr.unshift(0); //慢99.86%<br><strong>Safari Mobile(v9)</strong></li>\n<li>arr.unshift(0); //3 250 184 ops/sec</li>\n<li>[0].concat(arr); //慢33.67%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">[<span class=\"number\">0</span>].concat(arr); <span class=\"comment\">//平均为4 972 622 ops/sec</span></span><br><span class=\"line\">arr.unshift(<span class=\"number\">0</span>); <span class=\"comment\">//慢64.70%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"我们看看在桌面设备上的性能比较\"><a href=\"#我们看看在桌面设备上的性能比较\" class=\"headerlink\" title=\"我们看看在桌面设备上的性能比较\"></a>我们看看在桌面设备上的性能比较</h3><p><strong>Chrome(v48.0.2564)</strong></p>\n<ol>\n<li>[0].concat(arr); //2 656 685 ops/sec</li>\n<li>arr.unshift(0); //慢96.77%<br><strong>Firefox(v44)</strong></li>\n<li>[0].concat(arr); //8 039 759 ops/sec</li>\n<li>arr.unshift(0); //慢99.72%<br><strong>IE(v11)</strong></li>\n<li>[0].concat(arr); //3 604 226 ops/sec</li>\n<li>arr.unshift(0); //慢98.31%<br><strong>Opera(v35.0.2066.68)</strong></li>\n<li>[0].concat(arr); //4 102 128 ops/sec</li>\n<li>arr.unshift(0); //慢97.44%<br><strong>Safari(v9.0.3)</strong></li>\n<li>arr.unshift(0); //12 356 477 ops/sec</li>\n<li>[0].concat(arr); //慢15.17%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">[<span class=\"number\">0</span>].concat(arr); <span class=\"comment\">//平均为6 032 573 ops/sec</span></span><br><span class=\"line\">arr.unshift(<span class=\"number\">0</span>); <span class=\"comment\">//慢78.65%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在数组的中间新增一个元素\"><a href=\"#在数组的中间新增一个元素\" class=\"headerlink\" title=\"在数组的中间新增一个元素\"></a>在数组的中间新增一个元素</h2><p>在数组中间新增一个元素的最简单的方法是<code>splice</code>，并且用它是最高效的方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"string\">'one'</span>,<span class=\"string\">'two'</span>,<span class=\"string\">'three'</span>,<span class=\"string\">'four'</span>];</span><br><span class=\"line\">items.splice(item.length/<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"string\">'hello'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>我尝试在各个不同类型的浏览器和移动设备中进行了测试，结果是类似的。我希望这些tips能够对你有所帮助并且鼓励你也尝试自己做这些尝试。</p>\n","excerpt":"","more":"<h1 id=\"在数组中插入元素\"><a href=\"#在数组中插入元素\" class=\"headerlink\" title=\"在数组中插入元素\"></a>在数组中插入元素</h1><p>在数组中插入一个元素是我们日常都需要操作的事。当然你可以通过<code>push</code>来在一个数组的尾部插入一个元素，或者用<code>unshift</code>在数组的开头插入一个元素，或者用<code>splice</code>在元素的中间。这些都是被广泛使用的方法，但是这并不意味着我们没有更加高效的方法。比如：</p>\n<h2 id=\"在数组的尾部新增一个元素\"><a href=\"#在数组的尾部新增一个元素\" class=\"headerlink\" title=\"在数组的尾部新增一个元素\"></a>在数组的尾部新增一个元素</h2><p>在数组的尾部新增一个元素最简单的方法是<code>push()</code>，但是还是有其他的方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.push(<span class=\"number\">6</span>);</span><br><span class=\"line\">arr[arr.length] = <span class=\"number\">6</span>;</span><br><span class=\"line\">arr2 = arr.concat([<span class=\"number\">6</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>上面的方法都能够修改原始的数组。</p>\n<h3 id=\"那我们看看在移动设备上性能比较：\"><a href=\"#那我们看看在移动设备上性能比较：\" class=\"headerlink\" title=\"那我们看看在移动设备上性能比较：\"></a>那我们看看在移动设备上性能比较：</h3><p><strong>Android(v4.2.2)</strong></p>\n<ol>\n<li>arr.push(6);以及arr[arr.length] = 6; 性能是相同的，都是3 319 694 ops/sec</li>\n<li>arr2 = arr.concat([6]); 相比较上面的两个方法在性能上慢50.61%<br><strong>Chrome Mobile(v33.0.0)</strong></li>\n<li>arr[arr.length] = 6; //6 125 975 ops/sec</li>\n<li>arr.push(6); //慢66.74%</li>\n<li>arr2 = arr.concat([6]); //慢87.63%<br><strong>Safari Mobile</strong></li>\n<li>arr[arr.length] = 6; //7 452 898 ops/sec</li>\n<li>arr.push(6); //慢40.19%</li>\n<li>arr2 = arr.concat([6]); //慢49.78%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">arr[arr.length] = <span class=\"number\">6</span>; <span class=\"comment\">//平均为5 632 856 ops/sec</span></span><br><span class=\"line\">arr.push(<span class=\"number\">6</span>); <span class=\"comment\">//慢33.64%</span></span><br><span class=\"line\">arr2 = arr.concat([<span class=\"number\">6</span>]); <span class=\"comment\">//慢62.67%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"我们再看看在桌面设备上的性能比较\"><a href=\"#我们再看看在桌面设备上的性能比较\" class=\"headerlink\" title=\"我们再看看在桌面设备上的性能比较\"></a>我们再看看在桌面设备上的性能比较</h3><p><strong>Chrome(v48.0.2564)</strong></p>\n<ol>\n<li>arr[arr.length] = 6; //21 602 722 ops/sec</li>\n<li>arr.push(6); //慢61.94%</li>\n<li>arr2 = arr.concat([6]); //慢87.45%<br><strong>Firefox(v44)</strong></li>\n<li>arr[arr.length] = 6; //56 032 805 ops/sec</li>\n<li>arr.push(6); //慢0.52%</li>\n<li>arr2 = arr.concat([6]); //慢87.36%<br><strong>IE(v11)</strong></li>\n<li>arr[arr.length] = 6; //67 197 046 ops/sec</li>\n<li>arr.push(6); //慢39.61%</li>\n<li>arr2 = arr.concat([6]); //慢93.41%<br><strong>Opera(v35.0.2066.68)</strong></li>\n<li>arr[arr.length] = 6; //30 775 071 ops/sec</li>\n<li>arr.push(6); //慢71.60%</li>\n<li>arr2 = arr.concat([6]); //慢83.70%<br><strong>Safari(v9.0.3)</strong></li>\n<li>arr[arr.length] = 6; //42 670 978 ops/sec</li>\n<li>arr.push(6); //慢0.80%</li>\n<li>arr2 = arr.concat([6]); //慢76.07%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">arr[arr.length] = <span class=\"number\">6</span>; <span class=\"comment\">//平均为42 345 449 ops/sec</span></span><br><span class=\"line\">arr.push(<span class=\"number\">6</span>); <span class=\"comment\">//慢34.66%</span></span><br><span class=\"line\">arr2 = arr.concat([<span class=\"number\">6</span>]); <span class=\"comment\">//慢85.79%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在数组的开头新增一个元素\"><a href=\"#在数组的开头新增一个元素\" class=\"headerlink\" title=\"在数组的开头新增一个元素\"></a>在数组的开头新增一个元素</h2><p>现在我们尝试在数组的开头新增一个元素：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">arr.unshift(<span class=\"number\">0</span>);</span><br><span class=\"line\">[<span class=\"number\">0</span>].concat(arr);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"我们看看在移动设备上的性能比较\"><a href=\"#我们看看在移动设备上的性能比较\" class=\"headerlink\" title=\"我们看看在移动设备上的性能比较\"></a>我们看看在移动设备上的性能比较</h3><p><strong>Android(v4.2.2)</strong></p>\n<ol>\n<li>[0].concat(arr); //1 808 717 ops/sec</li>\n<li>arr.unshift(0); //慢97.85%<br><strong>Chrome Mobile(v33.0.0)</strong></li>\n<li>[0].concat(arr); //1 269 498 ops/sec</li>\n<li>arr.unshift(0); //慢99.86%<br><strong>Safari Mobile(v9)</strong></li>\n<li>arr.unshift(0); //3 250 184 ops/sec</li>\n<li>[0].concat(arr); //慢33.67%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">[<span class=\"number\">0</span>].concat(arr); <span class=\"comment\">//平均为4 972 622 ops/sec</span></span><br><span class=\"line\">arr.unshift(<span class=\"number\">0</span>); <span class=\"comment\">//慢64.70%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"我们看看在桌面设备上的性能比较\"><a href=\"#我们看看在桌面设备上的性能比较\" class=\"headerlink\" title=\"我们看看在桌面设备上的性能比较\"></a>我们看看在桌面设备上的性能比较</h3><p><strong>Chrome(v48.0.2564)</strong></p>\n<ol>\n<li>[0].concat(arr); //2 656 685 ops/sec</li>\n<li>arr.unshift(0); //慢96.77%<br><strong>Firefox(v44)</strong></li>\n<li>[0].concat(arr); //8 039 759 ops/sec</li>\n<li>arr.unshift(0); //慢99.72%<br><strong>IE(v11)</strong></li>\n<li>[0].concat(arr); //3 604 226 ops/sec</li>\n<li>arr.unshift(0); //慢98.31%<br><strong>Opera(v35.0.2066.68)</strong></li>\n<li>[0].concat(arr); //4 102 128 ops/sec</li>\n<li>arr.unshift(0); //慢97.44%<br><strong>Safari(v9.0.3)</strong></li>\n<li>arr.unshift(0); //12 356 477 ops/sec</li>\n<li>[0].concat(arr); //慢15.17%<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最终的比较结果</span></span><br><span class=\"line\">[<span class=\"number\">0</span>].concat(arr); <span class=\"comment\">//平均为6 032 573 ops/sec</span></span><br><span class=\"line\">arr.unshift(<span class=\"number\">0</span>); <span class=\"comment\">//慢78.65%</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"在数组的中间新增一个元素\"><a href=\"#在数组的中间新增一个元素\" class=\"headerlink\" title=\"在数组的中间新增一个元素\"></a>在数组的中间新增一个元素</h2><p>在数组中间新增一个元素的最简单的方法是<code>splice</code>，并且用它是最高效的方法。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> items = [<span class=\"string\">'one'</span>,<span class=\"string\">'two'</span>,<span class=\"string\">'three'</span>,<span class=\"string\">'four'</span>];</span><br><span class=\"line\">items.splice(item.length/<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"string\">'hello'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>我尝试在各个不同类型的浏览器和移动设备中进行了测试，结果是类似的。我希望这些tips能够对你有所帮助并且鼓励你也尝试自己做这些尝试。</p>\n"},{"title":"用卡通图介绍Redux","date":"2016-05-30T08:25:43.000Z","_content":"> 本文翻译自[A cartoon intro to Redux](https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6#.p3894jxov)\n\n![页面效果图](/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png)\n\n//todo\n","source":"_posts/用卡通图介绍Redux.md","raw":"---\ntitle: 用卡通图介绍Redux\ndate: 2016-05-30 16:25:43\ntags:\n  - react\n  - Redux\ncategories: 翻译\n---\n> 本文翻译自[A cartoon intro to Redux](https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6#.p3894jxov)\n\n![页面效果图](/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png)\n\n//todo\n","slug":"用卡通图介绍Redux","published":1,"updated":"2016-05-30T08:36:30.020Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enr0028b0dlnjqmj27o","content":"<blockquote>\n<p>本文翻译自<a href=\"https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6#.p3894jxov\" target=\"_blank\" rel=\"external\">A cartoon intro to Redux</a></p>\n</blockquote>\n<p><img src=\"/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png\" alt=\"页面效果图\"></p>\n<p>//todo</p>\n","excerpt":"","more":"<blockquote>\n<p>本文翻译自<a href=\"https://code-cartoons.com/a-cartoon-intro-to-redux-3afb775501a6#.p3894jxov\">A cartoon intro to Redux</a></p>\n</blockquote>\n<p><img src=\"/images/react/1-dODKUGyGkF8qeGLrXKWkiA.png\" alt=\"页面效果图\"></p>\n<p>//todo</p>\n"},{"title":"深入理解Redux的Middleware","date":"2016-05-26T06:22:35.000Z","_content":"> 文章转载自[深入理解Redux的Middleware](http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redux%E7%9A%84Middleware.html)，仅供学习和参考\n\n# 1. 中间件\nRedux最有趣的一个概念是它允许你通过自定义的中间件来影响你store的dispatch逻辑。\n> “中间件”这个词听起来很恐怖，但它实际一点都不难。想更好的了解中间件的方法就是看一下那些已经实现了的中间件是怎么工作的，然后尝试自己写一个。函数嵌套写法看起来很恐怖，但是大多数你能找到的中间件，代码都不超过十行，但是它们的强大来自于它们的可嵌套组合性。\n\n区区十行的中间件很容易写，但是你要想明白它们是如何放入中间件调用链，又是如何影响store的dispatch方法的，还真需要一些经验。首先让我们来简单定义一下中间件到底是个啥，并且找一些简单的中间件看一下他们的具体实现方式。关于中间件的定义我能找到的最简单的描述是：\n> 中间件主要被用于分离那些不属于你应用的核心业务逻辑，可以被组合起来使用的代码\n\nRedux的中间件主要用于store的dispatch的函数上。dispatch函数的作用是发送actions给一个或多个reducer来影响应用状态。中间件可以增强默认的dispatch函数，我们来看一下Redux 1.0.1版本的applyMiddleware源码：\n```javascript\n  export default function applyMiddleware(...middlewares){\n    return (next) => (reducer, initialStare) => {\n      var store = next(reducer, initialStare);\n      var dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: (action) => dispatch(action)\n      };\n\n      chain = middlewares.map(middleware => middleware(middlewareAPI));\n      dispatch = compose(...chain, store.dispatch);\n      return {\n        ...store,\n        dispatch\n      }\n    }\n  }\n```\n\n就这几行代码，跟着敲一下也就一会儿时间，但是什么鬼，完全看不懂。因为里面用了很多的函数式编程的思想，包括：高阶函数、复合函数、珂理化和ES6语法。关于函数式编程思想，我也转载了不少文章，但理解起来需要花点时间。\n\n# 2. 函数式编程概念\n在开始阅读Redux中间件源码之前，你需要先掌握一些函数式编程知识。\n## 2.1 复合函数\n函数式编程是非常理论和非常数学化的。用数学的视角来解释复合函数，如下：\n```javascript\n  given:\n    f(x) = x^2 + 3*x + 1\n    g(x) = 2*x\n  then:\n     (f ∘ g)(x) = f(g(x)) = f(2*x) = 4*x^2 + 6*x + 1\n```\n你可以将上面的方式扩展到组合两个或更多个函数这都是可以的。我们再来看个例子，演示组合两个函数并返回一个新的函数：\n```javascript\n  var greet = function(x){ return `Hello, ${x}` };\n  var emote = function(x){ return `${x}` };\n\n  var compose = function(f,g){\n    return function(x){\n      return f(g(x));\n    }\n  }\n\n  var happyGreeting = compose(green, emote);\n  //happyGreeting(\"Mark\") -> Hello,Mark\n```\n\n## 2.2 珂理化\n珂理化是这样一个过程：它把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数的参数。正式的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每一个函数只有一个参数。\n```javascript\n  var curriedAdd = function(a){\n    return function(b){\n      return a + b;\n    }\n  };\n\n  var addTen = curriedAdd(10);\n  addTen(10); //20\n```\n通过珂理化来组合你的函数，你可以创建一个强大的数据处理管道。\n\n# 3. Redux的dispatch函数\nRedux的Store有一个dispatch函数，它关注你的应用实现的业务逻辑。你可以用它指派actions到你定义的reducer函数，用以更新你的应用状态。Redux的reducer函数接受一个当前状态参数和一个action参数，并返回一个新的状态对象：\n`\n  reducer:: state -> action -> state\n`\n指派给action很像发送消息，如果我们假设要从一个列表中删除某个元素，action结构一般如下：\n`\n  {type: types.DELETE_ITEM, id:1 }\n`\nstore会指派这个action对象到它所拥有的所有reducer函数来影响应用的状态，然而只有关注删除逻辑的reducer会真的修改状态。在此期间没人会关注到底是谁修改了状态，花了多长时间，或者记录一下变更前后的状态数据镜像。这些非核心关注点都可以交给中间件来完成。\n\n# 4. Redux Middleware\nRedux中间件被设计成可组合的，会在dispatch方法之前调用的函数。让我们来创建一个简单的日志中间件，他会简单的输出dispatch前后的应用状态。Redux中间件的签名如下：\n`\nMiddleware:: next -> action -> retVal\n`\n我们的logger中间件实现如下：\n```javascript\n  export default function createLogger({getState}){\n    return (next) => (action) => {\n      const console = window.console;\n      const prevState = getState();\n      const returnValue = next(action);\n      const nextState = getState();\n      const actionType = String(action.type);\n      const message = `action ${actionType}`;\n\n      console.log(`%c prev state`, `color: #9E9E9E`, prevState);\n      console.log(`%c action`, `color: #03A9F4`, action);\n      console.log(`%c next state`, `color: #4CAF50`, nextState);\n      return returnValue;\n    }\n  }\n```\n注意，我们的createLogger接受的getState方法是由applyMiddleware.js注入进来的。使用它可以在内部的闭包中得到应用的当前状态。最后我们返回调用next创建的函数作为结果。next方法用于维护中间件调用链和dispatch，它返回一个接受action对象的柯里化函数，接受的action对象可以在中间件中被修改，再传递给下一个被调用的中间件，最终dispatch会使用中间件修改后的action来执行。\n\n我们来看看上面的logger中间件的业务流程：\n1. 得到当前的应用状态\n2. 将action指派给下一个中间件\n3. 调用链下游的中间件全部被执行\n4. store中的匹配reducer被执行\n5. 此时得到新的应用状态\n\n# 5. 剖析applyMiddleware.js\n下面让我们一步步分析applyMiddleware.js源码，applyMiddleware可能应该起一个更好一点的名字，applyMiddlewareToStore。\n首先我们看一下方法的签名：\n`\n  export default function applyMiddleware(...middlewares)\n`\n注意这里有个很有趣的写法，参数：...middlewares，这么定义允许我们调用时传入任意个数的中间件函数作为参数。接下来函数将返回一个接受next作为参数的函数：\n`\n  return (next) => (reducer,initialStare) => {...}\n`\nnext参数是一个被用来创建store的函数，你可以看一下createStore.js源码的实现细节。最后这个函数返回一个类似createStore的函数，不同的是它包含一个有中间件加工过的dispatch实现。\n\n接下来我们通过调用next拿到store对象。我们用一个变量保存原始的dispatch函数，最后我们申明一个数组来存储我们创建的中间件链：\n```javascript\n  var store = next(reducer, initialStare);\n  var dispatch = store.dispatch;\n  var chain = [];\n```\n\n接下来的代码将getState 和调用原始的dispatch函数注入给所有的中间件：\n```javascript\n  var middlewareAPI = {\n    getState: store.getState,\n    dispatch: (action) => dispatch(action)\n  };\n\n  chain = middlewares.map(middleware => middleware(middlewareAPI));\n```\n\n然后我们根据中间件链创建一个加工过的dispatch实现：\n```javascript\n  dispatch = compose(...chain, store.dispatch);\n```\n\n最精妙的地方就是上面这行，Redux提供的compose工具函数组合了我们的中间件链，compose实现如下：\n```javascript\n  export default function compose(...funcs){\n    return funcs.reduceRight((compose, f) => f(compose));\n  }\n```\n\n碉堡了！上面的代码展示了中间件调用链是如何创建出来的。中间件调用链的顺序很重要，调用链类似下面这样：\n```javascript\n  middlewareI(middlewareJ(middlewareK(store.dispatch)))(action)\n```\n\n现在我们知道为啥我们要掌握复合函数和珂理化概念了。最后我们只需要将新的store和调整过的dispatch函数返回即可：\n```javascript\n  return {\n    ...store,\n    dispatch\n  };\n```\n\n上面这种写法的意思是返回一个对象，该对象拥有store的所有属性，并增加一个dispatch函数属性，store里自带的那个原始dispatch函数会被覆盖。这种写法会被Babel转化成：\n```javascript\n  return _extends({}, store, {dispatch : _dispatch});\n```\n\n现在让我们将我们的logger中间件注入到dispatch中：\n```javascript\n  import { createStore, applyMiddleware } from 'redux';\n  import loggerMiddleware from 'logger';\n  import rootReducer from '../reducers';\n\n  const createStoreWithMiddleware = applyMiddleware(loggerMiddleware)(createStore);\n\n  export default function configureStore(initialStare){\n    return createStoreWithMiddleware(rootReducer, initialStare);\n  }\n\n  const store = configureStore();\n```\n\n# 6. 异步中间件\n我们已经会写基础的中间件了，我们就要玩更高深的，整个能处理异步action的中间件咋样？让我们来看一下redux-thunk的更多细节。我们假设有一个包含异步请求的action，如下：\n```javascript\n  function fetchQuote(symbol){\n    requestQuote(symbol);\n    return fetch(`http://www.google.com/finance/info?q=${symbol}`)\n            .then(req => req.json())\n            .then(json => showCurrentQuote(symbol,json));\n  }\n```\n\n上面的代码并没有明显的调用dispatch来分派一个返回promise的action，我们需要使用redux-thunk中间件来延迟dispatch的执行：\n```javascript\n  function fetchQuote(symbol){\n    return dispatch => {\n      dispatch(requestQuote(symbol));\n      return fetch(`http://www.google.com/finance/info?${symbol}`)\n              .then(req => req.json())\n              .then(json => dispatch(showCurrentQuote(symbol, json)));\n    }\n  }\n```\n\n注意这里的dispatch和getState是由applyMiddleware函数注入进来的。现在我们就可以分派最终得到的action对象到store的reducers了。下面是类似redux-thunk的实现：\n```javascript\n  export default function thunkMiddleware({ dispatch, getState}){\n    return next => action => typeof action === 'function' ? action(dispatch,getState) : next(action);\n  }\n```\n\n这个和你之前看到的中间件没什么太大不同。如果得到的action是个函数，就用dispatch和getState当作参数来调用它，否则就直接分派给store。你可以看一下Redux提供的更详细的异步示例。另外还有一个支持promise的中间件是redux-promise。\n\n# 7. 使用middleware实现异步action和异步数据流\nredux的生态在持续的完善，其中就有不少的middleware供开发者使用，同时大家也可以实现自己的middleware。\n现在让我们来使用以下两个中间件来完成一个示例：\n\n - redux-thunk -- Redux-Thunk可以让你的action creator返回一个function而不是action。这可以用于延迟dispatch一个action或是在特定条件下dispatch才触发。他的内部函数接受store的dispatch和getState方法作为参数。\n - redux-logger -- Redux-Logger的用处很明显，就是用于记录所有action和下一次state的日志。\n - isomorphic-fetch: 用于ajax请求数据\n\n# 总结\n希望你已经了解了关于Redux中间件的足够信息，我也希望你掌握了更多的关于函数式编程的知识。我不断的尝试更多更好的函数式编程方法，尽管一开始并不容易，你需要不断的学习和尝试来参悟它的精髓。如果你完全掌握了这篇文章交给你的，那么你已经拥有了足够的信心去投入更多的学习当中。\n\n最后，千万别使用那些你还没有搞明白的第三方类库，你必须确定它会给你的项目带来好处。掌握它的一个好方法就是去阅读它的源码，你将会学到新的编程技术，淘汰那些老的解决方案。将一个工具引入你的项目前，你有责任搞清楚它的细节。\n","source":"_posts/深入理解Redux的Middleware.md","raw":"---\ntitle: 深入理解Redux的Middleware\ndate: 2016-05-26 14:22:35\ntags:\n  - react\n  - Redux\ncategories: 转载笔记\n---\n> 文章转载自[深入理解Redux的Middleware](http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redux%E7%9A%84Middleware.html)，仅供学习和参考\n\n# 1. 中间件\nRedux最有趣的一个概念是它允许你通过自定义的中间件来影响你store的dispatch逻辑。\n> “中间件”这个词听起来很恐怖，但它实际一点都不难。想更好的了解中间件的方法就是看一下那些已经实现了的中间件是怎么工作的，然后尝试自己写一个。函数嵌套写法看起来很恐怖，但是大多数你能找到的中间件，代码都不超过十行，但是它们的强大来自于它们的可嵌套组合性。\n\n区区十行的中间件很容易写，但是你要想明白它们是如何放入中间件调用链，又是如何影响store的dispatch方法的，还真需要一些经验。首先让我们来简单定义一下中间件到底是个啥，并且找一些简单的中间件看一下他们的具体实现方式。关于中间件的定义我能找到的最简单的描述是：\n> 中间件主要被用于分离那些不属于你应用的核心业务逻辑，可以被组合起来使用的代码\n\nRedux的中间件主要用于store的dispatch的函数上。dispatch函数的作用是发送actions给一个或多个reducer来影响应用状态。中间件可以增强默认的dispatch函数，我们来看一下Redux 1.0.1版本的applyMiddleware源码：\n```javascript\n  export default function applyMiddleware(...middlewares){\n    return (next) => (reducer, initialStare) => {\n      var store = next(reducer, initialStare);\n      var dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: (action) => dispatch(action)\n      };\n\n      chain = middlewares.map(middleware => middleware(middlewareAPI));\n      dispatch = compose(...chain, store.dispatch);\n      return {\n        ...store,\n        dispatch\n      }\n    }\n  }\n```\n\n就这几行代码，跟着敲一下也就一会儿时间，但是什么鬼，完全看不懂。因为里面用了很多的函数式编程的思想，包括：高阶函数、复合函数、珂理化和ES6语法。关于函数式编程思想，我也转载了不少文章，但理解起来需要花点时间。\n\n# 2. 函数式编程概念\n在开始阅读Redux中间件源码之前，你需要先掌握一些函数式编程知识。\n## 2.1 复合函数\n函数式编程是非常理论和非常数学化的。用数学的视角来解释复合函数，如下：\n```javascript\n  given:\n    f(x) = x^2 + 3*x + 1\n    g(x) = 2*x\n  then:\n     (f ∘ g)(x) = f(g(x)) = f(2*x) = 4*x^2 + 6*x + 1\n```\n你可以将上面的方式扩展到组合两个或更多个函数这都是可以的。我们再来看个例子，演示组合两个函数并返回一个新的函数：\n```javascript\n  var greet = function(x){ return `Hello, ${x}` };\n  var emote = function(x){ return `${x}` };\n\n  var compose = function(f,g){\n    return function(x){\n      return f(g(x));\n    }\n  }\n\n  var happyGreeting = compose(green, emote);\n  //happyGreeting(\"Mark\") -> Hello,Mark\n```\n\n## 2.2 珂理化\n珂理化是这样一个过程：它把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数的参数。正式的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每一个函数只有一个参数。\n```javascript\n  var curriedAdd = function(a){\n    return function(b){\n      return a + b;\n    }\n  };\n\n  var addTen = curriedAdd(10);\n  addTen(10); //20\n```\n通过珂理化来组合你的函数，你可以创建一个强大的数据处理管道。\n\n# 3. Redux的dispatch函数\nRedux的Store有一个dispatch函数，它关注你的应用实现的业务逻辑。你可以用它指派actions到你定义的reducer函数，用以更新你的应用状态。Redux的reducer函数接受一个当前状态参数和一个action参数，并返回一个新的状态对象：\n`\n  reducer:: state -> action -> state\n`\n指派给action很像发送消息，如果我们假设要从一个列表中删除某个元素，action结构一般如下：\n`\n  {type: types.DELETE_ITEM, id:1 }\n`\nstore会指派这个action对象到它所拥有的所有reducer函数来影响应用的状态，然而只有关注删除逻辑的reducer会真的修改状态。在此期间没人会关注到底是谁修改了状态，花了多长时间，或者记录一下变更前后的状态数据镜像。这些非核心关注点都可以交给中间件来完成。\n\n# 4. Redux Middleware\nRedux中间件被设计成可组合的，会在dispatch方法之前调用的函数。让我们来创建一个简单的日志中间件，他会简单的输出dispatch前后的应用状态。Redux中间件的签名如下：\n`\nMiddleware:: next -> action -> retVal\n`\n我们的logger中间件实现如下：\n```javascript\n  export default function createLogger({getState}){\n    return (next) => (action) => {\n      const console = window.console;\n      const prevState = getState();\n      const returnValue = next(action);\n      const nextState = getState();\n      const actionType = String(action.type);\n      const message = `action ${actionType}`;\n\n      console.log(`%c prev state`, `color: #9E9E9E`, prevState);\n      console.log(`%c action`, `color: #03A9F4`, action);\n      console.log(`%c next state`, `color: #4CAF50`, nextState);\n      return returnValue;\n    }\n  }\n```\n注意，我们的createLogger接受的getState方法是由applyMiddleware.js注入进来的。使用它可以在内部的闭包中得到应用的当前状态。最后我们返回调用next创建的函数作为结果。next方法用于维护中间件调用链和dispatch，它返回一个接受action对象的柯里化函数，接受的action对象可以在中间件中被修改，再传递给下一个被调用的中间件，最终dispatch会使用中间件修改后的action来执行。\n\n我们来看看上面的logger中间件的业务流程：\n1. 得到当前的应用状态\n2. 将action指派给下一个中间件\n3. 调用链下游的中间件全部被执行\n4. store中的匹配reducer被执行\n5. 此时得到新的应用状态\n\n# 5. 剖析applyMiddleware.js\n下面让我们一步步分析applyMiddleware.js源码，applyMiddleware可能应该起一个更好一点的名字，applyMiddlewareToStore。\n首先我们看一下方法的签名：\n`\n  export default function applyMiddleware(...middlewares)\n`\n注意这里有个很有趣的写法，参数：...middlewares，这么定义允许我们调用时传入任意个数的中间件函数作为参数。接下来函数将返回一个接受next作为参数的函数：\n`\n  return (next) => (reducer,initialStare) => {...}\n`\nnext参数是一个被用来创建store的函数，你可以看一下createStore.js源码的实现细节。最后这个函数返回一个类似createStore的函数，不同的是它包含一个有中间件加工过的dispatch实现。\n\n接下来我们通过调用next拿到store对象。我们用一个变量保存原始的dispatch函数，最后我们申明一个数组来存储我们创建的中间件链：\n```javascript\n  var store = next(reducer, initialStare);\n  var dispatch = store.dispatch;\n  var chain = [];\n```\n\n接下来的代码将getState 和调用原始的dispatch函数注入给所有的中间件：\n```javascript\n  var middlewareAPI = {\n    getState: store.getState,\n    dispatch: (action) => dispatch(action)\n  };\n\n  chain = middlewares.map(middleware => middleware(middlewareAPI));\n```\n\n然后我们根据中间件链创建一个加工过的dispatch实现：\n```javascript\n  dispatch = compose(...chain, store.dispatch);\n```\n\n最精妙的地方就是上面这行，Redux提供的compose工具函数组合了我们的中间件链，compose实现如下：\n```javascript\n  export default function compose(...funcs){\n    return funcs.reduceRight((compose, f) => f(compose));\n  }\n```\n\n碉堡了！上面的代码展示了中间件调用链是如何创建出来的。中间件调用链的顺序很重要，调用链类似下面这样：\n```javascript\n  middlewareI(middlewareJ(middlewareK(store.dispatch)))(action)\n```\n\n现在我们知道为啥我们要掌握复合函数和珂理化概念了。最后我们只需要将新的store和调整过的dispatch函数返回即可：\n```javascript\n  return {\n    ...store,\n    dispatch\n  };\n```\n\n上面这种写法的意思是返回一个对象，该对象拥有store的所有属性，并增加一个dispatch函数属性，store里自带的那个原始dispatch函数会被覆盖。这种写法会被Babel转化成：\n```javascript\n  return _extends({}, store, {dispatch : _dispatch});\n```\n\n现在让我们将我们的logger中间件注入到dispatch中：\n```javascript\n  import { createStore, applyMiddleware } from 'redux';\n  import loggerMiddleware from 'logger';\n  import rootReducer from '../reducers';\n\n  const createStoreWithMiddleware = applyMiddleware(loggerMiddleware)(createStore);\n\n  export default function configureStore(initialStare){\n    return createStoreWithMiddleware(rootReducer, initialStare);\n  }\n\n  const store = configureStore();\n```\n\n# 6. 异步中间件\n我们已经会写基础的中间件了，我们就要玩更高深的，整个能处理异步action的中间件咋样？让我们来看一下redux-thunk的更多细节。我们假设有一个包含异步请求的action，如下：\n```javascript\n  function fetchQuote(symbol){\n    requestQuote(symbol);\n    return fetch(`http://www.google.com/finance/info?q=${symbol}`)\n            .then(req => req.json())\n            .then(json => showCurrentQuote(symbol,json));\n  }\n```\n\n上面的代码并没有明显的调用dispatch来分派一个返回promise的action，我们需要使用redux-thunk中间件来延迟dispatch的执行：\n```javascript\n  function fetchQuote(symbol){\n    return dispatch => {\n      dispatch(requestQuote(symbol));\n      return fetch(`http://www.google.com/finance/info?${symbol}`)\n              .then(req => req.json())\n              .then(json => dispatch(showCurrentQuote(symbol, json)));\n    }\n  }\n```\n\n注意这里的dispatch和getState是由applyMiddleware函数注入进来的。现在我们就可以分派最终得到的action对象到store的reducers了。下面是类似redux-thunk的实现：\n```javascript\n  export default function thunkMiddleware({ dispatch, getState}){\n    return next => action => typeof action === 'function' ? action(dispatch,getState) : next(action);\n  }\n```\n\n这个和你之前看到的中间件没什么太大不同。如果得到的action是个函数，就用dispatch和getState当作参数来调用它，否则就直接分派给store。你可以看一下Redux提供的更详细的异步示例。另外还有一个支持promise的中间件是redux-promise。\n\n# 7. 使用middleware实现异步action和异步数据流\nredux的生态在持续的完善，其中就有不少的middleware供开发者使用，同时大家也可以实现自己的middleware。\n现在让我们来使用以下两个中间件来完成一个示例：\n\n - redux-thunk -- Redux-Thunk可以让你的action creator返回一个function而不是action。这可以用于延迟dispatch一个action或是在特定条件下dispatch才触发。他的内部函数接受store的dispatch和getState方法作为参数。\n - redux-logger -- Redux-Logger的用处很明显，就是用于记录所有action和下一次state的日志。\n - isomorphic-fetch: 用于ajax请求数据\n\n# 总结\n希望你已经了解了关于Redux中间件的足够信息，我也希望你掌握了更多的关于函数式编程的知识。我不断的尝试更多更好的函数式编程方法，尽管一开始并不容易，你需要不断的学习和尝试来参悟它的精髓。如果你完全掌握了这篇文章交给你的，那么你已经拥有了足够的信心去投入更多的学习当中。\n\n最后，千万别使用那些你还没有搞明白的第三方类库，你必须确定它会给你的项目带来好处。掌握它的一个好方法就是去阅读它的源码，你将会学到新的编程技术，淘汰那些老的解决方案。将一个工具引入你的项目前，你有责任搞清楚它的细节。\n","slug":"深入理解Redux的Middleware","published":1,"updated":"2016-05-27T04:02:13.507Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0ent002cb0dlqi87uuj3","content":"<blockquote>\n<p>文章转载自<a href=\"http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redux%E7%9A%84Middleware.html\" target=\"_blank\" rel=\"external\">深入理解Redux的Middleware</a>，仅供学习和参考</p>\n</blockquote>\n<h1 id=\"1-中间件\"><a href=\"#1-中间件\" class=\"headerlink\" title=\"1. 中间件\"></a>1. 中间件</h1><p>Redux最有趣的一个概念是它允许你通过自定义的中间件来影响你store的dispatch逻辑。</p>\n<blockquote>\n<p>“中间件”这个词听起来很恐怖，但它实际一点都不难。想更好的了解中间件的方法就是看一下那些已经实现了的中间件是怎么工作的，然后尝试自己写一个。函数嵌套写法看起来很恐怖，但是大多数你能找到的中间件，代码都不超过十行，但是它们的强大来自于它们的可嵌套组合性。</p>\n</blockquote>\n<p>区区十行的中间件很容易写，但是你要想明白它们是如何放入中间件调用链，又是如何影响store的dispatch方法的，还真需要一些经验。首先让我们来简单定义一下中间件到底是个啥，并且找一些简单的中间件看一下他们的具体实现方式。关于中间件的定义我能找到的最简单的描述是：</p>\n<blockquote>\n<p>中间件主要被用于分离那些不属于你应用的核心业务逻辑，可以被组合起来使用的代码</p>\n</blockquote>\n<p>Redux的中间件主要用于store的dispatch的函数上。dispatch函数的作用是发送actions给一个或多个reducer来影响应用状态。中间件可以增强默认的dispatch函数，我们来看一下Redux 1.0.1版本的applyMiddleware源码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (next) =&gt; (reducer, initialStare) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = next(reducer, initialStare);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dispatch = store.dispatch;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: (action) =&gt; dispatch(action)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br><span class=\"line\">    dispatch = compose(...chain, store.dispatch);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就这几行代码，跟着敲一下也就一会儿时间，但是什么鬼，完全看不懂。因为里面用了很多的函数式编程的思想，包括：高阶函数、复合函数、珂理化和ES6语法。关于函数式编程思想，我也转载了不少文章，但理解起来需要花点时间。</p>\n<h1 id=\"2-函数式编程概念\"><a href=\"#2-函数式编程概念\" class=\"headerlink\" title=\"2. 函数式编程概念\"></a>2. 函数式编程概念</h1><p>在开始阅读Redux中间件源码之前，你需要先掌握一些函数式编程知识。</p>\n<h2 id=\"2-1-复合函数\"><a href=\"#2-1-复合函数\" class=\"headerlink\" title=\"2.1 复合函数\"></a>2.1 复合函数</h2><p>函数式编程是非常理论和非常数学化的。用数学的视角来解释复合函数，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">given:</span><br><span class=\"line\">  f(x) = x^<span class=\"number\">2</span> + <span class=\"number\">3</span>*x + <span class=\"number\">1</span></span><br><span class=\"line\">  g(x) = <span class=\"number\">2</span>*x</span><br><span class=\"line\">then:</span><br><span class=\"line\">   (f ∘ g)(x) = f(g(x)) = f(<span class=\"number\">2</span>*x) = <span class=\"number\">4</span>*x^<span class=\"number\">2</span> + <span class=\"number\">6</span>*x + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>你可以将上面的方式扩展到组合两个或更多个函数这都是可以的。我们再来看个例子，演示组合两个函数并返回一个新的函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;x&#125;</span>`</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> emote = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>`</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> happyGreeting = compose(green, emote);</span><br><span class=\"line\"><span class=\"comment\">//happyGreeting(\"Mark\") -&gt; Hello,Mark</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-珂理化\"><a href=\"#2-2-珂理化\" class=\"headerlink\" title=\"2.2 珂理化\"></a>2.2 珂理化</h2><p>珂理化是这样一个过程：它把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数的参数。正式的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每一个函数只有一个参数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curriedAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTen = curriedAdd(<span class=\"number\">10</span>);</span><br><span class=\"line\">addTen(<span class=\"number\">10</span>); <span class=\"comment\">//20</span></span><br></pre></td></tr></table></figure></p>\n<p>通过珂理化来组合你的函数，你可以创建一个强大的数据处理管道。</p>\n<h1 id=\"3-Redux的dispatch函数\"><a href=\"#3-Redux的dispatch函数\" class=\"headerlink\" title=\"3. Redux的dispatch函数\"></a>3. Redux的dispatch函数</h1><p>Redux的Store有一个dispatch函数，它关注你的应用实现的业务逻辑。你可以用它指派actions到你定义的reducer函数，用以更新你的应用状态。Redux的reducer函数接受一个当前状态参数和一个action参数，并返回一个新的状态对象：<br><code>reducer:: state -&gt; action -&gt; state</code><br>指派给action很像发送消息，如果我们假设要从一个列表中删除某个元素，action结构一般如下：<br><code>{type: types.DELETE_ITEM, id:1 }</code><br>store会指派这个action对象到它所拥有的所有reducer函数来影响应用的状态，然而只有关注删除逻辑的reducer会真的修改状态。在此期间没人会关注到底是谁修改了状态，花了多长时间，或者记录一下变更前后的状态数据镜像。这些非核心关注点都可以交给中间件来完成。</p>\n<h1 id=\"4-Redux-Middleware\"><a href=\"#4-Redux-Middleware\" class=\"headerlink\" title=\"4. Redux Middleware\"></a>4. Redux Middleware</h1><p>Redux中间件被设计成可组合的，会在dispatch方法之前调用的函数。让我们来创建一个简单的日志中间件，他会简单的输出dispatch前后的应用状态。Redux中间件的签名如下：<br><code>Middleware:: next -&gt; action -&gt; retVal</code><br>我们的logger中间件实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createLogger</span>(<span class=\"params\">&#123;getState&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (next) =&gt; (action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">console</span> = <span class=\"built_in\">window</span>.console;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prevState = getState();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> returnValue = next(action);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = getState();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionType = <span class=\"built_in\">String</span>(action.type);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> message = <span class=\"string\">`action <span class=\"subst\">$&#123;actionType&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`%c prev state`</span>, <span class=\"string\">`color: #9E9E9E`</span>, prevState);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`%c action`</span>, <span class=\"string\">`color: #03A9F4`</span>, action);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`%c next state`</span>, <span class=\"string\">`color: #4CAF50`</span>, nextState);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，我们的createLogger接受的getState方法是由applyMiddleware.js注入进来的。使用它可以在内部的闭包中得到应用的当前状态。最后我们返回调用next创建的函数作为结果。next方法用于维护中间件调用链和dispatch，它返回一个接受action对象的柯里化函数，接受的action对象可以在中间件中被修改，再传递给下一个被调用的中间件，最终dispatch会使用中间件修改后的action来执行。</p>\n<p>我们来看看上面的logger中间件的业务流程：</p>\n<ol>\n<li>得到当前的应用状态</li>\n<li>将action指派给下一个中间件</li>\n<li>调用链下游的中间件全部被执行</li>\n<li>store中的匹配reducer被执行</li>\n<li>此时得到新的应用状态</li>\n</ol>\n<h1 id=\"5-剖析applyMiddleware-js\"><a href=\"#5-剖析applyMiddleware-js\" class=\"headerlink\" title=\"5. 剖析applyMiddleware.js\"></a>5. 剖析applyMiddleware.js</h1><p>下面让我们一步步分析applyMiddleware.js源码，applyMiddleware可能应该起一个更好一点的名字，applyMiddlewareToStore。<br>首先我们看一下方法的签名：<br><code>export default function applyMiddleware(...middlewares)</code><br>注意这里有个很有趣的写法，参数：…middlewares，这么定义允许我们调用时传入任意个数的中间件函数作为参数。接下来函数将返回一个接受next作为参数的函数：<br><code>return (next) =&gt; (reducer,initialStare) =&gt; {...}</code><br>next参数是一个被用来创建store的函数，你可以看一下createStore.js源码的实现细节。最后这个函数返回一个类似createStore的函数，不同的是它包含一个有中间件加工过的dispatch实现。</p>\n<p>接下来我们通过调用next拿到store对象。我们用一个变量保存原始的dispatch函数，最后我们申明一个数组来存储我们创建的中间件链：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> store = next(reducer, initialStare);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dispatch = store.dispatch;</span><br><span class=\"line\"><span class=\"keyword\">var</span> chain = [];</span><br></pre></td></tr></table></figure></p>\n<p>接下来的代码将getState 和调用原始的dispatch函数注入给所有的中间件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: (action) =&gt; dispatch(action)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br></pre></td></tr></table></figure></p>\n<p>然后我们根据中间件链创建一个加工过的dispatch实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch = compose(...chain, store.dispatch);</span><br></pre></td></tr></table></figure></p>\n<p>最精妙的地方就是上面这行，Redux提供的compose工具函数组合了我们的中间件链，compose实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduceRight((compose, f) =&gt; f(compose));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>碉堡了！上面的代码展示了中间件调用链是如何创建出来的。中间件调用链的顺序很重要，调用链类似下面这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">middlewareI(middlewareJ(middlewareK(store.dispatch)))(action)</span><br></pre></td></tr></table></figure></p>\n<p>现在我们知道为啥我们要掌握复合函数和珂理化概念了。最后我们只需要将新的store和调整过的dispatch函数返回即可：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  ...store,</span><br><span class=\"line\">  dispatch</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面这种写法的意思是返回一个对象，该对象拥有store的所有属性，并增加一个dispatch函数属性，store里自带的那个原始dispatch函数会被覆盖。这种写法会被Babel转化成：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> _extends(&#123;&#125;, store, &#123;dispatch : _dispatch&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>现在让我们将我们的logger中间件注入到dispatch中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> loggerMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'logger'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> rootReducer <span class=\"keyword\">from</span> <span class=\"string\">'../reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createStoreWithMiddleware = applyMiddleware(loggerMiddleware)(createStore);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configureStore</span>(<span class=\"params\">initialStare</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createStoreWithMiddleware(rootReducer, initialStare);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"6-异步中间件\"><a href=\"#6-异步中间件\" class=\"headerlink\" title=\"6. 异步中间件\"></a>6. 异步中间件</h1><p>我们已经会写基础的中间件了，我们就要玩更高深的，整个能处理异步action的中间件咋样？让我们来看一下redux-thunk的更多细节。我们假设有一个包含异步请求的action，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchQuote</span>(<span class=\"params\">symbol</span>)</span>&#123;</span><br><span class=\"line\">  requestQuote(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetch(<span class=\"string\">`http://www.google.com/finance/info?q=<span class=\"subst\">$&#123;symbol&#125;</span>`</span>)</span><br><span class=\"line\">          .then(req =&gt; req.json())</span><br><span class=\"line\">          .then(json =&gt; showCurrentQuote(symbol,json));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码并没有明显的调用dispatch来分派一个返回promise的action，我们需要使用redux-thunk中间件来延迟dispatch的执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchQuote</span>(<span class=\"params\">symbol</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch =&gt; &#123;</span><br><span class=\"line\">    dispatch(requestQuote(symbol));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(<span class=\"string\">`http://www.google.com/finance/info?<span class=\"subst\">$&#123;symbol&#125;</span>`</span>)</span><br><span class=\"line\">            .then(req =&gt; req.json())</span><br><span class=\"line\">            .then(json =&gt; dispatch(showCurrentQuote(symbol, json)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意这里的dispatch和getState是由applyMiddleware函数注入进来的。现在我们就可以分派最终得到的action对象到store的reducers了。下面是类似redux-thunk的实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">thunkMiddleware</span>(<span class=\"params\">&#123; dispatch, getState&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next =&gt; action =&gt; <span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span> ? action(dispatch,getState) : next(action);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个和你之前看到的中间件没什么太大不同。如果得到的action是个函数，就用dispatch和getState当作参数来调用它，否则就直接分派给store。你可以看一下Redux提供的更详细的异步示例。另外还有一个支持promise的中间件是redux-promise。</p>\n<h1 id=\"7-使用middleware实现异步action和异步数据流\"><a href=\"#7-使用middleware实现异步action和异步数据流\" class=\"headerlink\" title=\"7. 使用middleware实现异步action和异步数据流\"></a>7. 使用middleware实现异步action和异步数据流</h1><p>redux的生态在持续的完善，其中就有不少的middleware供开发者使用，同时大家也可以实现自己的middleware。<br>现在让我们来使用以下两个中间件来完成一个示例：</p>\n<ul>\n<li>redux-thunk – Redux-Thunk可以让你的action creator返回一个function而不是action。这可以用于延迟dispatch一个action或是在特定条件下dispatch才触发。他的内部函数接受store的dispatch和getState方法作为参数。</li>\n<li>redux-logger – Redux-Logger的用处很明显，就是用于记录所有action和下一次state的日志。</li>\n<li>isomorphic-fetch: 用于ajax请求数据</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>希望你已经了解了关于Redux中间件的足够信息，我也希望你掌握了更多的关于函数式编程的知识。我不断的尝试更多更好的函数式编程方法，尽管一开始并不容易，你需要不断的学习和尝试来参悟它的精髓。如果你完全掌握了这篇文章交给你的，那么你已经拥有了足够的信心去投入更多的学习当中。</p>\n<p>最后，千万别使用那些你还没有搞明白的第三方类库，你必须确定它会给你的项目带来好处。掌握它的一个好方法就是去阅读它的源码，你将会学到新的编程技术，淘汰那些老的解决方案。将一个工具引入你的项目前，你有责任搞清楚它的细节。</p>\n","excerpt":"","more":"<blockquote>\n<p>文章转载自<a href=\"http://guoyongfeng.github.io/idoc/html/React%E8%AF%BE%E7%A8%8B%E4%B8%93%E9%A2%98/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Redux%E7%9A%84Middleware.html\">深入理解Redux的Middleware</a>，仅供学习和参考</p>\n</blockquote>\n<h1 id=\"1-中间件\"><a href=\"#1-中间件\" class=\"headerlink\" title=\"1. 中间件\"></a>1. 中间件</h1><p>Redux最有趣的一个概念是它允许你通过自定义的中间件来影响你store的dispatch逻辑。</p>\n<blockquote>\n<p>“中间件”这个词听起来很恐怖，但它实际一点都不难。想更好的了解中间件的方法就是看一下那些已经实现了的中间件是怎么工作的，然后尝试自己写一个。函数嵌套写法看起来很恐怖，但是大多数你能找到的中间件，代码都不超过十行，但是它们的强大来自于它们的可嵌套组合性。</p>\n</blockquote>\n<p>区区十行的中间件很容易写，但是你要想明白它们是如何放入中间件调用链，又是如何影响store的dispatch方法的，还真需要一些经验。首先让我们来简单定义一下中间件到底是个啥，并且找一些简单的中间件看一下他们的具体实现方式。关于中间件的定义我能找到的最简单的描述是：</p>\n<blockquote>\n<p>中间件主要被用于分离那些不属于你应用的核心业务逻辑，可以被组合起来使用的代码</p>\n</blockquote>\n<p>Redux的中间件主要用于store的dispatch的函数上。dispatch函数的作用是发送actions给一个或多个reducer来影响应用状态。中间件可以增强默认的dispatch函数，我们来看一下Redux 1.0.1版本的applyMiddleware源码：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (next) =&gt; (reducer, initialStare) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> store = next(reducer, initialStare);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> dispatch = store.dispatch;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> chain = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: (action) =&gt; dispatch(action)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br><span class=\"line\">    dispatch = compose(...chain, store.dispatch);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>就这几行代码，跟着敲一下也就一会儿时间，但是什么鬼，完全看不懂。因为里面用了很多的函数式编程的思想，包括：高阶函数、复合函数、珂理化和ES6语法。关于函数式编程思想，我也转载了不少文章，但理解起来需要花点时间。</p>\n<h1 id=\"2-函数式编程概念\"><a href=\"#2-函数式编程概念\" class=\"headerlink\" title=\"2. 函数式编程概念\"></a>2. 函数式编程概念</h1><p>在开始阅读Redux中间件源码之前，你需要先掌握一些函数式编程知识。</p>\n<h2 id=\"2-1-复合函数\"><a href=\"#2-1-复合函数\" class=\"headerlink\" title=\"2.1 复合函数\"></a>2.1 复合函数</h2><p>函数式编程是非常理论和非常数学化的。用数学的视角来解释复合函数，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">given:</span><br><span class=\"line\">  f(x) = x^<span class=\"number\">2</span> + <span class=\"number\">3</span>*x + <span class=\"number\">1</span></span><br><span class=\"line\">  g(x) = <span class=\"number\">2</span>*x</span><br><span class=\"line\">then:</span><br><span class=\"line\">   (f ∘ g)(x) = f(g(x)) = f(<span class=\"number\">2</span>*x) = <span class=\"number\">4</span>*x^<span class=\"number\">2</span> + <span class=\"number\">6</span>*x + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>你可以将上面的方式扩展到组合两个或更多个函数这都是可以的。我们再来看个例子，演示组合两个函数并返回一个新的函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> greet = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">`Hello, <span class=\"subst\">$&#123;x&#125;</span>`</span> &#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> emote = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">$&#123;x&#125;</span>`</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(g(x));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> happyGreeting = compose(green, emote);</span><br><span class=\"line\"><span class=\"comment\">//happyGreeting(\"Mark\") -&gt; Hello,Mark</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"2-2-珂理化\"><a href=\"#2-2-珂理化\" class=\"headerlink\" title=\"2.2 珂理化\"></a>2.2 珂理化</h2><p>珂理化是这样一个过程：它把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数的参数。正式的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每一个函数只有一个参数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curriedAdd = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> addTen = curriedAdd(<span class=\"number\">10</span>);</span><br><span class=\"line\">addTen(<span class=\"number\">10</span>); <span class=\"comment\">//20</span></span><br></pre></td></tr></table></figure></p>\n<p>通过珂理化来组合你的函数，你可以创建一个强大的数据处理管道。</p>\n<h1 id=\"3-Redux的dispatch函数\"><a href=\"#3-Redux的dispatch函数\" class=\"headerlink\" title=\"3. Redux的dispatch函数\"></a>3. Redux的dispatch函数</h1><p>Redux的Store有一个dispatch函数，它关注你的应用实现的业务逻辑。你可以用它指派actions到你定义的reducer函数，用以更新你的应用状态。Redux的reducer函数接受一个当前状态参数和一个action参数，并返回一个新的状态对象：<br><code>reducer:: state -&gt; action -&gt; state</code><br>指派给action很像发送消息，如果我们假设要从一个列表中删除某个元素，action结构一般如下：<br><code>{type: types.DELETE_ITEM, id:1 }</code><br>store会指派这个action对象到它所拥有的所有reducer函数来影响应用的状态，然而只有关注删除逻辑的reducer会真的修改状态。在此期间没人会关注到底是谁修改了状态，花了多长时间，或者记录一下变更前后的状态数据镜像。这些非核心关注点都可以交给中间件来完成。</p>\n<h1 id=\"4-Redux-Middleware\"><a href=\"#4-Redux-Middleware\" class=\"headerlink\" title=\"4. Redux Middleware\"></a>4. Redux Middleware</h1><p>Redux中间件被设计成可组合的，会在dispatch方法之前调用的函数。让我们来创建一个简单的日志中间件，他会简单的输出dispatch前后的应用状态。Redux中间件的签名如下：<br><code>Middleware:: next -&gt; action -&gt; retVal</code><br>我们的logger中间件实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createLogger</span>(<span class=\"params\">&#123;getState&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (next) =&gt; (action) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"built_in\">console</span> = <span class=\"built_in\">window</span>.console;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> prevState = getState();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> returnValue = next(action);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> nextState = getState();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> actionType = <span class=\"built_in\">String</span>(action.type);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> message = <span class=\"string\">`action <span class=\"subst\">$&#123;actionType&#125;</span>`</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`%c prev state`</span>, <span class=\"string\">`color: #9E9E9E`</span>, prevState);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`%c action`</span>, <span class=\"string\">`color: #03A9F4`</span>, action);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`%c next state`</span>, <span class=\"string\">`color: #4CAF50`</span>, nextState);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> returnValue;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，我们的createLogger接受的getState方法是由applyMiddleware.js注入进来的。使用它可以在内部的闭包中得到应用的当前状态。最后我们返回调用next创建的函数作为结果。next方法用于维护中间件调用链和dispatch，它返回一个接受action对象的柯里化函数，接受的action对象可以在中间件中被修改，再传递给下一个被调用的中间件，最终dispatch会使用中间件修改后的action来执行。</p>\n<p>我们来看看上面的logger中间件的业务流程：</p>\n<ol>\n<li>得到当前的应用状态</li>\n<li>将action指派给下一个中间件</li>\n<li>调用链下游的中间件全部被执行</li>\n<li>store中的匹配reducer被执行</li>\n<li>此时得到新的应用状态</li>\n</ol>\n<h1 id=\"5-剖析applyMiddleware-js\"><a href=\"#5-剖析applyMiddleware-js\" class=\"headerlink\" title=\"5. 剖析applyMiddleware.js\"></a>5. 剖析applyMiddleware.js</h1><p>下面让我们一步步分析applyMiddleware.js源码，applyMiddleware可能应该起一个更好一点的名字，applyMiddlewareToStore。<br>首先我们看一下方法的签名：<br><code>export default function applyMiddleware(...middlewares)</code><br>注意这里有个很有趣的写法，参数：…middlewares，这么定义允许我们调用时传入任意个数的中间件函数作为参数。接下来函数将返回一个接受next作为参数的函数：<br><code>return (next) =&gt; (reducer,initialStare) =&gt; {...}</code><br>next参数是一个被用来创建store的函数，你可以看一下createStore.js源码的实现细节。最后这个函数返回一个类似createStore的函数，不同的是它包含一个有中间件加工过的dispatch实现。</p>\n<p>接下来我们通过调用next拿到store对象。我们用一个变量保存原始的dispatch函数，最后我们申明一个数组来存储我们创建的中间件链：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> store = next(reducer, initialStare);</span><br><span class=\"line\"><span class=\"keyword\">var</span> dispatch = store.dispatch;</span><br><span class=\"line\"><span class=\"keyword\">var</span> chain = [];</span><br></pre></td></tr></table></figure></p>\n<p>接下来的代码将getState 和调用原始的dispatch函数注入给所有的中间件：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: (action) =&gt; dispatch(action)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br></pre></td></tr></table></figure></p>\n<p>然后我们根据中间件链创建一个加工过的dispatch实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch = compose(...chain, store.dispatch);</span><br></pre></td></tr></table></figure></p>\n<p>最精妙的地方就是上面这行，Redux提供的compose工具函数组合了我们的中间件链，compose实现如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduceRight((compose, f) =&gt; f(compose));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>碉堡了！上面的代码展示了中间件调用链是如何创建出来的。中间件调用链的顺序很重要，调用链类似下面这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">middlewareI(middlewareJ(middlewareK(store.dispatch)))(action)</span><br></pre></td></tr></table></figure></p>\n<p>现在我们知道为啥我们要掌握复合函数和珂理化概念了。最后我们只需要将新的store和调整过的dispatch函数返回即可：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">  ...store,</span><br><span class=\"line\">  dispatch</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面这种写法的意思是返回一个对象，该对象拥有store的所有属性，并增加一个dispatch函数属性，store里自带的那个原始dispatch函数会被覆盖。这种写法会被Babel转化成：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> _extends(&#123;&#125;, store, &#123;dispatch : _dispatch&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>现在让我们将我们的logger中间件注入到dispatch中：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> loggerMiddleware <span class=\"keyword\">from</span> <span class=\"string\">'logger'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> rootReducer <span class=\"keyword\">from</span> <span class=\"string\">'../reducers'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> createStoreWithMiddleware = applyMiddleware(loggerMiddleware)(createStore);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">configureStore</span>(<span class=\"params\">initialStare</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> createStoreWithMiddleware(rootReducer, initialStare);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = configureStore();</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"6-异步中间件\"><a href=\"#6-异步中间件\" class=\"headerlink\" title=\"6. 异步中间件\"></a>6. 异步中间件</h1><p>我们已经会写基础的中间件了，我们就要玩更高深的，整个能处理异步action的中间件咋样？让我们来看一下redux-thunk的更多细节。我们假设有一个包含异步请求的action，如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchQuote</span>(<span class=\"params\">symbol</span>)</span>&#123;</span><br><span class=\"line\">  requestQuote(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> fetch(<span class=\"string\">`http://www.google.com/finance/info?q=<span class=\"subst\">$&#123;symbol&#125;</span>`</span>)</span><br><span class=\"line\">          .then(req =&gt; req.json())</span><br><span class=\"line\">          .then(json =&gt; showCurrentQuote(symbol,json));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码并没有明显的调用dispatch来分派一个返回promise的action，我们需要使用redux-thunk中间件来延迟dispatch的执行：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchQuote</span>(<span class=\"params\">symbol</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> dispatch =&gt; &#123;</span><br><span class=\"line\">    dispatch(requestQuote(symbol));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(<span class=\"string\">`http://www.google.com/finance/info?<span class=\"subst\">$&#123;symbol&#125;</span>`</span>)</span><br><span class=\"line\">            .then(req =&gt; req.json())</span><br><span class=\"line\">            .then(json =&gt; dispatch(showCurrentQuote(symbol, json)));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意这里的dispatch和getState是由applyMiddleware函数注入进来的。现在我们就可以分派最终得到的action对象到store的reducers了。下面是类似redux-thunk的实现：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">thunkMiddleware</span>(<span class=\"params\">&#123; dispatch, getState&#125;</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> next =&gt; action =&gt; <span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span> ? action(dispatch,getState) : next(action);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个和你之前看到的中间件没什么太大不同。如果得到的action是个函数，就用dispatch和getState当作参数来调用它，否则就直接分派给store。你可以看一下Redux提供的更详细的异步示例。另外还有一个支持promise的中间件是redux-promise。</p>\n<h1 id=\"7-使用middleware实现异步action和异步数据流\"><a href=\"#7-使用middleware实现异步action和异步数据流\" class=\"headerlink\" title=\"7. 使用middleware实现异步action和异步数据流\"></a>7. 使用middleware实现异步action和异步数据流</h1><p>redux的生态在持续的完善，其中就有不少的middleware供开发者使用，同时大家也可以实现自己的middleware。<br>现在让我们来使用以下两个中间件来完成一个示例：</p>\n<ul>\n<li>redux-thunk – Redux-Thunk可以让你的action creator返回一个function而不是action。这可以用于延迟dispatch一个action或是在特定条件下dispatch才触发。他的内部函数接受store的dispatch和getState方法作为参数。</li>\n<li>redux-logger – Redux-Logger的用处很明显，就是用于记录所有action和下一次state的日志。</li>\n<li>isomorphic-fetch: 用于ajax请求数据</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>希望你已经了解了关于Redux中间件的足够信息，我也希望你掌握了更多的关于函数式编程的知识。我不断的尝试更多更好的函数式编程方法，尽管一开始并不容易，你需要不断的学习和尝试来参悟它的精髓。如果你完全掌握了这篇文章交给你的，那么你已经拥有了足够的信心去投入更多的学习当中。</p>\n<p>最后，千万别使用那些你还没有搞明白的第三方类库，你必须确定它会给你的项目带来好处。掌握它的一个好方法就是去阅读它的源码，你将会学到新的编程技术，淘汰那些老的解决方案。将一个工具引入你的项目前，你有责任搞清楚它的细节。</p>\n"},{"title":"语法和数据类型","date":"2016-05-16T02:13:21.000Z","_content":"> By plucking her petals you do not gather the beauty of the flower. \n\n> 本章讨论Javascript的基本语法(basic grammar)，变量声明(variable declarations)，数据类型(data types)和字面量(literals)。\n\n## 基础知识(Basic)\nJavascript很多语法借鉴自Java，但也受Awk, Perl和Python影响。\n\nJavascript是大小写敏感的，使用Unicode字符集。\n\n在Javascript中，语句被称为statements，并用分号分隔(;)。空格、制表符和换行符被称为空白。\nJavascript的脚本的源文件从左到右扫描，并转换成由令牌，控制字符，行结束符，注释或空白组成的输入元素序列。\nECMAScript中还定义了某些关键字和字面量，并具有分号自动插入功能(ASI)来结束语句。但是，建议随时添加分号结束你的语句以避免副作用。\n\n## 注释(Comments)\n注释语法和C++和其他语言相同：\n```javascript\n    //单行注释\n    /* 这是一个多行注释*/\n```\n\n## 声明(Declarations)\nJavascript有三种声明。\n\nvar 声明变量，可选择将其初始化为一个值\nlet 声明块范围局部变量(block scope local variable)，可选择将其初始化为一个值。\nconst 声明一个只读(read-only)命名常量。\n\n### 变量(variables)\n在应用程序中，使用变量来为值命名。变量的名称称为identifiers，需要遵守一定的规则。\n\n在Javascript语言中，一个标识符(identifier)必须以字母、下划线(_)或者美元($)符号开头；后续的字符可以包含数字(0-9)。因为Javascript语言中是区分大小写的，这里所指的字母可以是(大写的)\"A\"到字母\"Z\"和小写的\"a\"到\"z\"。\n从JavaScript 1.5版开始，你可以使用ISO 8859-1或Unicode编码的字符作标识符。你也可以使用\\uXXXX字样的转义序列Unicode escape sequences作标识符。\n\n### 声明变量(Declaring variables)\n你可以用以下三种方式声明变量：\n\n- 使用关键词var.例如，var x = 42。这个语法可以同时用来声明局部和全局变量。\n- 直接赋值。\n- 使用关键词let。例如let y = 13。这个语法可以用来声明语句块代码段的局部变量(block scope local variable)。\n\n### 对变量求值(Evaluation variables)\n用var或let声明的未赋初值的变量，值会被定义为undefined（即未定义值，本身也是一个值）。\n\n试图访问一个未初始化的变量会导致一个ReferenceError异常被抛出：\n\n```javascript\n    var a;\n    console.log(\"The value of a is \"+a); //logs的值未定义\n    console.log(\"The value of b is \"+b); //抛出ReferenceError异常\n```\n\n你可以使用undefined来确定变量是否已赋值。以下的代码中，变量input未被赋值，因而if条件语句的求值结果是true。\n\n```javascript\n    var input;\n    if(input === undefined){\n        doThis();\n    }else{\n        doThat();\n    }\n```\n\nundefined值在布尔类型环境中会被当做false。例如，下面的代码将运行函数myFunction，因为数组myArray中的元素未被赋值：\n\n```javascript\n    var myArray = new Array();\n    if(!myArray[0]){\n        myFunction();\n    }\n```\n\n数值类型环境中undefined值会被转换为NaN。\n\n```javascript\n    var a;\n    a + 2; // Evaluates to NaN\n```\n\n当你对一个空变量求值时，空值null在数值类型环境中会被当作0来对待，而布尔类型环境中会被当作false\n\n```javascript\n    var n = null;\n    console.log(n * 32); //logs 0\n```\n\n### 变量的域(Variable scope)\n在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。\n\nECMAScript6之前的Javascript没有语句块作用域；相反，语句块中声明的变量将成为语句块所在代码段的局部变量。例如，如下的代码将在控制台输出5，因为x的作用域是声明了x的那个函数(或全局范围)，而不是if语句块。\n\n```javascript\n    if(true){\n        var x = 5;\n    }\n    console.log(x); //5\n```\n\n如果使用ECMAScript6中的let声明，上述行为将发生变化。\n\n```javascript\n    if(true){\n        let x = 5;\n    }\n    console.log(x); //ReferenceError: y is not defined.\n```\n\n### 变量声明提升(Variable hoisting)\nJavaScript变量的另一个特别之处是，你可以引用稍后声明的变量，而不会引发异常。这一概念称为变量声明提升(hoisting)；JavaScript变量感觉上是被“举起”或提升到了所有函数和语句之前。然而提升后的变量将返回undefined值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到undefined值。\n\n```javascript\n    /**\n     * Example 1\n     */\n    console.log(x === undefined); //logs \"true\"\n    var x = 3;\n    /**\n     * Example 2\n     */\n    // will return a value of undefined\n    var myvar = \"my value\";\n    (function(){\n        console.log(myvar); //undefined\n        var myvar = \"local value\";\n    })();\n```\n\n上面的例子，也可写作：\n\n```javascript\n    /**\n     * Example 1\n     */\n    var x;\n    console.log(x === undefined); // logs \"true\"\n    x = 3;\n    /**\n     * Example 2\n     */\n    var myvar = \"my value\";\n    (function() {\n      var myvar;\n      console.log(myvar); // undefined\n      myvar = \"local value\";\n    })();\n```\n\n由于存在变量声明提升，一个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这大大地提升了程序代码的清晰度。\n\n### 全局变量(Global variables)\n全局变量实际上是全局对象的属性。在网页中，全局对象是window，所以你可以用形如window.variable的语法来设置和访问全局变量。\n\n因此，你可以通过制定window或frame的名字，从一个window或frame访问另一个window或frame中声明的变量。例如，设想一个叫phoneNumber的变量在文档里被声明，你可以在子框架里用phone.phoneNumber来引用它。\n\n## 常量(Constants)\n你可以用关键字const创建一个只读(read-only)的常量。常量标识符的命名规则和变量的相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。\n\n```javascript\n    const prefix = '212';\n```\n\n常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。**它必须被初始化为某个值。**\n\n常量的作用域规则与let会计作用域变量相同。若const关键字被省略了，该标识符将被视为变量。\n\n在同一个作用域下，不能用于变量或函数同样的名字来命名常量。例如：\n\n```javascript\n    //THIS WILL CAUSE AN ERROR\n     function f(){};\n     const f = 5;\n    // THIS WILL CAUSE AN ERROR ALSO\n    function f(){\n        const g = 5;\n        var g;\n        //statements\n    }\n```\n\n## 数据结构和类型\nJavaScript语言可以识别下面7中不同类型的值：\n- 六种是原型的数据类型：\n    1. Boolean. 布尔值，true和false.\n    2. null. 一个表明null值得特殊关键字。JavaScript是大小敏感的，因此null与Null、NULL或其他变量完全不同。\n    3. undefined. 变量未定义时的属性。\n    4. Number. 表示数字，例如：42或者3.14.\n    5. String. 表示字符串，例如：\"Hello\"。\n    6. Symbol(在ECMAScript6中新添加的类型)。一种数据类型，它的实例是唯一且不可改变的。\n- 以及Object对象\n\n仅凭这些为数不多的数据类型，在你的应用程序中他们就能够执行有用的功能。\n\nObjects和functions是本语言的其他两个基本元素。你可以将对象视为存放值得命名容器，而将函数视为你的应用程序能够执行的过程(procedures)。\n\n### 数据类型的转换(Data type conversion)\nJavaScript是一种动态类型语言(dynamically typed language)。这意味着你声明变量时可以不指定数据类型，而数据会在脚本执行需要时自动转换。那么，你可以这样来定义变量：\n\n```javascript\n    var answer = 42;\n```\n\n然后，你还可以给同一个变量分配一个字符串值，例如：\n\n```javascript\n    answer = \"hello world!\";\n```\n\n因为JavaScript是动态类型的，这样的指定并不会提示出错。\n\n再涉及加法运算符(+)的数字和字符串表达式中，JavaScript会把数字值转换为字符串。例如，假设有如下的语句：\n\n```javascript\n   x = \"The answer is \" + 42 // \"The answer is 42\"\n   y = 42 + \" is the answer\" // \"42 is the answer\"\n```\n\n在涉及其他运算符(如下面的减号)时，JavaScript语言不会把数字变为字符。例如(第一例是数字运算符，第二例是字符串运算符):\n\n```javascript\n   \"37\" - 7 // 30\n   \"37\" + 7 // \"377\" \n```\n\n### 字符串转化为数字(converting strings to numbers)\n有一些方法可以将内存中表示一个数字的字符串转换为对应的数字\nparseInt()和parseFloat()\n\nparseInt仅能够返回整数，所以使用它会丢失小数部分。另外，调用parseInt时最好总是带上进制(radix)参数，这个参数用于指定使用哪一种数制。\n\n#### 单目加法运算符\n**将字符串转换为数字的另一种方法是使用单目加法运算符。**\n\n```javascript\n    \"1.1\" + \"1.1\" = \"1.11.1\"\n    (+\"1.1\") + (+\"1.1\") = 2.2   // 注：加入括号为清楚起见，不是必需的。\n```\n\n## 字面值(Literals)\n(注：字面值是由语法表达式定义的常量；或通过一定字辞组成的语词表达式定义的常量)\n\n在JavaScript中，你可以使用各种字面值。这些字面值是脚本中按字面意思给出的固定的值，而不是变量。(字面值是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false,3.1415,thisStringOfHelloWorld,invokedFunction: myFunction(\"myArgument\"))\n\n### 数组字面值(Array Literals)\n数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。当你使用数组字面值创建一个数组时，该数组将会以指定的值作为它的元素进行初始化，而其长度被设定为元素的个数。\n\n下面的示例用3个元素生成数组coffees，它的长度是3。\n\n```javascript\n   var coffees = [\"French Roast\", \"Colombian\", \"Kona\"];\n   var a=[3];\n   console.log(a.length); // 1\n   console.log(a[0]); // 3 \n```\n\n若在顶层（全局）脚本里用字面值创建数组，JavaScript语言会在每次对包含该数组字面值的表达式时解释该数组。另一方面，在函数中使用的数组，将在每次调用函数时被创建一次。\n\n数组字面值同时也是数组对象。\n\n**数组字面值中的多余逗号**\n你不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没被指定的元素，其初始值是undefined。以下示例创建了一个名为fish的数组：\n\n```javascript\n    var fish = [\"Lion\", , \"Angel\"];\n```\n\n这个数组中，有两个已被赋值的元素，和一个空元素，此时的数组的长度是3.\n\n若你在元素列表的尾部添加了一个逗号，它会被忽略。在下面的例子中，该数组的长度是3.并不存在myList[3]这个元素。元素列表中所有其他的逗号都表示一个新元素（的开始）。\n\n```javascript\n   var myList = ['home', , 'school', ]; \n```\n\n在下面的例子中，数组的长度是4，元素myList[0]和myList[2]缺失（译注：没被赋值，因而是undefined）。\n\n```javascript\n    var myList = [ , 'home', , 'school'];\n```\n\n又一个例子，在这里该数组的长度是4，元素myList[1]和myList[3]被漏掉了。（但是）只有最后的那个逗号被忽略。\n\n```javascript\n    var myList = ['home', , 'school', , ];\n```\n\n理解多余的逗号（在脚本运行时会被如何处理）的含义，对于从语言层面理解JavaScript是十分重要的。但是，你自己写代码时：**显式地将缺失的元素声明为undefined，将大大增加你的代码的清晰度和可维护性**。\n\n### 布尔字面值(Boolean literals)\n布尔类型有两种字面值：true和false。\n\n不要混淆作为布尔对象的真和假与布尔类型的原始值true和false。布尔对象是原始布尔数据类型的一个包装器。\n\n### 整数(Intergers)\n整数可以被表示成十进制(基数为10)、十六进制(基数为16)以及八进制(基数为8)。\n - 十进制整数字组成的数字序列，不带前导0.\n - 带前导0、0O、0o的整数字面值表明它是八进制。八进制整数只能包括数字0-7。\n - 前缀0x或0X表示十六进制。十六进制整数，可以包含数字（0-9）和字母a~f或A~F。\n \n### 浮点数字面值(Floating-point literal)\n浮点数字面值可以有以下的组成部分：\n - 一个十进制整数，它可以带符号（即前面的\"+\"或\"-\"号），\n - 一个小数点（\".\"），\n - 一个小数部分（由一串十进制数表示），\n - 一个指数部分\n \n指数部分是以\"e\"或\"E\"开头后面跟着一个整数，可以有正负号（即前面写\"+\"或\"-\"）。一个浮点数字面值必须至少有一位数字，后接小数点或者\"e\"(\"E\")组成。\n\n一些浮点数字面值的例子，如3.1415,-3.1415,1e12以及2E-12。\n\n简而言之，其语法是：\n```javascript\n    [(+|-)][digits][.digits][(E|e)[(+|-)]digits]\n```\n\n### 对象字面量(Object literals)\n对象字面值是封闭在花括号对({})中的一个对象的零个或多个\"属性名-值\"对的（元素）列表。你不能在一条语句的开头就使用对象字面值，这将导致错误或非你所预想的行为，因为此时左花括号({)会被认为一个语句块的齐师傅好。\n\n以下是一个对象字面值的例子。对象car的第一个元素（译注：即一个属性双值对）定义了属性myCar；第二个元素，属性getCar，引用了一个函数（即CarTypes(\"Honda\")）；第三个元素，属性special，使用了一个已有的变量（即Sales）\n\n```javascript\n   var Sales = \"Toyota\";\n   function CarTypes(name) {\n     return (name === \"Honda\") ?\n       name :\n       \"Sorry, we don't sell \" + name + \".\" ;\n   }\n   var car = { myCar: \"Saturn\", getCar: CarTypes(\"Honda\"), special: Sales };\n   console.log(car.myCar);   // Saturn\n   console.log(car.getCar);  // Honda\n   console.log(car.special); // Toyota \n```\n\n更进一步的，你可以使用数字或字符串字面值作为属性的名字，或者在另一个字面值内嵌套上一个字面值。如下的示例中使用了这些可选项\n\n```javascript\n   var car = { manyCars: {a: \"Saab\", \"b\": \"Jeep\"}, 7: \"Mazda\" };\n   console.log(car.manyCars.b); // Jeep\n   console.log(car[7]); // Mazda \n```\n\n对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的javascript标识符，它必须用\"\"包裹。属性的名字不合法，那么便不能用.访问属性值，而是通过类数组标记(\"[]\")访问和赋值。\n\n```javascript\n    var unusualPropertyNames = {\n      \"\": \"An empty string\",\n      \"!\": \"Bang!\"\n    }\n    console.log(unusualPropertyNames.\"\");   // 语法错误: Unexpected string\n    console.log(unusualPropertyNames[\"\"]);  // An empty string\n    console.log(unusualPropertyNames.!);    // 语法错误: Unexpected token !\n    console.log(unusualPropertyNames[\"!\"]); // Bang!\n```\n\n在ES2015，对象文本扩展到支持在原型设置建造，简写foo:foo分配，界定方法，得到很好的名称，并与表达式计算属性名。总之，这些也带来了对象文字和类声明紧密联系起来，让基于对象的设计得益于一些同样的便利。\n\n```javascript\n    var obj = {\n        //__proto__\n        __proto__: theProtoObj,\n        // Shorthand for 'handler:handler'\n        handler,\n        //Methods\n        toString(){\n            //super calls\n            return \"d\" + super.toString();\n        },\n        //Computed (dynamic) property names\n        [ 'prop_' + (() => 42)() ]:42\n    };\n```\n\n### RegExp literals\n一个正则表达式是字符被斜线围成的表达式。下面是一个正则表达式文字的一个例子。\n\n```javascript\n    var re = /ab+c/;\n```\n\n### 字符串字面值\n字符串字面值可以包含零个或多个字符，由双引号对或单引号对包围。字符串被限定在同种引号之间。\n你可以在字符串字面值上使用字符串对象的所有方法--JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串变量。你也能对字符串字面值使用类似String.length的属性：\n\n```javascript\n   \"John's cat\".length\n```\n\n除非有特别需要使用字符串对象，否则，你应当始终使用字符串字面值。\n\n在字符串中使用的特殊字符\n作为一般字符的扩展，你可以在字符串中使用特殊字符\n\n```javascript\n    \"one line \\n another line\"\n```\n以下表格列举了你能在JavaScript的字符串中使用的特殊字符。\n\n| Character | Meaning |\n| ----- | :-----: |\n| \\0 | 空字符 |\n| \\b | 退格 |\n| \\f | 换页符 |\n| \\n | 换行符 |\n| \\r | 回车符 |\n| \\t | Tab制表符 |\n| \\v | 垂直制表符 |\n| \\' | 单引号 |\n| \\\" | 双引号 |\n| \\\\ | 反斜杠字符(\\) |\n| \\XXX | 通过最多三个八进制位数x377.例如在0和指定的Latin-1编码的字符，\\251是版本符号八进制序列。 |\n| \\xXX | 由00和FF之间的两个十六进制数字XX指定的Latin-1编码的字符。例如，版权所有\\ xA9为版权符号十六进制序列。 |\n| \\uXXXX | 由四个十六进制数字XXXX规定的Unicode字符。例如，\\ u00A9为版权符号的Unicode序列。见Unicode转义序列。 |\n| \\u{XXXXX} | Unicode code point escapes. For example, \\u{2F804} is the same as the simple Unicode escapes \\uD87E\\uDC04. |\n\n转义字符\n对于那些未出现在表2.1中的字符，其所带的前导反斜线'\\'将被忽略。但是，这一用法已被废弃，应当避免使用。\n\n通过在引号前加上反斜线'\\'，可以在字符串中插入引号，这就是引号转义。例如:\n```javascript\n    var quote = \"He read \\\"The Cremation of Sam McGee\\\" by R.W. Service.\";\n    console.log(quote); // He read \"The Cremation of Sam McGee\" by R.W. Service.\n```\n\n要在字符串中插入'\\'字面值，必须转义反斜线。例如，要把文件路径 c:\\temp 赋值给一个字符串，可以采用如下方式:\n```javascript\n   var home = \"c:\\\\temp\";\n```\n\n也可以在换行之前加上反斜线以转义换行（译注：实际上就是一条语句拆成多行书写），这样反斜线和换行都不会出现在字符串的值中。\n```javascript\n   var str = \"this string \\\n   is broken \\\n   across multiple\\\n   lines.\"\n   console.log(str);   // this string is broken across multiplelines. \n```\n\nJavascript没有“heredoc”语法，但可以用行末的换行符转义和转义的换行来近似实现 \n```javascript\n    var poem = \n    \"Roses are red,\\n\\\n    Violets are blue.\\n\\\n    I'm schizophrenic,\\n\\\n    And so am I.\"\n```","source":"_posts/语法和数据类型.md","raw":"---\ntitle: 语法和数据类型\ndate: 2016-05-16 10:13:21\ntags:\n- javascript\n- 语法和数据类型\ncategories: 笔记\n---\n> By plucking her petals you do not gather the beauty of the flower. \n\n> 本章讨论Javascript的基本语法(basic grammar)，变量声明(variable declarations)，数据类型(data types)和字面量(literals)。\n\n## 基础知识(Basic)\nJavascript很多语法借鉴自Java，但也受Awk, Perl和Python影响。\n\nJavascript是大小写敏感的，使用Unicode字符集。\n\n在Javascript中，语句被称为statements，并用分号分隔(;)。空格、制表符和换行符被称为空白。\nJavascript的脚本的源文件从左到右扫描，并转换成由令牌，控制字符，行结束符，注释或空白组成的输入元素序列。\nECMAScript中还定义了某些关键字和字面量，并具有分号自动插入功能(ASI)来结束语句。但是，建议随时添加分号结束你的语句以避免副作用。\n\n## 注释(Comments)\n注释语法和C++和其他语言相同：\n```javascript\n    //单行注释\n    /* 这是一个多行注释*/\n```\n\n## 声明(Declarations)\nJavascript有三种声明。\n\nvar 声明变量，可选择将其初始化为一个值\nlet 声明块范围局部变量(block scope local variable)，可选择将其初始化为一个值。\nconst 声明一个只读(read-only)命名常量。\n\n### 变量(variables)\n在应用程序中，使用变量来为值命名。变量的名称称为identifiers，需要遵守一定的规则。\n\n在Javascript语言中，一个标识符(identifier)必须以字母、下划线(_)或者美元($)符号开头；后续的字符可以包含数字(0-9)。因为Javascript语言中是区分大小写的，这里所指的字母可以是(大写的)\"A\"到字母\"Z\"和小写的\"a\"到\"z\"。\n从JavaScript 1.5版开始，你可以使用ISO 8859-1或Unicode编码的字符作标识符。你也可以使用\\uXXXX字样的转义序列Unicode escape sequences作标识符。\n\n### 声明变量(Declaring variables)\n你可以用以下三种方式声明变量：\n\n- 使用关键词var.例如，var x = 42。这个语法可以同时用来声明局部和全局变量。\n- 直接赋值。\n- 使用关键词let。例如let y = 13。这个语法可以用来声明语句块代码段的局部变量(block scope local variable)。\n\n### 对变量求值(Evaluation variables)\n用var或let声明的未赋初值的变量，值会被定义为undefined（即未定义值，本身也是一个值）。\n\n试图访问一个未初始化的变量会导致一个ReferenceError异常被抛出：\n\n```javascript\n    var a;\n    console.log(\"The value of a is \"+a); //logs的值未定义\n    console.log(\"The value of b is \"+b); //抛出ReferenceError异常\n```\n\n你可以使用undefined来确定变量是否已赋值。以下的代码中，变量input未被赋值，因而if条件语句的求值结果是true。\n\n```javascript\n    var input;\n    if(input === undefined){\n        doThis();\n    }else{\n        doThat();\n    }\n```\n\nundefined值在布尔类型环境中会被当做false。例如，下面的代码将运行函数myFunction，因为数组myArray中的元素未被赋值：\n\n```javascript\n    var myArray = new Array();\n    if(!myArray[0]){\n        myFunction();\n    }\n```\n\n数值类型环境中undefined值会被转换为NaN。\n\n```javascript\n    var a;\n    a + 2; // Evaluates to NaN\n```\n\n当你对一个空变量求值时，空值null在数值类型环境中会被当作0来对待，而布尔类型环境中会被当作false\n\n```javascript\n    var n = null;\n    console.log(n * 32); //logs 0\n```\n\n### 变量的域(Variable scope)\n在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。\n\nECMAScript6之前的Javascript没有语句块作用域；相反，语句块中声明的变量将成为语句块所在代码段的局部变量。例如，如下的代码将在控制台输出5，因为x的作用域是声明了x的那个函数(或全局范围)，而不是if语句块。\n\n```javascript\n    if(true){\n        var x = 5;\n    }\n    console.log(x); //5\n```\n\n如果使用ECMAScript6中的let声明，上述行为将发生变化。\n\n```javascript\n    if(true){\n        let x = 5;\n    }\n    console.log(x); //ReferenceError: y is not defined.\n```\n\n### 变量声明提升(Variable hoisting)\nJavaScript变量的另一个特别之处是，你可以引用稍后声明的变量，而不会引发异常。这一概念称为变量声明提升(hoisting)；JavaScript变量感觉上是被“举起”或提升到了所有函数和语句之前。然而提升后的变量将返回undefined值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到undefined值。\n\n```javascript\n    /**\n     * Example 1\n     */\n    console.log(x === undefined); //logs \"true\"\n    var x = 3;\n    /**\n     * Example 2\n     */\n    // will return a value of undefined\n    var myvar = \"my value\";\n    (function(){\n        console.log(myvar); //undefined\n        var myvar = \"local value\";\n    })();\n```\n\n上面的例子，也可写作：\n\n```javascript\n    /**\n     * Example 1\n     */\n    var x;\n    console.log(x === undefined); // logs \"true\"\n    x = 3;\n    /**\n     * Example 2\n     */\n    var myvar = \"my value\";\n    (function() {\n      var myvar;\n      console.log(myvar); // undefined\n      myvar = \"local value\";\n    })();\n```\n\n由于存在变量声明提升，一个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这大大地提升了程序代码的清晰度。\n\n### 全局变量(Global variables)\n全局变量实际上是全局对象的属性。在网页中，全局对象是window，所以你可以用形如window.variable的语法来设置和访问全局变量。\n\n因此，你可以通过制定window或frame的名字，从一个window或frame访问另一个window或frame中声明的变量。例如，设想一个叫phoneNumber的变量在文档里被声明，你可以在子框架里用phone.phoneNumber来引用它。\n\n## 常量(Constants)\n你可以用关键字const创建一个只读(read-only)的常量。常量标识符的命名规则和变量的相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。\n\n```javascript\n    const prefix = '212';\n```\n\n常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。**它必须被初始化为某个值。**\n\n常量的作用域规则与let会计作用域变量相同。若const关键字被省略了，该标识符将被视为变量。\n\n在同一个作用域下，不能用于变量或函数同样的名字来命名常量。例如：\n\n```javascript\n    //THIS WILL CAUSE AN ERROR\n     function f(){};\n     const f = 5;\n    // THIS WILL CAUSE AN ERROR ALSO\n    function f(){\n        const g = 5;\n        var g;\n        //statements\n    }\n```\n\n## 数据结构和类型\nJavaScript语言可以识别下面7中不同类型的值：\n- 六种是原型的数据类型：\n    1. Boolean. 布尔值，true和false.\n    2. null. 一个表明null值得特殊关键字。JavaScript是大小敏感的，因此null与Null、NULL或其他变量完全不同。\n    3. undefined. 变量未定义时的属性。\n    4. Number. 表示数字，例如：42或者3.14.\n    5. String. 表示字符串，例如：\"Hello\"。\n    6. Symbol(在ECMAScript6中新添加的类型)。一种数据类型，它的实例是唯一且不可改变的。\n- 以及Object对象\n\n仅凭这些为数不多的数据类型，在你的应用程序中他们就能够执行有用的功能。\n\nObjects和functions是本语言的其他两个基本元素。你可以将对象视为存放值得命名容器，而将函数视为你的应用程序能够执行的过程(procedures)。\n\n### 数据类型的转换(Data type conversion)\nJavaScript是一种动态类型语言(dynamically typed language)。这意味着你声明变量时可以不指定数据类型，而数据会在脚本执行需要时自动转换。那么，你可以这样来定义变量：\n\n```javascript\n    var answer = 42;\n```\n\n然后，你还可以给同一个变量分配一个字符串值，例如：\n\n```javascript\n    answer = \"hello world!\";\n```\n\n因为JavaScript是动态类型的，这样的指定并不会提示出错。\n\n再涉及加法运算符(+)的数字和字符串表达式中，JavaScript会把数字值转换为字符串。例如，假设有如下的语句：\n\n```javascript\n   x = \"The answer is \" + 42 // \"The answer is 42\"\n   y = 42 + \" is the answer\" // \"42 is the answer\"\n```\n\n在涉及其他运算符(如下面的减号)时，JavaScript语言不会把数字变为字符。例如(第一例是数字运算符，第二例是字符串运算符):\n\n```javascript\n   \"37\" - 7 // 30\n   \"37\" + 7 // \"377\" \n```\n\n### 字符串转化为数字(converting strings to numbers)\n有一些方法可以将内存中表示一个数字的字符串转换为对应的数字\nparseInt()和parseFloat()\n\nparseInt仅能够返回整数，所以使用它会丢失小数部分。另外，调用parseInt时最好总是带上进制(radix)参数，这个参数用于指定使用哪一种数制。\n\n#### 单目加法运算符\n**将字符串转换为数字的另一种方法是使用单目加法运算符。**\n\n```javascript\n    \"1.1\" + \"1.1\" = \"1.11.1\"\n    (+\"1.1\") + (+\"1.1\") = 2.2   // 注：加入括号为清楚起见，不是必需的。\n```\n\n## 字面值(Literals)\n(注：字面值是由语法表达式定义的常量；或通过一定字辞组成的语词表达式定义的常量)\n\n在JavaScript中，你可以使用各种字面值。这些字面值是脚本中按字面意思给出的固定的值，而不是变量。(字面值是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false,3.1415,thisStringOfHelloWorld,invokedFunction: myFunction(\"myArgument\"))\n\n### 数组字面值(Array Literals)\n数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。当你使用数组字面值创建一个数组时，该数组将会以指定的值作为它的元素进行初始化，而其长度被设定为元素的个数。\n\n下面的示例用3个元素生成数组coffees，它的长度是3。\n\n```javascript\n   var coffees = [\"French Roast\", \"Colombian\", \"Kona\"];\n   var a=[3];\n   console.log(a.length); // 1\n   console.log(a[0]); // 3 \n```\n\n若在顶层（全局）脚本里用字面值创建数组，JavaScript语言会在每次对包含该数组字面值的表达式时解释该数组。另一方面，在函数中使用的数组，将在每次调用函数时被创建一次。\n\n数组字面值同时也是数组对象。\n\n**数组字面值中的多余逗号**\n你不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没被指定的元素，其初始值是undefined。以下示例创建了一个名为fish的数组：\n\n```javascript\n    var fish = [\"Lion\", , \"Angel\"];\n```\n\n这个数组中，有两个已被赋值的元素，和一个空元素，此时的数组的长度是3.\n\n若你在元素列表的尾部添加了一个逗号，它会被忽略。在下面的例子中，该数组的长度是3.并不存在myList[3]这个元素。元素列表中所有其他的逗号都表示一个新元素（的开始）。\n\n```javascript\n   var myList = ['home', , 'school', ]; \n```\n\n在下面的例子中，数组的长度是4，元素myList[0]和myList[2]缺失（译注：没被赋值，因而是undefined）。\n\n```javascript\n    var myList = [ , 'home', , 'school'];\n```\n\n又一个例子，在这里该数组的长度是4，元素myList[1]和myList[3]被漏掉了。（但是）只有最后的那个逗号被忽略。\n\n```javascript\n    var myList = ['home', , 'school', , ];\n```\n\n理解多余的逗号（在脚本运行时会被如何处理）的含义，对于从语言层面理解JavaScript是十分重要的。但是，你自己写代码时：**显式地将缺失的元素声明为undefined，将大大增加你的代码的清晰度和可维护性**。\n\n### 布尔字面值(Boolean literals)\n布尔类型有两种字面值：true和false。\n\n不要混淆作为布尔对象的真和假与布尔类型的原始值true和false。布尔对象是原始布尔数据类型的一个包装器。\n\n### 整数(Intergers)\n整数可以被表示成十进制(基数为10)、十六进制(基数为16)以及八进制(基数为8)。\n - 十进制整数字组成的数字序列，不带前导0.\n - 带前导0、0O、0o的整数字面值表明它是八进制。八进制整数只能包括数字0-7。\n - 前缀0x或0X表示十六进制。十六进制整数，可以包含数字（0-9）和字母a~f或A~F。\n \n### 浮点数字面值(Floating-point literal)\n浮点数字面值可以有以下的组成部分：\n - 一个十进制整数，它可以带符号（即前面的\"+\"或\"-\"号），\n - 一个小数点（\".\"），\n - 一个小数部分（由一串十进制数表示），\n - 一个指数部分\n \n指数部分是以\"e\"或\"E\"开头后面跟着一个整数，可以有正负号（即前面写\"+\"或\"-\"）。一个浮点数字面值必须至少有一位数字，后接小数点或者\"e\"(\"E\")组成。\n\n一些浮点数字面值的例子，如3.1415,-3.1415,1e12以及2E-12。\n\n简而言之，其语法是：\n```javascript\n    [(+|-)][digits][.digits][(E|e)[(+|-)]digits]\n```\n\n### 对象字面量(Object literals)\n对象字面值是封闭在花括号对({})中的一个对象的零个或多个\"属性名-值\"对的（元素）列表。你不能在一条语句的开头就使用对象字面值，这将导致错误或非你所预想的行为，因为此时左花括号({)会被认为一个语句块的齐师傅好。\n\n以下是一个对象字面值的例子。对象car的第一个元素（译注：即一个属性双值对）定义了属性myCar；第二个元素，属性getCar，引用了一个函数（即CarTypes(\"Honda\")）；第三个元素，属性special，使用了一个已有的变量（即Sales）\n\n```javascript\n   var Sales = \"Toyota\";\n   function CarTypes(name) {\n     return (name === \"Honda\") ?\n       name :\n       \"Sorry, we don't sell \" + name + \".\" ;\n   }\n   var car = { myCar: \"Saturn\", getCar: CarTypes(\"Honda\"), special: Sales };\n   console.log(car.myCar);   // Saturn\n   console.log(car.getCar);  // Honda\n   console.log(car.special); // Toyota \n```\n\n更进一步的，你可以使用数字或字符串字面值作为属性的名字，或者在另一个字面值内嵌套上一个字面值。如下的示例中使用了这些可选项\n\n```javascript\n   var car = { manyCars: {a: \"Saab\", \"b\": \"Jeep\"}, 7: \"Mazda\" };\n   console.log(car.manyCars.b); // Jeep\n   console.log(car[7]); // Mazda \n```\n\n对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的javascript标识符，它必须用\"\"包裹。属性的名字不合法，那么便不能用.访问属性值，而是通过类数组标记(\"[]\")访问和赋值。\n\n```javascript\n    var unusualPropertyNames = {\n      \"\": \"An empty string\",\n      \"!\": \"Bang!\"\n    }\n    console.log(unusualPropertyNames.\"\");   // 语法错误: Unexpected string\n    console.log(unusualPropertyNames[\"\"]);  // An empty string\n    console.log(unusualPropertyNames.!);    // 语法错误: Unexpected token !\n    console.log(unusualPropertyNames[\"!\"]); // Bang!\n```\n\n在ES2015，对象文本扩展到支持在原型设置建造，简写foo:foo分配，界定方法，得到很好的名称，并与表达式计算属性名。总之，这些也带来了对象文字和类声明紧密联系起来，让基于对象的设计得益于一些同样的便利。\n\n```javascript\n    var obj = {\n        //__proto__\n        __proto__: theProtoObj,\n        // Shorthand for 'handler:handler'\n        handler,\n        //Methods\n        toString(){\n            //super calls\n            return \"d\" + super.toString();\n        },\n        //Computed (dynamic) property names\n        [ 'prop_' + (() => 42)() ]:42\n    };\n```\n\n### RegExp literals\n一个正则表达式是字符被斜线围成的表达式。下面是一个正则表达式文字的一个例子。\n\n```javascript\n    var re = /ab+c/;\n```\n\n### 字符串字面值\n字符串字面值可以包含零个或多个字符，由双引号对或单引号对包围。字符串被限定在同种引号之间。\n你可以在字符串字面值上使用字符串对象的所有方法--JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串变量。你也能对字符串字面值使用类似String.length的属性：\n\n```javascript\n   \"John's cat\".length\n```\n\n除非有特别需要使用字符串对象，否则，你应当始终使用字符串字面值。\n\n在字符串中使用的特殊字符\n作为一般字符的扩展，你可以在字符串中使用特殊字符\n\n```javascript\n    \"one line \\n another line\"\n```\n以下表格列举了你能在JavaScript的字符串中使用的特殊字符。\n\n| Character | Meaning |\n| ----- | :-----: |\n| \\0 | 空字符 |\n| \\b | 退格 |\n| \\f | 换页符 |\n| \\n | 换行符 |\n| \\r | 回车符 |\n| \\t | Tab制表符 |\n| \\v | 垂直制表符 |\n| \\' | 单引号 |\n| \\\" | 双引号 |\n| \\\\ | 反斜杠字符(\\) |\n| \\XXX | 通过最多三个八进制位数x377.例如在0和指定的Latin-1编码的字符，\\251是版本符号八进制序列。 |\n| \\xXX | 由00和FF之间的两个十六进制数字XX指定的Latin-1编码的字符。例如，版权所有\\ xA9为版权符号十六进制序列。 |\n| \\uXXXX | 由四个十六进制数字XXXX规定的Unicode字符。例如，\\ u00A9为版权符号的Unicode序列。见Unicode转义序列。 |\n| \\u{XXXXX} | Unicode code point escapes. For example, \\u{2F804} is the same as the simple Unicode escapes \\uD87E\\uDC04. |\n\n转义字符\n对于那些未出现在表2.1中的字符，其所带的前导反斜线'\\'将被忽略。但是，这一用法已被废弃，应当避免使用。\n\n通过在引号前加上反斜线'\\'，可以在字符串中插入引号，这就是引号转义。例如:\n```javascript\n    var quote = \"He read \\\"The Cremation of Sam McGee\\\" by R.W. Service.\";\n    console.log(quote); // He read \"The Cremation of Sam McGee\" by R.W. Service.\n```\n\n要在字符串中插入'\\'字面值，必须转义反斜线。例如，要把文件路径 c:\\temp 赋值给一个字符串，可以采用如下方式:\n```javascript\n   var home = \"c:\\\\temp\";\n```\n\n也可以在换行之前加上反斜线以转义换行（译注：实际上就是一条语句拆成多行书写），这样反斜线和换行都不会出现在字符串的值中。\n```javascript\n   var str = \"this string \\\n   is broken \\\n   across multiple\\\n   lines.\"\n   console.log(str);   // this string is broken across multiplelines. \n```\n\nJavascript没有“heredoc”语法，但可以用行末的换行符转义和转义的换行来近似实现 \n```javascript\n    var poem = \n    \"Roses are red,\\n\\\n    Violets are blue.\\n\\\n    I'm schizophrenic,\\n\\\n    And so am I.\"\n```","slug":"语法和数据类型","published":1,"updated":"2016-05-17T10:04:47.584Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enu002gb0dlao3ipbx5","content":"<blockquote>\n<p>By plucking her petals you do not gather the beauty of the flower. </p>\n<p>本章讨论Javascript的基本语法(basic grammar)，变量声明(variable declarations)，数据类型(data types)和字面量(literals)。</p>\n</blockquote>\n<h2 id=\"基础知识-Basic\"><a href=\"#基础知识-Basic\" class=\"headerlink\" title=\"基础知识(Basic)\"></a>基础知识(Basic)</h2><p>Javascript很多语法借鉴自Java，但也受Awk, Perl和Python影响。</p>\n<p>Javascript是大小写敏感的，使用Unicode字符集。</p>\n<p>在Javascript中，语句被称为statements，并用分号分隔(;)。空格、制表符和换行符被称为空白。<br>Javascript的脚本的源文件从左到右扫描，并转换成由令牌，控制字符，行结束符，注释或空白组成的输入元素序列。<br>ECMAScript中还定义了某些关键字和字面量，并具有分号自动插入功能(ASI)来结束语句。但是，建议随时添加分号结束你的语句以避免副作用。</p>\n<h2 id=\"注释-Comments\"><a href=\"#注释-Comments\" class=\"headerlink\" title=\"注释(Comments)\"></a>注释(Comments)</h2><p>注释语法和C++和其他语言相同：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单行注释</span></span><br><span class=\"line\"><span class=\"comment\">/* 这是一个多行注释*/</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"声明-Declarations\"><a href=\"#声明-Declarations\" class=\"headerlink\" title=\"声明(Declarations)\"></a>声明(Declarations)</h2><p>Javascript有三种声明。</p>\n<p>var 声明变量，可选择将其初始化为一个值<br>let 声明块范围局部变量(block scope local variable)，可选择将其初始化为一个值。<br>const 声明一个只读(read-only)命名常量。</p>\n<h3 id=\"变量-variables\"><a href=\"#变量-variables\" class=\"headerlink\" title=\"变量(variables)\"></a>变量(variables)</h3><p>在应用程序中，使用变量来为值命名。变量的名称称为identifiers，需要遵守一定的规则。</p>\n<p>在Javascript语言中，一个标识符(identifier)必须以字母、下划线(_)或者美元($)符号开头；后续的字符可以包含数字(0-9)。因为Javascript语言中是区分大小写的，这里所指的字母可以是(大写的)”A”到字母”Z”和小写的”a”到”z”。<br>从JavaScript 1.5版开始，你可以使用ISO 8859-1或Unicode编码的字符作标识符。你也可以使用\\uXXXX字样的转义序列Unicode escape sequences作标识符。</p>\n<h3 id=\"声明变量-Declaring-variables\"><a href=\"#声明变量-Declaring-variables\" class=\"headerlink\" title=\"声明变量(Declaring variables)\"></a>声明变量(Declaring variables)</h3><p>你可以用以下三种方式声明变量：</p>\n<ul>\n<li>使用关键词var.例如，var x = 42。这个语法可以同时用来声明局部和全局变量。</li>\n<li>直接赋值。</li>\n<li>使用关键词let。例如let y = 13。这个语法可以用来声明语句块代码段的局部变量(block scope local variable)。</li>\n</ul>\n<h3 id=\"对变量求值-Evaluation-variables\"><a href=\"#对变量求值-Evaluation-variables\" class=\"headerlink\" title=\"对变量求值(Evaluation variables)\"></a>对变量求值(Evaluation variables)</h3><p>用var或let声明的未赋初值的变量，值会被定义为undefined（即未定义值，本身也是一个值）。</p>\n<p>试图访问一个未初始化的变量会导致一个ReferenceError异常被抛出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"The value of a is \"</span>+a); <span class=\"comment\">//logs的值未定义</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"The value of b is \"</span>+b); <span class=\"comment\">//抛出ReferenceError异常</span></span><br></pre></td></tr></table></figure>\n<p>你可以使用undefined来确定变量是否已赋值。以下的代码中，变量input未被赋值，因而if条件语句的求值结果是true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> input;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(input === <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">    doThis();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    doThat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>undefined值在布尔类型环境中会被当做false。例如，下面的代码将运行函数myFunction，因为数组myArray中的元素未被赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!myArray[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">    myFunction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数值类型环境中undefined值会被转换为NaN。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a + <span class=\"number\">2</span>; <span class=\"comment\">// Evaluates to NaN</span></span><br></pre></td></tr></table></figure>\n<p>当你对一个空变量求值时，空值null在数值类型环境中会被当作0来对待，而布尔类型环境中会被当作false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n * <span class=\"number\">32</span>); <span class=\"comment\">//logs 0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"变量的域-Variable-scope\"><a href=\"#变量的域-Variable-scope\" class=\"headerlink\" title=\"变量的域(Variable scope)\"></a>变量的域(Variable scope)</h3><p>在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。</p>\n<p>ECMAScript6之前的Javascript没有语句块作用域；相反，语句块中声明的变量将成为语句块所在代码段的局部变量。例如，如下的代码将在控制台输出5，因为x的作用域是声明了x的那个函数(或全局范围)，而不是if语句块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n<p>如果使用ECMAScript6中的let声明，上述行为将发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//ReferenceError: y is not defined.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"变量声明提升-Variable-hoisting\"><a href=\"#变量声明提升-Variable-hoisting\" class=\"headerlink\" title=\"变量声明提升(Variable hoisting)\"></a>变量声明提升(Variable hoisting)</h3><p>JavaScript变量的另一个特别之处是，你可以引用稍后声明的变量，而不会引发异常。这一概念称为变量声明提升(hoisting)；JavaScript变量感觉上是被“举起”或提升到了所有函数和语句之前。然而提升后的变量将返回undefined值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到undefined值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 1</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === <span class=\"literal\">undefined</span>); <span class=\"comment\">//logs \"true\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 2</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// will return a value of undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myvar = <span class=\"string\">\"my value\"</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(myvar); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> myvar = <span class=\"string\">\"local value\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>上面的例子，也可写作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 1</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === <span class=\"literal\">undefined</span>); <span class=\"comment\">// logs \"true\"</span></span><br><span class=\"line\">x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 2</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myvar = <span class=\"string\">\"my value\"</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myvar;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(myvar); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  myvar = <span class=\"string\">\"local value\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>由于存在变量声明提升，一个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这大大地提升了程序代码的清晰度。</p>\n<h3 id=\"全局变量-Global-variables\"><a href=\"#全局变量-Global-variables\" class=\"headerlink\" title=\"全局变量(Global variables)\"></a>全局变量(Global variables)</h3><p>全局变量实际上是全局对象的属性。在网页中，全局对象是window，所以你可以用形如window.variable的语法来设置和访问全局变量。</p>\n<p>因此，你可以通过制定window或frame的名字，从一个window或frame访问另一个window或frame中声明的变量。例如，设想一个叫phoneNumber的变量在文档里被声明，你可以在子框架里用phone.phoneNumber来引用它。</p>\n<h2 id=\"常量-Constants\"><a href=\"#常量-Constants\" class=\"headerlink\" title=\"常量(Constants)\"></a>常量(Constants)</h2><p>你可以用关键字const创建一个只读(read-only)的常量。常量标识符的命名规则和变量的相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> prefix = <span class=\"string\">'212'</span>;</span><br></pre></td></tr></table></figure>\n<p>常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。<strong>它必须被初始化为某个值。</strong></p>\n<p>常量的作用域规则与let会计作用域变量相同。若const关键字被省略了，该标识符将被视为变量。</p>\n<p>在同一个作用域下，不能用于变量或函数同样的名字来命名常量。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//THIS WILL CAUSE AN ERROR</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> f = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// THIS WILL CAUSE AN ERROR ALSO</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> g = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> g;</span><br><span class=\"line\">    <span class=\"comment\">//statements</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据结构和类型\"><a href=\"#数据结构和类型\" class=\"headerlink\" title=\"数据结构和类型\"></a>数据结构和类型</h2><p>JavaScript语言可以识别下面7中不同类型的值：</p>\n<ul>\n<li>六种是原型的数据类型：<ol>\n<li>Boolean. 布尔值，true和false.</li>\n<li>null. 一个表明null值得特殊关键字。JavaScript是大小敏感的，因此null与Null、NULL或其他变量完全不同。</li>\n<li>undefined. 变量未定义时的属性。</li>\n<li>Number. 表示数字，例如：42或者3.14.</li>\n<li>String. 表示字符串，例如：”Hello”。</li>\n<li>Symbol(在ECMAScript6中新添加的类型)。一种数据类型，它的实例是唯一且不可改变的。</li>\n</ol>\n</li>\n<li>以及Object对象</li>\n</ul>\n<p>仅凭这些为数不多的数据类型，在你的应用程序中他们就能够执行有用的功能。</p>\n<p>Objects和functions是本语言的其他两个基本元素。你可以将对象视为存放值得命名容器，而将函数视为你的应用程序能够执行的过程(procedures)。</p>\n<h3 id=\"数据类型的转换-Data-type-conversion\"><a href=\"#数据类型的转换-Data-type-conversion\" class=\"headerlink\" title=\"数据类型的转换(Data type conversion)\"></a>数据类型的转换(Data type conversion)</h3><p>JavaScript是一种动态类型语言(dynamically typed language)。这意味着你声明变量时可以不指定数据类型，而数据会在脚本执行需要时自动转换。那么，你可以这样来定义变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> answer = <span class=\"number\">42</span>;</span><br></pre></td></tr></table></figure>\n<p>然后，你还可以给同一个变量分配一个字符串值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = <span class=\"string\">\"hello world!\"</span>;</span><br></pre></td></tr></table></figure>\n<p>因为JavaScript是动态类型的，这样的指定并不会提示出错。</p>\n<p>再涉及加法运算符(+)的数字和字符串表达式中，JavaScript会把数字值转换为字符串。例如，假设有如下的语句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"string\">\"The answer is \"</span> + <span class=\"number\">42</span> <span class=\"comment\">// \"The answer is 42\"</span></span><br><span class=\"line\">y = <span class=\"number\">42</span> + <span class=\"string\">\" is the answer\"</span> <span class=\"comment\">// \"42 is the answer\"</span></span><br></pre></td></tr></table></figure>\n<p>在涉及其他运算符(如下面的减号)时，JavaScript语言不会把数字变为字符。例如(第一例是数字运算符，第二例是字符串运算符):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"37\"</span> - <span class=\"number\">7</span> <span class=\"comment\">// 30</span></span><br><span class=\"line\"><span class=\"string\">\"37\"</span> + <span class=\"number\">7</span> <span class=\"comment\">// \"377\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串转化为数字-converting-strings-to-numbers\"><a href=\"#字符串转化为数字-converting-strings-to-numbers\" class=\"headerlink\" title=\"字符串转化为数字(converting strings to numbers)\"></a>字符串转化为数字(converting strings to numbers)</h3><p>有一些方法可以将内存中表示一个数字的字符串转换为对应的数字<br>parseInt()和parseFloat()</p>\n<p>parseInt仅能够返回整数，所以使用它会丢失小数部分。另外，调用parseInt时最好总是带上进制(radix)参数，这个参数用于指定使用哪一种数制。</p>\n<h4 id=\"单目加法运算符\"><a href=\"#单目加法运算符\" class=\"headerlink\" title=\"单目加法运算符\"></a>单目加法运算符</h4><p><strong>将字符串转换为数字的另一种方法是使用单目加法运算符。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"1.1\"</span> + <span class=\"string\">\"1.1\"</span> = <span class=\"string\">\"1.11.1\"</span></span><br><span class=\"line\">(+<span class=\"string\">\"1.1\"</span>) + (+<span class=\"string\">\"1.1\"</span>) = <span class=\"number\">2.2</span>   <span class=\"comment\">// 注：加入括号为清楚起见，不是必需的。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字面值-Literals\"><a href=\"#字面值-Literals\" class=\"headerlink\" title=\"字面值(Literals)\"></a>字面值(Literals)</h2><p>(注：字面值是由语法表达式定义的常量；或通过一定字辞组成的语词表达式定义的常量)</p>\n<p>在JavaScript中，你可以使用各种字面值。这些字面值是脚本中按字面意思给出的固定的值，而不是变量。(字面值是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false,3.1415,thisStringOfHelloWorld,invokedFunction: myFunction(“myArgument”))</p>\n<h3 id=\"数组字面值-Array-Literals\"><a href=\"#数组字面值-Array-Literals\" class=\"headerlink\" title=\"数组字面值(Array Literals)\"></a>数组字面值(Array Literals)</h3><p>数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。当你使用数组字面值创建一个数组时，该数组将会以指定的值作为它的元素进行初始化，而其长度被设定为元素的个数。</p>\n<p>下面的示例用3个元素生成数组coffees，它的长度是3。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> coffees = [<span class=\"string\">\"French Roast\"</span>, <span class=\"string\">\"Colombian\"</span>, <span class=\"string\">\"Kona\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"number\">0</span>]); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>若在顶层（全局）脚本里用字面值创建数组，JavaScript语言会在每次对包含该数组字面值的表达式时解释该数组。另一方面，在函数中使用的数组，将在每次调用函数时被创建一次。</p>\n<p>数组字面值同时也是数组对象。</p>\n<p><strong>数组字面值中的多余逗号</strong><br>你不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没被指定的元素，其初始值是undefined。以下示例创建了一个名为fish的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fish = [<span class=\"string\">\"Lion\"</span>, , <span class=\"string\">\"Angel\"</span>];</span><br></pre></td></tr></table></figure>\n<p>这个数组中，有两个已被赋值的元素，和一个空元素，此时的数组的长度是3.</p>\n<p>若你在元素列表的尾部添加了一个逗号，它会被忽略。在下面的例子中，该数组的长度是3.并不存在myList[3]这个元素。元素列表中所有其他的逗号都表示一个新元素（的开始）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myList = [<span class=\"string\">'home'</span>, , <span class=\"string\">'school'</span>, ];</span><br></pre></td></tr></table></figure>\n<p>在下面的例子中，数组的长度是4，元素myList[0]和myList[2]缺失（译注：没被赋值，因而是undefined）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myList = [ , <span class=\"string\">'home'</span>, , <span class=\"string\">'school'</span>];</span><br></pre></td></tr></table></figure>\n<p>又一个例子，在这里该数组的长度是4，元素myList[1]和myList[3]被漏掉了。（但是）只有最后的那个逗号被忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myList = [<span class=\"string\">'home'</span>, , <span class=\"string\">'school'</span>, , ];</span><br></pre></td></tr></table></figure>\n<p>理解多余的逗号（在脚本运行时会被如何处理）的含义，对于从语言层面理解JavaScript是十分重要的。但是，你自己写代码时：<strong>显式地将缺失的元素声明为undefined，将大大增加你的代码的清晰度和可维护性</strong>。</p>\n<h3 id=\"布尔字面值-Boolean-literals\"><a href=\"#布尔字面值-Boolean-literals\" class=\"headerlink\" title=\"布尔字面值(Boolean literals)\"></a>布尔字面值(Boolean literals)</h3><p>布尔类型有两种字面值：true和false。</p>\n<p>不要混淆作为布尔对象的真和假与布尔类型的原始值true和false。布尔对象是原始布尔数据类型的一个包装器。</p>\n<h3 id=\"整数-Intergers\"><a href=\"#整数-Intergers\" class=\"headerlink\" title=\"整数(Intergers)\"></a>整数(Intergers)</h3><p>整数可以被表示成十进制(基数为10)、十六进制(基数为16)以及八进制(基数为8)。</p>\n<ul>\n<li>十进制整数字组成的数字序列，不带前导0.</li>\n<li>带前导0、0O、0o的整数字面值表明它是八进制。八进制整数只能包括数字0-7。</li>\n<li>前缀0x或0X表示十六进制。十六进制整数，可以包含数字（0-9）和字母a~f或A~F。</li>\n</ul>\n<h3 id=\"浮点数字面值-Floating-point-literal\"><a href=\"#浮点数字面值-Floating-point-literal\" class=\"headerlink\" title=\"浮点数字面值(Floating-point literal)\"></a>浮点数字面值(Floating-point literal)</h3><p>浮点数字面值可以有以下的组成部分：</p>\n<ul>\n<li>一个十进制整数，它可以带符号（即前面的”+”或”-“号），</li>\n<li>一个小数点（”.”），</li>\n<li>一个小数部分（由一串十进制数表示），</li>\n<li>一个指数部分</li>\n</ul>\n<p>指数部分是以”e”或”E”开头后面跟着一个整数，可以有正负号（即前面写”+”或”-“）。一个浮点数字面值必须至少有一位数字，后接小数点或者”e”(“E”)组成。</p>\n<p>一些浮点数字面值的例子，如3.1415,-3.1415,1e12以及2E-12。</p>\n<p>简而言之，其语法是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(+|-)][digits][.digits][(E|e)[(+|-)]digits]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象字面量-Object-literals\"><a href=\"#对象字面量-Object-literals\" class=\"headerlink\" title=\"对象字面量(Object literals)\"></a>对象字面量(Object literals)</h3><p>对象字面值是封闭在花括号对({})中的一个对象的零个或多个”属性名-值”对的（元素）列表。你不能在一条语句的开头就使用对象字面值，这将导致错误或非你所预想的行为，因为此时左花括号({)会被认为一个语句块的齐师傅好。</p>\n<p>以下是一个对象字面值的例子。对象car的第一个元素（译注：即一个属性双值对）定义了属性myCar；第二个元素，属性getCar，引用了一个函数（即CarTypes(“Honda”)）；第三个元素，属性special，使用了一个已有的变量（即Sales）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Sales = <span class=\"string\">\"Toyota\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CarTypes</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (name === <span class=\"string\">\"Honda\"</span>) ?</span><br><span class=\"line\">    name :</span><br><span class=\"line\">    <span class=\"string\">\"Sorry, we don't sell \"</span> + name + <span class=\"string\">\".\"</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = &#123; myCar: <span class=\"string\">\"Saturn\"</span>, getCar: CarTypes(<span class=\"string\">\"Honda\"</span>), special: Sales &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.myCar);   <span class=\"comment\">// Saturn</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.getCar);  <span class=\"comment\">// Honda</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.special); <span class=\"comment\">// Toyota</span></span><br></pre></td></tr></table></figure>\n<p>更进一步的，你可以使用数字或字符串字面值作为属性的名字，或者在另一个字面值内嵌套上一个字面值。如下的示例中使用了这些可选项</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> car = &#123; manyCars: &#123;a: <span class=\"string\">\"Saab\"</span>, <span class=\"string\">\"b\"</span>: <span class=\"string\">\"Jeep\"</span>&#125;, <span class=\"number\">7</span>: <span class=\"string\">\"Mazda\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.manyCars.b); <span class=\"comment\">// Jeep</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car[<span class=\"number\">7</span>]); <span class=\"comment\">// Mazda</span></span><br></pre></td></tr></table></figure>\n<p>对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的javascript标识符，它必须用””包裹。属性的名字不合法，那么便不能用.访问属性值，而是通过类数组标记(“[]”)访问和赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> unusualPropertyNames = &#123;</span><br><span class=\"line\">  <span class=\"string\">\"\"</span>: <span class=\"string\">\"An empty string\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"!\"</span>: <span class=\"string\">\"Bang!\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames.<span class=\"string\">\"\"</span>);   <span class=\"comment\">// 语法错误: Unexpected string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames[<span class=\"string\">\"\"</span>]);  <span class=\"comment\">// An empty string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames.!);    <span class=\"comment\">// 语法错误: Unexpected token !</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames[<span class=\"string\">\"!\"</span>]); <span class=\"comment\">// Bang!</span></span><br></pre></td></tr></table></figure>\n<p>在ES2015，对象文本扩展到支持在原型设置建造，简写foo:foo分配，界定方法，得到很好的名称，并与表达式计算属性名。总之，这些也带来了对象文字和类声明紧密联系起来，让基于对象的设计得益于一些同样的便利。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//__proto__</span></span><br><span class=\"line\">    __proto__: theProtoObj,</span><br><span class=\"line\">    <span class=\"comment\">// Shorthand for 'handler:handler'</span></span><br><span class=\"line\">    handler,</span><br><span class=\"line\">    <span class=\"comment\">//Methods</span></span><br><span class=\"line\">    toString()&#123;</span><br><span class=\"line\">        <span class=\"comment\">//super calls</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"d\"</span> + <span class=\"keyword\">super</span>.toString();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//Computed (dynamic) property names</span></span><br><span class=\"line\">    [ <span class=\"string\">'prop_'</span> + (() =&gt; <span class=\"number\">42</span>)() ]:<span class=\"number\">42</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RegExp-literals\"><a href=\"#RegExp-literals\" class=\"headerlink\" title=\"RegExp literals\"></a>RegExp literals</h3><p>一个正则表达式是字符被斜线围成的表达式。下面是一个正则表达式文字的一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/ab+c/</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串字面值\"><a href=\"#字符串字面值\" class=\"headerlink\" title=\"字符串字面值\"></a>字符串字面值</h3><p>字符串字面值可以包含零个或多个字符，由双引号对或单引号对包围。字符串被限定在同种引号之间。<br>你可以在字符串字面值上使用字符串对象的所有方法–JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串变量。你也能对字符串字面值使用类似String.length的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"John's cat\"</span>.length</span><br></pre></td></tr></table></figure>\n<p>除非有特别需要使用字符串对象，否则，你应当始终使用字符串字面值。</p>\n<p>在字符串中使用的特殊字符<br>作为一般字符的扩展，你可以在字符串中使用特殊字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"one line \\n another line\"</span></span><br></pre></td></tr></table></figure>\n<p>以下表格列举了你能在JavaScript的字符串中使用的特殊字符。</p>\n<table>\n<thead>\n<tr>\n<th>Character</th>\n<th style=\"text-align:center\">Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\0</td>\n<td style=\"text-align:center\">空字符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td style=\"text-align:center\">退格</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td style=\"text-align:center\">换页符</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td style=\"text-align:center\">换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td style=\"text-align:center\">回车符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td style=\"text-align:center\">Tab制表符</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td style=\"text-align:center\">垂直制表符</td>\n</tr>\n<tr>\n<td>\\’</td>\n<td style=\"text-align:center\">单引号</td>\n</tr>\n<tr>\n<td>\\”</td>\n<td style=\"text-align:center\">双引号</td>\n</tr>\n<tr>\n<td>\\</td>\n<td style=\"text-align:center\">反斜杠字符()</td>\n</tr>\n<tr>\n<td>\\XXX</td>\n<td style=\"text-align:center\">通过最多三个八进制位数x377.例如在0和指定的Latin-1编码的字符，\\251是版本符号八进制序列。</td>\n</tr>\n<tr>\n<td>\\xXX</td>\n<td style=\"text-align:center\">由00和FF之间的两个十六进制数字XX指定的Latin-1编码的字符。例如，版权所有\\ xA9为版权符号十六进制序列。</td>\n</tr>\n<tr>\n<td>\\uXXXX</td>\n<td style=\"text-align:center\">由四个十六进制数字XXXX规定的Unicode字符。例如，\\ u00A9为版权符号的Unicode序列。见Unicode转义序列。</td>\n</tr>\n<tr>\n<td>\\u{XXXXX}</td>\n<td style=\"text-align:center\">Unicode code point escapes. For example, \\u{2F804} is the same as the simple Unicode escapes \\uD87E\\uDC04.</td>\n</tr>\n</tbody>\n</table>\n<p>转义字符<br>对于那些未出现在表2.1中的字符，其所带的前导反斜线’\\’将被忽略。但是，这一用法已被废弃，应当避免使用。</p>\n<p>通过在引号前加上反斜线’\\’，可以在字符串中插入引号，这就是引号转义。例如:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quote = <span class=\"string\">\"He read \\\"The Cremation of Sam McGee\\\" by R.W. Service.\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(quote); <span class=\"comment\">// He read \"The Cremation of Sam McGee\" by R.W. Service.</span></span><br></pre></td></tr></table></figure></p>\n<p>要在字符串中插入’\\’字面值，必须转义反斜线。例如，要把文件路径 c:\\temp 赋值给一个字符串，可以采用如下方式:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> home = <span class=\"string\">\"c:\\\\temp\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p>也可以在换行之前加上反斜线以转义换行（译注：实际上就是一条语句拆成多行书写），这样反斜线和换行都不会出现在字符串的值中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"this string \\</span><br><span class=\"line\">is broken \\</span><br><span class=\"line\">across multiple\\</span><br><span class=\"line\">lines.\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);   <span class=\"comment\">// this string is broken across multiplelines.</span></span><br></pre></td></tr></table></figure></p>\n<p>Javascript没有“heredoc”语法，但可以用行末的换行符转义和转义的换行来近似实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> poem = </span><br><span class=\"line\"><span class=\"string\">\"Roses are red,\\n\\</span><br><span class=\"line\">Violets are blue.\\n\\</span><br><span class=\"line\">I'm schizophrenic,\\n\\</span><br><span class=\"line\">And so am I.\"</span></span><br></pre></td></tr></table></figure></p>\n","excerpt":"","more":"<blockquote>\n<p>By plucking her petals you do not gather the beauty of the flower. </p>\n<p>本章讨论Javascript的基本语法(basic grammar)，变量声明(variable declarations)，数据类型(data types)和字面量(literals)。</p>\n</blockquote>\n<h2 id=\"基础知识-Basic\"><a href=\"#基础知识-Basic\" class=\"headerlink\" title=\"基础知识(Basic)\"></a>基础知识(Basic)</h2><p>Javascript很多语法借鉴自Java，但也受Awk, Perl和Python影响。</p>\n<p>Javascript是大小写敏感的，使用Unicode字符集。</p>\n<p>在Javascript中，语句被称为statements，并用分号分隔(;)。空格、制表符和换行符被称为空白。<br>Javascript的脚本的源文件从左到右扫描，并转换成由令牌，控制字符，行结束符，注释或空白组成的输入元素序列。<br>ECMAScript中还定义了某些关键字和字面量，并具有分号自动插入功能(ASI)来结束语句。但是，建议随时添加分号结束你的语句以避免副作用。</p>\n<h2 id=\"注释-Comments\"><a href=\"#注释-Comments\" class=\"headerlink\" title=\"注释(Comments)\"></a>注释(Comments)</h2><p>注释语法和C++和其他语言相同：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//单行注释</span></span><br><span class=\"line\"><span class=\"comment\">/* 这是一个多行注释*/</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"声明-Declarations\"><a href=\"#声明-Declarations\" class=\"headerlink\" title=\"声明(Declarations)\"></a>声明(Declarations)</h2><p>Javascript有三种声明。</p>\n<p>var 声明变量，可选择将其初始化为一个值<br>let 声明块范围局部变量(block scope local variable)，可选择将其初始化为一个值。<br>const 声明一个只读(read-only)命名常量。</p>\n<h3 id=\"变量-variables\"><a href=\"#变量-variables\" class=\"headerlink\" title=\"变量(variables)\"></a>变量(variables)</h3><p>在应用程序中，使用变量来为值命名。变量的名称称为identifiers，需要遵守一定的规则。</p>\n<p>在Javascript语言中，一个标识符(identifier)必须以字母、下划线(_)或者美元($)符号开头；后续的字符可以包含数字(0-9)。因为Javascript语言中是区分大小写的，这里所指的字母可以是(大写的)”A”到字母”Z”和小写的”a”到”z”。<br>从JavaScript 1.5版开始，你可以使用ISO 8859-1或Unicode编码的字符作标识符。你也可以使用\\uXXXX字样的转义序列Unicode escape sequences作标识符。</p>\n<h3 id=\"声明变量-Declaring-variables\"><a href=\"#声明变量-Declaring-variables\" class=\"headerlink\" title=\"声明变量(Declaring variables)\"></a>声明变量(Declaring variables)</h3><p>你可以用以下三种方式声明变量：</p>\n<ul>\n<li>使用关键词var.例如，var x = 42。这个语法可以同时用来声明局部和全局变量。</li>\n<li>直接赋值。</li>\n<li>使用关键词let。例如let y = 13。这个语法可以用来声明语句块代码段的局部变量(block scope local variable)。</li>\n</ul>\n<h3 id=\"对变量求值-Evaluation-variables\"><a href=\"#对变量求值-Evaluation-variables\" class=\"headerlink\" title=\"对变量求值(Evaluation variables)\"></a>对变量求值(Evaluation variables)</h3><p>用var或let声明的未赋初值的变量，值会被定义为undefined（即未定义值，本身也是一个值）。</p>\n<p>试图访问一个未初始化的变量会导致一个ReferenceError异常被抛出：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"The value of a is \"</span>+a); <span class=\"comment\">//logs的值未定义</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"The value of b is \"</span>+b); <span class=\"comment\">//抛出ReferenceError异常</span></span><br></pre></td></tr></table></figure>\n<p>你可以使用undefined来确定变量是否已赋值。以下的代码中，变量input未被赋值，因而if条件语句的求值结果是true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> input;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(input === <span class=\"literal\">undefined</span>)&#123;</span><br><span class=\"line\">    doThis();</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    doThat();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>undefined值在布尔类型环境中会被当做false。例如，下面的代码将运行函数myFunction，因为数组myArray中的元素未被赋值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myArray = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>();</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!myArray[<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">    myFunction();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数值类型环境中undefined值会被转换为NaN。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;</span><br><span class=\"line\">a + <span class=\"number\">2</span>; <span class=\"comment\">// Evaluates to NaN</span></span><br></pre></td></tr></table></figure>\n<p>当你对一个空变量求值时，空值null在数值类型环境中会被当作0来对待，而布尔类型环境中会被当作false</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> n = <span class=\"literal\">null</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n * <span class=\"number\">32</span>); <span class=\"comment\">//logs 0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"变量的域-Variable-scope\"><a href=\"#变量的域-Variable-scope\" class=\"headerlink\" title=\"变量的域(Variable scope)\"></a>变量的域(Variable scope)</h3><p>在所有函数之外声明的变量，叫做全局变量，因为它可被当前文档中的其他代码所访问。在函数内部声明的变量，叫做局部变量，因为它只能在该函数内部访问。</p>\n<p>ECMAScript6之前的Javascript没有语句块作用域；相反，语句块中声明的变量将成为语句块所在代码段的局部变量。例如，如下的代码将在控制台输出5，因为x的作用域是声明了x的那个函数(或全局范围)，而不是if语句块。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n<p>如果使用ECMAScript6中的let声明，上述行为将发生变化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> x = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x); <span class=\"comment\">//ReferenceError: y is not defined.</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"变量声明提升-Variable-hoisting\"><a href=\"#变量声明提升-Variable-hoisting\" class=\"headerlink\" title=\"变量声明提升(Variable hoisting)\"></a>变量声明提升(Variable hoisting)</h3><p>JavaScript变量的另一个特别之处是，你可以引用稍后声明的变量，而不会引发异常。这一概念称为变量声明提升(hoisting)；JavaScript变量感觉上是被“举起”或提升到了所有函数和语句之前。然而提升后的变量将返回undefined值，所以即使在使用或引用某个变量之后存在声明和初始化操作，仍将得到undefined值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 1</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === <span class=\"literal\">undefined</span>); <span class=\"comment\">//logs \"true\"</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 2</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"comment\">// will return a value of undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myvar = <span class=\"string\">\"my value\"</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(myvar); <span class=\"comment\">//undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> myvar = <span class=\"string\">\"local value\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>上面的例子，也可写作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 1</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x === <span class=\"literal\">undefined</span>); <span class=\"comment\">// logs \"true\"</span></span><br><span class=\"line\">x = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span><br><span class=\"line\"> * Example 2</span><br><span class=\"line\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myvar = <span class=\"string\">\"my value\"</span>;</span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> myvar;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(myvar); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">  myvar = <span class=\"string\">\"local value\"</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>由于存在变量声明提升，一个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这大大地提升了程序代码的清晰度。</p>\n<h3 id=\"全局变量-Global-variables\"><a href=\"#全局变量-Global-variables\" class=\"headerlink\" title=\"全局变量(Global variables)\"></a>全局变量(Global variables)</h3><p>全局变量实际上是全局对象的属性。在网页中，全局对象是window，所以你可以用形如window.variable的语法来设置和访问全局变量。</p>\n<p>因此，你可以通过制定window或frame的名字，从一个window或frame访问另一个window或frame中声明的变量。例如，设想一个叫phoneNumber的变量在文档里被声明，你可以在子框架里用phone.phoneNumber来引用它。</p>\n<h2 id=\"常量-Constants\"><a href=\"#常量-Constants\" class=\"headerlink\" title=\"常量(Constants)\"></a>常量(Constants)</h2><p>你可以用关键字const创建一个只读(read-only)的常量。常量标识符的命名规则和变量的相同：必须以字母、下划线或美元符号开头并可以包含有字母、数字或下划线。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> prefix = <span class=\"string\">'212'</span>;</span><br></pre></td></tr></table></figure>\n<p>常量不可以通过赋值改变其值，也不可以在脚本运行时重新声明。<strong>它必须被初始化为某个值。</strong></p>\n<p>常量的作用域规则与let会计作用域变量相同。若const关键字被省略了，该标识符将被视为变量。</p>\n<p>在同一个作用域下，不能用于变量或函数同样的名字来命名常量。例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//THIS WILL CAUSE AN ERROR</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> f = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"comment\">// THIS WILL CAUSE AN ERROR ALSO</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> g = <span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> g;</span><br><span class=\"line\">    <span class=\"comment\">//statements</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据结构和类型\"><a href=\"#数据结构和类型\" class=\"headerlink\" title=\"数据结构和类型\"></a>数据结构和类型</h2><p>JavaScript语言可以识别下面7中不同类型的值：</p>\n<ul>\n<li>六种是原型的数据类型：<ol>\n<li>Boolean. 布尔值，true和false.</li>\n<li>null. 一个表明null值得特殊关键字。JavaScript是大小敏感的，因此null与Null、NULL或其他变量完全不同。</li>\n<li>undefined. 变量未定义时的属性。</li>\n<li>Number. 表示数字，例如：42或者3.14.</li>\n<li>String. 表示字符串，例如：”Hello”。</li>\n<li>Symbol(在ECMAScript6中新添加的类型)。一种数据类型，它的实例是唯一且不可改变的。</li>\n</ol>\n</li>\n<li>以及Object对象</li>\n</ul>\n<p>仅凭这些为数不多的数据类型，在你的应用程序中他们就能够执行有用的功能。</p>\n<p>Objects和functions是本语言的其他两个基本元素。你可以将对象视为存放值得命名容器，而将函数视为你的应用程序能够执行的过程(procedures)。</p>\n<h3 id=\"数据类型的转换-Data-type-conversion\"><a href=\"#数据类型的转换-Data-type-conversion\" class=\"headerlink\" title=\"数据类型的转换(Data type conversion)\"></a>数据类型的转换(Data type conversion)</h3><p>JavaScript是一种动态类型语言(dynamically typed language)。这意味着你声明变量时可以不指定数据类型，而数据会在脚本执行需要时自动转换。那么，你可以这样来定义变量：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> answer = <span class=\"number\">42</span>;</span><br></pre></td></tr></table></figure>\n<p>然后，你还可以给同一个变量分配一个字符串值，例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = <span class=\"string\">\"hello world!\"</span>;</span><br></pre></td></tr></table></figure>\n<p>因为JavaScript是动态类型的，这样的指定并不会提示出错。</p>\n<p>再涉及加法运算符(+)的数字和字符串表达式中，JavaScript会把数字值转换为字符串。例如，假设有如下的语句：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"string\">\"The answer is \"</span> + <span class=\"number\">42</span> <span class=\"comment\">// \"The answer is 42\"</span></span><br><span class=\"line\">y = <span class=\"number\">42</span> + <span class=\"string\">\" is the answer\"</span> <span class=\"comment\">// \"42 is the answer\"</span></span><br></pre></td></tr></table></figure>\n<p>在涉及其他运算符(如下面的减号)时，JavaScript语言不会把数字变为字符。例如(第一例是数字运算符，第二例是字符串运算符):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"37\"</span> - <span class=\"number\">7</span> <span class=\"comment\">// 30</span></span><br><span class=\"line\"><span class=\"string\">\"37\"</span> + <span class=\"number\">7</span> <span class=\"comment\">// \"377\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串转化为数字-converting-strings-to-numbers\"><a href=\"#字符串转化为数字-converting-strings-to-numbers\" class=\"headerlink\" title=\"字符串转化为数字(converting strings to numbers)\"></a>字符串转化为数字(converting strings to numbers)</h3><p>有一些方法可以将内存中表示一个数字的字符串转换为对应的数字<br>parseInt()和parseFloat()</p>\n<p>parseInt仅能够返回整数，所以使用它会丢失小数部分。另外，调用parseInt时最好总是带上进制(radix)参数，这个参数用于指定使用哪一种数制。</p>\n<h4 id=\"单目加法运算符\"><a href=\"#单目加法运算符\" class=\"headerlink\" title=\"单目加法运算符\"></a>单目加法运算符</h4><p><strong>将字符串转换为数字的另一种方法是使用单目加法运算符。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"1.1\"</span> + <span class=\"string\">\"1.1\"</span> = <span class=\"string\">\"1.11.1\"</span></span><br><span class=\"line\">(+<span class=\"string\">\"1.1\"</span>) + (+<span class=\"string\">\"1.1\"</span>) = <span class=\"number\">2.2</span>   <span class=\"comment\">// 注：加入括号为清楚起见，不是必需的。</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"字面值-Literals\"><a href=\"#字面值-Literals\" class=\"headerlink\" title=\"字面值(Literals)\"></a>字面值(Literals)</h2><p>(注：字面值是由语法表达式定义的常量；或通过一定字辞组成的语词表达式定义的常量)</p>\n<p>在JavaScript中，你可以使用各种字面值。这些字面值是脚本中按字面意思给出的固定的值，而不是变量。(字面值是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false,3.1415,thisStringOfHelloWorld,invokedFunction: myFunction(“myArgument”))</p>\n<h3 id=\"数组字面值-Array-Literals\"><a href=\"#数组字面值-Array-Literals\" class=\"headerlink\" title=\"数组字面值(Array Literals)\"></a>数组字面值(Array Literals)</h3><p>数组字面值是一个封闭在方括号对([])中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。当你使用数组字面值创建一个数组时，该数组将会以指定的值作为它的元素进行初始化，而其长度被设定为元素的个数。</p>\n<p>下面的示例用3个元素生成数组coffees，它的长度是3。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> coffees = [<span class=\"string\">\"French Roast\"</span>, <span class=\"string\">\"Colombian\"</span>, <span class=\"string\">\"Kona\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> a=[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length); <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a[<span class=\"number\">0</span>]); <span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure>\n<p>若在顶层（全局）脚本里用字面值创建数组，JavaScript语言会在每次对包含该数组字面值的表达式时解释该数组。另一方面，在函数中使用的数组，将在每次调用函数时被创建一次。</p>\n<p>数组字面值同时也是数组对象。</p>\n<p><strong>数组字面值中的多余逗号</strong><br>你不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没被指定的元素，其初始值是undefined。以下示例创建了一个名为fish的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fish = [<span class=\"string\">\"Lion\"</span>, , <span class=\"string\">\"Angel\"</span>];</span><br></pre></td></tr></table></figure>\n<p>这个数组中，有两个已被赋值的元素，和一个空元素，此时的数组的长度是3.</p>\n<p>若你在元素列表的尾部添加了一个逗号，它会被忽略。在下面的例子中，该数组的长度是3.并不存在myList[3]这个元素。元素列表中所有其他的逗号都表示一个新元素（的开始）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myList = [<span class=\"string\">'home'</span>, , <span class=\"string\">'school'</span>, ];</span><br></pre></td></tr></table></figure>\n<p>在下面的例子中，数组的长度是4，元素myList[0]和myList[2]缺失（译注：没被赋值，因而是undefined）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myList = [ , <span class=\"string\">'home'</span>, , <span class=\"string\">'school'</span>];</span><br></pre></td></tr></table></figure>\n<p>又一个例子，在这里该数组的长度是4，元素myList[1]和myList[3]被漏掉了。（但是）只有最后的那个逗号被忽略。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myList = [<span class=\"string\">'home'</span>, , <span class=\"string\">'school'</span>, , ];</span><br></pre></td></tr></table></figure>\n<p>理解多余的逗号（在脚本运行时会被如何处理）的含义，对于从语言层面理解JavaScript是十分重要的。但是，你自己写代码时：<strong>显式地将缺失的元素声明为undefined，将大大增加你的代码的清晰度和可维护性</strong>。</p>\n<h3 id=\"布尔字面值-Boolean-literals\"><a href=\"#布尔字面值-Boolean-literals\" class=\"headerlink\" title=\"布尔字面值(Boolean literals)\"></a>布尔字面值(Boolean literals)</h3><p>布尔类型有两种字面值：true和false。</p>\n<p>不要混淆作为布尔对象的真和假与布尔类型的原始值true和false。布尔对象是原始布尔数据类型的一个包装器。</p>\n<h3 id=\"整数-Intergers\"><a href=\"#整数-Intergers\" class=\"headerlink\" title=\"整数(Intergers)\"></a>整数(Intergers)</h3><p>整数可以被表示成十进制(基数为10)、十六进制(基数为16)以及八进制(基数为8)。</p>\n<ul>\n<li>十进制整数字组成的数字序列，不带前导0.</li>\n<li>带前导0、0O、0o的整数字面值表明它是八进制。八进制整数只能包括数字0-7。</li>\n<li>前缀0x或0X表示十六进制。十六进制整数，可以包含数字（0-9）和字母a~f或A~F。</li>\n</ul>\n<h3 id=\"浮点数字面值-Floating-point-literal\"><a href=\"#浮点数字面值-Floating-point-literal\" class=\"headerlink\" title=\"浮点数字面值(Floating-point literal)\"></a>浮点数字面值(Floating-point literal)</h3><p>浮点数字面值可以有以下的组成部分：</p>\n<ul>\n<li>一个十进制整数，它可以带符号（即前面的”+”或”-“号），</li>\n<li>一个小数点（”.”），</li>\n<li>一个小数部分（由一串十进制数表示），</li>\n<li>一个指数部分</li>\n</ul>\n<p>指数部分是以”e”或”E”开头后面跟着一个整数，可以有正负号（即前面写”+”或”-“）。一个浮点数字面值必须至少有一位数字，后接小数点或者”e”(“E”)组成。</p>\n<p>一些浮点数字面值的例子，如3.1415,-3.1415,1e12以及2E-12。</p>\n<p>简而言之，其语法是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[(+|-)][digits][.digits][(E|e)[(+|-)]digits]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"对象字面量-Object-literals\"><a href=\"#对象字面量-Object-literals\" class=\"headerlink\" title=\"对象字面量(Object literals)\"></a>对象字面量(Object literals)</h3><p>对象字面值是封闭在花括号对({})中的一个对象的零个或多个”属性名-值”对的（元素）列表。你不能在一条语句的开头就使用对象字面值，这将导致错误或非你所预想的行为，因为此时左花括号({)会被认为一个语句块的齐师傅好。</p>\n<p>以下是一个对象字面值的例子。对象car的第一个元素（译注：即一个属性双值对）定义了属性myCar；第二个元素，属性getCar，引用了一个函数（即CarTypes(“Honda”)）；第三个元素，属性special，使用了一个已有的变量（即Sales）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Sales = <span class=\"string\">\"Toyota\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">CarTypes</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (name === <span class=\"string\">\"Honda\"</span>) ?</span><br><span class=\"line\">    name :</span><br><span class=\"line\">    <span class=\"string\">\"Sorry, we don't sell \"</span> + name + <span class=\"string\">\".\"</span> ;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> car = &#123; myCar: <span class=\"string\">\"Saturn\"</span>, getCar: CarTypes(<span class=\"string\">\"Honda\"</span>), special: Sales &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.myCar);   <span class=\"comment\">// Saturn</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.getCar);  <span class=\"comment\">// Honda</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.special); <span class=\"comment\">// Toyota</span></span><br></pre></td></tr></table></figure>\n<p>更进一步的，你可以使用数字或字符串字面值作为属性的名字，或者在另一个字面值内嵌套上一个字面值。如下的示例中使用了这些可选项</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> car = &#123; manyCars: &#123;a: <span class=\"string\">\"Saab\"</span>, <span class=\"string\">\"b\"</span>: <span class=\"string\">\"Jeep\"</span>&#125;, <span class=\"number\">7</span>: <span class=\"string\">\"Mazda\"</span> &#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car.manyCars.b); <span class=\"comment\">// Jeep</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(car[<span class=\"number\">7</span>]); <span class=\"comment\">// Mazda</span></span><br></pre></td></tr></table></figure>\n<p>对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的javascript标识符，它必须用””包裹。属性的名字不合法，那么便不能用.访问属性值，而是通过类数组标记(“[]”)访问和赋值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> unusualPropertyNames = &#123;</span><br><span class=\"line\">  <span class=\"string\">\"\"</span>: <span class=\"string\">\"An empty string\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"!\"</span>: <span class=\"string\">\"Bang!\"</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames.<span class=\"string\">\"\"</span>);   <span class=\"comment\">// 语法错误: Unexpected string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames[<span class=\"string\">\"\"</span>]);  <span class=\"comment\">// An empty string</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames.!);    <span class=\"comment\">// 语法错误: Unexpected token !</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(unusualPropertyNames[<span class=\"string\">\"!\"</span>]); <span class=\"comment\">// Bang!</span></span><br></pre></td></tr></table></figure>\n<p>在ES2015，对象文本扩展到支持在原型设置建造，简写foo:foo分配，界定方法，得到很好的名称，并与表达式计算属性名。总之，这些也带来了对象文字和类声明紧密联系起来，让基于对象的设计得益于一些同样的便利。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//__proto__</span></span><br><span class=\"line\">    __proto__: theProtoObj,</span><br><span class=\"line\">    <span class=\"comment\">// Shorthand for 'handler:handler'</span></span><br><span class=\"line\">    handler,</span><br><span class=\"line\">    <span class=\"comment\">//Methods</span></span><br><span class=\"line\">    toString()&#123;</span><br><span class=\"line\">        <span class=\"comment\">//super calls</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"d\"</span> + <span class=\"keyword\">super</span>.toString();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//Computed (dynamic) property names</span></span><br><span class=\"line\">    [ <span class=\"string\">'prop_'</span> + (() =&gt; <span class=\"number\">42</span>)() ]:<span class=\"number\">42</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"RegExp-literals\"><a href=\"#RegExp-literals\" class=\"headerlink\" title=\"RegExp literals\"></a>RegExp literals</h3><p>一个正则表达式是字符被斜线围成的表达式。下面是一个正则表达式文字的一个例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = <span class=\"regexp\">/ab+c/</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串字面值\"><a href=\"#字符串字面值\" class=\"headerlink\" title=\"字符串字面值\"></a>字符串字面值</h3><p>字符串字面值可以包含零个或多个字符，由双引号对或单引号对包围。字符串被限定在同种引号之间。<br>你可以在字符串字面值上使用字符串对象的所有方法–JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串变量。你也能对字符串字面值使用类似String.length的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"John's cat\"</span>.length</span><br></pre></td></tr></table></figure>\n<p>除非有特别需要使用字符串对象，否则，你应当始终使用字符串字面值。</p>\n<p>在字符串中使用的特殊字符<br>作为一般字符的扩展，你可以在字符串中使用特殊字符</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"one line \\n another line\"</span></span><br></pre></td></tr></table></figure>\n<p>以下表格列举了你能在JavaScript的字符串中使用的特殊字符。</p>\n<table>\n<thead>\n<tr>\n<th>Character</th>\n<th style=\"text-align:center\">Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\0</td>\n<td style=\"text-align:center\">空字符</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td style=\"text-align:center\">退格</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td style=\"text-align:center\">换页符</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td style=\"text-align:center\">换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td style=\"text-align:center\">回车符</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td style=\"text-align:center\">Tab制表符</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td style=\"text-align:center\">垂直制表符</td>\n</tr>\n<tr>\n<td>\\’</td>\n<td style=\"text-align:center\">单引号</td>\n</tr>\n<tr>\n<td>\\”</td>\n<td style=\"text-align:center\">双引号</td>\n</tr>\n<tr>\n<td>\\</td>\n<td style=\"text-align:center\">反斜杠字符()</td>\n</tr>\n<tr>\n<td>\\XXX</td>\n<td style=\"text-align:center\">通过最多三个八进制位数x377.例如在0和指定的Latin-1编码的字符，\\251是版本符号八进制序列。</td>\n</tr>\n<tr>\n<td>\\xXX</td>\n<td style=\"text-align:center\">由00和FF之间的两个十六进制数字XX指定的Latin-1编码的字符。例如，版权所有\\ xA9为版权符号十六进制序列。</td>\n</tr>\n<tr>\n<td>\\uXXXX</td>\n<td style=\"text-align:center\">由四个十六进制数字XXXX规定的Unicode字符。例如，\\ u00A9为版权符号的Unicode序列。见Unicode转义序列。</td>\n</tr>\n<tr>\n<td>\\u{XXXXX}</td>\n<td style=\"text-align:center\">Unicode code point escapes. For example, \\u{2F804} is the same as the simple Unicode escapes \\uD87E\\uDC04.</td>\n</tr>\n</tbody>\n</table>\n<p>转义字符<br>对于那些未出现在表2.1中的字符，其所带的前导反斜线’\\’将被忽略。但是，这一用法已被废弃，应当避免使用。</p>\n<p>通过在引号前加上反斜线’\\’，可以在字符串中插入引号，这就是引号转义。例如:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quote = <span class=\"string\">\"He read \\\"The Cremation of Sam McGee\\\" by R.W. Service.\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(quote); <span class=\"comment\">// He read \"The Cremation of Sam McGee\" by R.W. Service.</span></span><br></pre></td></tr></table></figure></p>\n<p>要在字符串中插入’\\’字面值，必须转义反斜线。例如，要把文件路径 c:\\temp 赋值给一个字符串，可以采用如下方式:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> home = <span class=\"string\">\"c:\\\\temp\"</span>;</span><br></pre></td></tr></table></figure></p>\n<p>也可以在换行之前加上反斜线以转义换行（译注：实际上就是一条语句拆成多行书写），这样反斜线和换行都不会出现在字符串的值中。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"string\">\"this string \\</span><br><span class=\"line\">is broken \\</span><br><span class=\"line\">across multiple\\</span><br><span class=\"line\">lines.\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str);   <span class=\"comment\">// this string is broken across multiplelines.</span></span><br></pre></td></tr></table></figure></p>\n<p>Javascript没有“heredoc”语法，但可以用行末的换行符转义和转义的换行来近似实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> poem = </span><br><span class=\"line\"><span class=\"string\">\"Roses are red,\\n\\</span><br><span class=\"line\">Violets are blue.\\n\\</span><br><span class=\"line\">I'm schizophrenic,\\n\\</span><br><span class=\"line\">And so am I.\"</span></span><br></pre></td></tr></table></figure></p>\n"},{"title":"范畴论-JS函数式编程","date":"2016-05-23T01:32:54.000Z","_content":"托马斯.沃森(时任IBM董事长)说过一句著名的话，“我想全世界只有五台计算机的市场”。那是1948年，当时，每个人都认为计算机只会被用于两件事情：数学和工程。 即使是技术上最大胆的预想也不会认为有一天计算机能够把西班牙语翻译成英语， 或者模拟整个天气系统。在那时最快的计算机是IBM的SSEC，每秒能计算50次，显示终端要在15年后才出现， 多任务处理意味着多个用户终端共享一个单线程。晶体管改变了一切，然而对技术的远见没有跟上。 在1977年，Ken Olson（DEC创始人）说过另一个愚蠢的预言：“任何人都没有理由想在家里拥有个计算机”。\n\n对于我们来说很明显计算机不只是为科学家和工程师所用，但这只是事后诸葛。在70年前认为计算机只能作数学计算是很正常的。 沃森不仅没有意识到计算机会改变社会，他还没有意识到数学的改革和演进的能力。\n\n不过计算机和数学的潜力并非被所有人忽视。约翰·麦卡锡在1958年发明了Lisp，这是一个革命性的基于算法的语言， 它把计算机带入了新纪元。从那开始，Lisp对使用抽象层的思想（编译、解释、虚拟化）起到重要作用， 这促使了计算机从一个只能用于数学的机器变成了今天这样。\n\n从Lisp到Scheme，一个JavaScript的直接原型。现在它给我们带来了一个轮回。如果计算机在核心上只是一个做数学的机器， 那么它在以数学为基础编程范式上具有优越性是合理的\n\n这里所说的“数学”并不是指计算机明显能做的数字运算，而是要描述为离散数学：对于离散的、 对于诸如逻辑上的声明或者计算机语言命令的数学结构的研究。 通过把代码作为离散的数学结构来对待，我们可以把概念和想法应用到数学上。 这也就是为什么函数式编程在人工智能、图谱搜索、模式识别以及其它计算机科学中具有挑战性的领域里具有如此重要的地位。\n\n这一章我们将针对日常编程中的问题对一些概念和它们的应用进行试验，包括：\n\n - 范畴论（Category theory）\n - 态射（Morphisms）\n - 函子（Functors）\n - Maybes\n - Promises\n - Lenses\n - 函数组合\n\n利用这些概念我们可以轻松安全地写出整个库和API。并且我们要从对范畴论的解释开始一直到它在JavaScript里的实现。\n\n# 范畴论\n> 范畴论是用于函数组合的理论性概念。范畴论和函数组合他们俩在一起就像发动机排量和马力，像NASA和空间穿梭， 像好酒和装它的瓶子。基本上讲，你不能让它们中的一个脱离另一个而独立存在。\n\n## 范畴论概览\n范畴论实际并不是一个很难的概念。在数学上它大到能够填满一个本科课程，但是在计算机编程中它可以很容易地被总结出来。\n\n爱因斯坦曾说过：“如果你不能把它解释给一个六岁的孩子听，那你自己也没有理解”。这样，按照给六岁孩子解释的说法， 范畴论只不过是一些连接的圆点。也许这过分简化了范畴论，不过这从直观的方式上很好的解释了我们所需要知道的东西。\n\n首先你需要了解一些术语。范畴(category,也可以说是种类)只是一些同样类型的集合。在javascript里，它们是数组或对象，包含了明确指定为数字、字符串、布尔、日期或节点等类型的变量。太射(Morphism)是一些纯函数，当给定一系列输入时总会返回相同的输出。多态操作可以操作多个范畴，而同态操作限制在一个单独的范畴中。例如，同态函数“乘”只能作用于数字，而多态函数“加”还能作用于字符串。\n\n下图展示了三个范畴--A、B、C，以及两个太射--f和g\n\n![范畴论](/images/范畴论/1.png)\n范畴论告诉我们，当第一个态射的范畴是另一个态射所需的输入时，它们就可以像下图所示这样组合：\n![范畴论](/images/范畴论/2.png)\nfog符号代表态射f和g的组合。现在我们就可以连接这些原点。\n![范畴论](/images/范畴论/3.png)\n真的是这样，只是连接圆点。\n\n## 类型安全\n我们来连接一些圆点。范畴包含两样东西：\n1. 对象Object(在javascrip中是类型)\n2. 态射Morphisms(在javascrip中是只作用于类型的纯函数)。\n\n这是数学赋予范畴论的术语，所以不幸与我们的javascrip的术语集有些冲突。范畴论中的对象更像是代表一个指定数据类型的变量，而不是像JavaScript所定义的对象那样具有一系列属性和值。 态射只是使用这些类型的纯函数。\n所以在javascrip应用范畴论很简单。在javascrip中使用范畴论意味着每个范畴只使用一个特定的数据类型。数据类型是指数字、字符串、数组、日期、对象、布尔等等。但是javascrip没有严格的类型系统，很容易出岔子。所以我们不得不实现我们自己的方法来保证数据的正确。\njavascrip中有四种原始类型：number、string、Boolean、function.我们可以创建类型安全函数，返回变量或者抛出一个错误。这符合范畴论的对象定理。\n```javascript\n  var str = function(s) {\n    if (typeof s === \"string\") {￼￼\n      return s;\n    } else {\n      throw new TypeError(\"Error: String expected, \" + typeof s + \"given.\");\n    }\n  }\n  var num = function(n) {\n    if (typeof n === \"number\") {\n      return n;\n    } else {\n      throw new TypeError(\"Error: Number expected, \" + typeof n + \"given.\");\n    }\n  }\n  var bool = function(b) {\n    if (typeof b === \"boolean\") {\n      return b;\n    } else {\n      throw new TypeError(\"Error: Boolean expected, \" + typeof b + \"given.\");\n    }\n  }\n  var func = function(f) {\n    if (typeof f === \"function\") {\n      return f;\n    } else {\n      throw new TypeError(\"Error: Function expected, \" + typeof f +\n        \" given.\");\n    }\n  }\n```\n然而这里重复代码太多，并且不是很函数式。我们可以创建一个函数，它返回一个类型安全的函数。\n```javascript\n  var typeOf = function(type){\n    if(typeof x === type){\n      return x;\n    }else{\n      throw new TypeError(\"Error: \" + type + \" exceped, \" + typeof x + \"given.\");\n    }\n  }\n  var str = typeOf('string');\n  var num = typeOf('number');\n  var func = typeOf('function');\n  var bool = typeOf('boolean');\n```\n现在，我们可以利用这些函数让我们的函数像预期那样运行。\n```javascript\n  //未受保护的方法\n  var x = '24';\n  x + 1; //会返回‘241’，而不是25\n  //受保护的方法\n  //plus :: Int -> Int\n  function plus(n){\n    return num(n) + 1;\n  }\n  plus(x); //抛出错误，防止出现意外的结果\n```\n再来看个有点肉的例子。我们想检查Unix时间戳的长度，由于javascript函数Date.parse()返回的值是数字而不是字符串，我们得用str()函数。\n```javascript\n  //timestampLength :: String -> Int\n  function timestampLength(t){ return num(str(t).length);}\n  timestampLength(Date.parse('12/31/1999')); // 抛出错误\n  timestampLength(Date.parse('12/31/1999').toString()); // 返回12\n```\n像这样把明确地一个类型转换为另一个类型（或者是相同的类型）的函数叫做态射。这符合范畴论的态射定理。这里强迫通过类型安全函数进行类型声明，利用了这个机制的态射是我们在javascript中展示范畴概念所需的一切。\n\n## 对象识别\n另外还有一个重要的数据类型：对象。\n```javascript\n  var obj = typeOf('object');\n  obj(123); //抛出错误\n  obj({x:'a'}); //返回{x:'a'}\n```\n然而，对象各不相同。它们可以被继承。任何非原始类型(number、string、boolean、functin)的东西都是对象，包括数组、日期、元素等等。\n没有办法知道一个对象是个什么类型，也就是说没法通过typeof关键字知道javascript的对象的子类型是什么，所以我们得想办法。Object有个toString()函数，我们可以通过它变通实现这个目的。\n```javascript\n  var obj = function(o){\n    if(Object.prototype.toString.call(o) === \"[object object]\"){\n      return o;\n    }else{\n      throw new TypeError(\"Error: Object expected, something else given.\");\n    }\n  }\n```\n同样，对于各种对象，我们要实现代码重用：\n```javascript\n  var objectTypeOf = function(name){\n    return function(o){\n      if(Object.prototype.toString.call(o) === \"[object \" + name + \"]\"){\n        return o;\n      }else{\n        throw new TypeError(\n          \"Error: '+name+' expected, something else given.\"\n        )\n      }\n    }\n  }\n  var obj = objectTypeOf('Object');\n  var arr = objectTypeOf('Array');\n  var date = objectTypeOf('Date');\n  var div = objectTypeOf('HTMLDivElement');\n```\n\n# 函子(Functiors)\n态射是类型之间的映射；函子是范畴之间的映射。可以认为函子是这样一个函数，它从一个容器中取到值，并将其加工，然后放到一个新的容器中。这个函数的第一个输入的参数是类型的态射，第二个输入的参数是容器。\n> 函子的函数签名是这样子 //myFunctor :: (a -> b) -> fa -> fb\n> 意思是“给我一个传入a返回b的函数和一个包含a(一个或多个)的容器，我会返回一个包含b(一个或多个)的容器”\n\n## 创建函子\n要知道我们已经有了一个函子：map()，它攫取包含一些值的容器(数组)，然后把一个函数作用于它。\n```javascript\n  [1,4,9].map(Math.sqrt); //returns: [1,2,3]\n```\n\n然而我们要写成一个全局函数，而不是数组对象的方法。这样我们后面就可以写出简洁、安全的代码。\n```javascript\n  //map :: (a -> b) -> [a] -> [b]\n  var map = function(f,a){\n    return arr[a].map(func(f));\n  }\n```\n\n这个例子看起来像是故意弄的封装，因为我们只是把map()函数换了个形式。但这有它的目的。它为映射其他类型提供了一个模板。\n```javascript\n  //strmap :: (str -> str) -> str -> str\n  var strmap = function(f,s){\n    return str(s).split('').map(func(f)).join('');\n  }\n```\n\n## 数组和函子\n数组是函数式javascript使用数据最好的方式。\n\n是否有一种简单的方法来创建已经分配了态射的函子？有，它叫做arrayOf。当你传入一个以整数为参数、返回数组的态射时，你会得到一个以整数数组为参数返回数组的数组的态射。\n\n它自己本身不是函子，但是它让我们能够用态射建立函子。\n```javascript\n  //arrayOf :: (a -> b) -> ([a] -> [b])\n  var arrayOf = function(f){\n    return function(a){\n      return map(func(f),arr(a));\n    }\n  }\n```\n下面是如何用态射创建函子\n```javascript\n  var plusplusall = arrayOf(plusplus); //plusplus是函子\n  console.log(plusplusall([1,2,3])); //返回[2,3,4]\n  console.log(plusplusall([1,'2',3])); //抛出错误\n```\n\n## 函数组合，重访(revisitd)\n函数也是一种我们能够用函子来创建的原始类型，这个函子叫做“fcompose”.我们对函子是这样定义的：它从容器中取一个值，并对其应用一个函数。如果这个容器是一个函数，我们只需要调用它并获取里面的值。\n\n我们已经知道了什么事函数组合，不过让我们来看看在范畴论驱动的环境里它们能做些什么。\n\n函数组合就是结合(associative)，如果你的高中代数老师也像我这样的话那她只告诉了你函数组合的定律有什么，而没有没教你用它能做些什么。 在实践中，组合就是结合律所能够做的。\n```\n  (a*b)*c = a*(b*c)\n  (f o g)o h = f o (g o h)\n```\n\n```\n  f o g ≠ g o f\n```\n\n我们可以任意进行内部组合，无所谓怎样分组。交换律也没有什么可迷惑的。f o g 不总等于 g o f。比如说，一个句子的第一个单词被反转并不等同于一个被反转的句子的第一个单词。\n\n总的来说意思就是哪个函数以什么样的顺序被执行是无所谓的，只要每个函数的输入来源于上一个函数的输出。不过，等等，如果右边的函数依赖于左边的函数，不就是只有一个固定的求值顺序吗？从左到右？是的，如果把它封装起来，我们就可以按照我们感觉合适的方式来控制它。这就使得在JavaScript中可以实现惰性求值。\n```\n  (a*b)*c = a*(b*c)\n  (f o g)o h = f o (g o h)\n```\n\n我们来重写函数组合，不作为函数原型的扩展，而是作为一个单独的函数，这样我们就可以的到更多的功能。基本的形式是这样的：\n\n```javascript\n  var fcompose = function(f,g){\n    return function(){\n      return f.call(this,g.apply(this,arguments));\n    }\n  }\n```\n\n不过我们还得让它能接受任意数量的输入。\n```javascript\n  var fcompose = function(){\n    //首先确保所有的参数都是函数\n    var funcs = arrayOf(func)(Array.prototype.slice.call(arguments));\n    return function(){\n      var args = arguments;\n      for(var i=func.length-1;i>=0;i--){\n        args = [funcs[i].apply(this,args)];\n      }\n      return args[0];\n    }\n  }\n```\n\n现在我们封装好了这些函数并可以控制它们了。我们重写了组合函数使得每一个函数接受另一个函数作为输入， 存储起来，并同样返回一个对象。这里并不是接受一个数组作为输入处理它，而是对每一个操作返回一个新的数组， 我们可以在源头上让每一个元素接受一个数组，把所有操作合到一起执行（所有map、filter等等组合到一起）， 最终把结果存到一个新数组里。这就是通过函数组合实现的惰性求值。这里我们没有理由重新造轮子， 许多库对于这个概念都有很好的实现，包括Lazy.js、Bacon.js以及wu.js等库。\n\n利用这一不同模式的结果，我们可以做更多事情：异步迭代、异步事件处理、惰性求值甚至自动并行。\n\n# 单子(Monad)\n单子是帮助你组合函数的工具。\n\n像原始类型一样，单子是一种数据结构，它可以被当做装载让函子取东西的容器使用。函子取出了数据，进行处理，然后放到一个新的单子中并将其返回。\n\n我么要关注的三种单子：\n - Maybes\n - Promises\n - Lenses\n\n除了用于数组的map和函数的compose以外，我们还有三种函子(maybe、promise和lens).这仅仅是另一些函子和单子。\n\n## Maybe\nMaybe可以让我们优雅地使用有可能为空并且有默认值的数据。maybe是一个可以有值也可以没有值的变量，并且对于调用者来说无所谓。\n就他自己来说，这看起来不是什么大问题。所有人都知道空值检查可以通过一个if-self语句很容易实现\n```javascript\n  if(getUsername() == null){\n    username = 'Anonymous';\n  }else{\n    username = getUsername();\n  }\n```\n\n但是用函数式编程，我们要打破过程、一行接一行的做事方式，而应该用函数和数据的管道方式。如果我们不得不从链的中间断开来检查是否存在，我们就的创建临时变量并写更多的代码。maybe仅仅是帮助我们保持逻辑跟随管道的工具。\n\n要实现maybe，我们首先要创建一些构造器。\n```javascript\n  //Maybe单子构造器，目前是空的\n  var Maybe = function(){}\n\n  //None实例，对一个没有值的对象的包装\n  var None = function(){};\n  None.prototype = Object.create(Maybe.prototype);\n  None.prototype.toString = function(){return 'None'};\n\n  //现在可以写`none`函数\n  //这让我们不用总写`new None()`\n  var none = function(){return new None()};\n\n  //Just实例，对一个有一个值的对象的包装\n  var Just = function(x){return this.x = x};\n  Just.prototype = Object.create(Maybe.prototype);\n  Just.prototype.toString = function(){return \"Just\" + this.x};\n  var just = function(x){return new Just(x)};\n```\n-----------------\n","source":"_posts/范畴论-JS函数式编程.md","raw":"---\ntitle: 范畴论-JS函数式编程\ndate: 2016-05-23 09:32:54\ntags:\n  - javascript\n  - 函数式编程\ncategories: 转载笔记\n---\n托马斯.沃森(时任IBM董事长)说过一句著名的话，“我想全世界只有五台计算机的市场”。那是1948年，当时，每个人都认为计算机只会被用于两件事情：数学和工程。 即使是技术上最大胆的预想也不会认为有一天计算机能够把西班牙语翻译成英语， 或者模拟整个天气系统。在那时最快的计算机是IBM的SSEC，每秒能计算50次，显示终端要在15年后才出现， 多任务处理意味着多个用户终端共享一个单线程。晶体管改变了一切，然而对技术的远见没有跟上。 在1977年，Ken Olson（DEC创始人）说过另一个愚蠢的预言：“任何人都没有理由想在家里拥有个计算机”。\n\n对于我们来说很明显计算机不只是为科学家和工程师所用，但这只是事后诸葛。在70年前认为计算机只能作数学计算是很正常的。 沃森不仅没有意识到计算机会改变社会，他还没有意识到数学的改革和演进的能力。\n\n不过计算机和数学的潜力并非被所有人忽视。约翰·麦卡锡在1958年发明了Lisp，这是一个革命性的基于算法的语言， 它把计算机带入了新纪元。从那开始，Lisp对使用抽象层的思想（编译、解释、虚拟化）起到重要作用， 这促使了计算机从一个只能用于数学的机器变成了今天这样。\n\n从Lisp到Scheme，一个JavaScript的直接原型。现在它给我们带来了一个轮回。如果计算机在核心上只是一个做数学的机器， 那么它在以数学为基础编程范式上具有优越性是合理的\n\n这里所说的“数学”并不是指计算机明显能做的数字运算，而是要描述为离散数学：对于离散的、 对于诸如逻辑上的声明或者计算机语言命令的数学结构的研究。 通过把代码作为离散的数学结构来对待，我们可以把概念和想法应用到数学上。 这也就是为什么函数式编程在人工智能、图谱搜索、模式识别以及其它计算机科学中具有挑战性的领域里具有如此重要的地位。\n\n这一章我们将针对日常编程中的问题对一些概念和它们的应用进行试验，包括：\n\n - 范畴论（Category theory）\n - 态射（Morphisms）\n - 函子（Functors）\n - Maybes\n - Promises\n - Lenses\n - 函数组合\n\n利用这些概念我们可以轻松安全地写出整个库和API。并且我们要从对范畴论的解释开始一直到它在JavaScript里的实现。\n\n# 范畴论\n> 范畴论是用于函数组合的理论性概念。范畴论和函数组合他们俩在一起就像发动机排量和马力，像NASA和空间穿梭， 像好酒和装它的瓶子。基本上讲，你不能让它们中的一个脱离另一个而独立存在。\n\n## 范畴论概览\n范畴论实际并不是一个很难的概念。在数学上它大到能够填满一个本科课程，但是在计算机编程中它可以很容易地被总结出来。\n\n爱因斯坦曾说过：“如果你不能把它解释给一个六岁的孩子听，那你自己也没有理解”。这样，按照给六岁孩子解释的说法， 范畴论只不过是一些连接的圆点。也许这过分简化了范畴论，不过这从直观的方式上很好的解释了我们所需要知道的东西。\n\n首先你需要了解一些术语。范畴(category,也可以说是种类)只是一些同样类型的集合。在javascript里，它们是数组或对象，包含了明确指定为数字、字符串、布尔、日期或节点等类型的变量。太射(Morphism)是一些纯函数，当给定一系列输入时总会返回相同的输出。多态操作可以操作多个范畴，而同态操作限制在一个单独的范畴中。例如，同态函数“乘”只能作用于数字，而多态函数“加”还能作用于字符串。\n\n下图展示了三个范畴--A、B、C，以及两个太射--f和g\n\n![范畴论](/images/范畴论/1.png)\n范畴论告诉我们，当第一个态射的范畴是另一个态射所需的输入时，它们就可以像下图所示这样组合：\n![范畴论](/images/范畴论/2.png)\nfog符号代表态射f和g的组合。现在我们就可以连接这些原点。\n![范畴论](/images/范畴论/3.png)\n真的是这样，只是连接圆点。\n\n## 类型安全\n我们来连接一些圆点。范畴包含两样东西：\n1. 对象Object(在javascrip中是类型)\n2. 态射Morphisms(在javascrip中是只作用于类型的纯函数)。\n\n这是数学赋予范畴论的术语，所以不幸与我们的javascrip的术语集有些冲突。范畴论中的对象更像是代表一个指定数据类型的变量，而不是像JavaScript所定义的对象那样具有一系列属性和值。 态射只是使用这些类型的纯函数。\n所以在javascrip应用范畴论很简单。在javascrip中使用范畴论意味着每个范畴只使用一个特定的数据类型。数据类型是指数字、字符串、数组、日期、对象、布尔等等。但是javascrip没有严格的类型系统，很容易出岔子。所以我们不得不实现我们自己的方法来保证数据的正确。\njavascrip中有四种原始类型：number、string、Boolean、function.我们可以创建类型安全函数，返回变量或者抛出一个错误。这符合范畴论的对象定理。\n```javascript\n  var str = function(s) {\n    if (typeof s === \"string\") {￼￼\n      return s;\n    } else {\n      throw new TypeError(\"Error: String expected, \" + typeof s + \"given.\");\n    }\n  }\n  var num = function(n) {\n    if (typeof n === \"number\") {\n      return n;\n    } else {\n      throw new TypeError(\"Error: Number expected, \" + typeof n + \"given.\");\n    }\n  }\n  var bool = function(b) {\n    if (typeof b === \"boolean\") {\n      return b;\n    } else {\n      throw new TypeError(\"Error: Boolean expected, \" + typeof b + \"given.\");\n    }\n  }\n  var func = function(f) {\n    if (typeof f === \"function\") {\n      return f;\n    } else {\n      throw new TypeError(\"Error: Function expected, \" + typeof f +\n        \" given.\");\n    }\n  }\n```\n然而这里重复代码太多，并且不是很函数式。我们可以创建一个函数，它返回一个类型安全的函数。\n```javascript\n  var typeOf = function(type){\n    if(typeof x === type){\n      return x;\n    }else{\n      throw new TypeError(\"Error: \" + type + \" exceped, \" + typeof x + \"given.\");\n    }\n  }\n  var str = typeOf('string');\n  var num = typeOf('number');\n  var func = typeOf('function');\n  var bool = typeOf('boolean');\n```\n现在，我们可以利用这些函数让我们的函数像预期那样运行。\n```javascript\n  //未受保护的方法\n  var x = '24';\n  x + 1; //会返回‘241’，而不是25\n  //受保护的方法\n  //plus :: Int -> Int\n  function plus(n){\n    return num(n) + 1;\n  }\n  plus(x); //抛出错误，防止出现意外的结果\n```\n再来看个有点肉的例子。我们想检查Unix时间戳的长度，由于javascript函数Date.parse()返回的值是数字而不是字符串，我们得用str()函数。\n```javascript\n  //timestampLength :: String -> Int\n  function timestampLength(t){ return num(str(t).length);}\n  timestampLength(Date.parse('12/31/1999')); // 抛出错误\n  timestampLength(Date.parse('12/31/1999').toString()); // 返回12\n```\n像这样把明确地一个类型转换为另一个类型（或者是相同的类型）的函数叫做态射。这符合范畴论的态射定理。这里强迫通过类型安全函数进行类型声明，利用了这个机制的态射是我们在javascript中展示范畴概念所需的一切。\n\n## 对象识别\n另外还有一个重要的数据类型：对象。\n```javascript\n  var obj = typeOf('object');\n  obj(123); //抛出错误\n  obj({x:'a'}); //返回{x:'a'}\n```\n然而，对象各不相同。它们可以被继承。任何非原始类型(number、string、boolean、functin)的东西都是对象，包括数组、日期、元素等等。\n没有办法知道一个对象是个什么类型，也就是说没法通过typeof关键字知道javascript的对象的子类型是什么，所以我们得想办法。Object有个toString()函数，我们可以通过它变通实现这个目的。\n```javascript\n  var obj = function(o){\n    if(Object.prototype.toString.call(o) === \"[object object]\"){\n      return o;\n    }else{\n      throw new TypeError(\"Error: Object expected, something else given.\");\n    }\n  }\n```\n同样，对于各种对象，我们要实现代码重用：\n```javascript\n  var objectTypeOf = function(name){\n    return function(o){\n      if(Object.prototype.toString.call(o) === \"[object \" + name + \"]\"){\n        return o;\n      }else{\n        throw new TypeError(\n          \"Error: '+name+' expected, something else given.\"\n        )\n      }\n    }\n  }\n  var obj = objectTypeOf('Object');\n  var arr = objectTypeOf('Array');\n  var date = objectTypeOf('Date');\n  var div = objectTypeOf('HTMLDivElement');\n```\n\n# 函子(Functiors)\n态射是类型之间的映射；函子是范畴之间的映射。可以认为函子是这样一个函数，它从一个容器中取到值，并将其加工，然后放到一个新的容器中。这个函数的第一个输入的参数是类型的态射，第二个输入的参数是容器。\n> 函子的函数签名是这样子 //myFunctor :: (a -> b) -> fa -> fb\n> 意思是“给我一个传入a返回b的函数和一个包含a(一个或多个)的容器，我会返回一个包含b(一个或多个)的容器”\n\n## 创建函子\n要知道我们已经有了一个函子：map()，它攫取包含一些值的容器(数组)，然后把一个函数作用于它。\n```javascript\n  [1,4,9].map(Math.sqrt); //returns: [1,2,3]\n```\n\n然而我们要写成一个全局函数，而不是数组对象的方法。这样我们后面就可以写出简洁、安全的代码。\n```javascript\n  //map :: (a -> b) -> [a] -> [b]\n  var map = function(f,a){\n    return arr[a].map(func(f));\n  }\n```\n\n这个例子看起来像是故意弄的封装，因为我们只是把map()函数换了个形式。但这有它的目的。它为映射其他类型提供了一个模板。\n```javascript\n  //strmap :: (str -> str) -> str -> str\n  var strmap = function(f,s){\n    return str(s).split('').map(func(f)).join('');\n  }\n```\n\n## 数组和函子\n数组是函数式javascript使用数据最好的方式。\n\n是否有一种简单的方法来创建已经分配了态射的函子？有，它叫做arrayOf。当你传入一个以整数为参数、返回数组的态射时，你会得到一个以整数数组为参数返回数组的数组的态射。\n\n它自己本身不是函子，但是它让我们能够用态射建立函子。\n```javascript\n  //arrayOf :: (a -> b) -> ([a] -> [b])\n  var arrayOf = function(f){\n    return function(a){\n      return map(func(f),arr(a));\n    }\n  }\n```\n下面是如何用态射创建函子\n```javascript\n  var plusplusall = arrayOf(plusplus); //plusplus是函子\n  console.log(plusplusall([1,2,3])); //返回[2,3,4]\n  console.log(plusplusall([1,'2',3])); //抛出错误\n```\n\n## 函数组合，重访(revisitd)\n函数也是一种我们能够用函子来创建的原始类型，这个函子叫做“fcompose”.我们对函子是这样定义的：它从容器中取一个值，并对其应用一个函数。如果这个容器是一个函数，我们只需要调用它并获取里面的值。\n\n我们已经知道了什么事函数组合，不过让我们来看看在范畴论驱动的环境里它们能做些什么。\n\n函数组合就是结合(associative)，如果你的高中代数老师也像我这样的话那她只告诉了你函数组合的定律有什么，而没有没教你用它能做些什么。 在实践中，组合就是结合律所能够做的。\n```\n  (a*b)*c = a*(b*c)\n  (f o g)o h = f o (g o h)\n```\n\n```\n  f o g ≠ g o f\n```\n\n我们可以任意进行内部组合，无所谓怎样分组。交换律也没有什么可迷惑的。f o g 不总等于 g o f。比如说，一个句子的第一个单词被反转并不等同于一个被反转的句子的第一个单词。\n\n总的来说意思就是哪个函数以什么样的顺序被执行是无所谓的，只要每个函数的输入来源于上一个函数的输出。不过，等等，如果右边的函数依赖于左边的函数，不就是只有一个固定的求值顺序吗？从左到右？是的，如果把它封装起来，我们就可以按照我们感觉合适的方式来控制它。这就使得在JavaScript中可以实现惰性求值。\n```\n  (a*b)*c = a*(b*c)\n  (f o g)o h = f o (g o h)\n```\n\n我们来重写函数组合，不作为函数原型的扩展，而是作为一个单独的函数，这样我们就可以的到更多的功能。基本的形式是这样的：\n\n```javascript\n  var fcompose = function(f,g){\n    return function(){\n      return f.call(this,g.apply(this,arguments));\n    }\n  }\n```\n\n不过我们还得让它能接受任意数量的输入。\n```javascript\n  var fcompose = function(){\n    //首先确保所有的参数都是函数\n    var funcs = arrayOf(func)(Array.prototype.slice.call(arguments));\n    return function(){\n      var args = arguments;\n      for(var i=func.length-1;i>=0;i--){\n        args = [funcs[i].apply(this,args)];\n      }\n      return args[0];\n    }\n  }\n```\n\n现在我们封装好了这些函数并可以控制它们了。我们重写了组合函数使得每一个函数接受另一个函数作为输入， 存储起来，并同样返回一个对象。这里并不是接受一个数组作为输入处理它，而是对每一个操作返回一个新的数组， 我们可以在源头上让每一个元素接受一个数组，把所有操作合到一起执行（所有map、filter等等组合到一起）， 最终把结果存到一个新数组里。这就是通过函数组合实现的惰性求值。这里我们没有理由重新造轮子， 许多库对于这个概念都有很好的实现，包括Lazy.js、Bacon.js以及wu.js等库。\n\n利用这一不同模式的结果，我们可以做更多事情：异步迭代、异步事件处理、惰性求值甚至自动并行。\n\n# 单子(Monad)\n单子是帮助你组合函数的工具。\n\n像原始类型一样，单子是一种数据结构，它可以被当做装载让函子取东西的容器使用。函子取出了数据，进行处理，然后放到一个新的单子中并将其返回。\n\n我么要关注的三种单子：\n - Maybes\n - Promises\n - Lenses\n\n除了用于数组的map和函数的compose以外，我们还有三种函子(maybe、promise和lens).这仅仅是另一些函子和单子。\n\n## Maybe\nMaybe可以让我们优雅地使用有可能为空并且有默认值的数据。maybe是一个可以有值也可以没有值的变量，并且对于调用者来说无所谓。\n就他自己来说，这看起来不是什么大问题。所有人都知道空值检查可以通过一个if-self语句很容易实现\n```javascript\n  if(getUsername() == null){\n    username = 'Anonymous';\n  }else{\n    username = getUsername();\n  }\n```\n\n但是用函数式编程，我们要打破过程、一行接一行的做事方式，而应该用函数和数据的管道方式。如果我们不得不从链的中间断开来检查是否存在，我们就的创建临时变量并写更多的代码。maybe仅仅是帮助我们保持逻辑跟随管道的工具。\n\n要实现maybe，我们首先要创建一些构造器。\n```javascript\n  //Maybe单子构造器，目前是空的\n  var Maybe = function(){}\n\n  //None实例，对一个没有值的对象的包装\n  var None = function(){};\n  None.prototype = Object.create(Maybe.prototype);\n  None.prototype.toString = function(){return 'None'};\n\n  //现在可以写`none`函数\n  //这让我们不用总写`new None()`\n  var none = function(){return new None()};\n\n  //Just实例，对一个有一个值的对象的包装\n  var Just = function(x){return this.x = x};\n  Just.prototype = Object.create(Maybe.prototype);\n  Just.prototype.toString = function(){return \"Just\" + this.x};\n  var just = function(x){return new Just(x)};\n```\n-----------------\n","slug":"范畴论-JS函数式编程","published":1,"updated":"2016-05-24T09:23:57.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0env002jb0dls7z4cqk5","content":"<p>托马斯.沃森(时任IBM董事长)说过一句著名的话，“我想全世界只有五台计算机的市场”。那是1948年，当时，每个人都认为计算机只会被用于两件事情：数学和工程。 即使是技术上最大胆的预想也不会认为有一天计算机能够把西班牙语翻译成英语， 或者模拟整个天气系统。在那时最快的计算机是IBM的SSEC，每秒能计算50次，显示终端要在15年后才出现， 多任务处理意味着多个用户终端共享一个单线程。晶体管改变了一切，然而对技术的远见没有跟上。 在1977年，Ken Olson（DEC创始人）说过另一个愚蠢的预言：“任何人都没有理由想在家里拥有个计算机”。</p>\n<p>对于我们来说很明显计算机不只是为科学家和工程师所用，但这只是事后诸葛。在70年前认为计算机只能作数学计算是很正常的。 沃森不仅没有意识到计算机会改变社会，他还没有意识到数学的改革和演进的能力。</p>\n<p>不过计算机和数学的潜力并非被所有人忽视。约翰·麦卡锡在1958年发明了Lisp，这是一个革命性的基于算法的语言， 它把计算机带入了新纪元。从那开始，Lisp对使用抽象层的思想（编译、解释、虚拟化）起到重要作用， 这促使了计算机从一个只能用于数学的机器变成了今天这样。</p>\n<p>从Lisp到Scheme，一个JavaScript的直接原型。现在它给我们带来了一个轮回。如果计算机在核心上只是一个做数学的机器， 那么它在以数学为基础编程范式上具有优越性是合理的</p>\n<p>这里所说的“数学”并不是指计算机明显能做的数字运算，而是要描述为离散数学：对于离散的、 对于诸如逻辑上的声明或者计算机语言命令的数学结构的研究。 通过把代码作为离散的数学结构来对待，我们可以把概念和想法应用到数学上。 这也就是为什么函数式编程在人工智能、图谱搜索、模式识别以及其它计算机科学中具有挑战性的领域里具有如此重要的地位。</p>\n<p>这一章我们将针对日常编程中的问题对一些概念和它们的应用进行试验，包括：</p>\n<ul>\n<li>范畴论（Category theory）</li>\n<li>态射（Morphisms）</li>\n<li>函子（Functors）</li>\n<li>Maybes</li>\n<li>Promises</li>\n<li>Lenses</li>\n<li>函数组合</li>\n</ul>\n<p>利用这些概念我们可以轻松安全地写出整个库和API。并且我们要从对范畴论的解释开始一直到它在JavaScript里的实现。</p>\n<h1 id=\"范畴论\"><a href=\"#范畴论\" class=\"headerlink\" title=\"范畴论\"></a>范畴论</h1><blockquote>\n<p>范畴论是用于函数组合的理论性概念。范畴论和函数组合他们俩在一起就像发动机排量和马力，像NASA和空间穿梭， 像好酒和装它的瓶子。基本上讲，你不能让它们中的一个脱离另一个而独立存在。</p>\n</blockquote>\n<h2 id=\"范畴论概览\"><a href=\"#范畴论概览\" class=\"headerlink\" title=\"范畴论概览\"></a>范畴论概览</h2><p>范畴论实际并不是一个很难的概念。在数学上它大到能够填满一个本科课程，但是在计算机编程中它可以很容易地被总结出来。</p>\n<p>爱因斯坦曾说过：“如果你不能把它解释给一个六岁的孩子听，那你自己也没有理解”。这样，按照给六岁孩子解释的说法， 范畴论只不过是一些连接的圆点。也许这过分简化了范畴论，不过这从直观的方式上很好的解释了我们所需要知道的东西。</p>\n<p>首先你需要了解一些术语。范畴(category,也可以说是种类)只是一些同样类型的集合。在javascript里，它们是数组或对象，包含了明确指定为数字、字符串、布尔、日期或节点等类型的变量。太射(Morphism)是一些纯函数，当给定一系列输入时总会返回相同的输出。多态操作可以操作多个范畴，而同态操作限制在一个单独的范畴中。例如，同态函数“乘”只能作用于数字，而多态函数“加”还能作用于字符串。</p>\n<p>下图展示了三个范畴–A、B、C，以及两个太射–f和g</p>\n<p><img src=\"/images/范畴论/1.png\" alt=\"范畴论\"><br>范畴论告诉我们，当第一个态射的范畴是另一个态射所需的输入时，它们就可以像下图所示这样组合：<br><img src=\"/images/范畴论/2.png\" alt=\"范畴论\"><br>fog符号代表态射f和g的组合。现在我们就可以连接这些原点。<br><img src=\"/images/范畴论/3.png\" alt=\"范畴论\"><br>真的是这样，只是连接圆点。</p>\n<h2 id=\"类型安全\"><a href=\"#类型安全\" class=\"headerlink\" title=\"类型安全\"></a>类型安全</h2><p>我们来连接一些圆点。范畴包含两样东西：</p>\n<ol>\n<li>对象Object(在javascrip中是类型)</li>\n<li>态射Morphisms(在javascrip中是只作用于类型的纯函数)。</li>\n</ol>\n<p>这是数学赋予范畴论的术语，所以不幸与我们的javascrip的术语集有些冲突。范畴论中的对象更像是代表一个指定数据类型的变量，而不是像JavaScript所定义的对象那样具有一系列属性和值。 态射只是使用这些类型的纯函数。<br>所以在javascrip应用范畴论很简单。在javascrip中使用范畴论意味着每个范畴只使用一个特定的数据类型。数据类型是指数字、字符串、数组、日期、对象、布尔等等。但是javascrip没有严格的类型系统，很容易出岔子。所以我们不得不实现我们自己的方法来保证数据的正确。<br>javascrip中有四种原始类型：number、string、Boolean、function.我们可以创建类型安全函数，返回变量或者抛出一个错误。这符合范畴论的对象定理。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> s === <span class=\"string\">\"string\"</span>) &#123;￼￼</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: String expected, \"</span> + <span class=\"keyword\">typeof</span> s + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">\"number\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Number expected, \"</span> + <span class=\"keyword\">typeof</span> n + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">\"boolean\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Boolean expected, \"</span> + <span class=\"keyword\">typeof</span> b + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> f === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Function expected, \"</span> + <span class=\"keyword\">typeof</span> f +</span><br><span class=\"line\">      <span class=\"string\">\" given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然而这里重复代码太多，并且不是很函数式。我们可以创建一个函数，它返回一个类型安全的函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typeOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> x === type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: \"</span> + type + <span class=\"string\">\" exceped, \"</span> + <span class=\"keyword\">typeof</span> x + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = typeOf(<span class=\"string\">'string'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = typeOf(<span class=\"string\">'number'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = typeOf(<span class=\"string\">'function'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = typeOf(<span class=\"string\">'boolean'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>现在，我们可以利用这些函数让我们的函数像预期那样运行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//未受保护的方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">'24'</span>;</span><br><span class=\"line\">x + <span class=\"number\">1</span>; <span class=\"comment\">//会返回‘241’，而不是25</span></span><br><span class=\"line\"><span class=\"comment\">//受保护的方法</span></span><br><span class=\"line\"><span class=\"comment\">//plus :: Int -&gt; Int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">plus</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num(n) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">plus(x); <span class=\"comment\">//抛出错误，防止出现意外的结果</span></span><br></pre></td></tr></table></figure></p>\n<p>再来看个有点肉的例子。我们想检查Unix时间戳的长度，由于javascript函数Date.parse()返回的值是数字而不是字符串，我们得用str()函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//timestampLength :: String -&gt; Int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timestampLength</span>(<span class=\"params\">t</span>)</span>&#123; <span class=\"keyword\">return</span> num(str(t).length);&#125;</span><br><span class=\"line\">timestampLength(<span class=\"built_in\">Date</span>.parse(<span class=\"string\">'12/31/1999'</span>)); <span class=\"comment\">// 抛出错误</span></span><br><span class=\"line\">timestampLength(<span class=\"built_in\">Date</span>.parse(<span class=\"string\">'12/31/1999'</span>).toString()); <span class=\"comment\">// 返回12</span></span><br></pre></td></tr></table></figure></p>\n<p>像这样把明确地一个类型转换为另一个类型（或者是相同的类型）的函数叫做态射。这符合范畴论的态射定理。这里强迫通过类型安全函数进行类型声明，利用了这个机制的态射是我们在javascript中展示范畴概念所需的一切。</p>\n<h2 id=\"对象识别\"><a href=\"#对象识别\" class=\"headerlink\" title=\"对象识别\"></a>对象识别</h2><p>另外还有一个重要的数据类型：对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = typeOf(<span class=\"string\">'object'</span>);</span><br><span class=\"line\">obj(<span class=\"number\">123</span>); <span class=\"comment\">//抛出错误</span></span><br><span class=\"line\">obj(&#123;x:<span class=\"string\">'a'</span>&#125;); <span class=\"comment\">//返回&#123;x:'a'&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>然而，对象各不相同。它们可以被继承。任何非原始类型(number、string、boolean、functin)的东西都是对象，包括数组、日期、元素等等。<br>没有办法知道一个对象是个什么类型，也就是说没法通过typeof关键字知道javascript的对象的子类型是什么，所以我们得想办法。Object有个toString()函数，我们可以通过它变通实现这个目的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.toString.call(o) === <span class=\"string\">\"[object object]\"</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Object expected, something else given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样，对于各种对象，我们要实现代码重用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objectTypeOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.toString.call(o) === <span class=\"string\">\"[object \"</span> + name + <span class=\"string\">\"]\"</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(</span><br><span class=\"line\">        <span class=\"string\">\"Error: '+name+' expected, something else given.\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = objectTypeOf(<span class=\"string\">'Object'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = objectTypeOf(<span class=\"string\">'Array'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> date = objectTypeOf(<span class=\"string\">'Date'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> div = objectTypeOf(<span class=\"string\">'HTMLDivElement'</span>);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"函子-Functiors\"><a href=\"#函子-Functiors\" class=\"headerlink\" title=\"函子(Functiors)\"></a>函子(Functiors)</h1><p>态射是类型之间的映射；函子是范畴之间的映射。可以认为函子是这样一个函数，它从一个容器中取到值，并将其加工，然后放到一个新的容器中。这个函数的第一个输入的参数是类型的态射，第二个输入的参数是容器。</p>\n<blockquote>\n<p>函子的函数签名是这样子 //myFunctor :: (a -&gt; b) -&gt; fa -&gt; fb<br>意思是“给我一个传入a返回b的函数和一个包含a(一个或多个)的容器，我会返回一个包含b(一个或多个)的容器”</p>\n</blockquote>\n<h2 id=\"创建函子\"><a href=\"#创建函子\" class=\"headerlink\" title=\"创建函子\"></a>创建函子</h2><p>要知道我们已经有了一个函子：map()，它攫取包含一些值的容器(数组)，然后把一个函数作用于它。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>].map(<span class=\"built_in\">Math</span>.sqrt); <span class=\"comment\">//returns: [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>然而我们要写成一个全局函数，而不是数组对象的方法。这样我们后面就可以写出简洁、安全的代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[a].map(func(f));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个例子看起来像是故意弄的封装，因为我们只是把map()函数换了个形式。但这有它的目的。它为映射其他类型提供了一个模板。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//strmap :: (str -&gt; str) -&gt; str -&gt; str</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strmap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str(s).split(<span class=\"string\">''</span>).map(func(f)).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组和函子\"><a href=\"#数组和函子\" class=\"headerlink\" title=\"数组和函子\"></a>数组和函子</h2><p>数组是函数式javascript使用数据最好的方式。</p>\n<p>是否有一种简单的方法来创建已经分配了态射的函子？有，它叫做arrayOf。当你传入一个以整数为参数、返回数组的态射时，你会得到一个以整数数组为参数返回数组的数组的态射。</p>\n<p>它自己本身不是函子，但是它让我们能够用态射建立函子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//arrayOf :: (a -&gt; b) -&gt; ([a] -&gt; [b])</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map(func(f),arr(a));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是如何用态射创建函子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> plusplusall = arrayOf(plusplus); <span class=\"comment\">//plusplus是函子</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusplusall([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])); <span class=\"comment\">//返回[2,3,4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusplusall([<span class=\"number\">1</span>,<span class=\"string\">'2'</span>,<span class=\"number\">3</span>])); <span class=\"comment\">//抛出错误</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数组合，重访-revisitd\"><a href=\"#函数组合，重访-revisitd\" class=\"headerlink\" title=\"函数组合，重访(revisitd)\"></a>函数组合，重访(revisitd)</h2><p>函数也是一种我们能够用函子来创建的原始类型，这个函子叫做“fcompose”.我们对函子是这样定义的：它从容器中取一个值，并对其应用一个函数。如果这个容器是一个函数，我们只需要调用它并获取里面的值。</p>\n<p>我们已经知道了什么事函数组合，不过让我们来看看在范畴论驱动的环境里它们能做些什么。</p>\n<p>函数组合就是结合(associative)，如果你的高中代数老师也像我这样的话那她只告诉了你函数组合的定律有什么，而没有没教你用它能做些什么。 在实践中，组合就是结合律所能够做的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a*b)*c = a*(b*c)</span><br><span class=\"line\">(f o g)o h = f o (g o h)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f o g ≠ g o f</span><br></pre></td></tr></table></figure>\n<p>我们可以任意进行内部组合，无所谓怎样分组。交换律也没有什么可迷惑的。f o g 不总等于 g o f。比如说，一个句子的第一个单词被反转并不等同于一个被反转的句子的第一个单词。</p>\n<p>总的来说意思就是哪个函数以什么样的顺序被执行是无所谓的，只要每个函数的输入来源于上一个函数的输出。不过，等等，如果右边的函数依赖于左边的函数，不就是只有一个固定的求值顺序吗？从左到右？是的，如果把它封装起来，我们就可以按照我们感觉合适的方式来控制它。这就使得在JavaScript中可以实现惰性求值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a*b)*c = a*(b*c)</span><br><span class=\"line\">(f o g)o h = f o (g o h)</span><br></pre></td></tr></table></figure></p>\n<p>我们来重写函数组合，不作为函数原型的扩展，而是作为一个单独的函数，这样我们就可以的到更多的功能。基本的形式是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fcompose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(<span class=\"keyword\">this</span>,g.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过我们还得让它能接受任意数量的输入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fcompose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//首先确保所有的参数都是函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = arrayOf(func)(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=func.length<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">      args = [funcs[i].apply(<span class=\"keyword\">this</span>,args)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们封装好了这些函数并可以控制它们了。我们重写了组合函数使得每一个函数接受另一个函数作为输入， 存储起来，并同样返回一个对象。这里并不是接受一个数组作为输入处理它，而是对每一个操作返回一个新的数组， 我们可以在源头上让每一个元素接受一个数组，把所有操作合到一起执行（所有map、filter等等组合到一起）， 最终把结果存到一个新数组里。这就是通过函数组合实现的惰性求值。这里我们没有理由重新造轮子， 许多库对于这个概念都有很好的实现，包括Lazy.js、Bacon.js以及wu.js等库。</p>\n<p>利用这一不同模式的结果，我们可以做更多事情：异步迭代、异步事件处理、惰性求值甚至自动并行。</p>\n<h1 id=\"单子-Monad\"><a href=\"#单子-Monad\" class=\"headerlink\" title=\"单子(Monad)\"></a>单子(Monad)</h1><p>单子是帮助你组合函数的工具。</p>\n<p>像原始类型一样，单子是一种数据结构，它可以被当做装载让函子取东西的容器使用。函子取出了数据，进行处理，然后放到一个新的单子中并将其返回。</p>\n<p>我么要关注的三种单子：</p>\n<ul>\n<li>Maybes</li>\n<li>Promises</li>\n<li>Lenses</li>\n</ul>\n<p>除了用于数组的map和函数的compose以外，我们还有三种函子(maybe、promise和lens).这仅仅是另一些函子和单子。</p>\n<h2 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a>Maybe</h2><p>Maybe可以让我们优雅地使用有可能为空并且有默认值的数据。maybe是一个可以有值也可以没有值的变量，并且对于调用者来说无所谓。<br>就他自己来说，这看起来不是什么大问题。所有人都知道空值检查可以通过一个if-self语句很容易实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(getUsername() == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">  username = <span class=\"string\">'Anonymous'</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  username = getUsername();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是用函数式编程，我们要打破过程、一行接一行的做事方式，而应该用函数和数据的管道方式。如果我们不得不从链的中间断开来检查是否存在，我们就的创建临时变量并写更多的代码。maybe仅仅是帮助我们保持逻辑跟随管道的工具。</p>\n<p>要实现maybe，我们首先要创建一些构造器。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maybe单子构造器，目前是空的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Maybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//None实例，对一个没有值的对象的包装</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> None = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">None.prototype = <span class=\"built_in\">Object</span>.create(Maybe.prototype);</span><br><span class=\"line\">None.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">'None'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在可以写`none`函数</span></span><br><span class=\"line\"><span class=\"comment\">//这让我们不用总写`new None()`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> none = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> None()&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Just实例，对一个有一个值的对象的包装</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Just = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x = x&#125;;</span><br><span class=\"line\">Just.prototype = <span class=\"built_in\">Object</span>.create(Maybe.prototype);</span><br><span class=\"line\">Just.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">\"Just\"</span> + <span class=\"keyword\">this</span>.x&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> just = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Just(x)&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n","excerpt":"","more":"<p>托马斯.沃森(时任IBM董事长)说过一句著名的话，“我想全世界只有五台计算机的市场”。那是1948年，当时，每个人都认为计算机只会被用于两件事情：数学和工程。 即使是技术上最大胆的预想也不会认为有一天计算机能够把西班牙语翻译成英语， 或者模拟整个天气系统。在那时最快的计算机是IBM的SSEC，每秒能计算50次，显示终端要在15年后才出现， 多任务处理意味着多个用户终端共享一个单线程。晶体管改变了一切，然而对技术的远见没有跟上。 在1977年，Ken Olson（DEC创始人）说过另一个愚蠢的预言：“任何人都没有理由想在家里拥有个计算机”。</p>\n<p>对于我们来说很明显计算机不只是为科学家和工程师所用，但这只是事后诸葛。在70年前认为计算机只能作数学计算是很正常的。 沃森不仅没有意识到计算机会改变社会，他还没有意识到数学的改革和演进的能力。</p>\n<p>不过计算机和数学的潜力并非被所有人忽视。约翰·麦卡锡在1958年发明了Lisp，这是一个革命性的基于算法的语言， 它把计算机带入了新纪元。从那开始，Lisp对使用抽象层的思想（编译、解释、虚拟化）起到重要作用， 这促使了计算机从一个只能用于数学的机器变成了今天这样。</p>\n<p>从Lisp到Scheme，一个JavaScript的直接原型。现在它给我们带来了一个轮回。如果计算机在核心上只是一个做数学的机器， 那么它在以数学为基础编程范式上具有优越性是合理的</p>\n<p>这里所说的“数学”并不是指计算机明显能做的数字运算，而是要描述为离散数学：对于离散的、 对于诸如逻辑上的声明或者计算机语言命令的数学结构的研究。 通过把代码作为离散的数学结构来对待，我们可以把概念和想法应用到数学上。 这也就是为什么函数式编程在人工智能、图谱搜索、模式识别以及其它计算机科学中具有挑战性的领域里具有如此重要的地位。</p>\n<p>这一章我们将针对日常编程中的问题对一些概念和它们的应用进行试验，包括：</p>\n<ul>\n<li>范畴论（Category theory）</li>\n<li>态射（Morphisms）</li>\n<li>函子（Functors）</li>\n<li>Maybes</li>\n<li>Promises</li>\n<li>Lenses</li>\n<li>函数组合</li>\n</ul>\n<p>利用这些概念我们可以轻松安全地写出整个库和API。并且我们要从对范畴论的解释开始一直到它在JavaScript里的实现。</p>\n<h1 id=\"范畴论\"><a href=\"#范畴论\" class=\"headerlink\" title=\"范畴论\"></a>范畴论</h1><blockquote>\n<p>范畴论是用于函数组合的理论性概念。范畴论和函数组合他们俩在一起就像发动机排量和马力，像NASA和空间穿梭， 像好酒和装它的瓶子。基本上讲，你不能让它们中的一个脱离另一个而独立存在。</p>\n</blockquote>\n<h2 id=\"范畴论概览\"><a href=\"#范畴论概览\" class=\"headerlink\" title=\"范畴论概览\"></a>范畴论概览</h2><p>范畴论实际并不是一个很难的概念。在数学上它大到能够填满一个本科课程，但是在计算机编程中它可以很容易地被总结出来。</p>\n<p>爱因斯坦曾说过：“如果你不能把它解释给一个六岁的孩子听，那你自己也没有理解”。这样，按照给六岁孩子解释的说法， 范畴论只不过是一些连接的圆点。也许这过分简化了范畴论，不过这从直观的方式上很好的解释了我们所需要知道的东西。</p>\n<p>首先你需要了解一些术语。范畴(category,也可以说是种类)只是一些同样类型的集合。在javascript里，它们是数组或对象，包含了明确指定为数字、字符串、布尔、日期或节点等类型的变量。太射(Morphism)是一些纯函数，当给定一系列输入时总会返回相同的输出。多态操作可以操作多个范畴，而同态操作限制在一个单独的范畴中。例如，同态函数“乘”只能作用于数字，而多态函数“加”还能作用于字符串。</p>\n<p>下图展示了三个范畴–A、B、C，以及两个太射–f和g</p>\n<p><img src=\"/images/范畴论/1.png\" alt=\"范畴论\"><br>范畴论告诉我们，当第一个态射的范畴是另一个态射所需的输入时，它们就可以像下图所示这样组合：<br><img src=\"/images/范畴论/2.png\" alt=\"范畴论\"><br>fog符号代表态射f和g的组合。现在我们就可以连接这些原点。<br><img src=\"/images/范畴论/3.png\" alt=\"范畴论\"><br>真的是这样，只是连接圆点。</p>\n<h2 id=\"类型安全\"><a href=\"#类型安全\" class=\"headerlink\" title=\"类型安全\"></a>类型安全</h2><p>我们来连接一些圆点。范畴包含两样东西：</p>\n<ol>\n<li>对象Object(在javascrip中是类型)</li>\n<li>态射Morphisms(在javascrip中是只作用于类型的纯函数)。</li>\n</ol>\n<p>这是数学赋予范畴论的术语，所以不幸与我们的javascrip的术语集有些冲突。范畴论中的对象更像是代表一个指定数据类型的变量，而不是像JavaScript所定义的对象那样具有一系列属性和值。 态射只是使用这些类型的纯函数。<br>所以在javascrip应用范畴论很简单。在javascrip中使用范畴论意味着每个范畴只使用一个特定的数据类型。数据类型是指数字、字符串、数组、日期、对象、布尔等等。但是javascrip没有严格的类型系统，很容易出岔子。所以我们不得不实现我们自己的方法来保证数据的正确。<br>javascrip中有四种原始类型：number、string、Boolean、function.我们可以创建类型安全函数，返回变量或者抛出一个错误。这符合范畴论的对象定理。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> s === <span class=\"string\">\"string\"</span>) &#123;￼￼</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: String expected, \"</span> + <span class=\"keyword\">typeof</span> s + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> n === <span class=\"string\">\"number\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Number expected, \"</span> + <span class=\"keyword\">typeof</span> n + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> b === <span class=\"string\">\"boolean\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> b;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Boolean expected, \"</span> + <span class=\"keyword\">typeof</span> b + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> f === <span class=\"string\">\"function\"</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Function expected, \"</span> + <span class=\"keyword\">typeof</span> f +</span><br><span class=\"line\">      <span class=\"string\">\" given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然而这里重复代码太多，并且不是很函数式。我们可以创建一个函数，它返回一个类型安全的函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> typeOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> x === type)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: \"</span> + type + <span class=\"string\">\" exceped, \"</span> + <span class=\"keyword\">typeof</span> x + <span class=\"string\">\"given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> str = typeOf(<span class=\"string\">'string'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = typeOf(<span class=\"string\">'number'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = typeOf(<span class=\"string\">'function'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = typeOf(<span class=\"string\">'boolean'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>现在，我们可以利用这些函数让我们的函数像预期那样运行。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//未受保护的方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"string\">'24'</span>;</span><br><span class=\"line\">x + <span class=\"number\">1</span>; <span class=\"comment\">//会返回‘241’，而不是25</span></span><br><span class=\"line\"><span class=\"comment\">//受保护的方法</span></span><br><span class=\"line\"><span class=\"comment\">//plus :: Int -&gt; Int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">plus</span>(<span class=\"params\">n</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> num(n) + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">plus(x); <span class=\"comment\">//抛出错误，防止出现意外的结果</span></span><br></pre></td></tr></table></figure></p>\n<p>再来看个有点肉的例子。我们想检查Unix时间戳的长度，由于javascript函数Date.parse()返回的值是数字而不是字符串，我们得用str()函数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//timestampLength :: String -&gt; Int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timestampLength</span>(<span class=\"params\">t</span>)</span>&#123; <span class=\"keyword\">return</span> num(str(t).length);&#125;</span><br><span class=\"line\">timestampLength(<span class=\"built_in\">Date</span>.parse(<span class=\"string\">'12/31/1999'</span>)); <span class=\"comment\">// 抛出错误</span></span><br><span class=\"line\">timestampLength(<span class=\"built_in\">Date</span>.parse(<span class=\"string\">'12/31/1999'</span>).toString()); <span class=\"comment\">// 返回12</span></span><br></pre></td></tr></table></figure></p>\n<p>像这样把明确地一个类型转换为另一个类型（或者是相同的类型）的函数叫做态射。这符合范畴论的态射定理。这里强迫通过类型安全函数进行类型声明，利用了这个机制的态射是我们在javascript中展示范畴概念所需的一切。</p>\n<h2 id=\"对象识别\"><a href=\"#对象识别\" class=\"headerlink\" title=\"对象识别\"></a>对象识别</h2><p>另外还有一个重要的数据类型：对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = typeOf(<span class=\"string\">'object'</span>);</span><br><span class=\"line\">obj(<span class=\"number\">123</span>); <span class=\"comment\">//抛出错误</span></span><br><span class=\"line\">obj(&#123;x:<span class=\"string\">'a'</span>&#125;); <span class=\"comment\">//返回&#123;x:'a'&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>然而，对象各不相同。它们可以被继承。任何非原始类型(number、string、boolean、functin)的东西都是对象，包括数组、日期、元素等等。<br>没有办法知道一个对象是个什么类型，也就是说没法通过typeof关键字知道javascript的对象的子类型是什么，所以我们得想办法。Object有个toString()函数，我们可以通过它变通实现这个目的。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.toString.call(o) === <span class=\"string\">\"[object object]\"</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">\"Error: Object expected, something else given.\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同样，对于各种对象，我们要实现代码重用：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objectTypeOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">Object</span>.prototype.toString.call(o) === <span class=\"string\">\"[object \"</span> + name + <span class=\"string\">\"]\"</span>)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> o;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(</span><br><span class=\"line\">        <span class=\"string\">\"Error: '+name+' expected, something else given.\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = objectTypeOf(<span class=\"string\">'Object'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = objectTypeOf(<span class=\"string\">'Array'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> date = objectTypeOf(<span class=\"string\">'Date'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> div = objectTypeOf(<span class=\"string\">'HTMLDivElement'</span>);</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"函子-Functiors\"><a href=\"#函子-Functiors\" class=\"headerlink\" title=\"函子(Functiors)\"></a>函子(Functiors)</h1><p>态射是类型之间的映射；函子是范畴之间的映射。可以认为函子是这样一个函数，它从一个容器中取到值，并将其加工，然后放到一个新的容器中。这个函数的第一个输入的参数是类型的态射，第二个输入的参数是容器。</p>\n<blockquote>\n<p>函子的函数签名是这样子 //myFunctor :: (a -&gt; b) -&gt; fa -&gt; fb<br>意思是“给我一个传入a返回b的函数和一个包含a(一个或多个)的容器，我会返回一个包含b(一个或多个)的容器”</p>\n</blockquote>\n<h2 id=\"创建函子\"><a href=\"#创建函子\" class=\"headerlink\" title=\"创建函子\"></a>创建函子</h2><p>要知道我们已经有了一个函子：map()，它攫取包含一些值的容器(数组)，然后把一个函数作用于它。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">9</span>].map(<span class=\"built_in\">Math</span>.sqrt); <span class=\"comment\">//returns: [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>然而我们要写成一个全局函数，而不是数组对象的方法。这样我们后面就可以写出简洁、安全的代码。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr[a].map(func(f));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这个例子看起来像是故意弄的封装，因为我们只是把map()函数换了个形式。但这有它的目的。它为映射其他类型提供了一个模板。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//strmap :: (str -&gt; str) -&gt; str -&gt; str</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> strmap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,s</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str(s).split(<span class=\"string\">''</span>).map(func(f)).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数组和函子\"><a href=\"#数组和函子\" class=\"headerlink\" title=\"数组和函子\"></a>数组和函子</h2><p>数组是函数式javascript使用数据最好的方式。</p>\n<p>是否有一种简单的方法来创建已经分配了态射的函子？有，它叫做arrayOf。当你传入一个以整数为参数、返回数组的态射时，你会得到一个以整数数组为参数返回数组的数组的态射。</p>\n<p>它自己本身不是函子，但是它让我们能够用态射建立函子。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//arrayOf :: (a -&gt; b) -&gt; ([a] -&gt; [b])</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrayOf = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> map(func(f),arr(a));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>下面是如何用态射创建函子<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> plusplusall = arrayOf(plusplus); <span class=\"comment\">//plusplus是函子</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusplusall([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])); <span class=\"comment\">//返回[2,3,4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(plusplusall([<span class=\"number\">1</span>,<span class=\"string\">'2'</span>,<span class=\"number\">3</span>])); <span class=\"comment\">//抛出错误</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数组合，重访-revisitd\"><a href=\"#函数组合，重访-revisitd\" class=\"headerlink\" title=\"函数组合，重访(revisitd)\"></a>函数组合，重访(revisitd)</h2><p>函数也是一种我们能够用函子来创建的原始类型，这个函子叫做“fcompose”.我们对函子是这样定义的：它从容器中取一个值，并对其应用一个函数。如果这个容器是一个函数，我们只需要调用它并获取里面的值。</p>\n<p>我们已经知道了什么事函数组合，不过让我们来看看在范畴论驱动的环境里它们能做些什么。</p>\n<p>函数组合就是结合(associative)，如果你的高中代数老师也像我这样的话那她只告诉了你函数组合的定律有什么，而没有没教你用它能做些什么。 在实践中，组合就是结合律所能够做的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a*b)*c = a*(b*c)</span><br><span class=\"line\">(f o g)o h = f o (g o h)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f o g ≠ g o f</span><br></pre></td></tr></table></figure>\n<p>我们可以任意进行内部组合，无所谓怎样分组。交换律也没有什么可迷惑的。f o g 不总等于 g o f。比如说，一个句子的第一个单词被反转并不等同于一个被反转的句子的第一个单词。</p>\n<p>总的来说意思就是哪个函数以什么样的顺序被执行是无所谓的，只要每个函数的输入来源于上一个函数的输出。不过，等等，如果右边的函数依赖于左边的函数，不就是只有一个固定的求值顺序吗？从左到右？是的，如果把它封装起来，我们就可以按照我们感觉合适的方式来控制它。这就使得在JavaScript中可以实现惰性求值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a*b)*c = a*(b*c)</span><br><span class=\"line\">(f o g)o h = f o (g o h)</span><br></pre></td></tr></table></figure></p>\n<p>我们来重写函数组合，不作为函数原型的扩展，而是作为一个单独的函数，这样我们就可以的到更多的功能。基本的形式是这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fcompose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f,g</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f.call(<span class=\"keyword\">this</span>,g.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过我们还得让它能接受任意数量的输入。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fcompose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//首先确保所有的参数都是函数</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> funcs = arrayOf(func)(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=func.length<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;i--)&#123;</span><br><span class=\"line\">      args = [funcs[i].apply(<span class=\"keyword\">this</span>,args)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> args[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在我们封装好了这些函数并可以控制它们了。我们重写了组合函数使得每一个函数接受另一个函数作为输入， 存储起来，并同样返回一个对象。这里并不是接受一个数组作为输入处理它，而是对每一个操作返回一个新的数组， 我们可以在源头上让每一个元素接受一个数组，把所有操作合到一起执行（所有map、filter等等组合到一起）， 最终把结果存到一个新数组里。这就是通过函数组合实现的惰性求值。这里我们没有理由重新造轮子， 许多库对于这个概念都有很好的实现，包括Lazy.js、Bacon.js以及wu.js等库。</p>\n<p>利用这一不同模式的结果，我们可以做更多事情：异步迭代、异步事件处理、惰性求值甚至自动并行。</p>\n<h1 id=\"单子-Monad\"><a href=\"#单子-Monad\" class=\"headerlink\" title=\"单子(Monad)\"></a>单子(Monad)</h1><p>单子是帮助你组合函数的工具。</p>\n<p>像原始类型一样，单子是一种数据结构，它可以被当做装载让函子取东西的容器使用。函子取出了数据，进行处理，然后放到一个新的单子中并将其返回。</p>\n<p>我么要关注的三种单子：</p>\n<ul>\n<li>Maybes</li>\n<li>Promises</li>\n<li>Lenses</li>\n</ul>\n<p>除了用于数组的map和函数的compose以外，我们还有三种函子(maybe、promise和lens).这仅仅是另一些函子和单子。</p>\n<h2 id=\"Maybe\"><a href=\"#Maybe\" class=\"headerlink\" title=\"Maybe\"></a>Maybe</h2><p>Maybe可以让我们优雅地使用有可能为空并且有默认值的数据。maybe是一个可以有值也可以没有值的变量，并且对于调用者来说无所谓。<br>就他自己来说，这看起来不是什么大问题。所有人都知道空值检查可以通过一个if-self语句很容易实现<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(getUsername() == <span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">  username = <span class=\"string\">'Anonymous'</span>;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  username = getUsername();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但是用函数式编程，我们要打破过程、一行接一行的做事方式，而应该用函数和数据的管道方式。如果我们不得不从链的中间断开来检查是否存在，我们就的创建临时变量并写更多的代码。maybe仅仅是帮助我们保持逻辑跟随管道的工具。</p>\n<p>要实现maybe，我们首先要创建一些构造器。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Maybe单子构造器，目前是空的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Maybe = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//None实例，对一个没有值的对象的包装</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> None = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">None.prototype = <span class=\"built_in\">Object</span>.create(Maybe.prototype);</span><br><span class=\"line\">None.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">'None'</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//现在可以写`none`函数</span></span><br><span class=\"line\"><span class=\"comment\">//这让我们不用总写`new None()`</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> none = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> None()&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Just实例，对一个有一个值的对象的包装</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> Just = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x = x&#125;;</span><br><span class=\"line\">Just.prototype = <span class=\"built_in\">Object</span>.create(Maybe.prototype);</span><br><span class=\"line\">Just.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"string\">\"Just\"</span> + <span class=\"keyword\">this</span>.x&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> just = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Just(x)&#125;;</span><br></pre></td></tr></table></figure></p>\n<hr>\n"},{"title":"函数式编程(月影)","date":"2016-05-18T08:17:01.000Z","_content":"> 这是月影谈函数式编程系列的第2篇文章，上一篇文章讲的是：函数式编程离我们有多远？\n\n**纯函数**指的是函数的输出完全有输入所决定，运行过程不宜开与系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。\n\n纯函数对*设计可靠、稳定、易于调试和易于测试的系统有着非常重要的作用。*在Javascript程序设计中有一个基本的原则就是尽可能限制副作用，执行过程尽量不要依赖与环境。这是非常好的原则，纯函数的好处是非常明显的。\n\n不过，我们有时候也还是要用到非纯函数，显而易见的例子就是，Javascript总是在特定环境中运行的，浏览器中的Javascript不可能不操作DOM，Node.js也不可能永远不操作文件或者数据库，这些都会改变“环境状态”，还有诸如 Array.sort、Math.random、setTimeout、setInterval这些内置的函数也都是非纯的函数。\n\n纯函数和非纯函数的几个例子：\n\n//纯函数\n```javascript\n    function add(x,y){\n        return x+ y;\n    }\n```\n//纯函数\n```javascript\n    function sub(x, y){    \n      return x - y;\n    }\n```\n\n//非纯函数，依赖于系统时间\n```javascript\n    function now(){    \n      return data.now();\n    }\n```\n\n//非纯函数，依赖于作用域外的变量\n```javascript\nvar idx = 0;\n    function inc(){    \n      return ++idx;\n    }\n```\n\n//非纯函数，依赖于随机数生成\n```javascript\n    function random(){    \n      return Math.random();\n    }\n```\n\n//非纯函数，操作改变 DOM\n```javascript\n    function addItem(){    \n      var li = document.createElement(\"li\");\n      document.body.appendChild(li);\n    }\n```\n\n有一种观点认为，纯函数是函数式编程的一个支柱。由于函数式编程将函数本身也作为数据看来对待，纯函数的返回值只依赖于参数，这看起来对将函数作为数据的“运算”的函数式编程思想是十分重要的。除了以上直接的原因之外，函数式编程思想与纯函数之间究竟还有什么关联？针对纯函数，我们还能应用函数式编程做些什么？\n\n### “不纯度”污染\n纯函数的组合依然是纯函数，然而只要有一个函数不纯，那么调用了它的其他函数也是“不纯的”。\n\n```javascript\n    //setColor 不是纯函数，它改变外部环境(DOM)\n    function setColor(el,color){\n        el.style.color = color;\n        return el;\n    }\n    //setColorEls显然也不纯，因为它依赖于setColor\n    function setColorEls(els,color){\n        return els.map((el) => setColor(el,color));\n    }\n```\n\n上面的例子里，我们定义了两个函数，setColor和setColorEls它们都不是纯函数，因为setColorEls依赖了setColor。\n\n设想一下，如果调试时发现 setColorEls 出错了，我们就要检查 setColorEls 和 setColor 两个函数来确定问题所在。\n\n上面只是一个简单的例子，如果更加复杂的情况，那么可能一个出错点就需要牵扯出一系列函数，在一大坨代码中寻找问题了 —— 相信很多程序员都遇到过，那绝不是一种愉快的经历。\n\n有没有办法让 setColorEls 依赖于 setColor， 但同时又能限制造成的纯度污染呢？答案是有的，需要继续往下讨论。\n\n## 高阶函数的纯度\n### 函数可替代性与等价关系\n对于数值来说，我们很容易定义出两个数的等价关系。那么对于两个函数来说，我们如何定义它们的等价关系呢？\n\n对于“纯函数”来说，判断两个函数等价，只要保证对于任意相同输入，两个函数返回的输出都相同，那么两个函数等价。\n\n```javascript\n   //两个纯函数 foo 和 bar 等价\n   function foo(arr, obj){    \n     var ret = arr.slice(0);\n     ret.push(obj);    \n     return ret;\n   }\n   function bar(arr, obj){    \n     return arr.concat([obj]);\n   } \n```\n\n函数等价意味着可替换，也就是说，我们可以将系统里所有使用到 foo 的地方都用 bar 替换，系统的运行结果不会有任何问题。换句话说，如果确保 foo 没问题，那么将来系统出了问题，也可以直接排除是 bar 引起的问题。\n\n注意 JavaScript 函数纯度要考虑 this 上下文：\n```javascript\n   var point = {x:1, y:2};\n   //这个函数其实是不纯的，因为它依赖了 this 上下文\n   function pointAdd(x, y){    \n     return this.x + this.y;\n   }\n   point.add = pointAdd;\n   point.add2 = pointAdd.bind(point); \n```\n\n上面的代码，point.add和point.add2不等价，通常情况下的替换不会有问题，但是我们难以保证系统里面没有point.add.call、point.add.apply或者point2 = point.add 之类的代码存在，如果有那些代码存在，用point.add2代替point.add就会出大问题了。\n\n那么上面的例子是否说明只有纯函数才可以判定等价和可替换呢？\n\n答案显然不是：\n```javascript\n   //不论 foo 是任何函数，不论 foo 的纯度如何， bar 始终和 foo 可替换\n   function foo(){    \n     //blablabla....\n   }\n   function bar(...args){    \n     return foo.apply(this, args);\n   }\n```\n\n考虑上面的代码，毫无疑问地，不管 foo 内部是个什么鬼，不管它有没有副作用，有不管它没有 bind this，不管它在调用时的 this 是什么，我们都可以无比肯定，十分确定地下结论：bar和foo完全可以相互替换，任意替换 foo 为 bar 或者替换 bar为 foo，系统不会有任何问题（除开一些小小的性能开销，因为bar多了一层调用）。\n\n到这一步，我们可以给出一个定义：\n\n> 定义：JavaScript 函数 f 与 g 相等的充分必要条件是 f 与 g 是可替换的。\n\n好了，我们在上面给出了判定两个函数相等的一般性定义，而这个定义和函数本身的纯度无关。\n\n这个定义有什么意义呢？这个定义的意义就是，既然我们有了判定函数相等的一般性法则，我们就可以唯一确定一个函数了，就像确定数据一样，1是1，2-1，-1+2，0.5*2也都是1，1是唯一的。\n\n既然我们可以唯一确定一个函数，那么我们就能说如果一个高阶函数的参数确定，返回一组确定的函数，那么这个高阶函数是纯函数。\n\n使用高阶纯函数\n\n现在我们该回到前面 setColor 的例子了：\n```javascript\n    //高阶函数multicast是纯函数，它只依赖于不同的参数，返回确定的结果。\n    function multicast(fn){\n        return function(list,...rest){\n            if(Array.isArray(list)){\n                return list.map((o) => fn.apply(this,[o,...rest]));\n            }else{\n                return fn.apply(this,arguments);\n            }\n        }\n    }\n    //setColor 不是纯函数，它改变外部环境（DOM）\n    function setColor(el, color){\n      el.style.color = color;    \n      return el;\n    }\n    let setColorEls = multicast(setColor);\n    var list = document.querySelectorAll(\"li:nth-child(2n+1)\");\n    setColorEls(Array.from(list), \"red\");\n```\n\n上面的代码有几个好处：\n - multicast 是纯函数，它简单灵活，对系统的影响很小。\n - multicast 对任意函数返回确定的函数，不影响外部环境和状态。\n - setColorEls 在 multicast 保证可靠的情况下，完全依赖于 setColor，如果它出错，只需要检查 setColor 的实现，使得调试变得简单了。\n - multicast 是通用的，不管是setColor、setBGColor、setFont还是什么其他的API，都可以用它来统一处理，获得同样的好处。\n\n## 总结\n使用函数式编程思想中的高阶函数能够设计出简单可靠的API，这些高阶的API根据确定参数返回确定的函数，它们依然是纯函数，它们拥有纯函数的优点。使用它们对简化系统，提升可扩展性和可维护性都有着非常大的帮助。\n\n文章里面的例子只是非常简单的小案例，而实际项目中使用高阶函数设计系统能够取得更加不可思议的效果和美妙的开发体验。如果你善于使用这样的技巧，构建小而美却功能强大易于扩展的系统，就不是一件多么难的事情了。","source":"_posts/函数式编程-月影.md","raw":"---\ntitle: 函数式编程(月影)\ndate: 2016-05-18 16:17:01\ntags:\n- javascript\n- 函数式编程\ncategories: 转载笔记\n---\n> 这是月影谈函数式编程系列的第2篇文章，上一篇文章讲的是：函数式编程离我们有多远？\n\n**纯函数**指的是函数的输出完全有输入所决定，运行过程不宜开与系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。\n\n纯函数对*设计可靠、稳定、易于调试和易于测试的系统有着非常重要的作用。*在Javascript程序设计中有一个基本的原则就是尽可能限制副作用，执行过程尽量不要依赖与环境。这是非常好的原则，纯函数的好处是非常明显的。\n\n不过，我们有时候也还是要用到非纯函数，显而易见的例子就是，Javascript总是在特定环境中运行的，浏览器中的Javascript不可能不操作DOM，Node.js也不可能永远不操作文件或者数据库，这些都会改变“环境状态”，还有诸如 Array.sort、Math.random、setTimeout、setInterval这些内置的函数也都是非纯的函数。\n\n纯函数和非纯函数的几个例子：\n\n//纯函数\n```javascript\n    function add(x,y){\n        return x+ y;\n    }\n```\n//纯函数\n```javascript\n    function sub(x, y){    \n      return x - y;\n    }\n```\n\n//非纯函数，依赖于系统时间\n```javascript\n    function now(){    \n      return data.now();\n    }\n```\n\n//非纯函数，依赖于作用域外的变量\n```javascript\nvar idx = 0;\n    function inc(){    \n      return ++idx;\n    }\n```\n\n//非纯函数，依赖于随机数生成\n```javascript\n    function random(){    \n      return Math.random();\n    }\n```\n\n//非纯函数，操作改变 DOM\n```javascript\n    function addItem(){    \n      var li = document.createElement(\"li\");\n      document.body.appendChild(li);\n    }\n```\n\n有一种观点认为，纯函数是函数式编程的一个支柱。由于函数式编程将函数本身也作为数据看来对待，纯函数的返回值只依赖于参数，这看起来对将函数作为数据的“运算”的函数式编程思想是十分重要的。除了以上直接的原因之外，函数式编程思想与纯函数之间究竟还有什么关联？针对纯函数，我们还能应用函数式编程做些什么？\n\n### “不纯度”污染\n纯函数的组合依然是纯函数，然而只要有一个函数不纯，那么调用了它的其他函数也是“不纯的”。\n\n```javascript\n    //setColor 不是纯函数，它改变外部环境(DOM)\n    function setColor(el,color){\n        el.style.color = color;\n        return el;\n    }\n    //setColorEls显然也不纯，因为它依赖于setColor\n    function setColorEls(els,color){\n        return els.map((el) => setColor(el,color));\n    }\n```\n\n上面的例子里，我们定义了两个函数，setColor和setColorEls它们都不是纯函数，因为setColorEls依赖了setColor。\n\n设想一下，如果调试时发现 setColorEls 出错了，我们就要检查 setColorEls 和 setColor 两个函数来确定问题所在。\n\n上面只是一个简单的例子，如果更加复杂的情况，那么可能一个出错点就需要牵扯出一系列函数，在一大坨代码中寻找问题了 —— 相信很多程序员都遇到过，那绝不是一种愉快的经历。\n\n有没有办法让 setColorEls 依赖于 setColor， 但同时又能限制造成的纯度污染呢？答案是有的，需要继续往下讨论。\n\n## 高阶函数的纯度\n### 函数可替代性与等价关系\n对于数值来说，我们很容易定义出两个数的等价关系。那么对于两个函数来说，我们如何定义它们的等价关系呢？\n\n对于“纯函数”来说，判断两个函数等价，只要保证对于任意相同输入，两个函数返回的输出都相同，那么两个函数等价。\n\n```javascript\n   //两个纯函数 foo 和 bar 等价\n   function foo(arr, obj){    \n     var ret = arr.slice(0);\n     ret.push(obj);    \n     return ret;\n   }\n   function bar(arr, obj){    \n     return arr.concat([obj]);\n   } \n```\n\n函数等价意味着可替换，也就是说，我们可以将系统里所有使用到 foo 的地方都用 bar 替换，系统的运行结果不会有任何问题。换句话说，如果确保 foo 没问题，那么将来系统出了问题，也可以直接排除是 bar 引起的问题。\n\n注意 JavaScript 函数纯度要考虑 this 上下文：\n```javascript\n   var point = {x:1, y:2};\n   //这个函数其实是不纯的，因为它依赖了 this 上下文\n   function pointAdd(x, y){    \n     return this.x + this.y;\n   }\n   point.add = pointAdd;\n   point.add2 = pointAdd.bind(point); \n```\n\n上面的代码，point.add和point.add2不等价，通常情况下的替换不会有问题，但是我们难以保证系统里面没有point.add.call、point.add.apply或者point2 = point.add 之类的代码存在，如果有那些代码存在，用point.add2代替point.add就会出大问题了。\n\n那么上面的例子是否说明只有纯函数才可以判定等价和可替换呢？\n\n答案显然不是：\n```javascript\n   //不论 foo 是任何函数，不论 foo 的纯度如何， bar 始终和 foo 可替换\n   function foo(){    \n     //blablabla....\n   }\n   function bar(...args){    \n     return foo.apply(this, args);\n   }\n```\n\n考虑上面的代码，毫无疑问地，不管 foo 内部是个什么鬼，不管它有没有副作用，有不管它没有 bind this，不管它在调用时的 this 是什么，我们都可以无比肯定，十分确定地下结论：bar和foo完全可以相互替换，任意替换 foo 为 bar 或者替换 bar为 foo，系统不会有任何问题（除开一些小小的性能开销，因为bar多了一层调用）。\n\n到这一步，我们可以给出一个定义：\n\n> 定义：JavaScript 函数 f 与 g 相等的充分必要条件是 f 与 g 是可替换的。\n\n好了，我们在上面给出了判定两个函数相等的一般性定义，而这个定义和函数本身的纯度无关。\n\n这个定义有什么意义呢？这个定义的意义就是，既然我们有了判定函数相等的一般性法则，我们就可以唯一确定一个函数了，就像确定数据一样，1是1，2-1，-1+2，0.5*2也都是1，1是唯一的。\n\n既然我们可以唯一确定一个函数，那么我们就能说如果一个高阶函数的参数确定，返回一组确定的函数，那么这个高阶函数是纯函数。\n\n使用高阶纯函数\n\n现在我们该回到前面 setColor 的例子了：\n```javascript\n    //高阶函数multicast是纯函数，它只依赖于不同的参数，返回确定的结果。\n    function multicast(fn){\n        return function(list,...rest){\n            if(Array.isArray(list)){\n                return list.map((o) => fn.apply(this,[o,...rest]));\n            }else{\n                return fn.apply(this,arguments);\n            }\n        }\n    }\n    //setColor 不是纯函数，它改变外部环境（DOM）\n    function setColor(el, color){\n      el.style.color = color;    \n      return el;\n    }\n    let setColorEls = multicast(setColor);\n    var list = document.querySelectorAll(\"li:nth-child(2n+1)\");\n    setColorEls(Array.from(list), \"red\");\n```\n\n上面的代码有几个好处：\n - multicast 是纯函数，它简单灵活，对系统的影响很小。\n - multicast 对任意函数返回确定的函数，不影响外部环境和状态。\n - setColorEls 在 multicast 保证可靠的情况下，完全依赖于 setColor，如果它出错，只需要检查 setColor 的实现，使得调试变得简单了。\n - multicast 是通用的，不管是setColor、setBGColor、setFont还是什么其他的API，都可以用它来统一处理，获得同样的好处。\n\n## 总结\n使用函数式编程思想中的高阶函数能够设计出简单可靠的API，这些高阶的API根据确定参数返回确定的函数，它们依然是纯函数，它们拥有纯函数的优点。使用它们对简化系统，提升可扩展性和可维护性都有着非常大的帮助。\n\n文章里面的例子只是非常简单的小案例，而实际项目中使用高阶函数设计系统能够取得更加不可思议的效果和美妙的开发体验。如果你善于使用这样的技巧，构建小而美却功能强大易于扩展的系统，就不是一件多么难的事情了。","slug":"函数式编程-月影","published":1,"updated":"2016-05-19T03:43:54.126Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0enz002ob0dl62iin9ms","content":"<blockquote>\n<p>这是月影谈函数式编程系列的第2篇文章，上一篇文章讲的是：函数式编程离我们有多远？</p>\n</blockquote>\n<p><strong>纯函数</strong>指的是函数的输出完全有输入所决定，运行过程不宜开与系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。</p>\n<p>纯函数对<em>设计可靠、稳定、易于调试和易于测试的系统有着非常重要的作用。</em>在Javascript程序设计中有一个基本的原则就是尽可能限制副作用，执行过程尽量不要依赖与环境。这是非常好的原则，纯函数的好处是非常明显的。</p>\n<p>不过，我们有时候也还是要用到非纯函数，显而易见的例子就是，Javascript总是在特定环境中运行的，浏览器中的Javascript不可能不操作DOM，Node.js也不可能永远不操作文件或者数据库，这些都会改变“环境状态”，还有诸如 Array.sort、Math.random、setTimeout、setInterval这些内置的函数也都是非纯的函数。</p>\n<p>纯函数和非纯函数的几个例子：</p>\n<p>//纯函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+ y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//纯函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sub</span>(<span class=\"params\">x, y</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，依赖于系统时间<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">now</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> data.now();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，依赖于作用域外的变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inc</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> ++idx;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，依赖于随机数生成<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，操作改变 DOM<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">var</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(li);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有一种观点认为，纯函数是函数式编程的一个支柱。由于函数式编程将函数本身也作为数据看来对待，纯函数的返回值只依赖于参数，这看起来对将函数作为数据的“运算”的函数式编程思想是十分重要的。除了以上直接的原因之外，函数式编程思想与纯函数之间究竟还有什么关联？针对纯函数，我们还能应用函数式编程做些什么？</p>\n<h3 id=\"“不纯度”污染\"><a href=\"#“不纯度”污染\" class=\"headerlink\" title=\"“不纯度”污染\"></a>“不纯度”污染</h3><p>纯函数的组合依然是纯函数，然而只要有一个函数不纯，那么调用了它的其他函数也是“不纯的”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//setColor 不是纯函数，它改变外部环境(DOM)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setColor</span>(<span class=\"params\">el,color</span>)</span>&#123;</span><br><span class=\"line\">    el.style.color = color;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//setColorEls显然也不纯，因为它依赖于setColor</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setColorEls</span>(<span class=\"params\">els,color</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> els.map((el) =&gt; setColor(el,color));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子里，我们定义了两个函数，setColor和setColorEls它们都不是纯函数，因为setColorEls依赖了setColor。</p>\n<p>设想一下，如果调试时发现 setColorEls 出错了，我们就要检查 setColorEls 和 setColor 两个函数来确定问题所在。</p>\n<p>上面只是一个简单的例子，如果更加复杂的情况，那么可能一个出错点就需要牵扯出一系列函数，在一大坨代码中寻找问题了 —— 相信很多程序员都遇到过，那绝不是一种愉快的经历。</p>\n<p>有没有办法让 setColorEls 依赖于 setColor， 但同时又能限制造成的纯度污染呢？答案是有的，需要继续往下讨论。</p>\n<h2 id=\"高阶函数的纯度\"><a href=\"#高阶函数的纯度\" class=\"headerlink\" title=\"高阶函数的纯度\"></a>高阶函数的纯度</h2><h3 id=\"函数可替代性与等价关系\"><a href=\"#函数可替代性与等价关系\" class=\"headerlink\" title=\"函数可替代性与等价关系\"></a>函数可替代性与等价关系</h3><p>对于数值来说，我们很容易定义出两个数的等价关系。那么对于两个函数来说，我们如何定义它们的等价关系呢？</p>\n<p>对于“纯函数”来说，判断两个函数等价，只要保证对于任意相同输入，两个函数返回的输出都相同，那么两个函数等价。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//两个纯函数 foo 和 bar 等价</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arr, obj</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = arr.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">  ret.push(obj);    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">arr, obj</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.concat([obj]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数等价意味着可替换，也就是说，我们可以将系统里所有使用到 foo 的地方都用 bar 替换，系统的运行结果不会有任何问题。换句话说，如果确保 foo 没问题，那么将来系统出了问题，也可以直接排除是 bar 引起的问题。</p>\n<p>注意 JavaScript 函数纯度要考虑 this 上下文：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point = &#123;x:<span class=\"number\">1</span>, y:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//这个函数其实是不纯的，因为它依赖了 this 上下文</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pointAdd</span>(<span class=\"params\">x, y</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + <span class=\"keyword\">this</span>.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">point.add = pointAdd;</span><br><span class=\"line\">point.add2 = pointAdd.bind(point);</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，point.add和point.add2不等价，通常情况下的替换不会有问题，但是我们难以保证系统里面没有point.add.call、point.add.apply或者point2 = point.add 之类的代码存在，如果有那些代码存在，用point.add2代替point.add就会出大问题了。</p>\n<p>那么上面的例子是否说明只有纯函数才可以判定等价和可替换呢？</p>\n<p>答案显然不是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不论 foo 是任何函数，不论 foo 的纯度如何， bar 始终和 foo 可替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"comment\">//blablabla....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">...args</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> foo.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>考虑上面的代码，毫无疑问地，不管 foo 内部是个什么鬼，不管它有没有副作用，有不管它没有 bind this，不管它在调用时的 this 是什么，我们都可以无比肯定，十分确定地下结论：bar和foo完全可以相互替换，任意替换 foo 为 bar 或者替换 bar为 foo，系统不会有任何问题（除开一些小小的性能开销，因为bar多了一层调用）。</p>\n<p>到这一步，我们可以给出一个定义：</p>\n<blockquote>\n<p>定义：JavaScript 函数 f 与 g 相等的充分必要条件是 f 与 g 是可替换的。</p>\n</blockquote>\n<p>好了，我们在上面给出了判定两个函数相等的一般性定义，而这个定义和函数本身的纯度无关。</p>\n<p>这个定义有什么意义呢？这个定义的意义就是，既然我们有了判定函数相等的一般性法则，我们就可以唯一确定一个函数了，就像确定数据一样，1是1，2-1，-1+2，0.5*2也都是1，1是唯一的。</p>\n<p>既然我们可以唯一确定一个函数，那么我们就能说如果一个高阶函数的参数确定，返回一组确定的函数，那么这个高阶函数是纯函数。</p>\n<p>使用高阶纯函数</p>\n<p>现在我们该回到前面 setColor 的例子了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//高阶函数multicast是纯函数，它只依赖于不同的参数，返回确定的结果。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multicast</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list,...rest</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(list))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list.map((o) =&gt; fn.apply(<span class=\"keyword\">this</span>,[o,...rest]));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//setColor 不是纯函数，它改变外部环境（DOM）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setColor</span>(<span class=\"params\">el, color</span>)</span>&#123;</span><br><span class=\"line\">  el.style.color = color;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> setColorEls = multicast(setColor);</span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"li:nth-child(2n+1)\"</span>);</span><br><span class=\"line\">setColorEls(<span class=\"built_in\">Array</span>.from(list), <span class=\"string\">\"red\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码有几个好处：</p>\n<ul>\n<li>multicast 是纯函数，它简单灵活，对系统的影响很小。</li>\n<li>multicast 对任意函数返回确定的函数，不影响外部环境和状态。</li>\n<li>setColorEls 在 multicast 保证可靠的情况下，完全依赖于 setColor，如果它出错，只需要检查 setColor 的实现，使得调试变得简单了。</li>\n<li>multicast 是通用的，不管是setColor、setBGColor、setFont还是什么其他的API，都可以用它来统一处理，获得同样的好处。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用函数式编程思想中的高阶函数能够设计出简单可靠的API，这些高阶的API根据确定参数返回确定的函数，它们依然是纯函数，它们拥有纯函数的优点。使用它们对简化系统，提升可扩展性和可维护性都有着非常大的帮助。</p>\n<p>文章里面的例子只是非常简单的小案例，而实际项目中使用高阶函数设计系统能够取得更加不可思议的效果和美妙的开发体验。如果你善于使用这样的技巧，构建小而美却功能强大易于扩展的系统，就不是一件多么难的事情了。</p>\n","excerpt":"","more":"<blockquote>\n<p>这是月影谈函数式编程系列的第2篇文章，上一篇文章讲的是：函数式编程离我们有多远？</p>\n</blockquote>\n<p><strong>纯函数</strong>指的是函数的输出完全有输入所决定，运行过程不宜开与系统的状态和上下文环境，运行过程不改变它作用域之外的环境状态。</p>\n<p>纯函数对<em>设计可靠、稳定、易于调试和易于测试的系统有着非常重要的作用。</em>在Javascript程序设计中有一个基本的原则就是尽可能限制副作用，执行过程尽量不要依赖与环境。这是非常好的原则，纯函数的好处是非常明显的。</p>\n<p>不过，我们有时候也还是要用到非纯函数，显而易见的例子就是，Javascript总是在特定环境中运行的，浏览器中的Javascript不可能不操作DOM，Node.js也不可能永远不操作文件或者数据库，这些都会改变“环境状态”，还有诸如 Array.sort、Math.random、setTimeout、setInterval这些内置的函数也都是非纯的函数。</p>\n<p>纯函数和非纯函数的几个例子：</p>\n<p>//纯函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x,y</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x+ y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//纯函数<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sub</span>(<span class=\"params\">x, y</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> x - y;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，依赖于系统时间<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">now</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> data.now();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，依赖于作用域外的变量<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">inc</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">      <span class=\"keyword\">return</span> ++idx;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，依赖于随机数生成<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">random</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>//非纯函数，操作改变 DOM<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addItem</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">var</span> li = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">\"li\"</span>);</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.body.appendChild(li);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>有一种观点认为，纯函数是函数式编程的一个支柱。由于函数式编程将函数本身也作为数据看来对待，纯函数的返回值只依赖于参数，这看起来对将函数作为数据的“运算”的函数式编程思想是十分重要的。除了以上直接的原因之外，函数式编程思想与纯函数之间究竟还有什么关联？针对纯函数，我们还能应用函数式编程做些什么？</p>\n<h3 id=\"“不纯度”污染\"><a href=\"#“不纯度”污染\" class=\"headerlink\" title=\"“不纯度”污染\"></a>“不纯度”污染</h3><p>纯函数的组合依然是纯函数，然而只要有一个函数不纯，那么调用了它的其他函数也是“不纯的”。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//setColor 不是纯函数，它改变外部环境(DOM)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setColor</span>(<span class=\"params\">el,color</span>)</span>&#123;</span><br><span class=\"line\">    el.style.color = color;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//setColorEls显然也不纯，因为它依赖于setColor</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setColorEls</span>(<span class=\"params\">els,color</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> els.map((el) =&gt; setColor(el,color));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的例子里，我们定义了两个函数，setColor和setColorEls它们都不是纯函数，因为setColorEls依赖了setColor。</p>\n<p>设想一下，如果调试时发现 setColorEls 出错了，我们就要检查 setColorEls 和 setColor 两个函数来确定问题所在。</p>\n<p>上面只是一个简单的例子，如果更加复杂的情况，那么可能一个出错点就需要牵扯出一系列函数，在一大坨代码中寻找问题了 —— 相信很多程序员都遇到过，那绝不是一种愉快的经历。</p>\n<p>有没有办法让 setColorEls 依赖于 setColor， 但同时又能限制造成的纯度污染呢？答案是有的，需要继续往下讨论。</p>\n<h2 id=\"高阶函数的纯度\"><a href=\"#高阶函数的纯度\" class=\"headerlink\" title=\"高阶函数的纯度\"></a>高阶函数的纯度</h2><h3 id=\"函数可替代性与等价关系\"><a href=\"#函数可替代性与等价关系\" class=\"headerlink\" title=\"函数可替代性与等价关系\"></a>函数可替代性与等价关系</h3><p>对于数值来说，我们很容易定义出两个数的等价关系。那么对于两个函数来说，我们如何定义它们的等价关系呢？</p>\n<p>对于“纯函数”来说，判断两个函数等价，只要保证对于任意相同输入，两个函数返回的输出都相同，那么两个函数等价。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//两个纯函数 foo 和 bar 等价</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">arr, obj</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">var</span> ret = arr.slice(<span class=\"number\">0</span>);</span><br><span class=\"line\">  ret.push(obj);    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">arr, obj</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.concat([obj]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数等价意味着可替换，也就是说，我们可以将系统里所有使用到 foo 的地方都用 bar 替换，系统的运行结果不会有任何问题。换句话说，如果确保 foo 没问题，那么将来系统出了问题，也可以直接排除是 bar 引起的问题。</p>\n<p>注意 JavaScript 函数纯度要考虑 this 上下文：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> point = &#123;x:<span class=\"number\">1</span>, y:<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\"><span class=\"comment\">//这个函数其实是不纯的，因为它依赖了 this 上下文</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pointAdd</span>(<span class=\"params\">x, y</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.x + <span class=\"keyword\">this</span>.y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">point.add = pointAdd;</span><br><span class=\"line\">point.add2 = pointAdd.bind(point);</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码，point.add和point.add2不等价，通常情况下的替换不会有问题，但是我们难以保证系统里面没有point.add.call、point.add.apply或者point2 = point.add 之类的代码存在，如果有那些代码存在，用point.add2代替point.add就会出大问题了。</p>\n<p>那么上面的例子是否说明只有纯函数才可以判定等价和可替换呢？</p>\n<p>答案显然不是：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不论 foo 是任何函数，不论 foo 的纯度如何， bar 始终和 foo 可替换</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"comment\">//blablabla....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\">...args</span>)</span>&#123;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> foo.apply(<span class=\"keyword\">this</span>, args);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>考虑上面的代码，毫无疑问地，不管 foo 内部是个什么鬼，不管它有没有副作用，有不管它没有 bind this，不管它在调用时的 this 是什么，我们都可以无比肯定，十分确定地下结论：bar和foo完全可以相互替换，任意替换 foo 为 bar 或者替换 bar为 foo，系统不会有任何问题（除开一些小小的性能开销，因为bar多了一层调用）。</p>\n<p>到这一步，我们可以给出一个定义：</p>\n<blockquote>\n<p>定义：JavaScript 函数 f 与 g 相等的充分必要条件是 f 与 g 是可替换的。</p>\n</blockquote>\n<p>好了，我们在上面给出了判定两个函数相等的一般性定义，而这个定义和函数本身的纯度无关。</p>\n<p>这个定义有什么意义呢？这个定义的意义就是，既然我们有了判定函数相等的一般性法则，我们就可以唯一确定一个函数了，就像确定数据一样，1是1，2-1，-1+2，0.5*2也都是1，1是唯一的。</p>\n<p>既然我们可以唯一确定一个函数，那么我们就能说如果一个高阶函数的参数确定，返回一组确定的函数，那么这个高阶函数是纯函数。</p>\n<p>使用高阶纯函数</p>\n<p>现在我们该回到前面 setColor 的例子了：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//高阶函数multicast是纯函数，它只依赖于不同的参数，返回确定的结果。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">multicast</span>(<span class=\"params\">fn</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list,...rest</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">Array</span>.isArray(list))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list.map((o) =&gt; fn.apply(<span class=\"keyword\">this</span>,[o,...rest]));</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//setColor 不是纯函数，它改变外部环境（DOM）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setColor</span>(<span class=\"params\">el, color</span>)</span>&#123;</span><br><span class=\"line\">  el.style.color = color;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> el;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> setColorEls = multicast(setColor);</span><br><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">\"li:nth-child(2n+1)\"</span>);</span><br><span class=\"line\">setColorEls(<span class=\"built_in\">Array</span>.from(list), <span class=\"string\">\"red\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>上面的代码有几个好处：</p>\n<ul>\n<li>multicast 是纯函数，它简单灵活，对系统的影响很小。</li>\n<li>multicast 对任意函数返回确定的函数，不影响外部环境和状态。</li>\n<li>setColorEls 在 multicast 保证可靠的情况下，完全依赖于 setColor，如果它出错，只需要检查 setColor 的实现，使得调试变得简单了。</li>\n<li>multicast 是通用的，不管是setColor、setBGColor、setFont还是什么其他的API，都可以用它来统一处理，获得同样的好处。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>使用函数式编程思想中的高阶函数能够设计出简单可靠的API，这些高阶的API根据确定参数返回确定的函数，它们依然是纯函数，它们拥有纯函数的优点。使用它们对简化系统，提升可扩展性和可维护性都有着非常大的帮助。</p>\n<p>文章里面的例子只是非常简单的小案例，而实际项目中使用高阶函数设计系统能够取得更加不可思议的效果和美妙的开发体验。如果你善于使用这样的技巧，构建小而美却功能强大易于扩展的系统，就不是一件多么难的事情了。</p>\n"},{"title":"迭代协议","date":"2016-06-27T13:13:55.000Z","_content":"> Success is getting what you want, happiness is wanting what you get.  \n\n作为ECMAScript 2015(ES6)新增加的一部分，它不是新语法或一个新的内置对象，而是一种协议(protocol)。这种协议能被任何遵循某些约定的对象实现。\n\n它们是两类协议：可遍历(可迭代)协议和迭代器协议。\n\n## 可遍历(可迭代)协议  \n**可遍历(可迭代)**协议允许javascript对象去定义或定制它们的迭代行为，例如(定义)在一个for...of结构中什么值可以被循环(得到)。一些内置类型都是内置的可遍历对象并且有默认的迭代行为，比如Array or Map,另一些类型则不是(比如Object)\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\n","source":"_posts/迭代协议.md","raw":"---\ntitle: 迭代协议\ndate: 2016-06-27 21:13:55\ntags:\n- javascript\n- protocol\ncategories: 笔记\n---\n> Success is getting what you want, happiness is wanting what you get.  \n\n作为ECMAScript 2015(ES6)新增加的一部分，它不是新语法或一个新的内置对象，而是一种协议(protocol)。这种协议能被任何遵循某些约定的对象实现。\n\n它们是两类协议：可遍历(可迭代)协议和迭代器协议。\n\n## 可遍历(可迭代)协议  \n**可遍历(可迭代)**协议允许javascript对象去定义或定制它们的迭代行为，例如(定义)在一个for...of结构中什么值可以被循环(得到)。一些内置类型都是内置的可遍历对象并且有默认的迭代行为，比如Array or Map,另一些类型则不是(比如Object)\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\n","slug":"迭代协议","published":1,"updated":"2016-07-08T03:17:22.891Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0eo5002rb0dldnek7jzg","content":"<blockquote>\n<p>Success is getting what you want, happiness is wanting what you get.  </p>\n</blockquote>\n<p>作为ECMAScript 2015(ES6)新增加的一部分，它不是新语法或一个新的内置对象，而是一种协议(protocol)。这种协议能被任何遵循某些约定的对象实现。</p>\n<p>它们是两类协议：可遍历(可迭代)协议和迭代器协议。</p>\n<h2 id=\"可遍历-可迭代-协议\"><a href=\"#可遍历-可迭代-协议\" class=\"headerlink\" title=\"可遍历(可迭代)协议\"></a>可遍历(可迭代)协议</h2><p><strong>可遍历(可迭代)</strong>协议允许javascript对象去定义或定制它们的迭代行为，例如(定义)在一个for…of结构中什么值可以被循环(得到)。一些内置类型都是内置的可遍历对象并且有默认的迭代行为，比如Array or Map,另一些类型则不是(比如Object)</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></p>\n","excerpt":"","more":"<blockquote>\n<p>Success is getting what you want, happiness is wanting what you get.  </p>\n</blockquote>\n<p>作为ECMAScript 2015(ES6)新增加的一部分，它不是新语法或一个新的内置对象，而是一种协议(protocol)。这种协议能被任何遵循某些约定的对象实现。</p>\n<p>它们是两类协议：可遍历(可迭代)协议和迭代器协议。</p>\n<h2 id=\"可遍历-可迭代-协议\"><a href=\"#可遍历-可迭代-协议\" class=\"headerlink\" title=\"可遍历(可迭代)协议\"></a>可遍历(可迭代)协议</h2><p><strong>可遍历(可迭代)</strong>协议允许javascript对象去定义或定制它们的迭代行为，例如(定义)在一个for…of结构中什么值可以被循环(得到)。一些内置类型都是内置的可遍历对象并且有默认的迭代行为，比如Array or Map,另一些类型则不是(比如Object)</p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols</a></p>\n"},{"title":"在Javascript中实现函数式编程的技术","date":"2016-05-19T07:03:40.000Z","_content":"\n这章我们继续下面的内容：\n- 把所有的核心概念放到一个集中的范式里\n- 探索函数式编程之美\n- 一步步跟踪函数式模式相互交织的逻辑\n- 我们将贯穿整章建立一个简单的应用做一些很酷的事情\n\n你可能已经注意到，在上一章我们介绍Javascript的函数式库的时候引入了一些概念， 而不是在第二章《函数式编程基础》里。呃，这是有原因的！组合、柯里化、不全调用...... 让我们来探索这些库为何以及如何实现这些概念。\n\n函数式编程可以出现各种各样的模式，这章会覆盖很多不同风格的函数式编程：\n- 数据泛型编程\n- 基本上函数式的编程\n- 函数式响应式编程等\n\n然而这章将会避免偏向于任何风格。我们不会花费很大精力学完一个函数式编程风格再学另一个， 总的目标是展示写代码更好的方式，而不是被动接受唯一一个正确的选择。 如果你先人一步感觉到了什么是好的写代码的方法而什么不是，你就可以作任何想做的事情了。 当你像个孩子那样仅凭喜好放纵地写代码时，当你不关心如何去循规蹈矩的做事时，无限的可能就出现了。\n\n## 部分函数应用和珂理化\n> 许多语言支持可选参数，但是javascript不支持。javascript采用一种完全不同的模式，它允许任意数量的参数传给函数。这就是一些有趣且非同寻常的设计模式留下了门路。函数可以全部或部分应用。\n\n部分应用在javascript中的处理方式是：给函数一个或多个参数绑定上值，然后返回另一个函数接受剩余的未绑定参数。同样，珂理化的处理方式是把一个有多个参数的函数转换为一个只接受一个参数的函数，它返回的函数接受剩余的参数。\n\n这两者的差异现在看起来不是很明显，但最后会清楚的。\n\n## 函数操作\n在我们进一步解释如何实现部分应用和珂理化之前，我们需要进行一些回顾。如果我们想要扒掉javascript厚重的C风格语法外衣，暴露器函数是本质的话，我们需要理解原始函数、原型在javascript是如何工作的；而如果我们只是想设置一些cookie或验证一些表单的话则永远不用考虑这些。\n\n## apply、call和this关键词\n在纯函数式语言中，函数不会被唤起(invoke)，他们是被应用(apply)。javascript以同样的方式工作，甚至提供了手动调用(call)和应用(apply)函数的工具。这些都是与this关键词有关的，当然this指的是函数所属的那个对象。\n\ncall()函数把第一个参数作为this关键字。它是这样工作的：\n\n```javascript\n    console.log(['Hello','world'].join(' ')); //正常方式\n    console.log(Array.prototype.join.call(['Hello','world'],' ')); //使用call\n```\n\ncall()函数可以唤起匿名函数：\n\n```javascript\n    console.log((function(){console.log(this.length)}).call([1,2,3]));\n```\n\napply()函数和call()函数很像，但是更有用一些：\n\n```javascript\n   console.log(Math.max(1,2,3)); // 返回3\n   console.log(Math.max([1,2,3])); // 无法应用于数组\n   console.log(Math.max.apply(null, [1,2,3])); // 这样就可以了\n```\n\n基本的区别是：call()函数接受一列参数，apply函数接受一个数组作为参数。\n\ncall()和apply()让你可以只写一次函数，其它对象可以继承它而无需再写一遍函数。 并且他俩都是Function对象的成员。\n```javascript\n  //当你对call()自己调用call()的时候，会发生有趣的事情。\n  //这两行代码是等价的\n  func.call(thisValue);\n  Function.prototype.call.call(func,thisValue);\n```\n\n## 绑定函数\nbind()函数让你能够调用一个对象的函数时this指向另一个对象。这跟call()函数差不多，不过他可以让方法链式调用，返回一个新的函数。\n\n这对于回调非常有用，就像下面的代码那样：\n\n```javascript\n   function Drum() {\n     this.noise = 'boom';\n     this.duration = 1000;\n     this.goBoom = function() {\n       console.log(this.noise)\n     };\n   }\n   var drum = new Drum();\n   setInterval(drum.goBoom.bind(drum), drum.duration);\n```\n\n这解决了许多面向对象框架中的问题，比如Dojo，特别是对于那些有自己的handler函数的类处理状态维持的问题。 不过我们也可以用bind()来进行函数式编程。\n\n`bind()函数实际上自己实现了部分应用，尽管是通过一种很有限的方式。`\n\n## 函数工厂\n> 还记得第二章《函数式编程基础》中关于闭包的那节吗？闭包使建立函数工厂这种Javascript编程模式成为可能。 它们使你能够手动绑定函数的参数。\n\n首先我们需要一个为另一个函数绑定参数的函数：\n\n```javascript\n    function bindFirstArg(func,a){\n        return function(b){\n            return func(a,b);\n        }\n    }\n```\n\n现在我们可以用它来创建更多的泛型函数(generic function)\n\n```javascript\n    var powersOfTwo = bindFirstArg(Math.pow, 2);\n    console.log(powersOfTwo(3)); // 8\n    console.log(powersOfTwo(5)); // 32\n```\n\n也可以针对于其它参数：\n\n```javascript\n   function bindSecondArg(func, b) {\n     return function(a) {\n       return func(a, b);\n     };\n   }\n   var squareOf = bindSecondArg(Math.pow, 2);\n   var cubeOf = bindSecondArg(Math.pow, 3);\n   console.log(squareOf(3)); // 9\n   console.log(squareOf(4)); // 16\n   console.log(cubeOf(3)); // 27\n   console.log(cubeOf(4)); // 64\n```\n\n在函数式编程中，创建泛型函数的能力十分重要。然而还有更巧妙的方式可以更加一般化的完成这一过程。bindFirstArg()函数接受两个参数，第一个参数是这个函数。如果我们把bindFirstArg本身作为第一个参数的函数传给它自己，我们就可以创建绑定函数。最好用下面的例子来描述：\n\n```javascript\n    var makePowersOf = bindFirstArg(bindFirstArg, Math.pow);\n    var powersOfThree = makePowersOf(3);\n    console.log(powersOfThree(2)); // 9\n    console.log(powersOfThree(3)); // 27\n```\n\n这就是为什么它被叫做函数工厂。\n\n## 部分应用\n注意我们函数工厂的例子里bindFirstArg()和bindSecondArg()函数只能有两个参数。我们可以写新的不同数量参数的函数，但是这就违背我们一般化的模型了。\n\n我们需要部分应用\n\n部分应用是这样一个过程：它给函数的一个或多个参数绑定上值，返回一个已经部分应用过的函数，这个函数仍然需要接收未绑定的参数。\n\n与bind()函数等Function对象內建的方法不同，我们需要创建自己的函数来实现部分调用和柯里化。主要有两种方式：\n- 作为一个单独的函数，也就是，var partial = function(func){...}\n- 作为补充，也就是，Function.prototype.partial = function(func){...}\n\n补充的方式视为原型增加新的函数，这会允许我们在为想要部分应用的函数调用我们的新函数的时候作为它的一个方法。就像这样：myfunction.partial(arg1,arg2,...)；\n\n### 左端部分应用\n这里Javascript的call()和apply()函数将对我们很有用。我们看看补充Function对象的方式：\n\n```javascript\n  Function.prototype.partialApply = function(){\n    var func = this;\n    args = Array.prototype.slice.call(arguments);\n    return function(){\n      func.apply(this,args.concat(\n        Array.prototype.slice.call(arguments)\n      ))\n    }\n  }\n```\n\n如你所见，它的工作方式是对arguments这个特殊的值调用slice\n\n```\n  每个函数又有一个特殊的内部变量叫做arguments,它是一个类似于数组的对象，包含传入函数的全部参数。从技术层面说，她不是数组，因此他没有slice和forEach这些数组的方法。这儿就是为什么我们需要使用Array的slice.call方法。\n```\n\n现在我们通过一个例子看看如何使用它。这次我们不做数学题，来搞点有用的东西。 我们来建立一个把数字转换为16进制的小应用。\n\n```javascript\n  function nums2hex(){\n    function componentToHex(component){\n      var hex = component.toString(16);\n      //确保返回的数值是两位数字，比如0c或12\n      if(hex.length == 1){\n        return \"0\" + hex;\n      }else{\n        return hex;\n      }\n    }\n    return Array.prototype.map.call(arguments,componentToHex).join('');\n  }\n  //这个函数对多少个数字有效\n  console.log(nums2hex()); // ''\nconsole.log(nums2hex(100, 200)); // '64c8'\nconsole.log(nums2hex(100, 200, 255, 0, 123)); // '64c8ff007b'\n// 不过我们可以用部分函数来对部分参数进行应用，比如mac地址的OUI\n// ( OUI，“组织唯一标识符”，即网卡制造商的唯一标识符。)\nvar myOUI = 123;\nvar getMacAddress = nums2hex.partialApply(myOUI);\nconsole.log(getMacAddress()); // '7b'\nconsole.log(getMacAddress(100, 200, 2, 123, 66, 0, 1));\n// '7b64c8027b420001'\n// 我们还可以转换全红基础上的颜色rgb十六进制值\nvar shadesOfRed = nums2hex.partialApply(255);\nconsole.log(shadesOfRed(123, 0)); // 'ff7b00'\nconsole.log(shadesOfRed(100, 200)); // 'ff64c8'\n```\n\n这个例子展示出了我们可以应用部分参数而生成一个新的函数。它是左-右的，意思是我们只能部分应用从左边开始的若干参数。\n\n### 右部分应用\n为了从右边开始应用参数，我们可以再定义一个补充函数。\n\n```javascript\nFunction.prototype.partialApplyRight = function() {\nvar func = this;\nargs = Array.prototype.slice.call(arguments);\nreturn function() {\n  return func.apply(\n    this, [].slice.call(arguments, 0)\n    .concat(args));\n};\n};\nvar shadesOfBlue = nums2hex.partialApplyRight(255);\nconsole.log(shadesOfBlue(123, 0));   // '7b00ff'\nconsole.log(shadesOfBlue(100, 200)); // '64c8ff'\nvar someShadesOfGreen = nums2hex.partialApplyRight(255, 0);\nconsole.log(shadesOfGreen(123));   // '7bff00'\nconsole.log(shadesOfGreen(100));   // '64ff00'\n```\n\n部分应用使我们能够创建非常一般化的函数，并从它提取出更多特殊化的函数。 但是这个方法最大的缺点在于参数传入的方式，也就是参数有多少个，是什么样的顺序，这些不太明确。 不明确性在编程中永远不是个好事儿。还有个更好的方式：珂理化。\n\n## 柯里化(currying)\n柯里化是这样一个过程：他把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数剩余的参数。这是的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每个函数只有一个参数。\n\n一个普遍的问题是：部分应用和柯里化的区别是什么？实际就是部分应用立刻返回一个值，而柯里化只返回另一个柯里化的函数来获取下一个参数，本质的区别是柯里化可以更好的控制参数传入的方式。\n\n这里我们再为Function的原型补充一个柯里化的方法：\n\n```javascript\n  Function.prototype.curry = function(numArgs){\n    var func = this;\n    numArgs = numArgs || func.length; //func.length是调用此方法的函数的形参个数\n    //递归地获取参数\n    function subCurry(prev){\n      return function(arg){\n        if(args.length < numArgs){\n          //递归情形：仍需要更多的参数\n          return subCurry(args);\n        }else{\n          //基准情形：执行函数\n          return func.apply(this,args);\n        }\n      }\n    }\n    return subCurry([]);\n  }\n```\n\nnumArgs参数让我们可以在被珂理化的函数没有给出确切参数的时候指定参数的个数。\n\n来看看用它如何处理我们的十六进制应用。我们先写个函数，它会把RGB值转化为适合HTML的16进制字符串。\n```javascript\n  function rgb2hex(r,g,b){\n    return '#' + nums2hex(r) + nums2hex(g) + nums2hex(b);\n  }\n  var hexColors = rgb2hex.curry();\n  console.log(hexColors(11)) // 返回一个珂理化的函数\n  console.log(hexColors(11, 12, 123)) // 返回一个珂理化的函数\n  console.log(hexColors(11)(12)(123)) // 返回 #0b0c7b\n  console.log(hexColors(210)(12)(0)) // 返回 #d20c00\n```\n\n> 注意，curry方法返回的函数只接受一个参数，所以上例倒数第三行传入的三个参数的后两个是没用的。\n\n这样使用柯里化不错。但是如果我们相对nums2hex()这个函数进行柯里化就会有点问题，因为这个函数没有指定参数，你可以传入任意数量的参数。所以我们需要定义参数的个数。我们curry函数的那个可选的参数来设置被柯里化函数的参数个数。\n```javascript\n  var hexs = nums2hex.curry(2);\n  console.log(hexs(11)(12));     // 返回 0b0c\n  console.log(hexs(11));         // 返回一个函数\n  console.log(hexs(110)(12)(0)); // 不正确\n```\n所以柯里化不太适合可变参数的函数，对于这种情况，建议使用部分应用函数。\n所有这些不只是利用函数工厂和代码重用，柯里化和部分应用在函数组合中扮演着更重要的角色。\n","source":"_posts/在Javascript中实现函数式编程的技术0.md","raw":"---\ntitle: 在Javascript中实现函数式编程的技术\ndate: 2016-05-19T15:03:40.000Z\ntags:\n  - javascript\n  - 函数式编程\ncategories: 转载笔记\n---\n\n这章我们继续下面的内容：\n- 把所有的核心概念放到一个集中的范式里\n- 探索函数式编程之美\n- 一步步跟踪函数式模式相互交织的逻辑\n- 我们将贯穿整章建立一个简单的应用做一些很酷的事情\n\n你可能已经注意到，在上一章我们介绍Javascript的函数式库的时候引入了一些概念， 而不是在第二章《函数式编程基础》里。呃，这是有原因的！组合、柯里化、不全调用...... 让我们来探索这些库为何以及如何实现这些概念。\n\n函数式编程可以出现各种各样的模式，这章会覆盖很多不同风格的函数式编程：\n- 数据泛型编程\n- 基本上函数式的编程\n- 函数式响应式编程等\n\n然而这章将会避免偏向于任何风格。我们不会花费很大精力学完一个函数式编程风格再学另一个， 总的目标是展示写代码更好的方式，而不是被动接受唯一一个正确的选择。 如果你先人一步感觉到了什么是好的写代码的方法而什么不是，你就可以作任何想做的事情了。 当你像个孩子那样仅凭喜好放纵地写代码时，当你不关心如何去循规蹈矩的做事时，无限的可能就出现了。\n\n## 部分函数应用和珂理化\n> 许多语言支持可选参数，但是javascript不支持。javascript采用一种完全不同的模式，它允许任意数量的参数传给函数。这就是一些有趣且非同寻常的设计模式留下了门路。函数可以全部或部分应用。\n\n部分应用在javascript中的处理方式是：给函数一个或多个参数绑定上值，然后返回另一个函数接受剩余的未绑定参数。同样，珂理化的处理方式是把一个有多个参数的函数转换为一个只接受一个参数的函数，它返回的函数接受剩余的参数。\n\n这两者的差异现在看起来不是很明显，但最后会清楚的。\n\n## 函数操作\n在我们进一步解释如何实现部分应用和珂理化之前，我们需要进行一些回顾。如果我们想要扒掉javascript厚重的C风格语法外衣，暴露器函数是本质的话，我们需要理解原始函数、原型在javascript是如何工作的；而如果我们只是想设置一些cookie或验证一些表单的话则永远不用考虑这些。\n\n## apply、call和this关键词\n在纯函数式语言中，函数不会被唤起(invoke)，他们是被应用(apply)。javascript以同样的方式工作，甚至提供了手动调用(call)和应用(apply)函数的工具。这些都是与this关键词有关的，当然this指的是函数所属的那个对象。\n\ncall()函数把第一个参数作为this关键字。它是这样工作的：\n\n```javascript\n    console.log(['Hello','world'].join(' ')); //正常方式\n    console.log(Array.prototype.join.call(['Hello','world'],' ')); //使用call\n```\n\ncall()函数可以唤起匿名函数：\n\n```javascript\n    console.log((function(){console.log(this.length)}).call([1,2,3]));\n```\n\napply()函数和call()函数很像，但是更有用一些：\n\n```javascript\n   console.log(Math.max(1,2,3)); // 返回3\n   console.log(Math.max([1,2,3])); // 无法应用于数组\n   console.log(Math.max.apply(null, [1,2,3])); // 这样就可以了\n```\n\n基本的区别是：call()函数接受一列参数，apply函数接受一个数组作为参数。\n\ncall()和apply()让你可以只写一次函数，其它对象可以继承它而无需再写一遍函数。 并且他俩都是Function对象的成员。\n```javascript\n  //当你对call()自己调用call()的时候，会发生有趣的事情。\n  //这两行代码是等价的\n  func.call(thisValue);\n  Function.prototype.call.call(func,thisValue);\n```\n\n## 绑定函数\nbind()函数让你能够调用一个对象的函数时this指向另一个对象。这跟call()函数差不多，不过他可以让方法链式调用，返回一个新的函数。\n\n这对于回调非常有用，就像下面的代码那样：\n\n```javascript\n   function Drum() {\n     this.noise = 'boom';\n     this.duration = 1000;\n     this.goBoom = function() {\n       console.log(this.noise)\n     };\n   }\n   var drum = new Drum();\n   setInterval(drum.goBoom.bind(drum), drum.duration);\n```\n\n这解决了许多面向对象框架中的问题，比如Dojo，特别是对于那些有自己的handler函数的类处理状态维持的问题。 不过我们也可以用bind()来进行函数式编程。\n\n`bind()函数实际上自己实现了部分应用，尽管是通过一种很有限的方式。`\n\n## 函数工厂\n> 还记得第二章《函数式编程基础》中关于闭包的那节吗？闭包使建立函数工厂这种Javascript编程模式成为可能。 它们使你能够手动绑定函数的参数。\n\n首先我们需要一个为另一个函数绑定参数的函数：\n\n```javascript\n    function bindFirstArg(func,a){\n        return function(b){\n            return func(a,b);\n        }\n    }\n```\n\n现在我们可以用它来创建更多的泛型函数(generic function)\n\n```javascript\n    var powersOfTwo = bindFirstArg(Math.pow, 2);\n    console.log(powersOfTwo(3)); // 8\n    console.log(powersOfTwo(5)); // 32\n```\n\n也可以针对于其它参数：\n\n```javascript\n   function bindSecondArg(func, b) {\n     return function(a) {\n       return func(a, b);\n     };\n   }\n   var squareOf = bindSecondArg(Math.pow, 2);\n   var cubeOf = bindSecondArg(Math.pow, 3);\n   console.log(squareOf(3)); // 9\n   console.log(squareOf(4)); // 16\n   console.log(cubeOf(3)); // 27\n   console.log(cubeOf(4)); // 64\n```\n\n在函数式编程中，创建泛型函数的能力十分重要。然而还有更巧妙的方式可以更加一般化的完成这一过程。bindFirstArg()函数接受两个参数，第一个参数是这个函数。如果我们把bindFirstArg本身作为第一个参数的函数传给它自己，我们就可以创建绑定函数。最好用下面的例子来描述：\n\n```javascript\n    var makePowersOf = bindFirstArg(bindFirstArg, Math.pow);\n    var powersOfThree = makePowersOf(3);\n    console.log(powersOfThree(2)); // 9\n    console.log(powersOfThree(3)); // 27\n```\n\n这就是为什么它被叫做函数工厂。\n\n## 部分应用\n注意我们函数工厂的例子里bindFirstArg()和bindSecondArg()函数只能有两个参数。我们可以写新的不同数量参数的函数，但是这就违背我们一般化的模型了。\n\n我们需要部分应用\n\n部分应用是这样一个过程：它给函数的一个或多个参数绑定上值，返回一个已经部分应用过的函数，这个函数仍然需要接收未绑定的参数。\n\n与bind()函数等Function对象內建的方法不同，我们需要创建自己的函数来实现部分调用和柯里化。主要有两种方式：\n- 作为一个单独的函数，也就是，var partial = function(func){...}\n- 作为补充，也就是，Function.prototype.partial = function(func){...}\n\n补充的方式视为原型增加新的函数，这会允许我们在为想要部分应用的函数调用我们的新函数的时候作为它的一个方法。就像这样：myfunction.partial(arg1,arg2,...)；\n\n### 左端部分应用\n这里Javascript的call()和apply()函数将对我们很有用。我们看看补充Function对象的方式：\n\n```javascript\n  Function.prototype.partialApply = function(){\n    var func = this;\n    args = Array.prototype.slice.call(arguments);\n    return function(){\n      func.apply(this,args.concat(\n        Array.prototype.slice.call(arguments)\n      ))\n    }\n  }\n```\n\n如你所见，它的工作方式是对arguments这个特殊的值调用slice\n\n```\n  每个函数又有一个特殊的内部变量叫做arguments,它是一个类似于数组的对象，包含传入函数的全部参数。从技术层面说，她不是数组，因此他没有slice和forEach这些数组的方法。这儿就是为什么我们需要使用Array的slice.call方法。\n```\n\n现在我们通过一个例子看看如何使用它。这次我们不做数学题，来搞点有用的东西。 我们来建立一个把数字转换为16进制的小应用。\n\n```javascript\n  function nums2hex(){\n    function componentToHex(component){\n      var hex = component.toString(16);\n      //确保返回的数值是两位数字，比如0c或12\n      if(hex.length == 1){\n        return \"0\" + hex;\n      }else{\n        return hex;\n      }\n    }\n    return Array.prototype.map.call(arguments,componentToHex).join('');\n  }\n  //这个函数对多少个数字有效\n  console.log(nums2hex()); // ''\nconsole.log(nums2hex(100, 200)); // '64c8'\nconsole.log(nums2hex(100, 200, 255, 0, 123)); // '64c8ff007b'\n// 不过我们可以用部分函数来对部分参数进行应用，比如mac地址的OUI\n// ( OUI，“组织唯一标识符”，即网卡制造商的唯一标识符。)\nvar myOUI = 123;\nvar getMacAddress = nums2hex.partialApply(myOUI);\nconsole.log(getMacAddress()); // '7b'\nconsole.log(getMacAddress(100, 200, 2, 123, 66, 0, 1));\n// '7b64c8027b420001'\n// 我们还可以转换全红基础上的颜色rgb十六进制值\nvar shadesOfRed = nums2hex.partialApply(255);\nconsole.log(shadesOfRed(123, 0)); // 'ff7b00'\nconsole.log(shadesOfRed(100, 200)); // 'ff64c8'\n```\n\n这个例子展示出了我们可以应用部分参数而生成一个新的函数。它是左-右的，意思是我们只能部分应用从左边开始的若干参数。\n\n### 右部分应用\n为了从右边开始应用参数，我们可以再定义一个补充函数。\n\n```javascript\nFunction.prototype.partialApplyRight = function() {\nvar func = this;\nargs = Array.prototype.slice.call(arguments);\nreturn function() {\n  return func.apply(\n    this, [].slice.call(arguments, 0)\n    .concat(args));\n};\n};\nvar shadesOfBlue = nums2hex.partialApplyRight(255);\nconsole.log(shadesOfBlue(123, 0));   // '7b00ff'\nconsole.log(shadesOfBlue(100, 200)); // '64c8ff'\nvar someShadesOfGreen = nums2hex.partialApplyRight(255, 0);\nconsole.log(shadesOfGreen(123));   // '7bff00'\nconsole.log(shadesOfGreen(100));   // '64ff00'\n```\n\n部分应用使我们能够创建非常一般化的函数，并从它提取出更多特殊化的函数。 但是这个方法最大的缺点在于参数传入的方式，也就是参数有多少个，是什么样的顺序，这些不太明确。 不明确性在编程中永远不是个好事儿。还有个更好的方式：珂理化。\n\n## 柯里化(currying)\n柯里化是这样一个过程：他把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数剩余的参数。这是的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每个函数只有一个参数。\n\n一个普遍的问题是：部分应用和柯里化的区别是什么？实际就是部分应用立刻返回一个值，而柯里化只返回另一个柯里化的函数来获取下一个参数，本质的区别是柯里化可以更好的控制参数传入的方式。\n\n这里我们再为Function的原型补充一个柯里化的方法：\n\n```javascript\n  Function.prototype.curry = function(numArgs){\n    var func = this;\n    numArgs = numArgs || func.length; //func.length是调用此方法的函数的形参个数\n    //递归地获取参数\n    function subCurry(prev){\n      return function(arg){\n        if(args.length < numArgs){\n          //递归情形：仍需要更多的参数\n          return subCurry(args);\n        }else{\n          //基准情形：执行函数\n          return func.apply(this,args);\n        }\n      }\n    }\n    return subCurry([]);\n  }\n```\n\nnumArgs参数让我们可以在被珂理化的函数没有给出确切参数的时候指定参数的个数。\n\n来看看用它如何处理我们的十六进制应用。我们先写个函数，它会把RGB值转化为适合HTML的16进制字符串。\n```javascript\n  function rgb2hex(r,g,b){\n    return '#' + nums2hex(r) + nums2hex(g) + nums2hex(b);\n  }\n  var hexColors = rgb2hex.curry();\n  console.log(hexColors(11)) // 返回一个珂理化的函数\n  console.log(hexColors(11, 12, 123)) // 返回一个珂理化的函数\n  console.log(hexColors(11)(12)(123)) // 返回 #0b0c7b\n  console.log(hexColors(210)(12)(0)) // 返回 #d20c00\n```\n\n> 注意，curry方法返回的函数只接受一个参数，所以上例倒数第三行传入的三个参数的后两个是没用的。\n\n这样使用柯里化不错。但是如果我们相对nums2hex()这个函数进行柯里化就会有点问题，因为这个函数没有指定参数，你可以传入任意数量的参数。所以我们需要定义参数的个数。我们curry函数的那个可选的参数来设置被柯里化函数的参数个数。\n```javascript\n  var hexs = nums2hex.curry(2);\n  console.log(hexs(11)(12));     // 返回 0b0c\n  console.log(hexs(11));         // 返回一个函数\n  console.log(hexs(110)(12)(0)); // 不正确\n```\n所以柯里化不太适合可变参数的函数，对于这种情况，建议使用部分应用函数。\n所有这些不只是利用函数工厂和代码重用，柯里化和部分应用在函数组合中扮演着更重要的角色。\n","slug":"在Javascript中实现函数式编程的技术0","published":1,"updated":"2016-07-11T02:06:25.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0eo7002vb0dlj5s4a4hi","content":"<p>这章我们继续下面的内容：</p>\n<ul>\n<li>把所有的核心概念放到一个集中的范式里</li>\n<li>探索函数式编程之美</li>\n<li>一步步跟踪函数式模式相互交织的逻辑</li>\n<li>我们将贯穿整章建立一个简单的应用做一些很酷的事情</li>\n</ul>\n<p>你可能已经注意到，在上一章我们介绍Javascript的函数式库的时候引入了一些概念， 而不是在第二章《函数式编程基础》里。呃，这是有原因的！组合、柯里化、不全调用…… 让我们来探索这些库为何以及如何实现这些概念。</p>\n<p>函数式编程可以出现各种各样的模式，这章会覆盖很多不同风格的函数式编程：</p>\n<ul>\n<li>数据泛型编程</li>\n<li>基本上函数式的编程</li>\n<li>函数式响应式编程等</li>\n</ul>\n<p>然而这章将会避免偏向于任何风格。我们不会花费很大精力学完一个函数式编程风格再学另一个， 总的目标是展示写代码更好的方式，而不是被动接受唯一一个正确的选择。 如果你先人一步感觉到了什么是好的写代码的方法而什么不是，你就可以作任何想做的事情了。 当你像个孩子那样仅凭喜好放纵地写代码时，当你不关心如何去循规蹈矩的做事时，无限的可能就出现了。</p>\n<h2 id=\"部分函数应用和珂理化\"><a href=\"#部分函数应用和珂理化\" class=\"headerlink\" title=\"部分函数应用和珂理化\"></a>部分函数应用和珂理化</h2><blockquote>\n<p>许多语言支持可选参数，但是javascript不支持。javascript采用一种完全不同的模式，它允许任意数量的参数传给函数。这就是一些有趣且非同寻常的设计模式留下了门路。函数可以全部或部分应用。</p>\n</blockquote>\n<p>部分应用在javascript中的处理方式是：给函数一个或多个参数绑定上值，然后返回另一个函数接受剩余的未绑定参数。同样，珂理化的处理方式是把一个有多个参数的函数转换为一个只接受一个参数的函数，它返回的函数接受剩余的参数。</p>\n<p>这两者的差异现在看起来不是很明显，但最后会清楚的。</p>\n<h2 id=\"函数操作\"><a href=\"#函数操作\" class=\"headerlink\" title=\"函数操作\"></a>函数操作</h2><p>在我们进一步解释如何实现部分应用和珂理化之前，我们需要进行一些回顾。如果我们想要扒掉javascript厚重的C风格语法外衣，暴露器函数是本质的话，我们需要理解原始函数、原型在javascript是如何工作的；而如果我们只是想设置一些cookie或验证一些表单的话则永远不用考虑这些。</p>\n<h2 id=\"apply、call和this关键词\"><a href=\"#apply、call和this关键词\" class=\"headerlink\" title=\"apply、call和this关键词\"></a>apply、call和this关键词</h2><p>在纯函数式语言中，函数不会被唤起(invoke)，他们是被应用(apply)。javascript以同样的方式工作，甚至提供了手动调用(call)和应用(apply)函数的工具。这些都是与this关键词有关的，当然this指的是函数所属的那个对象。</p>\n<p>call()函数把第一个参数作为this关键字。它是这样工作的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"string\">'Hello'</span>,<span class=\"string\">'world'</span>].join(<span class=\"string\">' '</span>)); <span class=\"comment\">//正常方式</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.join.call([<span class=\"string\">'Hello'</span>,<span class=\"string\">'world'</span>],<span class=\"string\">' '</span>)); <span class=\"comment\">//使用call</span></span><br></pre></td></tr></table></figure>\n<p>call()函数可以唤起匿名函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length)&#125;).call([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]));</span><br></pre></td></tr></table></figure>\n<p>apply()函数和call()函数很像，但是更有用一些：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.max(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)); <span class=\"comment\">// 返回3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.max([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])); <span class=\"comment\">// 无法应用于数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])); <span class=\"comment\">// 这样就可以了</span></span><br></pre></td></tr></table></figure>\n<p>基本的区别是：call()函数接受一列参数，apply函数接受一个数组作为参数。</p>\n<p>call()和apply()让你可以只写一次函数，其它对象可以继承它而无需再写一遍函数。 并且他俩都是Function对象的成员。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当你对call()自己调用call()的时候，会发生有趣的事情。</span></span><br><span class=\"line\"><span class=\"comment\">//这两行代码是等价的</span></span><br><span class=\"line\">func.call(thisValue);</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call.call(func,thisValue);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"绑定函数\"><a href=\"#绑定函数\" class=\"headerlink\" title=\"绑定函数\"></a>绑定函数</h2><p>bind()函数让你能够调用一个对象的函数时this指向另一个对象。这跟call()函数差不多，不过他可以让方法链式调用，返回一个新的函数。</p>\n<p>这对于回调非常有用，就像下面的代码那样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Drum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.noise = <span class=\"string\">'boom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.duration = <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.goBoom = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.noise)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> drum = <span class=\"keyword\">new</span> Drum();</span><br><span class=\"line\">setInterval(drum.goBoom.bind(drum), drum.duration);</span><br></pre></td></tr></table></figure>\n<p>这解决了许多面向对象框架中的问题，比如Dojo，特别是对于那些有自己的handler函数的类处理状态维持的问题。 不过我们也可以用bind()来进行函数式编程。</p>\n<p><code>bind()函数实际上自己实现了部分应用，尽管是通过一种很有限的方式。</code></p>\n<h2 id=\"函数工厂\"><a href=\"#函数工厂\" class=\"headerlink\" title=\"函数工厂\"></a>函数工厂</h2><blockquote>\n<p>还记得第二章《函数式编程基础》中关于闭包的那节吗？闭包使建立函数工厂这种Javascript编程模式成为可能。 它们使你能够手动绑定函数的参数。</p>\n</blockquote>\n<p>首先我们需要一个为另一个函数绑定参数的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindFirstArg</span>(<span class=\"params\">func,a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以用它来创建更多的泛型函数(generic function)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> powersOfTwo = bindFirstArg(<span class=\"built_in\">Math</span>.pow, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfTwo(<span class=\"number\">3</span>)); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfTwo(<span class=\"number\">5</span>)); <span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n<p>也可以针对于其它参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindSecondArg</span>(<span class=\"params\">func, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(a, b);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> squareOf = bindSecondArg(<span class=\"built_in\">Math</span>.pow, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cubeOf = bindSecondArg(<span class=\"built_in\">Math</span>.pow, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(squareOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(squareOf(<span class=\"number\">4</span>)); <span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cubeOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 27</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cubeOf(<span class=\"number\">4</span>)); <span class=\"comment\">// 64</span></span><br></pre></td></tr></table></figure>\n<p>在函数式编程中，创建泛型函数的能力十分重要。然而还有更巧妙的方式可以更加一般化的完成这一过程。bindFirstArg()函数接受两个参数，第一个参数是这个函数。如果我们把bindFirstArg本身作为第一个参数的函数传给它自己，我们就可以创建绑定函数。最好用下面的例子来描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> makePowersOf = bindFirstArg(bindFirstArg, <span class=\"built_in\">Math</span>.pow);</span><br><span class=\"line\"><span class=\"keyword\">var</span> powersOfThree = makePowersOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfThree(<span class=\"number\">2</span>)); <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfThree(<span class=\"number\">3</span>)); <span class=\"comment\">// 27</span></span><br></pre></td></tr></table></figure>\n<p>这就是为什么它被叫做函数工厂。</p>\n<h2 id=\"部分应用\"><a href=\"#部分应用\" class=\"headerlink\" title=\"部分应用\"></a>部分应用</h2><p>注意我们函数工厂的例子里bindFirstArg()和bindSecondArg()函数只能有两个参数。我们可以写新的不同数量参数的函数，但是这就违背我们一般化的模型了。</p>\n<p>我们需要部分应用</p>\n<p>部分应用是这样一个过程：它给函数的一个或多个参数绑定上值，返回一个已经部分应用过的函数，这个函数仍然需要接收未绑定的参数。</p>\n<p>与bind()函数等Function对象內建的方法不同，我们需要创建自己的函数来实现部分调用和柯里化。主要有两种方式：</p>\n<ul>\n<li>作为一个单独的函数，也就是，var partial = function(func){…}</li>\n<li>作为补充，也就是，Function.prototype.partial = function(func){…}</li>\n</ul>\n<p>补充的方式视为原型增加新的函数，这会允许我们在为想要部分应用的函数调用我们的新函数的时候作为它的一个方法。就像这样：myfunction.partial(arg1,arg2,…)；</p>\n<h3 id=\"左端部分应用\"><a href=\"#左端部分应用\" class=\"headerlink\" title=\"左端部分应用\"></a>左端部分应用</h3><p>这里Javascript的call()和apply()函数将对我们很有用。我们看看补充Function对象的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.partialApply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    func.apply(<span class=\"keyword\">this</span>,args.concat(</span><br><span class=\"line\">      <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    ))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见，它的工作方式是对arguments这个特殊的值调用slice</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个函数又有一个特殊的内部变量叫做arguments,它是一个类似于数组的对象，包含传入函数的全部参数。从技术层面说，她不是数组，因此他没有slice和forEach这些数组的方法。这儿就是为什么我们需要使用Array的slice.call方法。</span><br></pre></td></tr></table></figure>\n<p>现在我们通过一个例子看看如何使用它。这次我们不做数学题，来搞点有用的东西。 我们来建立一个把数字转换为16进制的小应用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nums2hex</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">componentToHex</span>(<span class=\"params\">component</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> hex = component.toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">      <span class=\"comment\">//确保返回的数值是两位数字，比如0c或12</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(hex.length == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span> + hex;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">arguments</span>,componentToHex).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//这个函数对多少个数字有效</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(nums2hex()); <span class=\"comment\">// ''</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums2hex(<span class=\"number\">100</span>, <span class=\"number\">200</span>)); <span class=\"comment\">// '64c8'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums2hex(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">123</span>)); <span class=\"comment\">// '64c8ff007b'</span></span><br><span class=\"line\"><span class=\"comment\">// 不过我们可以用部分函数来对部分参数进行应用，比如mac地址的OUI</span></span><br><span class=\"line\"><span class=\"comment\">// ( OUI，“组织唯一标识符”，即网卡制造商的唯一标识符。)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myOUI = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getMacAddress = nums2hex.partialApply(myOUI);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getMacAddress()); <span class=\"comment\">// '7b'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getMacAddress(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">2</span>, <span class=\"number\">123</span>, <span class=\"number\">66</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">// '7b64c8027b420001'</span></span><br><span class=\"line\"><span class=\"comment\">// 我们还可以转换全红基础上的颜色rgb十六进制值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> shadesOfRed = nums2hex.partialApply(<span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfRed(<span class=\"number\">123</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// 'ff7b00'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfRed(<span class=\"number\">100</span>, <span class=\"number\">200</span>)); <span class=\"comment\">// 'ff64c8'</span></span><br></pre></td></tr></table></figure>\n<p>这个例子展示出了我们可以应用部分参数而生成一个新的函数。它是左-右的，意思是我们只能部分应用从左边开始的若干参数。</p>\n<h3 id=\"右部分应用\"><a href=\"#右部分应用\" class=\"headerlink\" title=\"右部分应用\"></a>右部分应用</h3><p>为了从右边开始应用参数，我们可以再定义一个补充函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.partialApplyRight = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> func.apply(</span><br><span class=\"line\">    <span class=\"keyword\">this</span>, [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    .concat(args));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> shadesOfBlue = nums2hex.partialApplyRight(<span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfBlue(<span class=\"number\">123</span>, <span class=\"number\">0</span>));   <span class=\"comment\">// '7b00ff'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfBlue(<span class=\"number\">100</span>, <span class=\"number\">200</span>)); <span class=\"comment\">// '64c8ff'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> someShadesOfGreen = nums2hex.partialApplyRight(<span class=\"number\">255</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfGreen(<span class=\"number\">123</span>));   <span class=\"comment\">// '7bff00'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfGreen(<span class=\"number\">100</span>));   <span class=\"comment\">// '64ff00'</span></span><br></pre></td></tr></table></figure>\n<p>部分应用使我们能够创建非常一般化的函数，并从它提取出更多特殊化的函数。 但是这个方法最大的缺点在于参数传入的方式，也就是参数有多少个，是什么样的顺序，这些不太明确。 不明确性在编程中永远不是个好事儿。还有个更好的方式：珂理化。</p>\n<h2 id=\"柯里化-currying\"><a href=\"#柯里化-currying\" class=\"headerlink\" title=\"柯里化(currying)\"></a>柯里化(currying)</h2><p>柯里化是这样一个过程：他把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数剩余的参数。这是的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每个函数只有一个参数。</p>\n<p>一个普遍的问题是：部分应用和柯里化的区别是什么？实际就是部分应用立刻返回一个值，而柯里化只返回另一个柯里化的函数来获取下一个参数，本质的区别是柯里化可以更好的控制参数传入的方式。</p>\n<p>这里我们再为Function的原型补充一个柯里化的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.curry = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  numArgs = numArgs || func.length; <span class=\"comment\">//func.length是调用此方法的函数的形参个数</span></span><br><span class=\"line\">  <span class=\"comment\">//递归地获取参数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subCurry</span>(<span class=\"params\">prev</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(args.length &lt; numArgs)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归情形：仍需要更多的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> subCurry(args);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//基准情形：执行函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"keyword\">this</span>,args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subCurry([]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>numArgs参数让我们可以在被珂理化的函数没有给出确切参数的时候指定参数的个数。</p>\n<p>来看看用它如何处理我们的十六进制应用。我们先写个函数，它会把RGB值转化为适合HTML的16进制字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rgb2hex</span>(<span class=\"params\">r,g,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + nums2hex(r) + nums2hex(g) + nums2hex(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hexColors = rgb2hex.curry();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">11</span>)) <span class=\"comment\">// 返回一个珂理化的函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">123</span>)) <span class=\"comment\">// 返回一个珂理化的函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">11</span>)(<span class=\"number\">12</span>)(<span class=\"number\">123</span>)) <span class=\"comment\">// 返回 #0b0c7b</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">210</span>)(<span class=\"number\">12</span>)(<span class=\"number\">0</span>)) <span class=\"comment\">// 返回 #d20c00</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意，curry方法返回的函数只接受一个参数，所以上例倒数第三行传入的三个参数的后两个是没用的。</p>\n</blockquote>\n<p>这样使用柯里化不错。但是如果我们相对nums2hex()这个函数进行柯里化就会有点问题，因为这个函数没有指定参数，你可以传入任意数量的参数。所以我们需要定义参数的个数。我们curry函数的那个可选的参数来设置被柯里化函数的参数个数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hexs = nums2hex.curry(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexs(<span class=\"number\">11</span>)(<span class=\"number\">12</span>));     <span class=\"comment\">// 返回 0b0c</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexs(<span class=\"number\">11</span>));         <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexs(<span class=\"number\">110</span>)(<span class=\"number\">12</span>)(<span class=\"number\">0</span>)); <span class=\"comment\">// 不正确</span></span><br></pre></td></tr></table></figure></p>\n<p>所以柯里化不太适合可变参数的函数，对于这种情况，建议使用部分应用函数。<br>所有这些不只是利用函数工厂和代码重用，柯里化和部分应用在函数组合中扮演着更重要的角色。</p>\n","excerpt":"","more":"<p>这章我们继续下面的内容：</p>\n<ul>\n<li>把所有的核心概念放到一个集中的范式里</li>\n<li>探索函数式编程之美</li>\n<li>一步步跟踪函数式模式相互交织的逻辑</li>\n<li>我们将贯穿整章建立一个简单的应用做一些很酷的事情</li>\n</ul>\n<p>你可能已经注意到，在上一章我们介绍Javascript的函数式库的时候引入了一些概念， 而不是在第二章《函数式编程基础》里。呃，这是有原因的！组合、柯里化、不全调用…… 让我们来探索这些库为何以及如何实现这些概念。</p>\n<p>函数式编程可以出现各种各样的模式，这章会覆盖很多不同风格的函数式编程：</p>\n<ul>\n<li>数据泛型编程</li>\n<li>基本上函数式的编程</li>\n<li>函数式响应式编程等</li>\n</ul>\n<p>然而这章将会避免偏向于任何风格。我们不会花费很大精力学完一个函数式编程风格再学另一个， 总的目标是展示写代码更好的方式，而不是被动接受唯一一个正确的选择。 如果你先人一步感觉到了什么是好的写代码的方法而什么不是，你就可以作任何想做的事情了。 当你像个孩子那样仅凭喜好放纵地写代码时，当你不关心如何去循规蹈矩的做事时，无限的可能就出现了。</p>\n<h2 id=\"部分函数应用和珂理化\"><a href=\"#部分函数应用和珂理化\" class=\"headerlink\" title=\"部分函数应用和珂理化\"></a>部分函数应用和珂理化</h2><blockquote>\n<p>许多语言支持可选参数，但是javascript不支持。javascript采用一种完全不同的模式，它允许任意数量的参数传给函数。这就是一些有趣且非同寻常的设计模式留下了门路。函数可以全部或部分应用。</p>\n</blockquote>\n<p>部分应用在javascript中的处理方式是：给函数一个或多个参数绑定上值，然后返回另一个函数接受剩余的未绑定参数。同样，珂理化的处理方式是把一个有多个参数的函数转换为一个只接受一个参数的函数，它返回的函数接受剩余的参数。</p>\n<p>这两者的差异现在看起来不是很明显，但最后会清楚的。</p>\n<h2 id=\"函数操作\"><a href=\"#函数操作\" class=\"headerlink\" title=\"函数操作\"></a>函数操作</h2><p>在我们进一步解释如何实现部分应用和珂理化之前，我们需要进行一些回顾。如果我们想要扒掉javascript厚重的C风格语法外衣，暴露器函数是本质的话，我们需要理解原始函数、原型在javascript是如何工作的；而如果我们只是想设置一些cookie或验证一些表单的话则永远不用考虑这些。</p>\n<h2 id=\"apply、call和this关键词\"><a href=\"#apply、call和this关键词\" class=\"headerlink\" title=\"apply、call和this关键词\"></a>apply、call和this关键词</h2><p>在纯函数式语言中，函数不会被唤起(invoke)，他们是被应用(apply)。javascript以同样的方式工作，甚至提供了手动调用(call)和应用(apply)函数的工具。这些都是与this关键词有关的，当然this指的是函数所属的那个对象。</p>\n<p>call()函数把第一个参数作为this关键字。它是这样工作的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log([<span class=\"string\">'Hello'</span>,<span class=\"string\">'world'</span>].join(<span class=\"string\">' '</span>)); <span class=\"comment\">//正常方式</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.join.call([<span class=\"string\">'Hello'</span>,<span class=\"string\">'world'</span>],<span class=\"string\">' '</span>)); <span class=\"comment\">//使用call</span></span><br></pre></td></tr></table></figure>\n<p>call()函数可以唤起匿名函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log((<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length)&#125;).call([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]));</span><br></pre></td></tr></table></figure>\n<p>apply()函数和call()函数很像，但是更有用一些：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.max(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)); <span class=\"comment\">// 返回3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.max([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])); <span class=\"comment\">// 无法应用于数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Math</span>.max.apply(<span class=\"literal\">null</span>, [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>])); <span class=\"comment\">// 这样就可以了</span></span><br></pre></td></tr></table></figure>\n<p>基本的区别是：call()函数接受一列参数，apply函数接受一个数组作为参数。</p>\n<p>call()和apply()让你可以只写一次函数，其它对象可以继承它而无需再写一遍函数。 并且他俩都是Function对象的成员。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//当你对call()自己调用call()的时候，会发生有趣的事情。</span></span><br><span class=\"line\"><span class=\"comment\">//这两行代码是等价的</span></span><br><span class=\"line\">func.call(thisValue);</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call.call(func,thisValue);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"绑定函数\"><a href=\"#绑定函数\" class=\"headerlink\" title=\"绑定函数\"></a>绑定函数</h2><p>bind()函数让你能够调用一个对象的函数时this指向另一个对象。这跟call()函数差不多，不过他可以让方法链式调用，返回一个新的函数。</p>\n<p>这对于回调非常有用，就像下面的代码那样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Drum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.noise = <span class=\"string\">'boom'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.duration = <span class=\"number\">1000</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.goBoom = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.noise)</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> drum = <span class=\"keyword\">new</span> Drum();</span><br><span class=\"line\">setInterval(drum.goBoom.bind(drum), drum.duration);</span><br></pre></td></tr></table></figure>\n<p>这解决了许多面向对象框架中的问题，比如Dojo，特别是对于那些有自己的handler函数的类处理状态维持的问题。 不过我们也可以用bind()来进行函数式编程。</p>\n<p><code>bind()函数实际上自己实现了部分应用，尽管是通过一种很有限的方式。</code></p>\n<h2 id=\"函数工厂\"><a href=\"#函数工厂\" class=\"headerlink\" title=\"函数工厂\"></a>函数工厂</h2><blockquote>\n<p>还记得第二章《函数式编程基础》中关于闭包的那节吗？闭包使建立函数工厂这种Javascript编程模式成为可能。 它们使你能够手动绑定函数的参数。</p>\n</blockquote>\n<p>首先我们需要一个为另一个函数绑定参数的函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindFirstArg</span>(<span class=\"params\">func,a</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func(a,b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以用它来创建更多的泛型函数(generic function)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> powersOfTwo = bindFirstArg(<span class=\"built_in\">Math</span>.pow, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfTwo(<span class=\"number\">3</span>)); <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfTwo(<span class=\"number\">5</span>)); <span class=\"comment\">// 32</span></span><br></pre></td></tr></table></figure>\n<p>也可以针对于其它参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindSecondArg</span>(<span class=\"params\">func, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> func(a, b);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> squareOf = bindSecondArg(<span class=\"built_in\">Math</span>.pow, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> cubeOf = bindSecondArg(<span class=\"built_in\">Math</span>.pow, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(squareOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(squareOf(<span class=\"number\">4</span>)); <span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cubeOf(<span class=\"number\">3</span>)); <span class=\"comment\">// 27</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(cubeOf(<span class=\"number\">4</span>)); <span class=\"comment\">// 64</span></span><br></pre></td></tr></table></figure>\n<p>在函数式编程中，创建泛型函数的能力十分重要。然而还有更巧妙的方式可以更加一般化的完成这一过程。bindFirstArg()函数接受两个参数，第一个参数是这个函数。如果我们把bindFirstArg本身作为第一个参数的函数传给它自己，我们就可以创建绑定函数。最好用下面的例子来描述：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> makePowersOf = bindFirstArg(bindFirstArg, <span class=\"built_in\">Math</span>.pow);</span><br><span class=\"line\"><span class=\"keyword\">var</span> powersOfThree = makePowersOf(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfThree(<span class=\"number\">2</span>)); <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(powersOfThree(<span class=\"number\">3</span>)); <span class=\"comment\">// 27</span></span><br></pre></td></tr></table></figure>\n<p>这就是为什么它被叫做函数工厂。</p>\n<h2 id=\"部分应用\"><a href=\"#部分应用\" class=\"headerlink\" title=\"部分应用\"></a>部分应用</h2><p>注意我们函数工厂的例子里bindFirstArg()和bindSecondArg()函数只能有两个参数。我们可以写新的不同数量参数的函数，但是这就违背我们一般化的模型了。</p>\n<p>我们需要部分应用</p>\n<p>部分应用是这样一个过程：它给函数的一个或多个参数绑定上值，返回一个已经部分应用过的函数，这个函数仍然需要接收未绑定的参数。</p>\n<p>与bind()函数等Function对象內建的方法不同，我们需要创建自己的函数来实现部分调用和柯里化。主要有两种方式：</p>\n<ul>\n<li>作为一个单独的函数，也就是，var partial = function(func){…}</li>\n<li>作为补充，也就是，Function.prototype.partial = function(func){…}</li>\n</ul>\n<p>补充的方式视为原型增加新的函数，这会允许我们在为想要部分应用的函数调用我们的新函数的时候作为它的一个方法。就像这样：myfunction.partial(arg1,arg2,…)；</p>\n<h3 id=\"左端部分应用\"><a href=\"#左端部分应用\" class=\"headerlink\" title=\"左端部分应用\"></a>左端部分应用</h3><p>这里Javascript的call()和apply()函数将对我们很有用。我们看看补充Function对象的方式：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.partialApply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    func.apply(<span class=\"keyword\">this</span>,args.concat(</span><br><span class=\"line\">      <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">    ))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如你所见，它的工作方式是对arguments这个特殊的值调用slice</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">每个函数又有一个特殊的内部变量叫做arguments,它是一个类似于数组的对象，包含传入函数的全部参数。从技术层面说，她不是数组，因此他没有slice和forEach这些数组的方法。这儿就是为什么我们需要使用Array的slice.call方法。</span><br></pre></td></tr></table></figure>\n<p>现在我们通过一个例子看看如何使用它。这次我们不做数学题，来搞点有用的东西。 我们来建立一个把数字转换为16进制的小应用。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">nums2hex</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">componentToHex</span>(<span class=\"params\">component</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> hex = component.toString(<span class=\"number\">16</span>);</span><br><span class=\"line\">      <span class=\"comment\">//确保返回的数值是两位数字，比如0c或12</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(hex.length == <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"0\"</span> + hex;</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hex;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Array</span>.prototype.map.call(<span class=\"built_in\">arguments</span>,componentToHex).join(<span class=\"string\">''</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//这个函数对多少个数字有效</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(nums2hex()); <span class=\"comment\">// ''</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums2hex(<span class=\"number\">100</span>, <span class=\"number\">200</span>)); <span class=\"comment\">// '64c8'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(nums2hex(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">255</span>, <span class=\"number\">0</span>, <span class=\"number\">123</span>)); <span class=\"comment\">// '64c8ff007b'</span></span><br><span class=\"line\"><span class=\"comment\">// 不过我们可以用部分函数来对部分参数进行应用，比如mac地址的OUI</span></span><br><span class=\"line\"><span class=\"comment\">// ( OUI，“组织唯一标识符”，即网卡制造商的唯一标识符。)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myOUI = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getMacAddress = nums2hex.partialApply(myOUI);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getMacAddress()); <span class=\"comment\">// '7b'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(getMacAddress(<span class=\"number\">100</span>, <span class=\"number\">200</span>, <span class=\"number\">2</span>, <span class=\"number\">123</span>, <span class=\"number\">66</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\"><span class=\"comment\">// '7b64c8027b420001'</span></span><br><span class=\"line\"><span class=\"comment\">// 我们还可以转换全红基础上的颜色rgb十六进制值</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> shadesOfRed = nums2hex.partialApply(<span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfRed(<span class=\"number\">123</span>, <span class=\"number\">0</span>)); <span class=\"comment\">// 'ff7b00'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfRed(<span class=\"number\">100</span>, <span class=\"number\">200</span>)); <span class=\"comment\">// 'ff64c8'</span></span><br></pre></td></tr></table></figure>\n<p>这个例子展示出了我们可以应用部分参数而生成一个新的函数。它是左-右的，意思是我们只能部分应用从左边开始的若干参数。</p>\n<h3 id=\"右部分应用\"><a href=\"#右部分应用\" class=\"headerlink\" title=\"右部分应用\"></a>右部分应用</h3><p>为了从右边开始应用参数，我们可以再定义一个补充函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.partialApplyRight = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">args = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> func.apply(</span><br><span class=\"line\">    <span class=\"keyword\">this</span>, [].slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\">    .concat(args));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> shadesOfBlue = nums2hex.partialApplyRight(<span class=\"number\">255</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfBlue(<span class=\"number\">123</span>, <span class=\"number\">0</span>));   <span class=\"comment\">// '7b00ff'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfBlue(<span class=\"number\">100</span>, <span class=\"number\">200</span>)); <span class=\"comment\">// '64c8ff'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> someShadesOfGreen = nums2hex.partialApplyRight(<span class=\"number\">255</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfGreen(<span class=\"number\">123</span>));   <span class=\"comment\">// '7bff00'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(shadesOfGreen(<span class=\"number\">100</span>));   <span class=\"comment\">// '64ff00'</span></span><br></pre></td></tr></table></figure>\n<p>部分应用使我们能够创建非常一般化的函数，并从它提取出更多特殊化的函数。 但是这个方法最大的缺点在于参数传入的方式，也就是参数有多少个，是什么样的顺序，这些不太明确。 不明确性在编程中永远不是个好事儿。还有个更好的方式：珂理化。</p>\n<h2 id=\"柯里化-currying\"><a href=\"#柯里化-currying\" class=\"headerlink\" title=\"柯里化(currying)\"></a>柯里化(currying)</h2><p>柯里化是这样一个过程：他把一个具有多个参数的函数转换为一个只有一个参数的函数并返回另一个函数，这个被返回的函数需要原函数剩余的参数。这是的说法是：一个具有N个参数的函数可以被转换为具有N个函数的函数链，其中每个函数只有一个参数。</p>\n<p>一个普遍的问题是：部分应用和柯里化的区别是什么？实际就是部分应用立刻返回一个值，而柯里化只返回另一个柯里化的函数来获取下一个参数，本质的区别是柯里化可以更好的控制参数传入的方式。</p>\n<p>这里我们再为Function的原型补充一个柯里化的方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.curry = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">numArgs</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  numArgs = numArgs || func.length; <span class=\"comment\">//func.length是调用此方法的函数的形参个数</span></span><br><span class=\"line\">  <span class=\"comment\">//递归地获取参数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subCurry</span>(<span class=\"params\">prev</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">arg</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(args.length &lt; numArgs)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//递归情形：仍需要更多的参数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> subCurry(args);</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//基准情形：执行函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"keyword\">this</span>,args);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> subCurry([]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>numArgs参数让我们可以在被珂理化的函数没有给出确切参数的时候指定参数的个数。</p>\n<p>来看看用它如何处理我们的十六进制应用。我们先写个函数，它会把RGB值转化为适合HTML的16进制字符串。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rgb2hex</span>(<span class=\"params\">r,g,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">'#'</span> + nums2hex(r) + nums2hex(g) + nums2hex(b);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hexColors = rgb2hex.curry();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">11</span>)) <span class=\"comment\">// 返回一个珂理化的函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">11</span>, <span class=\"number\">12</span>, <span class=\"number\">123</span>)) <span class=\"comment\">// 返回一个珂理化的函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">11</span>)(<span class=\"number\">12</span>)(<span class=\"number\">123</span>)) <span class=\"comment\">// 返回 #0b0c7b</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexColors(<span class=\"number\">210</span>)(<span class=\"number\">12</span>)(<span class=\"number\">0</span>)) <span class=\"comment\">// 返回 #d20c00</span></span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意，curry方法返回的函数只接受一个参数，所以上例倒数第三行传入的三个参数的后两个是没用的。</p>\n</blockquote>\n<p>这样使用柯里化不错。但是如果我们相对nums2hex()这个函数进行柯里化就会有点问题，因为这个函数没有指定参数，你可以传入任意数量的参数。所以我们需要定义参数的个数。我们curry函数的那个可选的参数来设置被柯里化函数的参数个数。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> hexs = nums2hex.curry(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexs(<span class=\"number\">11</span>)(<span class=\"number\">12</span>));     <span class=\"comment\">// 返回 0b0c</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexs(<span class=\"number\">11</span>));         <span class=\"comment\">// 返回一个函数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hexs(<span class=\"number\">110</span>)(<span class=\"number\">12</span>)(<span class=\"number\">0</span>)); <span class=\"comment\">// 不正确</span></span><br></pre></td></tr></table></figure></p>\n<p>所以柯里化不太适合可变参数的函数，对于这种情况，建议使用部分应用函数。<br>所有这些不只是利用函数工厂和代码重用，柯里化和部分应用在函数组合中扮演着更重要的角色。</p>\n"},{"title":"这个API很迷人","date":"2016-07-25T07:25:12.000Z","_content":"> 文章转载自[这个API很“迷人”——(新的Fetch API)](http://www.w3ctech.com/topic/854)，仅供学习和参考\n\n## 原标题是This API is so Fetching, Fetching也可以表示迷人的意思\nJavascript通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说他很有用，但他不是最佳API。他在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近Javascript流行的Promise以及基于生成器的异步编程模型不太搭。\n\n新的[Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) API打算修正上面提到的那些缺陷。他向JS中引入和HTTP协议中同样的原语。具体而言，它引入一个使用的函数fetch()用来捕捉从网络上检索一个资源的意图。\n\n[Fetch规范](https://fetch.spec.whatwg.org/)的API明确了用户代理获取资源的语义。它结合ServiceWorkers，尝试达到以下优化：\n 1. 改善离线体验\n 2. 保持可扩展性\n\n## 特性检测\n要检查是否支持Fetch API，可以通过检查Headers、Request、Response或者fetch在window或者worker作用域中是否存在。\n```javascript\n  if(self.fetch){\n    //run my fetch request here\n  }else{\n    // do something with XMLHttpRequest\n  }\n```\n\n### 简单的fetching示例\n在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。\n```javascript\n  fetch('./data.json').then(function(res){\n    // res instanceof response == true\n    if(res.ok){\n      res.json().then(function(data){\n        console.log(data);\n      });\n    }else{\n      console.log('Looks like the response',res.status);\n    }\n  },function(e){\n    console.log('Fetch failed',e);\n  })\n```\n如果是提交一个POST请求，代码如下：\n```javascript\n  fetch('http://www.example.org/submit.php',{\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    body: 'firstName=Nikhil&favColor=blue&password=easytoguess'\n  }).then(function(res){\n    if(res.ok){\n      alert('Perfect! Your settings are saved.');\n    }else if(res.status == 401){\n      alert('Oops! You are not authorized.');\n    }\n  },function(e){\n    alert('Error submitting form!')\n  })\n```\nfetch()函数的参数和传给Request()构造函数的参数保持完全一致，所以你可以直接传任意复杂的request请求给fetch().\n\n### Headers\nFetch引入了3个接口，它们分别是Headers、Request以及Response。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。\nHeaders接口是一个简单的多映射的名-值表\n```javascript\n  var content = 'Hello World';\n  var reqHeaders = new Headers();\n  reqHeaders.append('Content-Type','text/plain');\n  reqHeaders.append('Content-Length',content.length.toString());\n  reqHeaders.append('X-Custom-Header','ProcessThisImmediately');\n```\n也可以传一个多维数组或者json：\n```javascript\n  reqHeaders = new Headers({\n    \"Content-Type\": \"text/plain\",\n    \"Content-Length\": content.length.toString(),\n    \"X-Custom-Header\": \"ProcessThisImmediately\"\n  })\n```\nHeaders的内容可以被检索：\n```javascript\n  console.log(reqHeaders.has('Content-Type'));\n  console.log(reqHeaders.has(\"Set-Cookie\"));\n  reqHeaders.set(\"Content-Type\", \"text/html\");\n  reqHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n\n  console.log(reqHeaders.get(\"Content-Length\"));\n  console.log(reqHeaders.getAll(\"X-Custom-Header\"));\n\n  reqHeaders.delete(\"X-Custom-Header\");\n  console.log(reqHeaders.getAll(\"X-Custom-Header\"));\n```\n一些操作不仅仅对ServiceWorkers有用，本身也提供了更方便的操作Headers的API。\n\n由于Headers可以在request请求中被发送或者在response请求中被接收，并且规定了哪些参数是可写的，Headers对象有一个特殊的guard属性。这个属性没有暴露给Web，但是它影响到哪些内容可以在Headers对象中被改变。\n可能的值如下：\n - \"none\": 默认值。\n - \"request\": 从Request中获得的Headers只读。\n - \"request-no-cors\": 从不同域的Request中获得的Headers只读。\n - \"response\": 从Response获得的Headers只读.\n - \"immutable\": 在ServiceWorkers中最常用，所有的Headers都只读。\n\n哪一种guard作用于Headers导致什么行为，详细定义在这个[规范](https://fetch.spec.whatwg.org/)中。例如，你不可以添加或者修改一个guard属性是\"request\"的Request Headers的\"Content-Length\"属性。同样地，插入\"Set-Cookie\"属性到一个Response headers是不允许的，因此ServiceWorkers是不能给合成的Request的headers添加一些cookies。\n\n如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出TypeError异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：\n```javascript\n  var res = Response.error();\n  try{\n    res.headers.set('Origin', 'http://myback.com')\n  }catch(e){\n    console.log('Cannot pretend to be a bank!')\n  }\n```\n\n### Requset\nRequest接口定义了通过HTTP请求资源的request格式。参数需要URL、method和headers,同时Requset也接受一个特定的body、mode、credentials以及cache hints.\n最简单的Request当然是一个URL，可以通过URL来GET一个资源。\n```javascript\n  var req = new Request('./index.html');\n  console.log(req.method); //\"GET\"\n  console.log(req.url);\n```\n\n你也可以将一个建好的Request对象传给构造函数，这样将复制出一个新的Request。\n```javascript\n  var copy = new Request(req);\n  console.log(copy.method);\n  console.log(copy.url);\n```\n\n这种用法通常见于ServiceWorkers.\nURL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json：\n```javascript\n  var uploadReq = new Request('/uploadImage',{\n    method: 'POST',\n    headers: {\n      'Content-Type': 'image/png',\n    },\n    body: 'image data'\n  })\n```\nmode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为`same-origin`,`no-cors`以及`cors`。\n\n`same-origin`模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。\n```javascript\n  var arbitraryUrl = document.getElementById('url-input').value;\n  fetch(arbitraryUrl, {mode:'same-origin'}).then(function(res){\n    console.log('Response succeeded ', res.ok);\n  },function(e){\n    console.log('Please enter a same-orgin URL!');\n  })\n```\n\n`no-cors`模式允许来自CDN的脚本、其他域的图片和其他一些跨域的资源，但是首先有个前提条件，就是请求的method只能是'HEAD'、'GET'或者'POST'。此外，任何ServiceWorkers拦截了这些请求，它不能随意添加或者改写任何headers，除了[这些](https://fetch.spec.whatwg.org/#simple-header)。第三，javascript不能访问Response中的任何属性，这保证了ServiceWorkers不会导致任何跨域下的安全问题而隐私信息泄露。\n\n`cros`模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守[CORS协议](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).只有有限的[一些](https://fetch.spec.whatwg.org/#concept-filtered-response-cors)headers被暴露给Response对象，但是body是可读的。例如，你可以获得一个Flickr的最感兴趣的照片的清单:\n```javascript\n  var u = new URLSearchParams();\n  u.append('method', 'flickr.interestingness.getList');\n  u.append('api_key', '<insert api key here>');\n  u.append('format', 'json');\n  u.append('nojsoncallback', '1');\n\n  var apiCall = fetch('https://api.flickr.com/services/rest?' + u);\n\n  apiCall.then(function(response) {\n    return response.json().then(function(json) {\n      // photo is a list of photos.\n      return json.photos.photo;\n    });\n  }).then(function(photos) {\n    photos.forEach(function(photo) {\n      console.log(photo.title);\n    });\n  });\n```\n你无法从Headers中读取'Date'属性，因为Flickr在Access-Control-Expose-Headers中设置了不允许读取它。\n```javascript\n  response.headers.get('Date'); //null\n```\n\n`credentials`枚举属性决定了cookies是否能跨域得到。这个属性与XHR的withCredentials标志相同，但是只有三个值，分别是'omit(默认)'、'same-origin'以及'include'。\nRequest对象也可以提供caching hints给用户代理。这个属性还在安全复审阶段。Firefox提供了这个属性，但是它目前还不起作用。\nRequest还有两个只读的属性与ServiceWorkers拦截有关。其中一个是referrer，表示Request的来源，可能为空。另外一个是context，是一个非常大的枚举集合定义了获得的资源的种类，它可能是image比如请求来自于img标签，可能是worker如果是一个worker脚本，等等。如果使用fetch()函数，这个值是fetch。\n\n### Response\nResponse实例通常在fetch()的回调中获得。但是它们也可以用JS构造，不过通常这招只用于ServiceWorkers。\nResponse中最常见的成员是status(一个整数默认值是200)和status Text(默认值是'OK')，对应HTTP请求的status和reason。还有一个'ok'属性，当status为2xx的时候它是true.\nheaders属性是Response的Headers对象，它是只读的，url属性是当前Response的来源URL.\nResponse也有一个type属性，它的值可能是'basic'、'cors'、'default'、'error'或者'opaque'。\n - 'basic': 正常的，同域的请求，包含所有的headers除开'Set-Cookie'和'Set-Cookie2'.\n - 'cros': Response从一个合法的跨域请求获得，[一部分headers和body](https://fetch.spec.whatwg.org/#concept-filtered-response-cors)可读.\n - 'error': 网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。\n - 'opaque': Response从'no-cros'请求了跨域资源。依靠Server端来做限制。\n\n'error'类型会导致fetch()函数的Promise被reject并回调一个TypeError.\n还有一些属性只在ServiceWorkers作用域下有效。以正确的方式返回一个Response针对一个被ServiceWorkers拦截的Request，可以像下面这样写：\n```javascript\n  addEventListener('fetch', function(event){\n    event.responseWith(new Response('Response body', {\n      headers: { 'Content-Type': 'text/plain' }\n    }))\n  })\n```\n如你所见，Response有个接收两个可选参数的构造器。第一个参数返回的body，第二个参数是一个json,设置status、statusText以及headers.\n静态方法Response.error()简单返回一个错误的请求。类似的，Response.redirect(url,status)返回一个跳转URL的请求。\n\n### 处理body\n无论Request还是Response都可能带着body。由于body可以是各种类型。body可以是以下任何一种类型的示例:\n - [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n - [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView)(Unit8Array and friends)\n - [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)/[File](https://developer.mozilla.org/en-US/docs/Web/API/File)\n - 字符串\n - [URLSearchParams](https://url.spec.whatwg.org/#interface-urlsearchparams)\n - [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n\n此外，Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象。\n - arrayBuffer()\n - blof()\n - json()\n - text()\n - formData()\n在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。\n\n可以通过传body参数来设置Request的body：\n```javascript\n  var form = new FormData(document.getElementById('login-form'));\n  fetch('/login', {\n    method: 'POST',\n    body: form\n  })\n```\nResponse的第一个参数是body:\n```javascript\n  var res = new Response(new File(['chunk', 'chunk'], 'archive.zip',{ type: 'application/zip' }));\n```\nRequest和Response(通过fetch()方法)都能够[自动识别自己的content type](https://fetch.spec.whatwg.org/#concept-bodyinit-extract)，Request还可以自动设置'Content-Type'header,如果开发者没有设置它的话。\n\n### 流和克隆\n非常重要的一点要说明，那就是Request和Response的body只能被读取一次！它们有一个属性叫bodyUsed,读取一次之后设置为true，就不能再读取了。\n```javascript\n  var res = new Response('one time use');\n  console.log(res.bodyUsed); //false\n  res.text().then(function(){\n    console.log(res.bodyUsed); //true\n  });\n  console.log(res.bodyUsed); //true\n\n  res.text().catch(function(e){\n    console.log('Tried to read already consumed Response')\n  })\n```\n\n这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。\n有时候，我们希望多次访问body，例如，你可能想用即将支持的[Cache API](http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects)去缓存Request和Response,以便于可以离线使用，Cache要求body能被再次读取。\n\n所以，我们该如何让body能经得起多次读取呢？API提供了一个clone()方法。调用这个方法可以得到一个克隆对象。不过要记得，**clone()必须要在读取之前调用，也就是先clone()在读取**。\n```javascript\n  addEventListener('fetch', function(evt){\n    var sheep = new Response('Dolly');\n    console.log(sheep.bodyUsed); //false\n    var clone = sheep.clone();\n    console.log(clone.bodyUsed); //false\n\n    clone.text();\n    console.log(sheep.bodyUsed); //false\n    console.log(clone.bodyUsed); //true\n\n    evt.responseWith(cache.add(sheep.clone()).then(fucntion(e){\n      return sheep;\n    }))\n  })\n```\n\n### 未来的改进\n为了支持流，Fetch最终将提供可以中断执行读取资源的能力，并且提供可以得到读取进度的API。这些能力在XHR中有，但是想要实现成Promise-based的Fetch API有些麻烦。\n","source":"_posts/这个API很迷人.md","raw":"---\ntitle: 这个API很迷人\ndate: 2016-07-25 15:25:12\ntags:\n- javascript\n- protocol\ncategories: 笔记\n---\n> 文章转载自[这个API很“迷人”——(新的Fetch API)](http://www.w3ctech.com/topic/854)，仅供学习和参考\n\n## 原标题是This API is so Fetching, Fetching也可以表示迷人的意思\nJavascript通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说他很有用，但他不是最佳API。他在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近Javascript流行的Promise以及基于生成器的异步编程模型不太搭。\n\n新的[Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) API打算修正上面提到的那些缺陷。他向JS中引入和HTTP协议中同样的原语。具体而言，它引入一个使用的函数fetch()用来捕捉从网络上检索一个资源的意图。\n\n[Fetch规范](https://fetch.spec.whatwg.org/)的API明确了用户代理获取资源的语义。它结合ServiceWorkers，尝试达到以下优化：\n 1. 改善离线体验\n 2. 保持可扩展性\n\n## 特性检测\n要检查是否支持Fetch API，可以通过检查Headers、Request、Response或者fetch在window或者worker作用域中是否存在。\n```javascript\n  if(self.fetch){\n    //run my fetch request here\n  }else{\n    // do something with XMLHttpRequest\n  }\n```\n\n### 简单的fetching示例\n在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。\n```javascript\n  fetch('./data.json').then(function(res){\n    // res instanceof response == true\n    if(res.ok){\n      res.json().then(function(data){\n        console.log(data);\n      });\n    }else{\n      console.log('Looks like the response',res.status);\n    }\n  },function(e){\n    console.log('Fetch failed',e);\n  })\n```\n如果是提交一个POST请求，代码如下：\n```javascript\n  fetch('http://www.example.org/submit.php',{\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    body: 'firstName=Nikhil&favColor=blue&password=easytoguess'\n  }).then(function(res){\n    if(res.ok){\n      alert('Perfect! Your settings are saved.');\n    }else if(res.status == 401){\n      alert('Oops! You are not authorized.');\n    }\n  },function(e){\n    alert('Error submitting form!')\n  })\n```\nfetch()函数的参数和传给Request()构造函数的参数保持完全一致，所以你可以直接传任意复杂的request请求给fetch().\n\n### Headers\nFetch引入了3个接口，它们分别是Headers、Request以及Response。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。\nHeaders接口是一个简单的多映射的名-值表\n```javascript\n  var content = 'Hello World';\n  var reqHeaders = new Headers();\n  reqHeaders.append('Content-Type','text/plain');\n  reqHeaders.append('Content-Length',content.length.toString());\n  reqHeaders.append('X-Custom-Header','ProcessThisImmediately');\n```\n也可以传一个多维数组或者json：\n```javascript\n  reqHeaders = new Headers({\n    \"Content-Type\": \"text/plain\",\n    \"Content-Length\": content.length.toString(),\n    \"X-Custom-Header\": \"ProcessThisImmediately\"\n  })\n```\nHeaders的内容可以被检索：\n```javascript\n  console.log(reqHeaders.has('Content-Type'));\n  console.log(reqHeaders.has(\"Set-Cookie\"));\n  reqHeaders.set(\"Content-Type\", \"text/html\");\n  reqHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n\n  console.log(reqHeaders.get(\"Content-Length\"));\n  console.log(reqHeaders.getAll(\"X-Custom-Header\"));\n\n  reqHeaders.delete(\"X-Custom-Header\");\n  console.log(reqHeaders.getAll(\"X-Custom-Header\"));\n```\n一些操作不仅仅对ServiceWorkers有用，本身也提供了更方便的操作Headers的API。\n\n由于Headers可以在request请求中被发送或者在response请求中被接收，并且规定了哪些参数是可写的，Headers对象有一个特殊的guard属性。这个属性没有暴露给Web，但是它影响到哪些内容可以在Headers对象中被改变。\n可能的值如下：\n - \"none\": 默认值。\n - \"request\": 从Request中获得的Headers只读。\n - \"request-no-cors\": 从不同域的Request中获得的Headers只读。\n - \"response\": 从Response获得的Headers只读.\n - \"immutable\": 在ServiceWorkers中最常用，所有的Headers都只读。\n\n哪一种guard作用于Headers导致什么行为，详细定义在这个[规范](https://fetch.spec.whatwg.org/)中。例如，你不可以添加或者修改一个guard属性是\"request\"的Request Headers的\"Content-Length\"属性。同样地，插入\"Set-Cookie\"属性到一个Response headers是不允许的，因此ServiceWorkers是不能给合成的Request的headers添加一些cookies。\n\n如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出TypeError异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：\n```javascript\n  var res = Response.error();\n  try{\n    res.headers.set('Origin', 'http://myback.com')\n  }catch(e){\n    console.log('Cannot pretend to be a bank!')\n  }\n```\n\n### Requset\nRequest接口定义了通过HTTP请求资源的request格式。参数需要URL、method和headers,同时Requset也接受一个特定的body、mode、credentials以及cache hints.\n最简单的Request当然是一个URL，可以通过URL来GET一个资源。\n```javascript\n  var req = new Request('./index.html');\n  console.log(req.method); //\"GET\"\n  console.log(req.url);\n```\n\n你也可以将一个建好的Request对象传给构造函数，这样将复制出一个新的Request。\n```javascript\n  var copy = new Request(req);\n  console.log(copy.method);\n  console.log(copy.url);\n```\n\n这种用法通常见于ServiceWorkers.\nURL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json：\n```javascript\n  var uploadReq = new Request('/uploadImage',{\n    method: 'POST',\n    headers: {\n      'Content-Type': 'image/png',\n    },\n    body: 'image data'\n  })\n```\nmode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为`same-origin`,`no-cors`以及`cors`。\n\n`same-origin`模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。\n```javascript\n  var arbitraryUrl = document.getElementById('url-input').value;\n  fetch(arbitraryUrl, {mode:'same-origin'}).then(function(res){\n    console.log('Response succeeded ', res.ok);\n  },function(e){\n    console.log('Please enter a same-orgin URL!');\n  })\n```\n\n`no-cors`模式允许来自CDN的脚本、其他域的图片和其他一些跨域的资源，但是首先有个前提条件，就是请求的method只能是'HEAD'、'GET'或者'POST'。此外，任何ServiceWorkers拦截了这些请求，它不能随意添加或者改写任何headers，除了[这些](https://fetch.spec.whatwg.org/#simple-header)。第三，javascript不能访问Response中的任何属性，这保证了ServiceWorkers不会导致任何跨域下的安全问题而隐私信息泄露。\n\n`cros`模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守[CORS协议](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS).只有有限的[一些](https://fetch.spec.whatwg.org/#concept-filtered-response-cors)headers被暴露给Response对象，但是body是可读的。例如，你可以获得一个Flickr的最感兴趣的照片的清单:\n```javascript\n  var u = new URLSearchParams();\n  u.append('method', 'flickr.interestingness.getList');\n  u.append('api_key', '<insert api key here>');\n  u.append('format', 'json');\n  u.append('nojsoncallback', '1');\n\n  var apiCall = fetch('https://api.flickr.com/services/rest?' + u);\n\n  apiCall.then(function(response) {\n    return response.json().then(function(json) {\n      // photo is a list of photos.\n      return json.photos.photo;\n    });\n  }).then(function(photos) {\n    photos.forEach(function(photo) {\n      console.log(photo.title);\n    });\n  });\n```\n你无法从Headers中读取'Date'属性，因为Flickr在Access-Control-Expose-Headers中设置了不允许读取它。\n```javascript\n  response.headers.get('Date'); //null\n```\n\n`credentials`枚举属性决定了cookies是否能跨域得到。这个属性与XHR的withCredentials标志相同，但是只有三个值，分别是'omit(默认)'、'same-origin'以及'include'。\nRequest对象也可以提供caching hints给用户代理。这个属性还在安全复审阶段。Firefox提供了这个属性，但是它目前还不起作用。\nRequest还有两个只读的属性与ServiceWorkers拦截有关。其中一个是referrer，表示Request的来源，可能为空。另外一个是context，是一个非常大的枚举集合定义了获得的资源的种类，它可能是image比如请求来自于img标签，可能是worker如果是一个worker脚本，等等。如果使用fetch()函数，这个值是fetch。\n\n### Response\nResponse实例通常在fetch()的回调中获得。但是它们也可以用JS构造，不过通常这招只用于ServiceWorkers。\nResponse中最常见的成员是status(一个整数默认值是200)和status Text(默认值是'OK')，对应HTTP请求的status和reason。还有一个'ok'属性，当status为2xx的时候它是true.\nheaders属性是Response的Headers对象，它是只读的，url属性是当前Response的来源URL.\nResponse也有一个type属性，它的值可能是'basic'、'cors'、'default'、'error'或者'opaque'。\n - 'basic': 正常的，同域的请求，包含所有的headers除开'Set-Cookie'和'Set-Cookie2'.\n - 'cros': Response从一个合法的跨域请求获得，[一部分headers和body](https://fetch.spec.whatwg.org/#concept-filtered-response-cors)可读.\n - 'error': 网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。\n - 'opaque': Response从'no-cros'请求了跨域资源。依靠Server端来做限制。\n\n'error'类型会导致fetch()函数的Promise被reject并回调一个TypeError.\n还有一些属性只在ServiceWorkers作用域下有效。以正确的方式返回一个Response针对一个被ServiceWorkers拦截的Request，可以像下面这样写：\n```javascript\n  addEventListener('fetch', function(event){\n    event.responseWith(new Response('Response body', {\n      headers: { 'Content-Type': 'text/plain' }\n    }))\n  })\n```\n如你所见，Response有个接收两个可选参数的构造器。第一个参数返回的body，第二个参数是一个json,设置status、statusText以及headers.\n静态方法Response.error()简单返回一个错误的请求。类似的，Response.redirect(url,status)返回一个跳转URL的请求。\n\n### 处理body\n无论Request还是Response都可能带着body。由于body可以是各种类型。body可以是以下任何一种类型的示例:\n - [ArrayBuffer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)\n - [ArrayBufferView](https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView)(Unit8Array and friends)\n - [Blob](https://developer.mozilla.org/en-US/docs/Web/API/Blob)/[File](https://developer.mozilla.org/en-US/docs/Web/API/File)\n - 字符串\n - [URLSearchParams](https://url.spec.whatwg.org/#interface-urlsearchparams)\n - [FormData](https://developer.mozilla.org/en-US/docs/Web/API/FormData)\n\n此外，Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象。\n - arrayBuffer()\n - blof()\n - json()\n - text()\n - formData()\n在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。\n\n可以通过传body参数来设置Request的body：\n```javascript\n  var form = new FormData(document.getElementById('login-form'));\n  fetch('/login', {\n    method: 'POST',\n    body: form\n  })\n```\nResponse的第一个参数是body:\n```javascript\n  var res = new Response(new File(['chunk', 'chunk'], 'archive.zip',{ type: 'application/zip' }));\n```\nRequest和Response(通过fetch()方法)都能够[自动识别自己的content type](https://fetch.spec.whatwg.org/#concept-bodyinit-extract)，Request还可以自动设置'Content-Type'header,如果开发者没有设置它的话。\n\n### 流和克隆\n非常重要的一点要说明，那就是Request和Response的body只能被读取一次！它们有一个属性叫bodyUsed,读取一次之后设置为true，就不能再读取了。\n```javascript\n  var res = new Response('one time use');\n  console.log(res.bodyUsed); //false\n  res.text().then(function(){\n    console.log(res.bodyUsed); //true\n  });\n  console.log(res.bodyUsed); //true\n\n  res.text().catch(function(e){\n    console.log('Tried to read already consumed Response')\n  })\n```\n\n这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。\n有时候，我们希望多次访问body，例如，你可能想用即将支持的[Cache API](http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects)去缓存Request和Response,以便于可以离线使用，Cache要求body能被再次读取。\n\n所以，我们该如何让body能经得起多次读取呢？API提供了一个clone()方法。调用这个方法可以得到一个克隆对象。不过要记得，**clone()必须要在读取之前调用，也就是先clone()在读取**。\n```javascript\n  addEventListener('fetch', function(evt){\n    var sheep = new Response('Dolly');\n    console.log(sheep.bodyUsed); //false\n    var clone = sheep.clone();\n    console.log(clone.bodyUsed); //false\n\n    clone.text();\n    console.log(sheep.bodyUsed); //false\n    console.log(clone.bodyUsed); //true\n\n    evt.responseWith(cache.add(sheep.clone()).then(fucntion(e){\n      return sheep;\n    }))\n  })\n```\n\n### 未来的改进\n为了支持流，Fetch最终将提供可以中断执行读取资源的能力，并且提供可以得到读取进度的API。这些能力在XHR中有，但是想要实现成Promise-based的Fetch API有些麻烦。\n","slug":"这个API很迷人","published":1,"updated":"2016-07-26T07:05:04.931Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cirlo0eo8002yb0dljs8789c1","content":"<blockquote>\n<p>文章转载自<a href=\"http://www.w3ctech.com/topic/854\" target=\"_blank\" rel=\"external\">这个API很“迷人”——(新的Fetch API)</a>，仅供学习和参考</p>\n</blockquote>\n<h2 id=\"原标题是This-API-is-so-Fetching-Fetching也可以表示迷人的意思\"><a href=\"#原标题是This-API-is-so-Fetching-Fetching也可以表示迷人的意思\" class=\"headerlink\" title=\"原标题是This API is so Fetching, Fetching也可以表示迷人的意思\"></a>原标题是This API is so Fetching, Fetching也可以表示迷人的意思</h2><p>Javascript通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说他很有用，但他不是最佳API。他在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近Javascript流行的Promise以及基于生成器的异步编程模型不太搭。</p>\n<p>新的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\" target=\"_blank\" rel=\"external\">Fetch</a> API打算修正上面提到的那些缺陷。他向JS中引入和HTTP协议中同样的原语。具体而言，它引入一个使用的函数fetch()用来捕捉从网络上检索一个资源的意图。</p>\n<p><a href=\"https://fetch.spec.whatwg.org/\" target=\"_blank\" rel=\"external\">Fetch规范</a>的API明确了用户代理获取资源的语义。它结合ServiceWorkers，尝试达到以下优化：</p>\n<ol>\n<li>改善离线体验</li>\n<li>保持可扩展性</li>\n</ol>\n<h2 id=\"特性检测\"><a href=\"#特性检测\" class=\"headerlink\" title=\"特性检测\"></a>特性检测</h2><p>要检查是否支持Fetch API，可以通过检查Headers、Request、Response或者fetch在window或者worker作用域中是否存在。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(self.fetch)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//run my fetch request here</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something with XMLHttpRequest</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"简单的fetching示例\"><a href=\"#简单的fetching示例\" class=\"headerlink\" title=\"简单的fetching示例\"></a>简单的fetching示例</h3><p>在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'./data.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// res instanceof response == true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(res.ok)&#123;</span><br><span class=\"line\">    res.json().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Looks like the response'</span>,res.status);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Fetch failed'</span>,e);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果是提交一个POST请求，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'http://www.example.org/submit.php'</span>,&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: <span class=\"string\">'firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess'</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(res.ok)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'Perfect! Your settings are saved.'</span>);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(res.status == <span class=\"number\">401</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'Oops! You are not authorized.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'Error submitting form!'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>fetch()函数的参数和传给Request()构造函数的参数保持完全一致，所以你可以直接传任意复杂的request请求给fetch().</p>\n<h3 id=\"Headers\"><a href=\"#Headers\" class=\"headerlink\" title=\"Headers\"></a>Headers</h3><p>Fetch引入了3个接口，它们分别是Headers、Request以及Response。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。<br>Headers接口是一个简单的多映射的名-值表<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> reqHeaders = <span class=\"keyword\">new</span> Headers();</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">'Content-Type'</span>,<span class=\"string\">'text/plain'</span>);</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">'Content-Length'</span>,content.length.toString());</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">'X-Custom-Header'</span>,<span class=\"string\">'ProcessThisImmediately'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>也可以传一个多维数组或者json：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reqHeaders = <span class=\"keyword\">new</span> Headers(&#123;</span><br><span class=\"line\">  <span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Content-Length\"</span>: content.length.toString(),</span><br><span class=\"line\">  <span class=\"string\">\"X-Custom-Header\"</span>: <span class=\"string\">\"ProcessThisImmediately\"</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Headers的内容可以被检索：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">'Content-Type'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">\"Set-Cookie\"</span>));</span><br><span class=\"line\">reqHeaders.set(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/html\"</span>);</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">\"X-Custom-Header\"</span>, <span class=\"string\">\"AnotherValue\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.get(<span class=\"string\">\"Content-Length\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.getAll(<span class=\"string\">\"X-Custom-Header\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">reqHeaders.delete(<span class=\"string\">\"X-Custom-Header\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.getAll(<span class=\"string\">\"X-Custom-Header\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>一些操作不仅仅对ServiceWorkers有用，本身也提供了更方便的操作Headers的API。</p>\n<p>由于Headers可以在request请求中被发送或者在response请求中被接收，并且规定了哪些参数是可写的，Headers对象有一个特殊的guard属性。这个属性没有暴露给Web，但是它影响到哪些内容可以在Headers对象中被改变。<br>可能的值如下：</p>\n<ul>\n<li>“none”: 默认值。</li>\n<li>“request”: 从Request中获得的Headers只读。</li>\n<li>“request-no-cors”: 从不同域的Request中获得的Headers只读。</li>\n<li>“response”: 从Response获得的Headers只读.</li>\n<li>“immutable”: 在ServiceWorkers中最常用，所有的Headers都只读。</li>\n</ul>\n<p>哪一种guard作用于Headers导致什么行为，详细定义在这个<a href=\"https://fetch.spec.whatwg.org/\" target=\"_blank\" rel=\"external\">规范</a>中。例如，你不可以添加或者修改一个guard属性是”request”的Request Headers的”Content-Length”属性。同样地，插入”Set-Cookie”属性到一个Response headers是不允许的，因此ServiceWorkers是不能给合成的Request的headers添加一些cookies。</p>\n<p>如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出TypeError异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = Response.error();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  res.headers.set(<span class=\"string\">'Origin'</span>, <span class=\"string\">'http://myback.com'</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Cannot pretend to be a bank!'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Requset\"><a href=\"#Requset\" class=\"headerlink\" title=\"Requset\"></a>Requset</h3><p>Request接口定义了通过HTTP请求资源的request格式。参数需要URL、method和headers,同时Requset也接受一个特定的body、mode、credentials以及cache hints.<br>最简单的Request当然是一个URL，可以通过URL来GET一个资源。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"keyword\">new</span> Request(<span class=\"string\">'./index.html'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.method); <span class=\"comment\">//\"GET\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.url);</span><br></pre></td></tr></table></figure></p>\n<p>你也可以将一个建好的Request对象传给构造函数，这样将复制出一个新的Request。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"keyword\">new</span> Request(req);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy.method);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy.url);</span><br></pre></td></tr></table></figure></p>\n<p>这种用法通常见于ServiceWorkers.<br>URL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uploadReq = <span class=\"keyword\">new</span> Request(<span class=\"string\">'/uploadImage'</span>,&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: <span class=\"string\">'image data'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>mode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为<code>same-origin</code>,<code>no-cors</code>以及<code>cors</code>。</p>\n<p><code>same-origin</code>模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arbitraryUrl = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'url-input'</span>).value;</span><br><span class=\"line\">fetch(arbitraryUrl, &#123;mode:<span class=\"string\">'same-origin'</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Response succeeded '</span>, res.ok);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Please enter a same-orgin URL!'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>no-cors</code>模式允许来自CDN的脚本、其他域的图片和其他一些跨域的资源，但是首先有个前提条件，就是请求的method只能是’HEAD’、’GET’或者’POST’。此外，任何ServiceWorkers拦截了这些请求，它不能随意添加或者改写任何headers，除了<a href=\"https://fetch.spec.whatwg.org/#simple-header\" target=\"_blank\" rel=\"external\">这些</a>。第三，javascript不能访问Response中的任何属性，这保证了ServiceWorkers不会导致任何跨域下的安全问题而隐私信息泄露。</p>\n<p><code>cros</code>模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\" target=\"_blank\" rel=\"external\">CORS协议</a>.只有有限的<a href=\"https://fetch.spec.whatwg.org/#concept-filtered-response-cors\" target=\"_blank\" rel=\"external\">一些</a>headers被暴露给Response对象，但是body是可读的。例如，你可以获得一个Flickr的最感兴趣的照片的清单:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> u = <span class=\"keyword\">new</span> URLSearchParams();</span><br><span class=\"line\">u.append(<span class=\"string\">'method'</span>, <span class=\"string\">'flickr.interestingness.getList'</span>);</span><br><span class=\"line\">u.append(<span class=\"string\">'api_key'</span>, <span class=\"string\">'&lt;insert api key here&gt;'</span>);</span><br><span class=\"line\">u.append(<span class=\"string\">'format'</span>, <span class=\"string\">'json'</span>);</span><br><span class=\"line\">u.append(<span class=\"string\">'nojsoncallback'</span>, <span class=\"string\">'1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> apiCall = fetch(<span class=\"string\">'https://api.flickr.com/services/rest?'</span> + u);</span><br><span class=\"line\"></span><br><span class=\"line\">apiCall.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response.json().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// photo is a list of photos.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.photos.photo;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">photos</span>) </span>&#123;</span><br><span class=\"line\">  photos.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">photo</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(photo.title);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>你无法从Headers中读取’Date’属性，因为Flickr在Access-Control-Expose-Headers中设置了不允许读取它。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.headers.get(<span class=\"string\">'Date'</span>); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure></p>\n<p><code>credentials</code>枚举属性决定了cookies是否能跨域得到。这个属性与XHR的withCredentials标志相同，但是只有三个值，分别是’omit(默认)’、’same-origin’以及’include’。<br>Request对象也可以提供caching hints给用户代理。这个属性还在安全复审阶段。Firefox提供了这个属性，但是它目前还不起作用。<br>Request还有两个只读的属性与ServiceWorkers拦截有关。其中一个是referrer，表示Request的来源，可能为空。另外一个是context，是一个非常大的枚举集合定义了获得的资源的种类，它可能是image比如请求来自于img标签，可能是worker如果是一个worker脚本，等等。如果使用fetch()函数，这个值是fetch。</p>\n<h3 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h3><p>Response实例通常在fetch()的回调中获得。但是它们也可以用JS构造，不过通常这招只用于ServiceWorkers。<br>Response中最常见的成员是status(一个整数默认值是200)和status Text(默认值是’OK’)，对应HTTP请求的status和reason。还有一个’ok’属性，当status为2xx的时候它是true.<br>headers属性是Response的Headers对象，它是只读的，url属性是当前Response的来源URL.<br>Response也有一个type属性，它的值可能是’basic’、’cors’、’default’、’error’或者’opaque’。</p>\n<ul>\n<li>‘basic’: 正常的，同域的请求，包含所有的headers除开’Set-Cookie’和’Set-Cookie2’.</li>\n<li>‘cros’: Response从一个合法的跨域请求获得，<a href=\"https://fetch.spec.whatwg.org/#concept-filtered-response-cors\" target=\"_blank\" rel=\"external\">一部分headers和body</a>可读.</li>\n<li>‘error’: 网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。</li>\n<li>‘opaque’: Response从’no-cros’请求了跨域资源。依靠Server端来做限制。</li>\n</ul>\n<p>‘error’类型会导致fetch()函数的Promise被reject并回调一个TypeError.<br>还有一些属性只在ServiceWorkers作用域下有效。以正确的方式返回一个Response针对一个被ServiceWorkers拦截的Request，可以像下面这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event.responseWith(<span class=\"keyword\">new</span> Response(<span class=\"string\">'Response body'</span>, &#123;</span><br><span class=\"line\">    headers: &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span> &#125;</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，Response有个接收两个可选参数的构造器。第一个参数返回的body，第二个参数是一个json,设置status、statusText以及headers.<br>静态方法Response.error()简单返回一个错误的请求。类似的，Response.redirect(url,status)返回一个跳转URL的请求。</p>\n<h3 id=\"处理body\"><a href=\"#处理body\" class=\"headerlink\" title=\"处理body\"></a>处理body</h3><p>无论Request还是Response都可能带着body。由于body可以是各种类型。body可以是以下任何一种类型的示例:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\" target=\"_blank\" rel=\"external\">ArrayBuffer</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView\" target=\"_blank\" rel=\"external\">ArrayBufferView</a>(Unit8Array and friends)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\" target=\"_blank\" rel=\"external\">Blob</a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File\" target=\"_blank\" rel=\"external\">File</a></li>\n<li>字符串</li>\n<li><a href=\"https://url.spec.whatwg.org/#interface-urlsearchparams\" target=\"_blank\" rel=\"external\">URLSearchParams</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\" target=\"_blank\" rel=\"external\">FormData</a></li>\n</ul>\n<p>此外，Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象。</p>\n<ul>\n<li>arrayBuffer()</li>\n<li>blof()</li>\n<li>json()</li>\n<li>text()</li>\n<li>formData()<br>在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。</li>\n</ul>\n<p>可以通过传body参数来设置Request的body：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> FormData(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'login-form'</span>));</span><br><span class=\"line\">fetch(<span class=\"string\">'/login'</span>, &#123;</span><br><span class=\"line\">  method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  body: form</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Response的第一个参数是body:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"keyword\">new</span> Response(<span class=\"keyword\">new</span> File([<span class=\"string\">'chunk'</span>, <span class=\"string\">'chunk'</span>], <span class=\"string\">'archive.zip'</span>,&#123; type: <span class=\"string\">'application/zip'</span> &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>Request和Response(通过fetch()方法)都能够<a href=\"https://fetch.spec.whatwg.org/#concept-bodyinit-extract\" target=\"_blank\" rel=\"external\">自动识别自己的content type</a>，Request还可以自动设置’Content-Type’header,如果开发者没有设置它的话。</p>\n<h3 id=\"流和克隆\"><a href=\"#流和克隆\" class=\"headerlink\" title=\"流和克隆\"></a>流和克隆</h3><p>非常重要的一点要说明，那就是Request和Response的body只能被读取一次！它们有一个属性叫bodyUsed,读取一次之后设置为true，就不能再读取了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"keyword\">new</span> Response(<span class=\"string\">'one time use'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\">res.text().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.bodyUsed); <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res.bodyUsed); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">res.text().catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Tried to read already consumed Response'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。<br>有时候，我们希望多次访问body，例如，你可能想用即将支持的<a href=\"http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects\" target=\"_blank\" rel=\"external\">Cache API</a>去缓存Request和Response,以便于可以离线使用，Cache要求body能被再次读取。</p>\n<p>所以，我们该如何让body能经得起多次读取呢？API提供了一个clone()方法。调用这个方法可以得到一个克隆对象。不过要记得，<strong>clone()必须要在读取之前调用，也就是先clone()在读取</strong>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sheep = <span class=\"keyword\">new</span> Response(<span class=\"string\">'Dolly'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(sheep.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = sheep.clone();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clone.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  clone.text();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(sheep.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clone.bodyUsed); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  evt.responseWith(cache.add(sheep.clone()).then(fucntion(e)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sheep;</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"未来的改进\"><a href=\"#未来的改进\" class=\"headerlink\" title=\"未来的改进\"></a>未来的改进</h3><p>为了支持流，Fetch最终将提供可以中断执行读取资源的能力，并且提供可以得到读取进度的API。这些能力在XHR中有，但是想要实现成Promise-based的Fetch API有些麻烦。</p>\n","excerpt":"","more":"<blockquote>\n<p>文章转载自<a href=\"http://www.w3ctech.com/topic/854\">这个API很“迷人”——(新的Fetch API)</a>，仅供学习和参考</p>\n</blockquote>\n<h2 id=\"原标题是This-API-is-so-Fetching-Fetching也可以表示迷人的意思\"><a href=\"#原标题是This-API-is-so-Fetching-Fetching也可以表示迷人的意思\" class=\"headerlink\" title=\"原标题是This API is so Fetching, Fetching也可以表示迷人的意思\"></a>原标题是This API is so Fetching, Fetching也可以表示迷人的意思</h2><p>Javascript通过XMLHttpRequest(XHR)来执行异步请求，这个方式已经存在了很长一段时间。虽说他很有用，但他不是最佳API。他在设计上不符合职责分离原则，将输入、输出和用事件来跟踪的状态混杂在一个对象里。而且，基于事件的模型与最近Javascript流行的Promise以及基于生成器的异步编程模型不太搭。</p>\n<p>新的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\">Fetch</a> API打算修正上面提到的那些缺陷。他向JS中引入和HTTP协议中同样的原语。具体而言，它引入一个使用的函数fetch()用来捕捉从网络上检索一个资源的意图。</p>\n<p><a href=\"https://fetch.spec.whatwg.org/\">Fetch规范</a>的API明确了用户代理获取资源的语义。它结合ServiceWorkers，尝试达到以下优化：</p>\n<ol>\n<li>改善离线体验</li>\n<li>保持可扩展性</li>\n</ol>\n<h2 id=\"特性检测\"><a href=\"#特性检测\" class=\"headerlink\" title=\"特性检测\"></a>特性检测</h2><p>要检查是否支持Fetch API，可以通过检查Headers、Request、Response或者fetch在window或者worker作用域中是否存在。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(self.fetch)&#123;</span><br><span class=\"line\">  <span class=\"comment\">//run my fetch request here</span></span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something with XMLHttpRequest</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"简单的fetching示例\"><a href=\"#简单的fetching示例\" class=\"headerlink\" title=\"简单的fetching示例\"></a>简单的fetching示例</h3><p>在Fetch API中，最常用的就是fetch()函数。它接收一个URL参数，返回一个promise来处理response。response参数带着一个Response对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'./data.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// res instanceof response == true</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(res.ok)&#123;</span><br><span class=\"line\">    res.json().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Looks like the response'</span>,res.status);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Fetch failed'</span>,e);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果是提交一个POST请求，代码如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'http://www.example.org/submit.php'</span>,&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'application/x-www-form-urlencoded'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: <span class=\"string\">'firstName=Nikhil&amp;favColor=blue&amp;password=easytoguess'</span></span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(res.ok)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'Perfect! Your settings are saved.'</span>);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(res.status == <span class=\"number\">401</span>)&#123;</span><br><span class=\"line\">    alert(<span class=\"string\">'Oops! You are not authorized.'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  alert(<span class=\"string\">'Error submitting form!'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>fetch()函数的参数和传给Request()构造函数的参数保持完全一致，所以你可以直接传任意复杂的request请求给fetch().</p>\n<h3 id=\"Headers\"><a href=\"#Headers\" class=\"headerlink\" title=\"Headers\"></a>Headers</h3><p>Fetch引入了3个接口，它们分别是Headers、Request以及Response。他们直接对应了相应的HTTP概念，但是基于安全考虑，有些区别，例如支持CORS规则以及保证cookies不能被第三方获取。<br>Headers接口是一个简单的多映射的名-值表<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> reqHeaders = <span class=\"keyword\">new</span> Headers();</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">'Content-Type'</span>,<span class=\"string\">'text/plain'</span>);</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">'Content-Length'</span>,content.length.toString());</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">'X-Custom-Header'</span>,<span class=\"string\">'ProcessThisImmediately'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>也可以传一个多维数组或者json：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reqHeaders = <span class=\"keyword\">new</span> Headers(&#123;</span><br><span class=\"line\">  <span class=\"string\">\"Content-Type\"</span>: <span class=\"string\">\"text/plain\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"Content-Length\"</span>: content.length.toString(),</span><br><span class=\"line\">  <span class=\"string\">\"X-Custom-Header\"</span>: <span class=\"string\">\"ProcessThisImmediately\"</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Headers的内容可以被检索：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">'Content-Type'</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.has(<span class=\"string\">\"Set-Cookie\"</span>));</span><br><span class=\"line\">reqHeaders.set(<span class=\"string\">\"Content-Type\"</span>, <span class=\"string\">\"text/html\"</span>);</span><br><span class=\"line\">reqHeaders.append(<span class=\"string\">\"X-Custom-Header\"</span>, <span class=\"string\">\"AnotherValue\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.get(<span class=\"string\">\"Content-Length\"</span>));</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.getAll(<span class=\"string\">\"X-Custom-Header\"</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">reqHeaders.delete(<span class=\"string\">\"X-Custom-Header\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(reqHeaders.getAll(<span class=\"string\">\"X-Custom-Header\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>一些操作不仅仅对ServiceWorkers有用，本身也提供了更方便的操作Headers的API。</p>\n<p>由于Headers可以在request请求中被发送或者在response请求中被接收，并且规定了哪些参数是可写的，Headers对象有一个特殊的guard属性。这个属性没有暴露给Web，但是它影响到哪些内容可以在Headers对象中被改变。<br>可能的值如下：</p>\n<ul>\n<li>“none”: 默认值。</li>\n<li>“request”: 从Request中获得的Headers只读。</li>\n<li>“request-no-cors”: 从不同域的Request中获得的Headers只读。</li>\n<li>“response”: 从Response获得的Headers只读.</li>\n<li>“immutable”: 在ServiceWorkers中最常用，所有的Headers都只读。</li>\n</ul>\n<p>哪一种guard作用于Headers导致什么行为，详细定义在这个<a href=\"https://fetch.spec.whatwg.org/\">规范</a>中。例如，你不可以添加或者修改一个guard属性是”request”的Request Headers的”Content-Length”属性。同样地，插入”Set-Cookie”属性到一个Response headers是不允许的，因此ServiceWorkers是不能给合成的Request的headers添加一些cookies。</p>\n<p>如果使用了一个不合法的HTTP Header属性名，那么Headers的方法通常都抛出TypeError异常。如果不小心写入了一个不可写的属性，也会抛出一个 TypeError 异常。除此以外的情况，失败了并不抛出异常。例如：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = Response.error();</span><br><span class=\"line\"><span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">  res.headers.set(<span class=\"string\">'Origin'</span>, <span class=\"string\">'http://myback.com'</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">catch</span>(e)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Cannot pretend to be a bank!'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Requset\"><a href=\"#Requset\" class=\"headerlink\" title=\"Requset\"></a>Requset</h3><p>Request接口定义了通过HTTP请求资源的request格式。参数需要URL、method和headers,同时Requset也接受一个特定的body、mode、credentials以及cache hints.<br>最简单的Request当然是一个URL，可以通过URL来GET一个资源。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> req = <span class=\"keyword\">new</span> Request(<span class=\"string\">'./index.html'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.method); <span class=\"comment\">//\"GET\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(req.url);</span><br></pre></td></tr></table></figure></p>\n<p>你也可以将一个建好的Request对象传给构造函数，这样将复制出一个新的Request。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> copy = <span class=\"keyword\">new</span> Request(req);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy.method);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(copy.url);</span><br></pre></td></tr></table></figure></p>\n<p>这种用法通常见于ServiceWorkers.<br>URL以外的其他属性的初始值能够通过第二个参数传给Request构造函数。这个参数是一个json：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> uploadReq = <span class=\"keyword\">new</span> Request(<span class=\"string\">'/uploadImage'</span>,&#123;</span><br><span class=\"line\">  method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  headers: &#123;</span><br><span class=\"line\">    <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'image/png'</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  body: <span class=\"string\">'image data'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>mode属性用来决定是否允许跨域请求，以及哪些response属性可读。可选的mode属性值为<code>same-origin</code>,<code>no-cors</code>以及<code>cors</code>。</p>\n<p><code>same-origin</code>模式很简单，如果一个请求是跨域的，那么返回一个简单的error，这样确保所有的请求遵守同源策略。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arbitraryUrl = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'url-input'</span>).value;</span><br><span class=\"line\">fetch(arbitraryUrl, &#123;mode:<span class=\"string\">'same-origin'</span>&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">res</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Response succeeded '</span>, res.ok);</span><br><span class=\"line\">&#125;,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Please enter a same-orgin URL!'</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p><code>no-cors</code>模式允许来自CDN的脚本、其他域的图片和其他一些跨域的资源，但是首先有个前提条件，就是请求的method只能是’HEAD’、’GET’或者’POST’。此外，任何ServiceWorkers拦截了这些请求，它不能随意添加或者改写任何headers，除了<a href=\"https://fetch.spec.whatwg.org/#simple-header\">这些</a>。第三，javascript不能访问Response中的任何属性，这保证了ServiceWorkers不会导致任何跨域下的安全问题而隐私信息泄露。</p>\n<p><code>cros</code>模式我们通常用作跨域请求来从第三方提供的API获取数据。这个模式遵守<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\">CORS协议</a>.只有有限的<a href=\"https://fetch.spec.whatwg.org/#concept-filtered-response-cors\">一些</a>headers被暴露给Response对象，但是body是可读的。例如，你可以获得一个Flickr的最感兴趣的照片的清单:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> u = <span class=\"keyword\">new</span> URLSearchParams();</span><br><span class=\"line\">u.append(<span class=\"string\">'method'</span>, <span class=\"string\">'flickr.interestingness.getList'</span>);</span><br><span class=\"line\">u.append(<span class=\"string\">'api_key'</span>, <span class=\"string\">'&lt;insert api key here&gt;'</span>);</span><br><span class=\"line\">u.append(<span class=\"string\">'format'</span>, <span class=\"string\">'json'</span>);</span><br><span class=\"line\">u.append(<span class=\"string\">'nojsoncallback'</span>, <span class=\"string\">'1'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> apiCall = fetch(<span class=\"string\">'https://api.flickr.com/services/rest?'</span> + u);</span><br><span class=\"line\"></span><br><span class=\"line\">apiCall.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> response.json().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// photo is a list of photos.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.photos.photo;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">photos</span>) </span>&#123;</span><br><span class=\"line\">  photos.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">photo</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(photo.title);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>你无法从Headers中读取’Date’属性，因为Flickr在Access-Control-Expose-Headers中设置了不允许读取它。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.headers.get(<span class=\"string\">'Date'</span>); <span class=\"comment\">//null</span></span><br></pre></td></tr></table></figure></p>\n<p><code>credentials</code>枚举属性决定了cookies是否能跨域得到。这个属性与XHR的withCredentials标志相同，但是只有三个值，分别是’omit(默认)’、’same-origin’以及’include’。<br>Request对象也可以提供caching hints给用户代理。这个属性还在安全复审阶段。Firefox提供了这个属性，但是它目前还不起作用。<br>Request还有两个只读的属性与ServiceWorkers拦截有关。其中一个是referrer，表示Request的来源，可能为空。另外一个是context，是一个非常大的枚举集合定义了获得的资源的种类，它可能是image比如请求来自于img标签，可能是worker如果是一个worker脚本，等等。如果使用fetch()函数，这个值是fetch。</p>\n<h3 id=\"Response\"><a href=\"#Response\" class=\"headerlink\" title=\"Response\"></a>Response</h3><p>Response实例通常在fetch()的回调中获得。但是它们也可以用JS构造，不过通常这招只用于ServiceWorkers。<br>Response中最常见的成员是status(一个整数默认值是200)和status Text(默认值是’OK’)，对应HTTP请求的status和reason。还有一个’ok’属性，当status为2xx的时候它是true.<br>headers属性是Response的Headers对象，它是只读的，url属性是当前Response的来源URL.<br>Response也有一个type属性，它的值可能是’basic’、’cors’、’default’、’error’或者’opaque’。</p>\n<ul>\n<li>‘basic’: 正常的，同域的请求，包含所有的headers除开’Set-Cookie’和’Set-Cookie2’.</li>\n<li>‘cros’: Response从一个合法的跨域请求获得，<a href=\"https://fetch.spec.whatwg.org/#concept-filtered-response-cors\">一部分headers和body</a>可读.</li>\n<li>‘error’: 网络错误。Response的status是0，Headers是空的并且不可写。当Response是从Response.error()中得到时，就是这种类型。</li>\n<li>‘opaque’: Response从’no-cros’请求了跨域资源。依靠Server端来做限制。</li>\n</ul>\n<p>‘error’类型会导致fetch()函数的Promise被reject并回调一个TypeError.<br>还有一些属性只在ServiceWorkers作用域下有效。以正确的方式返回一个Response针对一个被ServiceWorkers拦截的Request，可以像下面这样写：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123;</span><br><span class=\"line\">  event.responseWith(<span class=\"keyword\">new</span> Response(<span class=\"string\">'Response body'</span>, &#123;</span><br><span class=\"line\">    headers: &#123; <span class=\"string\">'Content-Type'</span>: <span class=\"string\">'text/plain'</span> &#125;</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如你所见，Response有个接收两个可选参数的构造器。第一个参数返回的body，第二个参数是一个json,设置status、statusText以及headers.<br>静态方法Response.error()简单返回一个错误的请求。类似的，Response.redirect(url,status)返回一个跳转URL的请求。</p>\n<h3 id=\"处理body\"><a href=\"#处理body\" class=\"headerlink\" title=\"处理body\"></a>处理body</h3><p>无论Request还是Response都可能带着body。由于body可以是各种类型。body可以是以下任何一种类型的示例:</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer\">ArrayBuffer</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ArrayBufferView\">ArrayBufferView</a>(Unit8Array and friends)</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Blob\">Blob</a>/<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/File\">File</a></li>\n<li>字符串</li>\n<li><a href=\"https://url.spec.whatwg.org/#interface-urlsearchparams\">URLSearchParams</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/FormData\">FormData</a></li>\n</ul>\n<p>此外，Request和Response都为他们的body提供了以下方法，这些方法都返回一个Promise对象。</p>\n<ul>\n<li>arrayBuffer()</li>\n<li>blof()</li>\n<li>json()</li>\n<li>text()</li>\n<li>formData()<br>在使用非文本的数据方面，Fetch API和XHR相比提供了极大的便利。</li>\n</ul>\n<p>可以通过传body参数来设置Request的body：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> form = <span class=\"keyword\">new</span> FormData(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'login-form'</span>));</span><br><span class=\"line\">fetch(<span class=\"string\">'/login'</span>, &#123;</span><br><span class=\"line\">  method: <span class=\"string\">'POST'</span>,</span><br><span class=\"line\">  body: form</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Response的第一个参数是body:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"keyword\">new</span> Response(<span class=\"keyword\">new</span> File([<span class=\"string\">'chunk'</span>, <span class=\"string\">'chunk'</span>], <span class=\"string\">'archive.zip'</span>,&#123; type: <span class=\"string\">'application/zip'</span> &#125;));</span><br></pre></td></tr></table></figure></p>\n<p>Request和Response(通过fetch()方法)都能够<a href=\"https://fetch.spec.whatwg.org/#concept-bodyinit-extract\">自动识别自己的content type</a>，Request还可以自动设置’Content-Type’header,如果开发者没有设置它的话。</p>\n<h3 id=\"流和克隆\"><a href=\"#流和克隆\" class=\"headerlink\" title=\"流和克隆\"></a>流和克隆</h3><p>非常重要的一点要说明，那就是Request和Response的body只能被读取一次！它们有一个属性叫bodyUsed,读取一次之后设置为true，就不能再读取了。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> res = <span class=\"keyword\">new</span> Response(<span class=\"string\">'one time use'</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\">res.text().then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(res.bodyUsed); <span class=\"comment\">//true</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(res.bodyUsed); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">res.text().catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Tried to read already consumed Response'</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这样设计的目的是为了之后兼容基于流的API，让应用一次消费data，这样就允许了JavaScript处理大文件例如视频，并且可以支持实时压缩和编辑。<br>有时候，我们希望多次访问body，例如，你可能想用即将支持的<a href=\"http://slightlyoff.github.io/ServiceWorker/spec/service_worker/index.html#cache-objects\">Cache API</a>去缓存Request和Response,以便于可以离线使用，Cache要求body能被再次读取。</p>\n<p>所以，我们该如何让body能经得起多次读取呢？API提供了一个clone()方法。调用这个方法可以得到一个克隆对象。不过要记得，<strong>clone()必须要在读取之前调用，也就是先clone()在读取</strong>。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">evt</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sheep = <span class=\"keyword\">new</span> Response(<span class=\"string\">'Dolly'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(sheep.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> clone = sheep.clone();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clone.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\"></span><br><span class=\"line\">  clone.text();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(sheep.bodyUsed); <span class=\"comment\">//false</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(clone.bodyUsed); <span class=\"comment\">//true</span></span><br><span class=\"line\"></span><br><span class=\"line\">  evt.responseWith(cache.add(sheep.clone()).then(fucntion(e)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sheep;</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"未来的改进\"><a href=\"#未来的改进\" class=\"headerlink\" title=\"未来的改进\"></a>未来的改进</h3><p>为了支持流，Fetch最终将提供可以中断执行读取资源的能力，并且提供可以得到读取进度的API。这些能力在XHR中有，但是想要实现成Promise-based的Fetch API有些麻烦。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cirlo0elf0000b0dlk2s310sx","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0em9000cb0dld4pzt7qh"},{"post_id":"cirlo0em4000bb0dlpph7942x","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0emg000hb0dlybouhgkq"},{"post_id":"cirlo0eln0002b0dl58xj7aqe","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0emo000lb0dlfds72hsn"},{"post_id":"cirlo0emf000gb0dl51elblh5","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0emp000ob0dl67tn5rmz"},{"post_id":"cirlo0elu0005b0dl1gvd8sq5","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0ems000tb0dle0dyechq"},{"post_id":"cirlo0elw0006b0dl54fm7ryc","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0emv000xb0dlzvsr5h7n"},{"post_id":"cirlo0emq000qb0dlejmu0kl8","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0emz0011b0dlc4lbw1yr"},{"post_id":"cirlo0emt000ub0dlfwaq5pc9","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0en40014b0dl8ztziw1r"},{"post_id":"cirlo0em00008b0dl1216gtgb","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0en80018b0dllcbz98uj"},{"post_id":"cirlo0emu000vb0dl4hueiw5m","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0en9001ab0dlqwk2mb1z"},{"post_id":"cirlo0emy0010b0dlsbqpksqu","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0enb001eb0dl4epfbvwl"},{"post_id":"cirlo0ema000eb0dld4kijfg5","category_id":"cirlo0emv000yb0dlmhfm7xa5","_id":"cirlo0enc001hb0dlg28g53kn"},{"post_id":"cirlo0en00013b0dl6rjvsp7v","category_id":"cirlo0emv000yb0dlmhfm7xa5","_id":"cirlo0end001lb0dlmn7xnp3a"},{"post_id":"cirlo0en60017b0dlyp6r8zn8","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0enf001ob0dlkd5b980y"},{"post_id":"cirlo0emn000ib0dlvmn1vefy","category_id":"cirlo0emv000yb0dlmhfm7xa5","_id":"cirlo0eni001sb0dlxb4wsh4l"},{"post_id":"cirlo0en80019b0dlehu29xmt","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0enm001vb0dlu9sa6fte"},{"post_id":"cirlo0ena001db0dlxqfcj8y2","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0eno001zb0dlqga6g3t8"},{"post_id":"cirlo0emp000nb0dlinursj4d","category_id":"cirlo0emv000yb0dlmhfm7xa5","_id":"cirlo0enp0022b0dlzf7uttyh"},{"post_id":"cirlo0enb001gb0dl6qugibkq","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0enr0026b0dlj5ez3art"},{"post_id":"cirlo0end001kb0dlrno8814u","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0ens0029b0dluj17b8gt"},{"post_id":"cirlo0ene001nb0dl6hskbg1v","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0ent002db0dl2lgqv0jr"},{"post_id":"cirlo0enf001rb0dlbx38v3mk","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0env002hb0dliag6yt3v"},{"post_id":"cirlo0enj001ub0dl3uk3dzek","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0enx002lb0dltxaulc82"},{"post_id":"cirlo0enm001xb0dlrblyifif","category_id":"cirlo0emo000kb0dldl5b4905","_id":"cirlo0eo4002pb0dlmk79lmra"},{"post_id":"cirlo0eno0021b0dldn36fu31","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0eo6002sb0dl5vfwrd2d"},{"post_id":"cirlo0ent002cb0dlqi87uuj3","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0eo8002wb0dlx7mc8pqo"},{"post_id":"cirlo0enu002gb0dlao3ipbx5","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0eo9002zb0dl5tzurg2k"},{"post_id":"cirlo0enq0024b0dl3yz1g4t5","category_id":"cirlo0ens002bb0dlhgd76615","_id":"cirlo0eoa0032b0dlv4zpn6si"},{"post_id":"cirlo0env002jb0dls7z4cqk5","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0eoa0034b0dl75badtr7"},{"post_id":"cirlo0enz002ob0dl62iin9ms","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0eoa0037b0dl5ah5nomq"},{"post_id":"cirlo0enr0028b0dlnjqmj27o","category_id":"cirlo0ens002bb0dlhgd76615","_id":"cirlo0eob0039b0dl6j75k4ej"},{"post_id":"cirlo0eo5002rb0dldnek7jzg","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0eob003cb0dljoxpl5p7"},{"post_id":"cirlo0eo7002vb0dlj5s4a4hi","category_id":"cirlo0em10009b0dlfjjcnjon","_id":"cirlo0eob003eb0dluezt8k34"},{"post_id":"cirlo0eo8002yb0dljs8789c1","category_id":"cirlo0elr0004b0dltsse9log","_id":"cirlo0eoc003gb0dlsq02o9co"}],"PostTag":[{"post_id":"cirlo0elf0000b0dlk2s310sx","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0em3000ab0dlye1s00a6"},{"post_id":"cirlo0eln0002b0dl58xj7aqe","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0emo000mb0dlho1ai7t0"},{"post_id":"cirlo0eln0002b0dl58xj7aqe","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0emq000pb0dlnulu6u0s"},{"post_id":"cirlo0elu0005b0dl1gvd8sq5","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0emx000zb0dlhbnksvmd"},{"post_id":"cirlo0elu0005b0dl1gvd8sq5","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0en00012b0dlkwsv4jvy"},{"post_id":"cirlo0elw0006b0dl54fm7ryc","tag_id":"cirlo0emu000wb0dlsand5jzp","_id":"cirlo0enb001fb0dlidaw5grq"},{"post_id":"cirlo0elw0006b0dl54fm7ryc","tag_id":"cirlo0en50015b0dl7x3rk1xs","_id":"cirlo0enc001ib0dlcgaur6m9"},{"post_id":"cirlo0ena001db0dlxqfcj8y2","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0end001mb0dls6x5h5qz"},{"post_id":"cirlo0ena001db0dlxqfcj8y2","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0enf001pb0dlg27wkeri"},{"post_id":"cirlo0em00008b0dl1216gtgb","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eni001tb0dl913h7ipi"},{"post_id":"cirlo0em00008b0dl1216gtgb","tag_id":"cirlo0en9001bb0dl23bayv0g","_id":"cirlo0enm001wb0dlfx8t8p0x"},{"post_id":"cirlo0em00008b0dl1216gtgb","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0eno0020b0dld89jb2gd"},{"post_id":"cirlo0enf001rb0dlbx38v3mk","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0enp0023b0dlo4s18q9e"},{"post_id":"cirlo0enf001rb0dlbx38v3mk","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0enr0027b0dle3g4hro8"},{"post_id":"cirlo0enj001ub0dl3uk3dzek","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0ens002ab0dlyo7jjaal"},{"post_id":"cirlo0enj001ub0dl3uk3dzek","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0enu002fb0dlqul5ydfb"},{"post_id":"cirlo0em4000bb0dlpph7942x","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0env002ib0dlg0cc9f72"},{"post_id":"cirlo0em4000bb0dlpph7942x","tag_id":"cirlo0enf001qb0dl5hclql1j","_id":"cirlo0enz002nb0dl8cfrrran"},{"post_id":"cirlo0ema000eb0dld4kijfg5","tag_id":"cirlo0en9001bb0dl23bayv0g","_id":"cirlo0eo4002qb0dl5xxswct4"},{"post_id":"cirlo0ema000eb0dld4kijfg5","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eo7002ub0dl41inavh9"},{"post_id":"cirlo0emf000gb0dl51elblh5","tag_id":"cirlo0enq0025b0dl3our2p33","_id":"cirlo0eo8002xb0dl8zb9vqe6"},{"post_id":"cirlo0emf000gb0dl51elblh5","tag_id":"cirlo0ent002eb0dl661kxsrn","_id":"cirlo0eo90031b0dl6w30qusi"},{"post_id":"cirlo0env002jb0dls7z4cqk5","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoa0033b0dl934jcn4o"},{"post_id":"cirlo0env002jb0dls7z4cqk5","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0eoa0035b0dl6seycz9m"},{"post_id":"cirlo0enz002ob0dl62iin9ms","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoa0038b0dl6lae8uew"},{"post_id":"cirlo0enz002ob0dl62iin9ms","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0eob003ab0dl6bm0nwid"},{"post_id":"cirlo0emn000ib0dlvmn1vefy","tag_id":"cirlo0en9001bb0dl23bayv0g","_id":"cirlo0eob003db0dlajw76tqb"},{"post_id":"cirlo0emn000ib0dlvmn1vefy","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoc003fb0dlpg5omn2w"},{"post_id":"cirlo0eo7002vb0dlj5s4a4hi","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoc003ib0dli1qsax3w"},{"post_id":"cirlo0eo7002vb0dlj5s4a4hi","tag_id":"cirlo0ema000db0dlqiha4s1b","_id":"cirlo0eoc003jb0dll65aknm2"},{"post_id":"cirlo0emp000nb0dlinursj4d","tag_id":"cirlo0en9001bb0dl23bayv0g","_id":"cirlo0eod003lb0dlm83fwmj5"},{"post_id":"cirlo0emp000nb0dlinursj4d","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eod003mb0dlc22rzzug"},{"post_id":"cirlo0emq000qb0dlejmu0kl8","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoe003nb0dlg0nj62vr"},{"post_id":"cirlo0emq000qb0dlejmu0kl8","tag_id":"cirlo0eo90030b0dlnbzovuip","_id":"cirlo0eof003pb0dl4n6ozvma"},{"post_id":"cirlo0emt000ub0dlfwaq5pc9","tag_id":"cirlo0eoa0036b0dlo2u6ewda","_id":"cirlo0eof003qb0dl8a847z8y"},{"post_id":"cirlo0emt000ub0dlfwaq5pc9","tag_id":"cirlo0eob003bb0dlwlshfpxr","_id":"cirlo0eog003sb0dlu09nj6e2"},{"post_id":"cirlo0emu000vb0dl4hueiw5m","tag_id":"cirlo0eoc003hb0dldt4qq3cn","_id":"cirlo0eog003tb0dl78i4w7pp"},{"post_id":"cirlo0emu000vb0dl4hueiw5m","tag_id":"cirlo0eod003kb0dl28981sfe","_id":"cirlo0eog003vb0dlgpwafiqc"},{"post_id":"cirlo0emy0010b0dlsbqpksqu","tag_id":"cirlo0eoe003ob0dlmxsaxq31","_id":"cirlo0eoh003wb0dl21nii2qf"},{"post_id":"cirlo0emy0010b0dlsbqpksqu","tag_id":"cirlo0eog003rb0dlwo5lrd6s","_id":"cirlo0eoh003yb0dl9r8b1qyr"},{"post_id":"cirlo0en00013b0dl6rjvsp7v","tag_id":"cirlo0en9001bb0dl23bayv0g","_id":"cirlo0eoh003zb0dl67iur9p7"},{"post_id":"cirlo0en00013b0dl6rjvsp7v","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoh0041b0dlsvs5twvy"},{"post_id":"cirlo0en60017b0dlyp6r8zn8","tag_id":"cirlo0eoh003xb0dlhwzpg1nd","_id":"cirlo0eoi0043b0dlcgebqsz4"},{"post_id":"cirlo0en60017b0dlyp6r8zn8","tag_id":"cirlo0enq0025b0dl3our2p33","_id":"cirlo0eoi0044b0dlk2lfeqso"},{"post_id":"cirlo0en80019b0dlehu29xmt","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoi0046b0dlh6iv64fo"},{"post_id":"cirlo0en80019b0dlehu29xmt","tag_id":"cirlo0eoi0042b0dlpcl66jy4","_id":"cirlo0eoj0047b0dloefylbu9"},{"post_id":"cirlo0enb001gb0dl6qugibkq","tag_id":"cirlo0enq0025b0dl3our2p33","_id":"cirlo0eoj004ab0dlxxdw0hfu"},{"post_id":"cirlo0enb001gb0dl6qugibkq","tag_id":"cirlo0ent002eb0dl661kxsrn","_id":"cirlo0eoj004bb0dlg2qirdut"},{"post_id":"cirlo0end001kb0dlrno8814u","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eok004db0dlbv04tg3d"},{"post_id":"cirlo0end001kb0dlrno8814u","tag_id":"cirlo0eoi0042b0dlpcl66jy4","_id":"cirlo0eok004eb0dl1gmveadc"},{"post_id":"cirlo0ene001nb0dl6hskbg1v","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eol004gb0dlkya5rb8l"},{"post_id":"cirlo0ene001nb0dl6hskbg1v","tag_id":"cirlo0eok004cb0dlcxvt9nl5","_id":"cirlo0eol004hb0dlyhafec7s"},{"post_id":"cirlo0enm001xb0dlrblyifif","tag_id":"cirlo0eoc003hb0dldt4qq3cn","_id":"cirlo0eom004kb0dlpiaebfyy"},{"post_id":"cirlo0enm001xb0dlrblyifif","tag_id":"cirlo0eol004ib0dl8df8p69y","_id":"cirlo0eom004lb0dlol8meyv1"},{"post_id":"cirlo0eno0021b0dldn36fu31","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eon004nb0dl5wicf6vo"},{"post_id":"cirlo0eno0021b0dldn36fu31","tag_id":"cirlo0eom004jb0dlscexuj1y","_id":"cirlo0eon004ob0dl3npgecnf"},{"post_id":"cirlo0enq0024b0dl3yz1g4t5","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoo004qb0dlqcc47ryl"},{"post_id":"cirlo0enq0024b0dl3yz1g4t5","tag_id":"cirlo0eom004mb0dlykk7s8ig","_id":"cirlo0eoo004rb0dlbjhacrlg"},{"post_id":"cirlo0enr0028b0dlnjqmj27o","tag_id":"cirlo0enq0025b0dl3our2p33","_id":"cirlo0eoo004tb0dljrl3mfap"},{"post_id":"cirlo0enr0028b0dlnjqmj27o","tag_id":"cirlo0ent002eb0dl661kxsrn","_id":"cirlo0eop004ub0dlswf8ddki"},{"post_id":"cirlo0ent002cb0dlqi87uuj3","tag_id":"cirlo0enq0025b0dl3our2p33","_id":"cirlo0eop004wb0dlpogqg2kw"},{"post_id":"cirlo0ent002cb0dlqi87uuj3","tag_id":"cirlo0ent002eb0dl661kxsrn","_id":"cirlo0eop004xb0dl03hnbu1y"},{"post_id":"cirlo0enu002gb0dlao3ipbx5","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eoq004zb0dlwdwzbj7a"},{"post_id":"cirlo0enu002gb0dlao3ipbx5","tag_id":"cirlo0eop004vb0dlq2jifh3l","_id":"cirlo0eoq0050b0dlphcile0t"},{"post_id":"cirlo0eo5002rb0dldnek7jzg","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eor0052b0dl2vgt9qnw"},{"post_id":"cirlo0eo5002rb0dldnek7jzg","tag_id":"cirlo0eoq004yb0dl3poyap1z","_id":"cirlo0eos0053b0dlphg43avl"},{"post_id":"cirlo0eo8002yb0dljs8789c1","tag_id":"cirlo0elq0003b0dlm47cghx4","_id":"cirlo0eos0054b0dl9rtl1f2c"},{"post_id":"cirlo0eo8002yb0dljs8789c1","tag_id":"cirlo0eoq004yb0dl3poyap1z","_id":"cirlo0eos0055b0dl3v4x434f"}],"Tag":[{"name":"javascript","_id":"cirlo0elq0003b0dlm47cghx4"},{"name":"函数式编程","_id":"cirlo0ema000db0dlqiha4s1b"},{"name":"animation","_id":"cirlo0emu000wb0dlsand5jzp"},{"name":"css3","_id":"cirlo0en50015b0dl7x3rk1xs"},{"name":"es6","_id":"cirlo0en9001bb0dl23bayv0g"},{"name":"JSON","_id":"cirlo0enf001qb0dl5hclql1j"},{"name":"react","_id":"cirlo0enq0025b0dl3our2p33"},{"name":"Redux","_id":"cirlo0ent002eb0dl661kxsrn"},{"name":"reduce","_id":"cirlo0eo90030b0dlnbzovuip"},{"name":"zepto","_id":"cirlo0eoa0036b0dlo2u6ewda"},{"name":"学习笔记","_id":"cirlo0eob003bb0dlwlshfpxr"},{"name":"webpack","_id":"cirlo0eoc003hb0dldt4qq3cn"},{"name":"快速上手","_id":"cirlo0eod003kb0dl28981sfe"},{"name":"flexible","_id":"cirlo0eoe003ob0dlmxsaxq31"},{"name":"终端适配","_id":"cirlo0eog003rb0dlwo5lrd6s"},{"name":"immutable","_id":"cirlo0eoh003xb0dlhwzpg1nd"},{"name":"service worker","_id":"cirlo0eoi0042b0dlpcl66jy4"},{"name":"promise","_id":"cirlo0eok004cb0dlcxvt9nl5"},{"name":"模块系统","_id":"cirlo0eol004ib0dl8df8p69y"},{"name":"流程控制和错误处理","_id":"cirlo0eom004jb0dlscexuj1y"},{"name":"tips","_id":"cirlo0eom004mb0dlykk7s8ig"},{"name":"语法和数据类型","_id":"cirlo0eop004vb0dlq2jifh3l"},{"name":"protocol","_id":"cirlo0eoq004yb0dl3poyap1z"}]}}