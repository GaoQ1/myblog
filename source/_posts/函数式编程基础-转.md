---
title: 函数式编程基础(转)
date: 2016-05-18 11:50:30
tags:
- javascript
- 函数式编程
categories: 转载笔记
---
> 在这章，会覆盖函数式编程的核心概念：
 - 使用函数和数组实现控制流
 - 编写纯函数、匿名函数、递归函数等等
 - 像对象那样传递函数
 - 利用map()、filter()和reduce()函数

## char1.函数式编程语言
函数式编程语言是哪些方便与使用函数式编程范式的语言。简单来说，如果剧本函数式编程所需的特征，它就可以被称为函数式语言。在多数情况下，编程的风格实际上决定了一个程序是否是函数式的。

### 是什么让一个语言具有函数式特征？
函数式编程无法用C语言来实现。函数式编程也无法用Java来实现。这些语言不包含支持函数式编程的结构。他们是纯面向对象的、严格非函数式的语言。

同时，纯函数语言也无法使用面向对象编程，比如Scheme、Haskell以及Lisp。

然而有些语言两种模式都支持。Python是个著名的例子。不过还有别的：Ruby,Julia，以及我最感兴趣的Javascript。这些语言是如何支持这两种差别如此之大的设计模式？他们包含两种编程范式所需要的特征。然而对于Javascript来说，函数式的特征似乎是被隐藏了。

| 特点 | 命令式 | 函数式 |
| ----- | :-----: | :-----: |
| 编程风格 | 一步一步地执行，并且要管理状态的变化 | 描述问题和所需的数据变化已解决问题 |
| 状态变化 | 很重要 | 不存在 |
| 执行顺序 | 很重要 | 不太重要 |
| 主要的控制流 | 循环、条件、函数调用 | 函数调用和递归 |
| 主要的操作单元 | 结构体和类对象 | 函数作为一等公民的对象和数据集 |

函数式语言的语法必须要顾及到特定的设计模式，比如类型推断系统和匿名函数。大体上，这个语言必须实现lambda演算。并且解释器的求值策略必须是非严格、按需调用(也叫做延迟执行)，它允许不变数据结构和非严格、惰性求值。

> 注：这一段用了一些函数式编程的专业词汇。lambda演算是一套函数推演的形式化系统，它的先决条件是内部函数和匿名函数。非严格求值和惰性求职差不多差不多同一个意思，就是非严格地按照运算规则把所有元素先计算一遍，而是根据最终的需求只计算有用的把一部分，比如我们要去有一百个元素的数组的前三项，那惰性求值只会计算出一个具有三个元素是数组，而不会先去计算那个一百个元素的数组。

### 优点
当你最终掌握了函数式编程它将给你巨大的启迪。这样的经验会让你后面的程序员生涯更上一个台阶， 无论你是否真的会成为一个全职的函数式程序员。

不过我们现在不是在讨论如何去学习冥想；我们正在探讨如何去学习一个非常有用的工具，它将会让你成为一个更好的程序员。

总的来说，什么是使用函数式编程真正实际的优点呢？

### 更加简洁的代码
函数式编程更简洁、更简单、更小。它简化了调试、测试和维护。

例如，我们需要这样一个函数，它能将二维数组转化成一维数组。如果只用命令式的技术，我们会写成这样：
```javascript
    function merge2dArrayIntoOne(arrays){
        var count = arrays.length;
        var merged = new Array(count);
        var c = 0;
        for(var i=0;i<count;i++){
            for(var j=0,jlen = array[i].length;j<jlen;j++){
                merged[c++] = arrays[i][j];
            }
        }
        return merged;
    }
```

现在使用函数式技术，可以写成这样：
```javascript
   var merge2dArrayIntoOne = function(arrays){
    return arrays.reduce(function(p,n){
        return p.concat(n);
    });
   };
```

这两个函数具有同样的输入并返回相同的输出，但是函数式的例子更简洁。

### 模块化
函数式编程强制把大型问题拆分解决同样问题的更小的情形，这就意味着代码会更加模块化。模块化的程序具有更清晰的描述，更易调试，维护起来也更简单。测试也会变得更加容易，这是由于每一个模块的代码都可以单独检测正确性。

### 复用性
由于其模块化的特性，函数式编程会有许多通用的辅助函数。你将会发现这里面的许多函数可以在大量不同的应用里重用。

在后面的章节里，许多最通用的函数将会被覆盖到。然而，作为一个函数式程序员，你将会不可避免地编写自己的函数库， 这些函数会被一次又一次地使用。例如一个用于在行间查找配置文件的函数，如果设计好了也可以用于查找Hash表。

### 减少耦合
耦合是程序里模块间的大量依赖。由于函数式编程遵循编写一等公民、高阶的纯函数，这使得他们对全局变量没有副作用而彼此完全独立，耦合极大程度上的见笑了。当然，函数会不可避免地相互依赖，但是改变一个函数不会影响其他的，只要输入输出的一对一映射保持正确。

### 数学正确性
最后一点更理论一些。由于根植于lambda演算，函数式编程可以在数学上证明正确性。 这对于一些研究者来说是一个巨大的优点，他们需要用程序来证明增长率、时间复杂度以及数学正确性。

### 非函数式世界中的函数式编程
函数式和非函数式编程能混合在一起吗？

这本书并没要想要教你如何严格地用纯函数编程来实现整个应用。这样的应用在学术界之外不太适合。 相反，这本书是要教你如何在必要的命令式代码之上使用纯函数的设计策略。

例如，你需要在一段文本中找出头四个只含有字母的单词，稚嫩一些的写法会是这样：

```javascript
    var words = [];count = 0;
    text = myString.split(' ');
    for(var i=0;count<4,i<text.length;i++){
        if(!text[i].match(/[0-9]/)){
            words = words.concat(text[i]);
            count++;
        }
    }
```

函数式编程会这样写：

```javascript
    var words = [];
    var words = myString.split(' ').filter(function(x){
        return (!x.match(/[0-9]/));
    }).slice(0,4);
    console.log(words);
```

如果有一个函数式编程的工具库，代码可以进一步被简化：

```javascript
    var words = toSequence(myString).match(/[a-zA-Z]+/).first(4);
```

判断一个函数是否能被写成更加函数式的方式是寻找循环和临时变量，比如前面例子里面的"words"和"count"变量。我们通常可以用高阶函数来替换循环和临时变量，本章后面的部分将对其继续探索。

### Javascript是函数式编程语言吗？
现在还有最后一个问题我们需要问问自己，Javascript是函数式语言还是非函数式语言？

Javascript可以说是世界上最流行却最没有被理解的函数式编程语言。Javascript是一个披着C外衣的函数式编程语言。 它的语法无疑和C比较像，这意味着它使用C语言的块式语法和中缀语序。并且它是现存语言中名字起得最差劲的。 你不用去想象就可以看出来有多少人会因Javascript和Java的关系而迷惑，就好像它的名字暗示了它会是什么样的东西！ 但实际上它和Java的共同点非常少。不过还真有一些要把Javascript强制弄成面向对象语言的主意， 比如Dojo、ease.js这些库曾做了大量工作试图抽象Javascript以使其适合面向对象编程。 Javascript来自于90年代那个满世界都嚷嚷着面向对象的时代，我们被告知Javascript是一个面向对象语言是因为我们希望它是这样， 但实际上它不是。

它的真实身份可以追溯到它的原型：Scheme和Lisp，两个经典的函数式编程语言。Javascript一直都是一个函数式编程语言。 它的函数是头等公民，并且可以嵌套，它具有闭包和复合函数，它允许珂理化和monad。所有这些都是函数式编程的关键。 这里另外还有一些Javascript是函数式语言的原因：

 - Javascript的语法包括了传递函数为参数的能力，具有类型推断系统，支持匿名函数、高阶函数、闭包等等。这些特点对构成函数式编程的结构和行为至关重要。
 - Javascript不是一个纯面向对象语言，它的多数面向对象设计模式都是通过拷贝Prototype对象来完成的， 这是一个弱面向对象编程的模型。
 - Javascript是一个解释型语言。Javascript的解释器（有时被称为“引擎”）非常类似于Scheme的解释器。 它们都是动态的，都有易于组合和传输的灵活的数据类型，都把代码求值为表达式块，处理函数的方式也类似。
 
也就是说，Javascript的确不是一个纯函数式语言。它缺乏惰性求值和内建的不可变数据。 这是由于大多数解释器是按名调用，而不是按需调用。Javascript由于其尾调用的处理方式也不太善于处理递归。 不过所有的这些问题都可以通过一些小的注意事项来缓和。需要无穷序列和惰性求值的非严格求值可以通过一个叫Lazy.js的库来实现。 不可变量只需要简单的通过编程技巧就可以实现，不过它不是通过依赖语言层面来限制而是需要程序员自律。 尾递归消除可以通过一个叫Trampolining的方法实现。这些问题将在第六章讲解。

关于Javascript是函数式语言还是面向对象语言还是两者皆是还是两者皆非的争论一直都很多，而且这些争论还要继续下去。

最后，函数式编程是通过巧妙的变化、组合、使用函数而实现编写简洁代码的方式。而且Javascript为实现这些提供了很好的途径。 如果你真要挖掘出Javascript全部的潜能，你必须学会如何将它作为一个函数式语言来使用。

## char2.与函数共舞
> 有时，优雅的实现是一个函数。不是方法。不是类。不是框架。只是函数。 --John Carmack，游戏《毁灭战士》首席程序员

函数式编程全都是关于如何把一个问题分解为一系列函数的。通常，函数会链在一起，互相嵌套，来回传递，被视为头等公民。如果你使用过诸如jQuery或Node.js这样的框架，你应该用过一些这样的技术，只不过你没有意思到。

我们从Javascript的一个小尴尬开始。

假设我们需要一个值的列表，这些只会赋值给普通的对象。这些对象可能包含任何东西：数据、HTML对象等等。

```javascript
    var obj1 = {value:1},
        obj2 = {value:2},
        obj2 = {value:3};
    var values = [];
    function accumulate(obj){
        values.push(obj.value);
    }
    accumulate(obj1);
    accumulate(obj2);
    console.log(values); //Output: [obj1.value,obj2.value]
```

这个代码能用但是不稳定。任何代码都可以不通过accumulate()函数改变values对象。而且如果我们忘记了给values附上空数组[]，这个代码压根儿就不会工作。

但是如果变量声明在函数内部，他就不会被任何捣蛋的代码给更改。

```javascript
    function accumulate2(obj){
        var values = [];
        values.push(obj.value);
        return values;
    }
    console.log(accumulate2(obj1)); // Returns: [obj1.value]
    console.log(accumulate2(obj2)); // Returns: [obj2.value]
    console.log(accumulate2(obj3)); // Returns: [obj3.value]
```

只有最后传入的那个对象的值才被返回。我们也许可以通过在第一个函数内部嵌套一个函数来解决这个问题。

```javascript
    var ValueAccumulator = function(obj){
        var values = [];
        var accumulate = function(){
            value.push(obj.value);
        };
        accumulate();
        return values;
    }
```

可是问题依然存在，而且我们现在无法访问accumulate函数和values变量了。

我们需要的是一个自调用函数

### 自调用函数和闭包
如果我们能够返回一个可以依次返回values数组的函数表达式怎么样？在函数内声明的变量可以被函数内的所有代码访问到，包括自调用函数。
```javascript
    var ValueAccumulator = function(){
        var values = [];
        var accumulate = function(obj){
            if(obj){
                values.push(obj.value);
                return values;
            }else{
                return values;
            }
        };
        return accumulates;
    };
    //This allows us to do this
    var accumulator = ValueAccumulator();
    accumulator(obj1);
    accumulator(obj2);
    console.log(accumulator()); //Output: [obj1.value,obj2.value]
```

```javascript
    ValueAccumulator = ->
     values = []
     (obj) ->
     values.push obj.value if obj
     values
```

这些都是关于作用域的。变量values在内部函数accumulate()中可见，即便是在外部的代码在调用这个函数时。这叫做闭包。

> Javascript中的闭包就是函数可以访问父作用域，哪怕父函数已经执行完毕。

闭包是所有函数式语言都具有的特征。传统的命令式语言没有闭包。

### 高阶函数
自调用函数实际上是高阶函数的一种形式。高阶函数就是以其他函数为输入，或者返回一个函数为输出的函数。

高阶函数在传统的编程中并不常见。当命令式程序员使用循环来迭代数组的时候，函数是程序员会采用完全不同的一种实现方式。通过高阶函数，数组中的每一个元素可以被应用到一个函数上，并返回新的数组。

这是函数式编程中心思想。高阶函数具有把逻辑像对象一样传递给函数的能力。

在Javascript中，函数被当作头等公民对待，这和Scheme、Haskell等经典函数是语言一样的。这话听起来可能有点古怪，其实实际意思就是函数被当做基本类型，就像数字和对象一样。 如果数字和对象可以被来回传递，那么函数也可以。

来实际看看。现在把上一节的ValueAccumulator()函数配合高阶函数使用：
```javascript
   // 使用forEach()来遍历一个数组，并对其每个元素调用回调函数accumulator2
   var accumulator2 = ValueAccumulator();
   var objects = [obj1, obj2, obj3]; // 这个数组可以很大
   objects.forEach(accumulator2);
   console.log(accumulator2()); 
```

### 纯函数
纯函数返回的计算结果仅与传入的参数相关。这里不会使用外部的变量和全局状态，并且没有副作用。 换句话说就是不能改变作为输入传入的变量。所以，程序里只能使用纯函数返回的值。

用数学函数来举一个简单的例子。Math.sqrt(4)将总是返回2，不使用任何隐藏的信息，如设置或状态， 而且不会带来任何副作用。

纯函数是对数学上的“函数”的真实演绎，就是输入和输出的关系。它们思路简单也便于重用。 由于纯函数是完全独立的，它们更适合被一次又一次地使用。

举例说明来对比一下非纯函数和纯函数。
```javascript
   // 把信息打印到屏幕中央的函数
   var printCenter = function(str) {
     var elem = document.createElement("div");
     elem.textContent = str;
     elem.style.position = 'absolute';
     elem.style.top = window.innerHeight / 2 + "px";
     elem.style.left = window.innerWidth / 2 + "px";
     document.body.appendChild(elem);
   };
   printCenter('hello world');
   // 纯函数完成相同的事情
   var printSomewhere = function(str, height, width) {
     var elem = document.createElement("div");
     elem.textContent = str;
     elem.style.position = 'absolute';
     elem.style.top = height;
     elem.style.left = width;
     return elem;
   };
   document.body.appendChild(
   printSomewhere('hello world',
   window.innerHeight / 2) + 10 + "px",
   window.innerWidth / 2) + 10 + "px"));
```

http://www.cnblogs.com/tolg/p/4688261.html

http://www.ibm.com/developerworks/cn/web/1006_qiujt_jsfunctional/index.html

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow_and_error_handling#语句块（Block_Statement）
